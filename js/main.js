(function (factory) {
    typeof define === 'function' && define.amd ? define('main', factory) :
    factory();
}((function () { 'use strict';

    /**
     * SSR Window 4.0.2
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: December 13, 2021
     */

    /* eslint-disable no-param-reassign */
    function isObject(obj) {
      return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
    }

    function extend(target = {}, src = {}) {
      Object.keys(src).forEach(key => {
        if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
          extend(target[key], src[key]);
        }
      });
    }

    const ssrDocument = {
      body: {},

      addEventListener() {},

      removeEventListener() {},

      activeElement: {
        blur() {},

        nodeName: ''
      },

      querySelector() {
        return null;
      },

      querySelectorAll() {
        return [];
      },

      getElementById() {
        return null;
      },

      createEvent() {
        return {
          initEvent() {}

        };
      },

      createElement() {
        return {
          children: [],
          childNodes: [],
          style: {},

          setAttribute() {},

          getElementsByTagName() {
            return [];
          }

        };
      },

      createElementNS() {
        return {};
      },

      importNode() {
        return null;
      },

      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
      }
    };

    function getDocument() {
      const doc = typeof document !== 'undefined' ? document : {};
      extend(doc, ssrDocument);
      return doc;
    }

    const ssrWindow = {
      document: ssrDocument,
      navigator: {
        userAgent: ''
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
      },
      history: {
        replaceState() {},

        pushState() {},

        go() {},

        back() {}

      },
      CustomEvent: function CustomEvent() {
        return this;
      },

      addEventListener() {},

      removeEventListener() {},

      getComputedStyle() {
        return {
          getPropertyValue() {
            return '';
          }

        };
      },

      Image() {},

      Date() {},

      screen: {},

      setTimeout() {},

      clearTimeout() {},

      matchMedia() {
        return {};
      },

      requestAnimationFrame(callback) {
        if (typeof setTimeout === 'undefined') {
          callback();
          return null;
        }

        return setTimeout(callback, 0);
      },

      cancelAnimationFrame(id) {
        if (typeof setTimeout === 'undefined') {
          return;
        }

        clearTimeout(id);
      }

    };

    function getWindow() {
      const win = typeof window !== 'undefined' ? window : {};
      extend(win, ssrWindow);
      return win;
    }

    /**
     * Dom7 4.0.4
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2022, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: January 11, 2022
     */
    /* eslint-disable no-proto */

    function makeReactive(obj) {
      const proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get() {
          return proto;
        },

        set(value) {
          proto.__proto__ = value;
        }

      });
    }

    class Dom7 extends Array {
      constructor(items) {
        if (typeof items === 'number') {
          super(items);
        } else {
          super(...(items || []));
          makeReactive(this);
        }
      }

    }

    function arrayFlat(arr = []) {
      const res = [];
      arr.forEach(el => {
        if (Array.isArray(el)) {
          res.push(...arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }

    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }

    function arrayUnique(arr) {
      const uniqueArray = [];

      for (let i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }

      return uniqueArray;
    }


    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }

      const a = [];
      const res = context.querySelectorAll(selector);

      for (let i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }

      return a;
    }

    function $(selector, context) {
      const window = getWindow();
      const document = getDocument();
      let arr = [];

      if (!context && selector instanceof Dom7) {
        return selector;
      }

      if (!selector) {
        return new Dom7(arr);
      }

      if (typeof selector === 'string') {
        const html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          let toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          const tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (let i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);

      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
      }

      return new Dom7(arrayUnique(arr));
    }

    $.fn = Dom7.prototype; // eslint-disable-next-line

    function addClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        el.classList.add(...classNames);
      });
      return this;
    }

    function removeClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        el.classList.remove(...classNames);
      });
      return this;
    }

    function toggleClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        classNames.forEach(className => {
          el.classList.toggle(className);
        });
      });
    }

    function hasClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      return arrayFilter(this, el => {
        return classNames.filter(className => el.classList.contains(className)).length > 0;
      }).length > 0;
    }

    function attr(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs


      for (let i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (const attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }

      return this;
    }

    function removeAttr(attr) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }

      return this;
    }

    function transform(transform) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }

      return this;
    }

    function transition(duration) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
      }

      return this;
    }

    function on(...args) {
      let [eventType, targetSelector, listener, capture] = args;

      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }

      if (!capture) capture = false;

      function handleLiveEvent(e) {
        const target = e.target;
        if (!target) return;
        const eventData = e.target.dom7EventData || [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
          const parents = $(target).parents(); // eslint-disable-line

          for (let k = 0; k < parents.length; k += 1) {
            if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
          }
        }
      }

      function handleEvent(e) {
        const eventData = e && e.target ? e.target.dom7EventData || [] : [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        listener.apply(this, eventData);
      }

      const events = eventType.split(' ');
      let j;

      for (let i = 0; i < this.length; i += 1) {
        const el = this[i];

        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener,
              proxyListener: handleEvent
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
            el.dom7LiveListeners[event].push({
              listener,
              proxyListener: handleLiveEvent
            });
            el.addEventListener(event, handleLiveEvent, capture);
          }
        }
      }

      return this;
    }

    function off(...args) {
      let [eventType, targetSelector, listener, capture] = args;

      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }

      if (!capture) capture = false;
      const events = eventType.split(' ');

      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];

        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];
          let handlers;

          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }

          if (handlers && handlers.length) {
            for (let k = handlers.length - 1; k >= 0; k -= 1) {
              const handler = handlers[k];

              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }

      return this;
    }

    function trigger(...args) {
      const window = getWindow();
      const events = args[0].split(' ');
      const eventData = args[1];

      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];

        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];

          if (window.CustomEvent) {
            const evt = new window.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }

      return this;
    }

    function transitionEnd(callback) {
      const dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }

      if (callback) {
        dom.on('transitionend', fireCallBack);
      }

      return this;
    }

    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles = this.styles();
          return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
        }

        return this[0].offsetWidth;
      }

      return null;
    }

    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles = this.styles();
          return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
        }

        return this[0].offsetHeight;
      }

      return null;
    }

    function offset() {
      if (this.length > 0) {
        const window = getWindow();
        const document = getDocument();
        const el = this[0];
        const box = el.getBoundingClientRect();
        const body = document.body;
        const clientTop = el.clientTop || body.clientTop || 0;
        const clientLeft = el.clientLeft || body.clientLeft || 0;
        const scrollTop = el === window ? window.scrollY : el.scrollTop;
        const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }

      return null;
    }

    function styles() {
      const window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }

    function css(props, value) {
      const window = getWindow();
      let i;

      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (const prop in props) {
              this[i].style[prop] = props[prop];
            }
          }

          return this;
        }
      }

      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }

        return this;
      }

      return this;
    }

    function each(callback) {
      if (!callback) return this;
      this.forEach((el, index) => {
        callback.apply(el, [el, index]);
      });
      return this;
    }

    function filter(callback) {
      const result = arrayFilter(this, callback);
      return $(result);
    }

    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }

      for (let i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }

      return this;
    }

    function text(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }

      for (let i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }

      return this;
    }

    function is(selector) {
      const window = getWindow();
      const document = getDocument();
      const el = this[0];
      let compareWith;
      let i;
      if (!el || typeof selector === 'undefined') return false;

      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $(selector);

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      if (selector === document) {
        return el === document;
      }

      if (selector === window) {
        return el === window;
      }

      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      return false;
    }

    function index() {
      let child = this[0];
      let i;

      if (child) {
        i = 0; // eslint-disable-next-line

        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }

        return i;
      }

      return undefined;
    }

    function eq(index) {
      if (typeof index === 'undefined') return this;
      const length = this.length;

      if (index > length - 1) {
        return $([]);
      }

      if (index < 0) {
        const returnIndex = length + index;
        if (returnIndex < 0) return $([]);
        return $([this[returnIndex]]);
      }

      return $([this[index]]);
    }

    function append(...els) {
      let newChild;
      const document = getDocument();

      for (let k = 0; k < els.length; k += 1) {
        newChild = els[k];

        for (let i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (let j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }

      return this;
    }

    function prepend(newChild) {
      const document = getDocument();
      let i;
      let j;

      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    }

    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return $([this[0].nextElementSibling]);
          }

          return $([]);
        }

        if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function nextAll(selector) {
      const nextEls = [];
      let el = this[0];
      if (!el) return $([]);

      while (el.nextElementSibling) {
        const next = el.nextElementSibling; // eslint-disable-line

        if (selector) {
          if ($(next).is(selector)) nextEls.push(next);
        } else nextEls.push(next);

        el = next;
      }

      return $(nextEls);
    }

    function prev(selector) {
      if (this.length > 0) {
        const el = this[0];

        if (selector) {
          if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
            return $([el.previousElementSibling]);
          }

          return $([]);
        }

        if (el.previousElementSibling) return $([el.previousElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function prevAll(selector) {
      const prevEls = [];
      let el = this[0];
      if (!el) return $([]);

      while (el.previousElementSibling) {
        const prev = el.previousElementSibling; // eslint-disable-line

        if (selector) {
          if ($(prev).is(selector)) prevEls.push(prev);
        } else prevEls.push(prev);

        el = prev;
      }

      return $(prevEls);
    }

    function parent(selector) {
      const parents = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $(parents);
    }

    function parents(selector) {
      const parents = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        let parent = this[i].parentNode; // eslint-disable-line

        while (parent) {
          if (selector) {
            if ($(parent).is(selector)) parents.push(parent);
          } else {
            parents.push(parent);
          }

          parent = parent.parentNode;
        }
      }

      return $(parents);
    }

    function closest(selector) {
      let closest = this; // eslint-disable-line

      if (typeof selector === 'undefined') {
        return $([]);
      }

      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }

      return closest;
    }

    function find(selector) {
      const foundElements = [];

      for (let i = 0; i < this.length; i += 1) {
        const found = this[i].querySelectorAll(selector);

        for (let j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }

      return $(foundElements);
    }

    function children(selector) {
      const children = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        const childNodes = this[i].children;

        for (let j = 0; j < childNodes.length; j += 1) {
          if (!selector || $(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }

      return $(children);
    }

    function remove() {
      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }

      return this;
    }

    const Methods = {
      addClass,
      removeClass,
      hasClass,
      toggleClass,
      attr,
      removeAttr,
      transform,
      transition,
      on,
      off,
      trigger,
      transitionEnd,
      outerWidth,
      outerHeight,
      styles,
      offset,
      css,
      each,
      html,
      text,
      is,
      index,
      eq,
      append,
      prepend,
      next,
      nextAll,
      prev,
      prevAll,
      parent,
      parents,
      closest,
      find,
      children,
      filter,
      remove
    };
    Object.keys(Methods).forEach(methodName => {
      Object.defineProperty($.fn, methodName, {
        value: Methods[methodName],
        writable: true
      });
    });

    function deleteProps(obj) {
      const object = obj;
      Object.keys(object).forEach(key => {
        try {
          object[key] = null;
        } catch (e) {// no getter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    }

    function nextTick(callback, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return setTimeout(callback, delay);
    }

    function now() {
      return Date.now();
    }

    function getComputedStyle$1(el) {
      const window = getWindow();
      let style;

      if (window.getComputedStyle) {
        style = window.getComputedStyle(el, null);
      }

      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }

      if (!style) {
        style = el.style;
      }

      return style;
    }

    function getTranslate(el, axis) {
      if (axis === void 0) {
        axis = 'x';
      }

      const window = getWindow();
      let matrix;
      let curTransform;
      let transformMatrix;
      const curStyle = getComputedStyle$1(el);

      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
        else curTransform = parseFloat(matrix[4]);
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
        else curTransform = parseFloat(matrix[5]);
      }

      return curTransform || 0;
    }

    function isObject$1(o) {
      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }

    function isNode(node) {
      // eslint-disable-next-line
      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
      }

      return node && (node.nodeType === 1 || node.nodeType === 11);
    }

    function extend$1() {
      const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
      const noExtend = ['__proto__', 'constructor', 'prototype'];

      for (let i = 1; i < arguments.length; i += 1) {
        const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
          const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);

          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            const nextKey = keysArray[nextIndex];
            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                to[nextKey] = {};

                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }

    function setCSSProperty(el, varName, varValue) {
      el.style.setProperty(varName, varValue);
    }

    function animateCSSModeScroll(_ref) {
      let {
        swiper,
        targetPosition,
        side
      } = _ref;
      const window = getWindow();
      const startPosition = -swiper.translate;
      let startTime = null;
      let time;
      const duration = swiper.params.speed;
      swiper.wrapperEl.style.scrollSnapType = 'none';
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      const dir = targetPosition > startPosition ? 'next' : 'prev';

      const isOutOfBound = (current, target) => {
        return dir === 'next' && current >= target || dir === 'prev' && current <= target;
      };

      const animate = () => {
        time = new Date().getTime();

        if (startTime === null) {
          startTime = time;
        }

        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);

        if (isOutOfBound(currentPosition, targetPosition)) {
          currentPosition = targetPosition;
        }

        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });

        if (isOutOfBound(currentPosition, targetPosition)) {
          swiper.wrapperEl.style.overflow = 'hidden';
          swiper.wrapperEl.style.scrollSnapType = '';
          setTimeout(() => {
            swiper.wrapperEl.style.overflow = '';
            swiper.wrapperEl.scrollTo({
              [side]: currentPosition
            });
          });
          window.cancelAnimationFrame(swiper.cssModeFrameID);
          return;
        }

        swiper.cssModeFrameID = window.requestAnimationFrame(animate);
      };

      animate();
    }

    let support;

    function calcSupport() {
      const window = getWindow();
      const document = getDocument();
      return {
        smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
        passiveListener: function checkPassiveListener() {
          let supportsPassive = false;

          try {
            const opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get() {
                supportsPassive = true;
              }

            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {// No support
          }

          return supportsPassive;
        }(),
        gestures: function checkGestures() {
          return 'ongesturestart' in window;
        }()
      };
    }

    function getSupport() {
      if (!support) {
        support = calcSupport();
      }

      return support;
    }

    let deviceCached;

    function calcDevice(_temp) {
      let {
        userAgent
      } = _temp === void 0 ? {} : _temp;
      const support = getSupport();
      const window = getWindow();
      const platform = window.navigator.platform;
      const ua = userAgent || window.navigator.userAgent;
      const device = {
        ios: false,
        android: false
      };
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      const windows = platform === 'Win32';
      let macos = platform === 'MacIntel'; // iPadOs 13 fix

      const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

      if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      } // Android


      if (android && !windows) {
        device.os = 'android';
        device.android = true;
      }

      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // Export object


      return device;
    }

    function getDevice(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }

      if (!deviceCached) {
        deviceCached = calcDevice(overrides);
      }

      return deviceCached;
    }

    let browser;

    function calcBrowser() {
      const window = getWindow();

      function isSafari() {
        const ua = window.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }

      return {
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
      };
    }

    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }

      return browser;
    }

    function Resize(_ref) {
      let {
        swiper,
        on,
        emit
      } = _ref;
      const window = getWindow();
      let observer = null;
      let animationFrame = null;

      const resizeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('beforeResize');
        emit('resize');
      };

      const createObserver = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        observer = new ResizeObserver(entries => {
          animationFrame = window.requestAnimationFrame(() => {
            const {
              width,
              height
            } = swiper;
            let newWidth = width;
            let newHeight = height;
            entries.forEach(_ref2 => {
              let {
                contentBoxSize,
                contentRect,
                target
              } = _ref2;
              if (target && target !== swiper.el) return;
              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
            });

            if (newWidth !== width || newHeight !== height) {
              resizeHandler();
            }
          });
        });
        observer.observe(swiper.el);
      };

      const removeObserver = () => {
        if (animationFrame) {
          window.cancelAnimationFrame(animationFrame);
        }

        if (observer && observer.unobserve && swiper.el) {
          observer.unobserve(swiper.el);
          observer = null;
        }
      };

      const orientationChangeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('orientationchange');
      };

      on('init', () => {
        if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
          createObserver();
          return;
        }

        window.addEventListener('resize', resizeHandler);
        window.addEventListener('orientationchange', orientationChangeHandler);
      });
      on('destroy', () => {
        removeObserver();
        window.removeEventListener('resize', resizeHandler);
        window.removeEventListener('orientationchange', orientationChangeHandler);
      });
    }

    function Observer(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      const observers = [];
      const window = getWindow();

      const attach = function (target, options) {
        if (options === void 0) {
          options = {};
        }

        const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
        const observer = new ObserverFunc(mutations => {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            emit('observerUpdate', mutations[0]);
            return;
          }

          const observerUpdate = function observerUpdate() {
            emit('observerUpdate', mutations[0]);
          };

          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(observerUpdate);
          } else {
            window.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData
        });
        observers.push(observer);
      };

      const init = () => {
        if (!swiper.params.observer) return;

        if (swiper.params.observeParents) {
          const containerParents = swiper.$el.parents();

          for (let i = 0; i < containerParents.length; i += 1) {
            attach(containerParents[i]);
          }
        } // Observe container


        attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren
        }); // Observe wrapper

        attach(swiper.$wrapperEl[0], {
          attributes: false
        });
      };

      const destroy = () => {
        observers.forEach(observer => {
          observer.disconnect();
        });
        observers.splice(0, observers.length);
      };

      extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false
      });
      on('init', init);
      on('destroy', destroy);
    }

    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
      on(events, handler, priority) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(event => {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      },

      once(events, handler, priority) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (typeof handler !== 'function') return self;

        function onceHandler() {
          self.off(events, onceHandler);

          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          handler.apply(self, args);
        }

        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
      },

      onAny(handler, priority) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';

        if (self.eventsAnyListeners.indexOf(handler) < 0) {
          self.eventsAnyListeners[method](handler);
        }

        return self;
      },

      offAny(handler) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (!self.eventsAnyListeners) return self;
        const index = self.eventsAnyListeners.indexOf(handler);

        if (index >= 0) {
          self.eventsAnyListeners.splice(index, 1);
        }

        return self;
      },

      off(events, handler) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(event => {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach((eventHandler, index) => {
              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      },

      emit() {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (!self.eventsListeners) return self;
        let events;
        let data;
        let context;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }

        data.unshift(context);
        const eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(event => {
          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
            self.eventsAnyListeners.forEach(eventHandler => {
              eventHandler.apply(context, [event, ...data]);
            });
          }

          if (self.eventsListeners && self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(eventHandler => {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      }

    };

    function updateSize() {
      const swiper = this;
      let width;
      let height;
      const $el = swiper.$el;

      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }

      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }

      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
      } // Subtract paddings


      width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
      height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
      Object.assign(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height
      });
    }

    function updateSlides() {
      const swiper = this;

      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
          return property;
        } // prettier-ignore


        return {
          'width': 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          'marginRight': 'marginBottom'
        }[property];
      }

      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }

      const params = swiper.params;
      const {
        $wrapperEl,
        size: swiperSize,
        rtlTranslate: rtl,
        wrongRTL
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      let snapGrid = [];
      const slidesGrid = [];
      const slidesSizesGrid = [];
      let offsetBefore = params.slidesOffsetBefore;

      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }

      let offsetAfter = params.slidesOffsetAfter;

      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }

      const previousSnapGridLength = swiper.snapGrid.length;
      const previousSlidesGridLength = swiper.slidesGrid.length;
      let spaceBetween = params.spaceBetween;
      let slidePosition = -offsetBefore;
      let prevSlideSize = 0;
      let index = 0;

      if (typeof swiperSize === 'undefined') {
        return;
      }

      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
      }

      swiper.virtualSize = -spaceBetween; // reset margins

      if (rtl) slides.css({
        marginLeft: '',
        marginBottom: '',
        marginTop: ''
      });else slides.css({
        marginRight: '',
        marginBottom: '',
        marginTop: ''
      }); // reset cssMode offsets

      if (params.centeredSlides && params.cssMode) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
      }

      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;

      if (gridEnabled) {
        swiper.grid.initSlides(slidesLength);
      } // Calc slides


      let slideSize;
      const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
        return typeof params.breakpoints[key].slidesPerView !== 'undefined';
      }).length > 0;

      for (let i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        const slide = slides.eq(i);

        if (gridEnabled) {
          swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
        }

        if (slide.css('display') === 'none') continue; // eslint-disable-line

        if (params.slidesPerView === 'auto') {
          if (shouldResetSlideSize) {
            slides[i].style[getDirectionLabel('width')] = ``;
          }

          const slideStyles = getComputedStyle(slide[0]);
          const currentTransform = slide[0].style.transform;
          const currentWebKitTransform = slide[0].style.webkitTransform;

          if (currentTransform) {
            slide[0].style.transform = 'none';
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = 'none';
          }

          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            const width = getDirectionPropertyValue(slideStyles, 'width');
            const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
            const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
            const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
            const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
            const boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              const {
                clientWidth,
                offsetWidth
              } = slide[0];
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }

          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }

          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);

          if (slides[i]) {
            slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
          }
        }

        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }

        slidesSizesGrid.push(slideSize);

        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }

        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
      }

      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;

      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({
          width: `${swiper.virtualSize + params.spaceBetween}px`
        });
      }

      if (params.setWrapperSize) {
        $wrapperEl.css({
          [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
        });
      }

      if (gridEnabled) {
        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
      } // Remove last grid elements depending on width


      if (!params.centeredSlides) {
        const newSlidesGrid = [];

        for (let i = 0; i < snapGrid.length; i += 1) {
          let slidesGridItem = snapGrid[i];
          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);

          if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(slidesGridItem);
          }
        }

        snapGrid = newSlidesGrid;

        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }

      if (snapGrid.length === 0) snapGrid = [0];

      if (params.spaceBetween !== 0) {
        const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
        slides.filter((_, slideIndex) => {
          if (!params.cssMode) return true;

          if (slideIndex === slides.length - 1) {
            return false;
          }

          return true;
        }).css({
          [key]: `${spaceBetween}px`
        });
      }

      if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach(slideSizeValue => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        const maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(snap => {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }

      if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach(slideSizeValue => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;

        if (allSlidesSize < swiperSize) {
          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
          snapGrid.forEach((snap, snapIndex) => {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach((snap, snapIndex) => {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }

      Object.assign(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid
      });

      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
        const addToSnapGrid = -swiper.snapGrid[0];
        const addToSlidesGrid = -swiper.slidesGrid[0];
        swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
        swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
      }

      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }

      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }

      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }

      if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
      }

      if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
        const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);

        if (slidesLength <= params.maxBackfaceHiddenSlides) {
          if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
        } else if (hasClassBackfaceClassAdded) {
          swiper.$el.removeClass(backFaceHiddenClass);
        }
      }
    }

    function updateAutoHeight(speed) {
      const swiper = this;
      const activeSlides = [];
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      let newHeight = 0;
      let i;

      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }

      const getSlideByIndex = index => {
        if (isVirtual) {
          return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
        }

        return swiper.slides.eq(index)[0];
      }; // Find slides currently in view


      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          (swiper.visibleSlides || $([])).each(slide => {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            const index = swiper.activeIndex + i;
            if (index > swiper.slides.length && !isVirtual) break;
            activeSlides.push(getSlideByIndex(index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      } // Find new height from highest slide in view


      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          const height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      } // Update Height


      if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);
    }

    function updateSlidesOffset() {
      const swiper = this;
      const slides = swiper.slides;

      for (let i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
      }
    }

    function updateSlidesProgress(translate) {
      if (translate === void 0) {
        translate = this && this.translate || 0;
      }

      const swiper = this;
      const params = swiper.params;
      const {
        slides,
        rtlTranslate: rtl,
        snapGrid
      } = swiper;
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
      let offsetCenter = -translate;
      if (rtl) offsetCenter = translate; // Visible Slides

      slides.removeClass(params.slideVisibleClass);
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];

      for (let i = 0; i < slides.length; i += 1) {
        const slide = slides[i];
        let slideOffset = slide.swiperSlideOffset;

        if (params.cssMode && params.centeredSlides) {
          slideOffset -= slides[0].swiperSlideOffset;
        }

        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        const slideBefore = -(offsetCenter - slideOffset);
        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

        if (isVisible) {
          swiper.visibleSlides.push(slide);
          swiper.visibleSlidesIndexes.push(i);
          slides.eq(i).addClass(params.slideVisibleClass);
        }

        slide.progress = rtl ? -slideProgress : slideProgress;
        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
      }

      swiper.visibleSlides = $(swiper.visibleSlides);
    }

    function updateProgress(translate) {
      const swiper = this;

      if (typeof translate === 'undefined') {
        const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
      }

      const params = swiper.params;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      let {
        progress,
        isBeginning,
        isEnd
      } = swiper;
      const wasBeginning = isBeginning;
      const wasEnd = isEnd;

      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }

      Object.assign(swiper, {
        progress,
        isBeginning,
        isEnd
      });
      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }

      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }

      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit('fromEdge');
      }

      swiper.emit('progress', progress);
    }

    function updateSlidesClasses() {
      const swiper = this;
      const {
        slides,
        params,
        $wrapperEl,
        activeIndex,
        realIndex
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
      let activeSlide;

      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
      } else {
        activeSlide = slides.eq(activeIndex);
      } // Active classes


      activeSlide.addClass(params.slideActiveClass);

      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        }
      } // Next Slide


      let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);

      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      } // Prev Slide


      let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);

      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }

      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
        }

        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
        }
      }

      swiper.emitSlidesClasses();
    }

    function updateActiveIndex(newActiveIndex) {
      const swiper = this;
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      const {
        slidesGrid,
        snapGrid,
        params,
        activeIndex: previousIndex,
        realIndex: previousRealIndex,
        snapIndex: previousSnapIndex
      } = swiper;
      let activeIndex = newActiveIndex;
      let snapIndex;

      if (typeof activeIndex === 'undefined') {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        } // Normalize slideIndex


        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }

      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }

      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }

        return;
      } // Get real index


      const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
      Object.assign(swiper, {
        snapIndex,
        realIndex,
        previousIndex,
        activeIndex
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');

      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }

      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }

    function updateClickedSlide(e) {
      const swiper = this;
      const params = swiper.params;
      const slide = $(e).closest(`.${params.slideClass}`)[0];
      let slideFound = false;
      let slideIndex;

      if (slide) {
        for (let i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) {
            slideFound = true;
            slideIndex = i;
            break;
          }
        }
      }

      if (slide && slideFound) {
        swiper.clickedSlide = slide;

        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }

      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }

    var update = {
      updateSize,
      updateSlides,
      updateAutoHeight,
      updateSlidesOffset,
      updateSlidesProgress,
      updateProgress,
      updateSlidesClasses,
      updateActiveIndex,
      updateClickedSlide
    };

    function getSwiperTranslate(axis) {
      if (axis === void 0) {
        axis = this.isHorizontal() ? 'x' : 'y';
      }

      const swiper = this;
      const {
        params,
        rtlTranslate: rtl,
        translate,
        $wrapperEl
      } = swiper;

      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }

      if (params.cssMode) {
        return translate;
      }

      let currentTranslate = getTranslate($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }

    function setTranslate(translate, byController) {
      const swiper = this;
      const {
        rtlTranslate: rtl,
        params,
        $wrapperEl,
        wrapperEl,
        progress
      } = swiper;
      let x = 0;
      let y = 0;
      const z = 0;

      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }

      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }

      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
      }

      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }

      swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate() {
      return -this.snapGrid[0];
    }

    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }

    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
      if (translate === void 0) {
        translate = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (translateBounds === void 0) {
        translateBounds = true;
      }

      const swiper = this;
      const {
        params,
        wrapperEl
      } = swiper;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }

      const minTranslate = swiper.minTranslate();
      const maxTranslate = swiper.maxTranslate();
      let newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

      swiper.updateProgress(newTranslate);

      if (params.cssMode) {
        const isH = swiper.isHorizontal();

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper,
              targetPosition: -newTranslate,
              side: isH ? 'left' : 'top'
            });
            return true;
          }

          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: -newTranslate,
            behavior: 'smooth'
          });
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;

              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
        }
      }

      return true;
    }

    var translate = {
      getTranslate: getSwiperTranslate,
      setTranslate,
      minTranslate,
      maxTranslate,
      translateTo
    };

    function setTransition(duration, byController) {
      const swiper = this;

      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }

      swiper.emit('setTransition', duration, byController);
    }

    function transitionEmit(_ref) {
      let {
        swiper,
        runCallbacks,
        direction,
        step
      } = _ref;
      const {
        activeIndex,
        previousIndex
      } = swiper;
      let dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }

      swiper.emit(`transition${step}`);

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit(`slideResetTransition${step}`);
          return;
        }

        swiper.emit(`slideChangeTransition${step}`);

        if (dir === 'next') {
          swiper.emit(`slideNextTransition${step}`);
        } else {
          swiper.emit(`slidePrevTransition${step}`);
        }
      }
    }

    function transitionStart(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      const swiper = this;
      const {
        params
      } = swiper;
      if (params.cssMode) return;

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: 'Start'
      });
    }

    function transitionEnd$1(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      const swiper = this;
      const {
        params
      } = swiper;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
      transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: 'End'
      });
    }

    var transition$1 = {
      setTransition,
      transitionStart,
      transitionEnd: transitionEnd$1
    };

    function slideTo(index, speed, runCallbacks, internal, initial) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (typeof index !== 'number' && typeof index !== 'string') {
        throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
      }

      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        const indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        const isValidNumber = isFinite(indexAsNumber);

        if (!isValidNumber) {
          throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.


        index = indexAsNumber;
      }

      const swiper = this;
      let slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
      const {
        params,
        snapGrid,
        slidesGrid,
        previousIndex,
        activeIndex,
        rtlTranslate: rtl,
        wrapperEl,
        enabled
      } = swiper;

      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
      }

      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }

      const translate = -snapGrid[snapIndex]; // Update progress

      swiper.updateProgress(translate); // Normalize slideIndex

      if (params.normalizeSlideIndex) {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          const normalizedTranslate = -Math.floor(translate * 100);
          const normalizedGrid = Math.floor(slidesGrid[i] * 100);
          const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
              slideIndex = i;
            } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
              slideIndex = i + 1;
            }
          } else if (normalizedTranslate >= normalizedGrid) {
            slideIndex = i;
          }
        }
      } // Directions locks


      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
          return false;
        }

        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }

      let direction;
      if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
        swiper.updateActiveIndex(slideIndex); // Update Height

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }

        swiper.updateSlidesClasses();

        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }

        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }

        return false;
      }

      if (params.cssMode) {
        const isH = swiper.isHorizontal();
        const t = rtl ? translate : -translate;

        if (speed === 0) {
          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

          if (isVirtual) {
            swiper.wrapperEl.style.scrollSnapType = 'none';
            swiper._immediateVirtual = true;
          }

          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;

          if (isVirtual) {
            requestAnimationFrame(() => {
              swiper.wrapperEl.style.scrollSnapType = '';
              swiper._swiperImmediateVirtual = false;
            });
          }
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper,
              targetPosition: t,
              side: isH ? 'left' : 'top'
            });
            return true;
          }

          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: t,
            behavior: 'smooth'
          });
        }

        return true;
      }

      swiper.setTransition(speed);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);

      if (speed === 0) {
        swiper.transitionEnd(runCallbacks, direction);
      } else if (!swiper.animating) {
        swiper.animating = true;

        if (!swiper.onSlideToWrapperTransitionEnd) {
          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
          };
        }

        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
      }

      return true;
    }

    function slideToLoop(index, speed, runCallbacks, internal) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        const indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        const isValidNumber = isFinite(indexAsNumber);

        if (!isValidNumber) {
          throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.


        index = indexAsNumber;
      }

      const swiper = this;
      let newIndex = index;

      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }

      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      const swiper = this;
      const {
        animating,
        enabled,
        params
      } = swiper;
      if (!enabled) return swiper;
      let perGroup = params.slidesPerGroup;

      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
      }

      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      if (params.rewind && swiper.isEnd) {
        return swiper.slideTo(0, speed, runCallbacks, internal);
      }

      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      const swiper = this;
      const {
        params,
        animating,
        snapGrid,
        slidesGrid,
        rtlTranslate,
        enabled
      } = swiper;
      if (!enabled) return swiper;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      const translate = rtlTranslate ? swiper.translate : -swiper.translate;

      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }

      const normalizedTranslate = normalize(translate);
      const normalizedSnapGrid = snapGrid.map(val => normalize(val));
      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

      if (typeof prevSnap === 'undefined' && params.cssMode) {
        let prevSnapIndex;
        snapGrid.forEach((snap, snapIndex) => {
          if (normalizedTranslate >= snap) {
            // prevSnap = snap;
            prevSnapIndex = snapIndex;
          }
        });

        if (typeof prevSnapIndex !== 'undefined') {
          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
        }
      }

      let prevIndex = 0;

      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;

        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
          prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
          prevIndex = Math.max(prevIndex, 0);
        }
      }

      if (params.rewind && swiper.isBeginning) {
        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
      }

      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      const swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed, runCallbacks, internal, threshold) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (threshold === void 0) {
        threshold = 0.5;
      }

      const swiper = this;
      let index = swiper.activeIndex;
      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        const currentSnap = swiper.snapGrid[snapIndex];
        const nextSnap = swiper.snapGrid[snapIndex + 1];

        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        const prevSnap = swiper.snapGrid[snapIndex - 1];
        const currentSnap = swiper.snapGrid[snapIndex];

        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }

      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index, speed, runCallbacks, internal);
    }

    function slideToClickedSlide() {
      const swiper = this;
      const {
        params,
        $wrapperEl
      } = swiper;
      const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      let slideToIndex = swiper.clickedIndex;
      let realIndex;

      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
            nextTick(() => {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }

    var slide = {
      slideTo,
      slideToLoop,
      slideNext,
      slidePrev,
      slideReset,
      slideToClosest,
      slideToClickedSlide
    };

    function loopCreate() {
      const swiper = this;
      const document = getDocument();
      const {
        params,
        $wrapperEl
      } = swiper; // Remove duplicated slides

      const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
      $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
      let slides = $selector.children(`.${params.slideClass}`);

      if (params.loopFillGroupWithBlank) {
        const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

        if (blankSlidesNum !== params.slidesPerGroup) {
          for (let i = 0; i < blankSlidesNum; i += 1) {
            const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
            $selector.append(blankNode);
          }

          slides = $selector.children(`.${params.slideClass}`);
        }
      }

      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;

      if (swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit) {
        swiper.loopedSlides = slides.length;
      }

      const prependSlides = [];
      const appendSlides = [];
      slides.each((el, index) => {
        $(el).attr('data-swiper-slide-index', index);
      });

      for (let i = 0; i < swiper.loopedSlides; i += 1) {
        const index = i - Math.floor(i / slides.length) * slides.length;
        appendSlides.push(slides.eq(index)[0]);
        prependSlides.unshift(slides.eq(slides.length - index - 1)[0]);
      }

      for (let i = 0; i < appendSlides.length; i += 1) {
        $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }

      for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
        $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }

    function loopFix() {
      const swiper = this;
      swiper.emit('beforeLoopFix');
      const {
        activeIndex,
        slides,
        loopedSlides,
        allowSlidePrev,
        allowSlideNext,
        snapGrid,
        rtlTranslate: rtl
      } = swiper;
      let newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      const snapTranslate = -snapGrid[activeIndex];
      const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }

      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit('loopFix');
    }

    function loopDestroy() {
      const swiper = this;
      const {
        $wrapperEl,
        params,
        slides
      } = swiper;
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
      slides.removeAttr('data-swiper-slide-index');
    }

    var loop = {
      loopCreate,
      loopFix,
      loopDestroy
    };

    function setGrabCursor(moving) {
      const swiper = this;
      if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
      const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
      el.style.cursor = 'move';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor() {
      const swiper = this;

      if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
      }

      swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    }

    var grabCursor = {
      setGrabCursor,
      unsetGrabCursor
    };

    function closestElement(selector, base) {
      if (base === void 0) {
        base = this;
      }

      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        const found = el.closest(selector);

        if (!found && !el.getRootNode) {
          return null;
        }

        return found || __closestFrom(el.getRootNode().host);
      }

      return __closestFrom(base);
    }

    function onTouchStart(event) {
      const swiper = this;
      const document = getDocument();
      const window = getWindow();
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        enabled
      } = swiper;
      if (!enabled) return;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }

      if (!swiper.animating && params.cssMode && params.loop) {
        swiper.loopFix();
      }

      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      let $targetEl = $(e.target);

      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }

      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return; // change target el for shadow root component

      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

      if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
        $targetEl = $(event.path[0]);
      }

      const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
      const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
        swiper.allowClick = true;
        return;
      }

      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }

      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      const startX = touches.currentX;
      const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === 'prevent') {
          event.preventDefault();
        } else {
          return;
        }
      }

      Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;

      if (e.type !== 'touchstart') {
        let preventDefault = true;

        if ($targetEl.is(data.focusableElements)) {
          preventDefault = false;

          if ($targetEl[0].nodeName === 'SELECT') {
            data.isTouched = false;
          }
        }

        if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
          document.activeElement.blur();
        }

        const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
          e.preventDefault();
        }
      }

      if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
        swiper.freeMode.onTouchStart();
      }

      swiper.emit('touchStart', e);
    }

    function onTouchMove(event) {
      const document = getDocument();
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        enabled
      } = swiper;
      if (!enabled) return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }

        return;
      }

      if (data.isTouchEvent && e.type !== 'touchmove') return;
      const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }

      if (!swiper.allowTouchMove) {
        if (!$(e.target).is(data.focusableElements)) {
          swiper.allowClick = false;
        }

        if (data.isTouched) {
          Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY
          });
          data.touchStartTime = now();
        }

        return;
      }

      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
          return;
        }
      }

      if (data.isTouchEvent && document.activeElement) {
        if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }

      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }

      if (e.targetTouches && e.targetTouches.length > 1) return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      const diffX = touches.currentX - touches.startX;
      const diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

      if (typeof data.isScrolling === 'undefined') {
        let touchAngle;

        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }

      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }

      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }

      if (!data.startMoving) {
        return;
      }

      swiper.allowClick = false;

      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }

      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }

      if (!data.isMoved) {
        if (params.loop && !params.cssMode) {
          swiper.loopFix();
        }

        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);

        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }

        data.allowMomentumBounce = false; // Grab Cursor

        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }

        swiper.emit('sliderFirstMove', e);
      }

      swiper.emit('sliderMove', e);
      data.isMoved = true;
      let diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) diff = -diff;
      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;
      let disableParentSwiper = true;
      let resistanceRatio = params.resistanceRatio;

      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }

      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }

      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      } // Directions locks


      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      } // Threshold


      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }

      if (!params.followFinger || params.cssMode) return; // Update active index in free mode

      if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
        swiper.freeMode.onTouchMove();
      } // Update progress


      swiper.updateProgress(data.currentTranslate); // Update translate

      swiper.setTranslate(data.currentTranslate);
    }

    function onTouchEnd(event) {
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        slidesGrid,
        enabled
      } = swiper;
      if (!enabled) return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }

      data.allowTouchCallbacks = false;

      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }

        data.isMoved = false;
        data.startMoving = false;
        return;
      } // Return Grab Cursor


      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      } // Time diff


      const touchEndTime = now();
      const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

      if (swiper.allowClick) {
        const pathTree = e.path || e.composedPath && e.composedPath();
        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
        swiper.emit('tap click', e);

        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }

      data.lastClickTime = now();
      nextTick(() => {
        if (!swiper.destroyed) swiper.allowClick = true;
      });

      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }

      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      let currentPos;

      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }

      if (params.cssMode) {
        return;
      }

      if (swiper.params.freeMode && params.freeMode.enabled) {
        swiper.freeMode.onTouchEnd({
          currentPos
        });
        return;
      } // Find current slide


      let stopIndex = 0;
      let groupSize = swiper.slidesSizesGrid[0];

      for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

        if (typeof slidesGrid[i + increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      }

      let rewindFirstIndex = null;
      let rewindLastIndex = null;

      if (params.rewind) {
        if (swiper.isBeginning) {
          rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        } else if (swiper.isEnd) {
          rewindFirstIndex = 0;
        }
      } // Find current slide size


      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
        }

        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) {
            swiper.slideTo(stopIndex + increment);
          } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
            swiper.slideTo(rewindLastIndex);
          } else {
            swiper.slideTo(stopIndex);
          }
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
          }

          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }

    function onResize() {
      const swiper = this;
      const {
        params,
        el
      } = swiper;
      if (el && el.offsetWidth === 0) return; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      } // Save locks


      const {
        allowSlideNext,
        allowSlidePrev,
        snapGrid
      } = swiper; // Disable locks on resize

      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();

      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      } // Return locks after resize


      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;

      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }

    function onClick(e) {
      const swiper = this;
      if (!swiper.enabled) return;

      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();

        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }

    function onScroll() {
      const swiper = this;
      const {
        wrapperEl,
        rtlTranslate,
        enabled
      } = swiper;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;

      if (swiper.isHorizontal()) {
        swiper.translate = -wrapperEl.scrollLeft;
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      } // eslint-disable-next-line


      if (swiper.translate === 0) swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }

      swiper.emit('setTranslate', swiper.translate, false);
    }

    let dummyEventAttached = false;

    function dummyEventListener() {}

    const events = (swiper, method) => {
      const document = getDocument();
      const {
        params,
        touchEvents,
        el,
        wrapperEl,
        device,
        support
      } = swiper;
      const capture = !!params.nested;
      const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
      const swiperMethod = method; // Touch Events

      if (!support.touch) {
        el[domMethod](touchEvents.start, swiper.onTouchStart, false);
        document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
        document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
      } else {
        const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
        el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
          passive: false,
          capture
        } : capture);
        el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);

        if (touchEvents.cancel) {
          el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        el[domMethod]('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl[domMethod]('scroll', swiper.onScroll);
      } // Resize handler


      if (params.updateOnWindowResize) {
        swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
      } else {
        swiper[swiperMethod]('observerUpdate', onResize, true);
      }
    };

    function attachEvents() {
      const swiper = this;
      const document = getDocument();
      const {
        params,
        support
      } = swiper;
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);

      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }

      swiper.onClick = onClick.bind(swiper);

      if (support.touch && !dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }

      events(swiper, 'on');
    }

    function detachEvents() {
      const swiper = this;
      events(swiper, 'off');
    }

    var events$1 = {
      attachEvents,
      detachEvents
    };

    const isGridEnabled = (swiper, params) => {
      return swiper.grid && params.grid && params.grid.rows > 1;
    };

    function setBreakpoint() {
      const swiper = this;
      const {
        activeIndex,
        initialized,
        loopedSlides = 0,
        params,
        $el
      } = swiper;
      const breakpoints = params.breakpoints;
      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

      const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
      const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
      const breakpointParams = breakpointOnlyParams || swiper.originalParams;
      const wasMultiRow = isGridEnabled(swiper, params);
      const isMultiRow = isGridEnabled(swiper, breakpointParams);
      const wasEnabled = params.enabled;

      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(`${params.containerModifierClass}grid`);

        if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
          $el.addClass(`${params.containerModifierClass}grid-column`);
        }

        swiper.emitContainerClasses();
      } // Toggle navigation, pagination, scrollbar


      ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
        const wasModuleEnabled = params[prop] && params[prop].enabled;
        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;

        if (wasModuleEnabled && !isModuleEnabled) {
          swiper[prop].disable();
        }

        if (!wasModuleEnabled && isModuleEnabled) {
          swiper[prop].enable();
        }
      });
      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      extend$1(swiper.params, breakpointParams);
      const isEnabled = swiper.params.enabled;
      Object.assign(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });

      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }

      swiper.currentBreakpoint = breakpoint;
      swiper.emit('_beforeBreakpoint', breakpointParams);

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }

    function getBreakpoint(breakpoints, base, containerEl) {
      if (base === void 0) {
        base = 'window';
      }

      if (!breakpoints || base === 'container' && !containerEl) return undefined;
      let breakpoint = false;
      const window = getWindow();
      const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
      const points = Object.keys(breakpoints).map(point => {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          const minRatio = parseFloat(point.substr(1));
          const value = currentHeight * minRatio;
          return {
            value,
            point
          };
        }

        return {
          value: point,
          point
        };
      });
      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));

      for (let i = 0; i < points.length; i += 1) {
        const {
          point,
          value
        } = points[i];

        if (base === 'window') {
          if (window.matchMedia(`(min-width: ${value}px)`).matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }

      return breakpoint || 'max';
    }

    var breakpoints = {
      setBreakpoint,
      getBreakpoint
    };

    function prepareClasses(entries, prefix) {
      const resultClasses = [];
      entries.forEach(item => {
        if (typeof item === 'object') {
          Object.keys(item).forEach(classNames => {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === 'string') {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }

    function addClasses() {
      const swiper = this;
      const {
        classNames,
        params,
        rtl,
        $el,
        device,
        support
      } = swiper; // prettier-ignore

      const suffixes = prepareClasses(['initialized', params.direction, {
        'pointer-events': !support.touch
      }, {
        'free-mode': swiper.params.freeMode && params.freeMode.enabled
      }, {
        'autoheight': params.autoHeight
      }, {
        'rtl': rtl
      }, {
        'grid': params.grid && params.grid.rows > 1
      }, {
        'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
      }, {
        'android': device.android
      }, {
        'ios': device.ios
      }, {
        'css-mode': params.cssMode
      }, {
        'centered': params.cssMode && params.centeredSlides
      }, {
        'watch-progress': params.watchSlidesProgress
      }], params.containerModifierClass);
      classNames.push(...suffixes);
      $el.addClass([...classNames].join(' '));
      swiper.emitContainerClasses();
    }

    function removeClasses() {
      const swiper = this;
      const {
        $el,
        classNames
      } = swiper;
      $el.removeClass(classNames.join(' '));
      swiper.emitContainerClasses();
    }

    var classes = {
      addClasses,
      removeClasses
    };

    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
      const window = getWindow();
      let image;

      function onReady() {
        if (callback) callback();
      }

      const isPicture = $(imageEl).parent('picture')[0];

      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new window.Image();
          image.onload = onReady;
          image.onerror = onReady;

          if (sizes) {
            image.sizes = sizes;
          }

          if (srcset) {
            image.srcset = srcset;
          }

          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }

    function preloadImages() {
      const swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');

      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }

      for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
        const imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
      }
    }

    var images = {
      loadImage,
      preloadImages
    };

    function checkOverflow() {
      const swiper = this;
      const {
        isLocked: wasLocked,
        params
      } = swiper;
      const {
        slidesOffsetBefore
      } = params;

      if (slidesOffsetBefore) {
        const lastSlideIndex = swiper.slides.length - 1;
        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
        swiper.isLocked = swiper.size > lastSlideRightEdge;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }

      if (params.allowSlideNext === true) {
        swiper.allowSlideNext = !swiper.isLocked;
      }

      if (params.allowSlidePrev === true) {
        swiper.allowSlidePrev = !swiper.isLocked;
      }

      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
      }

      if (wasLocked !== swiper.isLocked) {
        swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
      }
    }

    var checkOverflow$1 = {
      checkOverflow
    };

    var defaults = {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'wrapper',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: true,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: 'input, select, option, textarea, button, video, label',
      // Overrides
      width: null,
      height: null,
      //
      preventInteractionOnTransition: false,
      // ssr
      userAgent: null,
      url: null,
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      // Autoheight
      autoHeight: false,
      // Set wrapper width
      setWrapperSize: false,
      // Virtual Translate
      virtualTranslate: false,
      // Effects
      effect: 'slide',
      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
      // Breakpoints
      breakpoints: undefined,
      breakpointsBase: 'window',
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: false,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      // in px
      slidesOffsetAfter: 0,
      // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: true,
      // Round length
      roundLengths: false,
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      // Unique Navigation Elements
      uniqueNavElements: true,
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
      // Progress
      watchSlidesProgress: false,
      // Cursor
      grabCursor: false,
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      // Images
      preloadImages: true,
      updateOnImagesReady: true,
      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopedSlidesLimit: true,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
      // rewind
      rewind: false,
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,
      // Passive Listeners
      passiveListeners: true,
      maxBackfaceHiddenSlides: 10,
      // NS
      containerModifierClass: 'swiper-',
      // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',
      // Callbacks
      runCallbacksOnInit: true,
      // Internals
      _emitClasses: false
    };

    function moduleExtendParams(params, allModulesParams) {
      return function extendParams(obj) {
        if (obj === void 0) {
          obj = {};
        }

        const moduleParamName = Object.keys(obj)[0];
        const moduleParams = obj[moduleParamName];

        if (typeof moduleParams !== 'object' || moduleParams === null) {
          extend$1(allModulesParams, obj);
          return;
        }

        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
          params[moduleParamName] = {
            auto: true
          };
        }

        if (!(moduleParamName in params && 'enabled' in moduleParams)) {
          extend$1(allModulesParams, obj);
          return;
        }

        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }

        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }

        if (!params[moduleParamName]) params[moduleParamName] = {
          enabled: false
        };
        extend$1(allModulesParams, obj);
      };
    }

    /* eslint no-param-reassign: "off" */
    const prototypes = {
      eventsEmitter,
      update,
      translate,
      transition: transition$1,
      slide,
      loop,
      grabCursor,
      events: events$1,
      breakpoints,
      checkOverflow: checkOverflow$1,
      classes,
      images
    };
    const extendedDefaults = {};

    class Swiper {
      constructor() {
        let el;
        let params;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
          params = args[0];
        } else {
          [el, params] = args;
        }

        if (!params) params = {};
        params = extend$1({}, params);
        if (el && !params.el) params.el = el;

        if (params.el && $(params.el).length > 1) {
          const swipers = [];
          $(params.el).each(containerEl => {
            const newParams = extend$1({}, params, {
              el: containerEl
            });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        } // Swiper Instance


        const swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
          userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        swiper.modules = [...swiper.__modules__];

        if (params.modules && Array.isArray(params.modules)) {
          swiper.modules.push(...params.modules);
        }

        const allModulesParams = {};
        swiper.modules.forEach(mod => {
          mod({
            swiper,
            extendParams: moduleExtendParams(params, allModulesParams),
            on: swiper.on.bind(swiper),
            once: swiper.once.bind(swiper),
            off: swiper.off.bind(swiper),
            emit: swiper.emit.bind(swiper)
          });
        }); // Extend defaults with modules params

        const swiperParams = extend$1({}, defaults, allModulesParams); // Extend defaults with passed params

        swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend$1({}, swiper.params);
        swiper.passedParams = extend$1({}, params); // add event listeners

        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach(eventName => {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }

        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        } // Save Dom lib


        swiper.$ = $; // Extend Swiper

        Object.assign(swiper, {
          enabled: swiper.params.enabled,
          el,
          // Classes
          classNames: [],
          // Slides
          slides: $(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],

          // isDirection
          isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },

          isVertical() {
            return swiper.params.direction === 'vertical';
          },

          // Indexes
          activeIndex: 0,
          realIndex: 0,
          //
          isBeginning: true,
          isEnd: false,
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
          // Touch Events
          touchEvents: function touchEvents() {
            const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            const desktop = ['pointerdown', 'pointermove', 'pointerup'];
            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3]
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2]
            };
            return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          }(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            focusableElements: swiper.params.focusableElements,
            // Last click time
            lastClickTime: now(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined
          },
          // Clicks
          allowClick: true,
          // Touches
          allowTouchMove: swiper.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          },
          // Images
          imagesToLoad: [],
          imagesLoaded: 0
        });
        swiper.emit('_swiper'); // Init

        if (swiper.params.init) {
          swiper.init();
        } // Return app instance


        return swiper;
      }

      enable() {
        const swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;

        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }

        swiper.emit('enable');
      }

      disable() {
        const swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;

        if (swiper.params.grabCursor) {
          swiper.unsetGrabCursor();
        }

        swiper.emit('disable');
      }

      setProgress(progress, speed) {
        const swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        const min = swiper.minTranslate();
        const max = swiper.maxTranslate();
        const current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      emitContainerClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const cls = swiper.el.className.split(' ').filter(className => {
          return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit('_containerClasses', cls.join(' '));
      }

      getSlideClasses(slideEl) {
        const swiper = this;
        if (swiper.destroyed) return '';
        return slideEl.className.split(' ').filter(className => {
          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(' ');
      }

      emitSlidesClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const updates = [];
        swiper.slides.each(slideEl => {
          const classNames = swiper.getSlideClasses(slideEl);
          updates.push({
            slideEl,
            classNames
          });
          swiper.emit('_slideClass', slideEl, classNames);
        });
        swiper.emit('_slideClasses', updates);
      }

      slidesPerViewDynamic(view, exact) {
        if (view === void 0) {
          view = 'current';
        }

        if (exact === void 0) {
          exact = false;
        }

        const swiper = this;
        const {
          params,
          slides,
          slidesGrid,
          slidesSizesGrid,
          size: swiperSize,
          activeIndex
        } = swiper;
        let spv = 1;

        if (params.centeredSlides) {
          let slideSize = slides[activeIndex].swiperSlideSize;
          let breakLoop;

          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }

          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
        } else {
          // eslint-disable-next-line
          if (view === 'current') {
            for (let i = activeIndex + 1; i < slides.length; i += 1) {
              const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;

              if (slideInView) {
                spv += 1;
              }
            }
          } else {
            // previous
            for (let i = activeIndex - 1; i >= 0; i -= 1) {
              const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;

              if (slideInView) {
                spv += 1;
              }
            }
          }
        }

        return spv;
      }

      update() {
        const swiper = this;
        if (!swiper || swiper.destroyed) return;
        const {
          snapGrid,
          params
        } = swiper; // Breakpoints

        if (params.breakpoints) {
          swiper.setBreakpoint();
        }

        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        function setTranslate() {
          const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        let translated;

        if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
          setTranslate();

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }

          if (!translated) {
            setTranslate();
          }
        }

        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }

        swiper.emit('update');
      }

      changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
          needUpdate = true;
        }

        const swiper = this;
        const currentDirection = swiper.params.direction;

        if (!newDirection) {
          // eslint-disable-next-line
          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }

        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
          return swiper;
        }

        swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each(slideEl => {
          if (newDirection === 'vertical') {
            slideEl.style.width = '';
          } else {
            slideEl.style.height = '';
          }
        });
        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();
        return swiper;
      }

      changeLanguageDirection(direction) {
        const swiper = this;
        if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
        swiper.rtl = direction === 'rtl';
        swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;

        if (swiper.rtl) {
          swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);
          swiper.el.dir = 'rtl';
        } else {
          swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);
          swiper.el.dir = 'ltr';
        }

        swiper.update();
      }

      mount(el) {
        const swiper = this;
        if (swiper.mounted) return true; // Find el

        const $el = $(el || swiper.params.el);
        el = $el[0];

        if (!el) {
          return false;
        }

        el.swiper = swiper;

        const getWrapperSelector = () => {
          return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
        };

        const getWrapper = () => {
          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            const res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

            res.children = options => $el.children(options);

            return res;
          }

          if (!$el.children) {
            return $($el).children(getWrapperSelector());
          }

          return $el.children(getWrapperSelector());
        }; // Find Wrapper


        let $wrapperEl = getWrapper();

        if ($wrapperEl.length === 0 && swiper.params.createElements) {
          const document = getDocument();
          const wrapper = document.createElement('div');
          $wrapperEl = $(wrapper);
          wrapper.className = swiper.params.wrapperClass;
          $el.append(wrapper);
          $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
            $wrapperEl.append(slideEl);
          });
        }

        Object.assign(swiper, {
          $el,
          el,
          $wrapperEl,
          wrapperEl: $wrapperEl[0],
          mounted: true,
          // RTL
          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
          wrongRTL: $wrapperEl.css('display') === '-webkit-box'
        });
        return true;
      }

      init(el) {
        const swiper = this;
        if (swiper.initialized) return swiper;
        const mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit('beforeInit'); // Set breakpoint

        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        } // Add Classes


        swiper.addClasses(); // Create loop

        if (swiper.params.loop) {
          swiper.loopCreate();
        } // Update size


        swiper.updateSize(); // Update slides

        swiper.updateSlides();

        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        } // Set Grab Cursor


        if (swiper.params.grabCursor && swiper.enabled) {
          swiper.setGrabCursor();
        }

        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        } // Slide To Initial Slide


        if (swiper.params.loop) {
          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        } // Attach events


        swiper.attachEvents(); // Init Flag

        swiper.initialized = true; // Emit

        swiper.emit('init');
        swiper.emit('afterInit');
        return swiper;
      }

      destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
          deleteInstance = true;
        }

        if (cleanStyles === void 0) {
          cleanStyles = true;
        }

        const swiper = this;
        const {
          params,
          $el,
          $wrapperEl,
          slides
        } = swiper;

        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
          return null;
        }

        swiper.emit('beforeDestroy'); // Init Flag

        swiper.initialized = false; // Detach events

        swiper.detachEvents(); // Destroy loop

        if (params.loop) {
          swiper.loopDestroy();
        } // Cleanup styles


        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr('style');
          $wrapperEl.removeAttr('style');

          if (slides && slides.length) {
            slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
          }
        }

        swiper.emit('destroy'); // Detach emitter events

        Object.keys(swiper.eventsListeners).forEach(eventName => {
          swiper.off(eventName);
        });

        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          deleteProps(swiper);
        }

        swiper.destroyed = true;
        return null;
      }

      static extendDefaults(newDefaults) {
        extend$1(extendedDefaults, newDefaults);
      }

      static get extendedDefaults() {
        return extendedDefaults;
      }

      static get defaults() {
        return defaults;
      }

      static installModule(mod) {
        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
        const modules = Swiper.prototype.__modules__;

        if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
          modules.push(mod);
        }
      }

      static use(module) {
        if (Array.isArray(module)) {
          module.forEach(m => Swiper.installModule(m));
          return Swiper;
        }

        Swiper.installModule(module);
        return Swiper;
      }

    }

    Object.keys(prototypes).forEach(prototypeGroup => {
      Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    Swiper.use([Resize, Observer]);

    /* eslint-disable consistent-return */
    function Mousewheel(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      const window = getWindow();
      extendParams({
        mousewheel: {
          enabled: false,
          releaseOnEdges: false,
          invert: false,
          forceToAxis: false,
          sensitivity: 1,
          eventsTarget: 'container',
          thresholdDelta: null,
          thresholdTime: null
        }
      });
      swiper.mousewheel = {
        enabled: false
      };
      let timeout;
      let lastScrollTime = now();
      let lastEventBeforeSnap;
      const recentWheelEvents = [];

      function normalize(e) {
        // Reasonable defaults
        const PIXEL_STEP = 10;
        const LINE_HEIGHT = 40;
        const PAGE_HEIGHT = 800;
        let sX = 0;
        let sY = 0; // spinX, spinY

        let pX = 0;
        let pY = 0; // pixelX, pixelY
        // Legacy

        if ('detail' in e) {
          sY = e.detail;
        }

        if ('wheelDelta' in e) {
          sY = -e.wheelDelta / 120;
        }

        if ('wheelDeltaY' in e) {
          sY = -e.wheelDeltaY / 120;
        }

        if ('wheelDeltaX' in e) {
          sX = -e.wheelDeltaX / 120;
        } // side scrolling on FF with DOMMouseScroll


        if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
          sX = sY;
          sY = 0;
        }

        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;

        if ('deltaY' in e) {
          pY = e.deltaY;
        }

        if ('deltaX' in e) {
          pX = e.deltaX;
        }

        if (e.shiftKey && !pX) {
          // if user scrolls with shift he wants horizontal scroll
          pX = pY;
          pY = 0;
        }

        if ((pX || pY) && e.deltaMode) {
          if (e.deltaMode === 1) {
            // delta in LINE units
            pX *= LINE_HEIGHT;
            pY *= LINE_HEIGHT;
          } else {
            // delta in PAGE units
            pX *= PAGE_HEIGHT;
            pY *= PAGE_HEIGHT;
          }
        } // Fall-back if spin cannot be determined


        if (pX && !sX) {
          sX = pX < 1 ? -1 : 1;
        }

        if (pY && !sY) {
          sY = pY < 1 ? -1 : 1;
        }

        return {
          spinX: sX,
          spinY: sY,
          pixelX: pX,
          pixelY: pY
        };
      }

      function handleMouseEnter() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = true;
      }

      function handleMouseLeave() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = false;
      }

      function animateSlider(newEvent) {
        if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
          // Prevent if delta of wheel scroll delta is below configured threshold
          return false;
        }

        if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
          // Prevent if time between scrolls is below configured threshold
          return false;
        } // If the movement is NOT big enough and
        // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
        //   Don't go any further (avoid insignificant scroll movement).


        if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
          // Return false as a default
          return true;
        } // If user is scrolling towards the end:
        //   If the slider hasn't hit the latest slide or
        //   if the slider is a loop and
        //   if the slider isn't moving right now:
        //     Go to next slide and
        //     emit a scroll event.
        // Else (the user is scrolling towards the beginning) and
        // if the slider hasn't hit the first slide or
        // if the slider is a loop and
        // if the slider isn't moving right now:
        //   Go to prev slide and
        //   emit a scroll event.


        if (newEvent.direction < 0) {
          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
            swiper.slideNext();
            emit('scroll', newEvent.raw);
          }
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
          swiper.slidePrev();
          emit('scroll', newEvent.raw);
        } // If you got here is because an animation has been triggered so store the current time


        lastScrollTime = new window.Date().getTime(); // Return false as a default

        return false;
      }

      function releaseScroll(newEvent) {
        const params = swiper.params.mousewheel;

        if (newEvent.direction < 0) {
          if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
            // Return true to animate scroll on edges
            return true;
          }
        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
          // Return true to animate scroll on edges
          return true;
        }

        return false;
      }

      function handle(event) {
        let e = event;
        let disableParentSwiper = true;
        if (!swiper.enabled) return;
        const params = swiper.params.mousewheel;

        if (swiper.params.cssMode) {
          e.preventDefault();
        }

        let target = swiper.$el;

        if (swiper.params.mousewheel.eventsTarget !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarget);
        }

        if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
        if (e.originalEvent) e = e.originalEvent; // jquery fix

        let delta = 0;
        const rtlFactor = swiper.rtlTranslate ? -1 : 1;
        const data = normalize(e);

        if (params.forceToAxis) {
          if (swiper.isHorizontal()) {
            if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
          } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
        } else {
          delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
        }

        if (delta === 0) return true;
        if (params.invert) delta = -delta; // Get the scroll positions

        let positions = swiper.getTranslate() + delta * params.sensitivity;
        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:
        //     the disableParentSwiper will be true.
        // When loop is false:
        //     if the scroll positions is not on edge,
        //     then the disableParentSwiper will be true.
        //     if the scroll on edge positions,
        //     then the disableParentSwiper will be false.

        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();

        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
          // Register the new event in a variable which stores the relevant data
          const newEvent = {
            time: now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta),
            raw: event
          }; // Keep the most recent events

          if (recentWheelEvents.length >= 2) {
            recentWheelEvents.shift(); // only store the last N events
          }

          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
          //   If direction has changed or
          //   if the scroll is quicker than the previous one:
          //     Animate the slider.
          // Else (this is the first time the wheel is moved):
          //     Animate the slider.

          if (prevEvent) {
            if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
              animateSlider(newEvent);
            }
          } else {
            animateSlider(newEvent);
          } // If it's time to release the scroll:
          //   Return now so you don't hit the preventDefault.


          if (releaseScroll(newEvent)) {
            return true;
          }
        } else {
          // Freemode or scrollContainer:
          // If we recently snapped after a momentum scroll, then ignore wheel events
          // to give time for the deceleration to finish. Stop ignoring after 500 msecs
          // or if it's a new scroll (larger delta or inverse sign as last event before
          // an end-of-momentum snap).
          const newEvent = {
            time: now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta)
          };
          const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;

          if (!ignoreWheelEvents) {
            lastEventBeforeSnap = undefined;

            if (swiper.params.loop) {
              swiper.loopFix();
            }

            let position = swiper.getTranslate() + delta * params.sensitivity;
            const wasBeginning = swiper.isBeginning;
            const wasEnd = swiper.isEnd;
            if (position >= swiper.minTranslate()) position = swiper.minTranslate();
            if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
            swiper.setTransition(0);
            swiper.setTranslate(position);
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();

            if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
              swiper.updateSlidesClasses();
            }

            if (swiper.params.freeMode.sticky) {
              // When wheel scrolling starts with sticky (aka snap) enabled, then detect
              // the end of a momentum scroll by storing recent (N=15?) wheel events.
              // 1. do all N events have decreasing or same (absolute value) delta?
              // 2. did all N events arrive in the last M (M=500?) msecs?
              // 3. does the earliest event have an (absolute value) delta that's
              //    at least P (P=1?) larger than the most recent event's delta?
              // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
              // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
              // Snap immediately and ignore remaining wheel events in this scroll.
              // See comment above for "remaining wheel events in this scroll" determination.
              // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
              clearTimeout(timeout);
              timeout = undefined;

              if (recentWheelEvents.length >= 15) {
                recentWheelEvents.shift(); // only store the last N events
              }

              const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
              const firstEvent = recentWheelEvents[0];
              recentWheelEvents.push(newEvent);

              if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                recentWheelEvents.splice(0);
              } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                // We're at the end of the deceleration of a momentum scroll, so there's no need
                // to wait for more events. Snap ASAP on the next tick.
                // Also, because there's some remaining momentum we'll bias the snap in the
                // direction of the ongoing scroll because it's better UX for the scroll to snap
                // in the same direction as the scroll instead of reversing to snap.  Therefore,
                // if it's already scrolled more than 20% in the current direction, keep going.
                const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                lastEventBeforeSnap = newEvent;
                recentWheelEvents.splice(0);
                timeout = nextTick(() => {
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 0); // no delay; move on next tick
              }

              if (!timeout) {
                // if we get here, then we haven't detected the end of a momentum scroll, so
                // we'll consider a scroll "complete" when there haven't been any wheel events
                // for 500ms.
                timeout = nextTick(() => {
                  const snapToThreshold = 0.5;
                  lastEventBeforeSnap = newEvent;
                  recentWheelEvents.splice(0);
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 500);
              }
            } // Emit event


            if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay

            if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions

            if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
          }
        }

        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        return false;
      }

      function events(method) {
        let target = swiper.$el;

        if (swiper.params.mousewheel.eventsTarget !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarget);
        }

        target[method]('mouseenter', handleMouseEnter);
        target[method]('mouseleave', handleMouseLeave);
        target[method]('wheel', handle);
      }

      function enable() {
        if (swiper.params.cssMode) {
          swiper.wrapperEl.removeEventListener('wheel', handle);
          return true;
        }

        if (swiper.mousewheel.enabled) return false;
        events('on');
        swiper.mousewheel.enabled = true;
        return true;
      }

      function disable() {
        if (swiper.params.cssMode) {
          swiper.wrapperEl.addEventListener(event, handle);
          return true;
        }

        if (!swiper.mousewheel.enabled) return false;
        events('off');
        swiper.mousewheel.enabled = false;
        return true;
      }

      on('init', () => {
        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
          disable();
        }

        if (swiper.params.mousewheel.enabled) enable();
      });
      on('destroy', () => {
        if (swiper.params.cssMode) {
          enable();
        }

        if (swiper.mousewheel.enabled) disable();
      });
      Object.assign(swiper.mousewheel, {
        enable,
        disable
      });
    }

    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
      const document = getDocument();

      if (swiper.params.createElements) {
        Object.keys(checkProps).forEach(key => {
          if (!params[key] && params.auto === true) {
            let element = swiper.$el.children(`.${checkProps[key]}`)[0];

            if (!element) {
              element = document.createElement('div');
              element.className = checkProps[key];
              swiper.$el.append(element);
            }

            params[key] = element;
            originalParams[key] = element;
          }
        });
      }

      return params;
    }

    function Navigation(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      extendParams({
        navigation: {
          nextEl: null,
          prevEl: null,
          hideOnClick: false,
          disabledClass: 'swiper-button-disabled',
          hiddenClass: 'swiper-button-hidden',
          lockClass: 'swiper-button-lock',
          navigationDisabledClass: 'swiper-navigation-disabled'
        }
      });
      swiper.navigation = {
        nextEl: null,
        $nextEl: null,
        prevEl: null,
        $prevEl: null
      };

      function getEl(el) {
        let $el;

        if (el) {
          $el = $(el);

          if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
            $el = swiper.$el.find(el);
          }
        }

        return $el;
      }

      function toggleEl($el, disabled) {
        const params = swiper.params.navigation;

        if ($el && $el.length > 0) {
          $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
          if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;

          if (swiper.params.watchOverflow && swiper.enabled) {
            $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          }
        }
      }

      function update() {
        // Update Navigation Buttons
        if (swiper.params.loop) return;
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
        toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
      }

      function onPrevClick(e) {
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slidePrev();
        emit('navigationPrev');
      }

      function onNextClick(e) {
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slideNext();
        emit('navigationNext');
      }

      function init() {
        const params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
          nextEl: 'swiper-button-next',
          prevEl: 'swiper-button-prev'
        });
        if (!(params.nextEl || params.prevEl)) return;
        const $nextEl = getEl(params.nextEl);
        const $prevEl = getEl(params.prevEl);

        if ($nextEl && $nextEl.length > 0) {
          $nextEl.on('click', onNextClick);
        }

        if ($prevEl && $prevEl.length > 0) {
          $prevEl.on('click', onPrevClick);
        }

        Object.assign(swiper.navigation, {
          $nextEl,
          nextEl: $nextEl && $nextEl[0],
          $prevEl,
          prevEl: $prevEl && $prevEl[0]
        });

        if (!swiper.enabled) {
          if ($nextEl) $nextEl.addClass(params.lockClass);
          if ($prevEl) $prevEl.addClass(params.lockClass);
        }
      }

      function destroy() {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;

        if ($nextEl && $nextEl.length) {
          $nextEl.off('click', onNextClick);
          $nextEl.removeClass(swiper.params.navigation.disabledClass);
        }

        if ($prevEl && $prevEl.length) {
          $prevEl.off('click', onPrevClick);
          $prevEl.removeClass(swiper.params.navigation.disabledClass);
        }
      }

      on('init', () => {
        if (swiper.params.navigation.enabled === false) {
          // eslint-disable-next-line
          disable();
        } else {
          init();
          update();
        }
      });
      on('toEdge fromEdge lock unlock', () => {
        update();
      });
      on('destroy', () => {
        destroy();
      });
      on('enable disable', () => {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;

        if ($nextEl) {
          $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }

        if ($prevEl) {
          $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }
      });
      on('click', (_s, e) => {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        const targetEl = e.target;

        if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
          if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
          let isHidden;

          if ($nextEl) {
            isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
          } else if ($prevEl) {
            isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
          }

          if (isHidden === true) {
            emit('navigationShow');
          } else {
            emit('navigationHide');
          }

          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }

          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      });

      const enable = () => {
        swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);
        init();
        update();
      };

      const disable = () => {
        swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);
        destroy();
      };

      Object.assign(swiper.navigation, {
        enable,
        disable,
        update,
        init,
        destroy
      });
    }

    function classesToSelector(classes) {
      if (classes === void 0) {
        classes = '';
      }

      return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
    }

    function Pagination(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      const pfx = 'swiper-pagination';
      extendParams({
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: 'bullets',
          // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: number => number,
          formatFractionTotal: number => number,
          bulletClass: `${pfx}-bullet`,
          bulletActiveClass: `${pfx}-bullet-active`,
          modifierClass: `${pfx}-`,
          currentClass: `${pfx}-current`,
          totalClass: `${pfx}-total`,
          hiddenClass: `${pfx}-hidden`,
          progressbarFillClass: `${pfx}-progressbar-fill`,
          progressbarOppositeClass: `${pfx}-progressbar-opposite`,
          clickableClass: `${pfx}-clickable`,
          lockClass: `${pfx}-lock`,
          horizontalClass: `${pfx}-horizontal`,
          verticalClass: `${pfx}-vertical`,
          paginationDisabledClass: `${pfx}-disabled`
        }
      });
      swiper.pagination = {
        el: null,
        $el: null,
        bullets: []
      };
      let bulletSize;
      let dynamicBulletIndex = 0;

      function isPaginationDisabled() {
        return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
      }

      function setSideBullets($bulletEl, position) {
        const {
          bulletActiveClass
        } = swiper.params.pagination;
        $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
      }

      function update() {
        // Render || Update Pagination bullets/items
        const rtl = swiper.rtl;
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const $el = swiper.pagination.$el; // Current/Total

        let current;
        const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        if (swiper.params.loop) {
          current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

          if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
            current -= slidesLength - swiper.loopedSlides * 2;
          }

          if (current > total - 1) current -= total;
          if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
        } else if (typeof swiper.snapIndex !== 'undefined') {
          current = swiper.snapIndex;
        } else {
          current = swiper.activeIndex || 0;
        } // Types


        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
          const bullets = swiper.pagination.bullets;
          let firstIndex;
          let lastIndex;
          let midIndex;

          if (params.dynamicBullets) {
            bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
            $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);

            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
              dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);

              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (dynamicBulletIndex < 0) {
                dynamicBulletIndex = 0;
              }
            }

            firstIndex = Math.max(current - dynamicBulletIndex, 0);
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }

          bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));

          if ($el.length > 1) {
            bullets.each(bullet => {
              const $bullet = $(bullet);
              const bulletIndex = $bullet.index();

              if (bulletIndex === current) {
                $bullet.addClass(params.bulletActiveClass);
              }

              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  $bullet.addClass(`${params.bulletActiveClass}-main`);
                }

                if (bulletIndex === firstIndex) {
                  setSideBullets($bullet, 'prev');
                }

                if (bulletIndex === lastIndex) {
                  setSideBullets($bullet, 'next');
                }
              }
            });
          } else {
            const $bullet = bullets.eq(current);
            const bulletIndex = $bullet.index();
            $bullet.addClass(params.bulletActiveClass);

            if (params.dynamicBullets) {
              const $firstDisplayedBullet = bullets.eq(firstIndex);
              const $lastDisplayedBullet = bullets.eq(lastIndex);

              for (let i = firstIndex; i <= lastIndex; i += 1) {
                bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
              }

              if (swiper.params.loop) {
                if (bulletIndex >= bullets.length) {
                  for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                    bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                  }

                  bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
                } else {
                  setSideBullets($firstDisplayedBullet, 'prev');
                  setSideBullets($lastDisplayedBullet, 'next');
                }
              } else {
                setSideBullets($firstDisplayedBullet, 'prev');
                setSideBullets($lastDisplayedBullet, 'next');
              }
            }
          }

          if (params.dynamicBullets) {
            const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
            const offsetProp = rtl ? 'right' : 'left';
            bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
          }
        }

        if (params.type === 'fraction') {
          $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
          $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }

        if (params.type === 'progressbar') {
          let progressbarDirection;

          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }

          const scale = (current + 1) / total;
          let scaleX = 1;
          let scaleY = 1;

          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }

          $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
        }

        if (params.type === 'custom' && params.renderCustom) {
          $el.html(params.renderCustom(swiper, current + 1, total));
          emit('paginationRender', $el[0]);
        } else {
          emit('paginationUpdate', $el[0]);
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      }

      function render() {
        // Render Container
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const $el = swiper.pagination.$el;
        let paginationHTML = '';

        if (params.type === 'bullets') {
          let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

          if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
            numberOfBullets = slidesLength;
          }

          for (let i = 0; i < numberOfBullets; i += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
            } else {
              paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
            }
          }

          $el.html(paginationHTML);
          swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }

        if (params.type === 'fraction') {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
          } else {
            paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
          }

          $el.html(paginationHTML);
        }

        if (params.type === 'progressbar') {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
          } else {
            paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
          }

          $el.html(paginationHTML);
        }

        if (params.type !== 'custom') {
          emit('paginationRender', swiper.pagination.$el[0]);
        }
      }

      function init() {
        swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
          el: 'swiper-pagination'
        });
        const params = swiper.params.pagination;
        if (!params.el) return;
        let $el = $(params.el);
        if ($el.length === 0) return;

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
          $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper

          if ($el.length > 1) {
            $el = $el.filter(el => {
              if ($(el).parents('.swiper')[0] !== swiper.el) return false;
              return true;
            });
          }
        }

        if (params.type === 'bullets' && params.clickable) {
          $el.addClass(params.clickableClass);
        }

        $el.addClass(params.modifierClass + params.type);
        $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);

        if (params.type === 'bullets' && params.dynamicBullets) {
          $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
          dynamicBulletIndex = 0;

          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }

        if (params.type === 'progressbar' && params.progressbarOpposite) {
          $el.addClass(params.progressbarOppositeClass);
        }

        if (params.clickable) {
          $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
            e.preventDefault();
            let index = $(this).index() * swiper.params.slidesPerGroup;
            if (swiper.params.loop) index += swiper.loopedSlides;
            swiper.slideTo(index);
          });
        }

        Object.assign(swiper.pagination, {
          $el,
          el: $el[0]
        });

        if (!swiper.enabled) {
          $el.addClass(params.lockClass);
        }
      }

      function destroy() {
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const $el = swiper.pagination.$el;
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

        if (params.clickable) {
          $el.off('click', classesToSelector(params.bulletClass));
        }
      }

      on('init', () => {
        if (swiper.params.pagination.enabled === false) {
          // eslint-disable-next-line
          disable();
        } else {
          init();
          render();
          update();
        }
      });
      on('activeIndexChange', () => {
        if (swiper.params.loop) {
          update();
        } else if (typeof swiper.snapIndex === 'undefined') {
          update();
        }
      });
      on('snapIndexChange', () => {
        if (!swiper.params.loop) {
          update();
        }
      });
      on('slidesLengthChange', () => {
        if (swiper.params.loop) {
          render();
          update();
        }
      });
      on('snapGridLengthChange', () => {
        if (!swiper.params.loop) {
          render();
          update();
        }
      });
      on('destroy', () => {
        destroy();
      });
      on('enable disable', () => {
        const {
          $el
        } = swiper.pagination;

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
        }
      });
      on('lock unlock', () => {
        update();
      });
      on('click', (_s, e) => {
        const targetEl = e.target;
        const {
          $el
        } = swiper.pagination;

        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
          if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
          const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);

          if (isHidden === true) {
            emit('paginationShow');
          } else {
            emit('paginationHide');
          }

          $el.toggleClass(swiper.params.pagination.hiddenClass);
        }
      });

      const enable = () => {
        swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);

        if (swiper.pagination.$el) {
          swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
        }

        init();
        render();
        update();
      };

      const disable = () => {
        swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);

        if (swiper.pagination.$el) {
          swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);
        }

        destroy();
      };

      Object.assign(swiper.pagination, {
        enable,
        disable,
        render,
        update,
        init,
        destroy
      });
    }

    function Scrollbar(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      const document = getDocument();
      let isTouched = false;
      let timeout = null;
      let dragTimeout = null;
      let dragStartPos;
      let dragSize;
      let trackSize;
      let divider;
      extendParams({
        scrollbar: {
          el: null,
          dragSize: 'auto',
          hide: false,
          draggable: false,
          snapOnRelease: true,
          lockClass: 'swiper-scrollbar-lock',
          dragClass: 'swiper-scrollbar-drag',
          scrollbarDisabledClass: 'swiper-scrollbar-disabled',
          horizontalClass: `swiper-scrollbar-horizontal`,
          verticalClass: `swiper-scrollbar-vertical`
        }
      });
      swiper.scrollbar = {
        el: null,
        dragEl: null,
        $el: null,
        $dragEl: null
      };

      function setTranslate() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const {
          scrollbar,
          rtlTranslate: rtl,
          progress
        } = swiper;
        const {
          $dragEl,
          $el
        } = scrollbar;
        const params = swiper.params.scrollbar;
        let newSize = dragSize;
        let newPos = (trackSize - dragSize) * progress;

        if (rtl) {
          newPos = -newPos;

          if (newPos > 0) {
            newSize = dragSize - newPos;
            newPos = 0;
          } else if (-newPos + dragSize > trackSize) {
            newSize = trackSize + newPos;
          }
        } else if (newPos < 0) {
          newSize = dragSize + newPos;
          newPos = 0;
        } else if (newPos + dragSize > trackSize) {
          newSize = trackSize - newPos;
        }

        if (swiper.isHorizontal()) {
          $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
          $dragEl[0].style.width = `${newSize}px`;
        } else {
          $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
          $dragEl[0].style.height = `${newSize}px`;
        }

        if (params.hide) {
          clearTimeout(timeout);
          $el[0].style.opacity = 1;
          timeout = setTimeout(() => {
            $el[0].style.opacity = 0;
            $el.transition(400);
          }, 1000);
        }
      }

      function setTransition(duration) {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.$dragEl.transition(duration);
      }

      function updateSize() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const {
          scrollbar
        } = swiper;
        const {
          $dragEl,
          $el
        } = scrollbar;
        $dragEl[0].style.width = '';
        $dragEl[0].style.height = '';
        trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));

        if (swiper.params.scrollbar.dragSize === 'auto') {
          dragSize = trackSize * divider;
        } else {
          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        }

        if (swiper.isHorizontal()) {
          $dragEl[0].style.width = `${dragSize}px`;
        } else {
          $dragEl[0].style.height = `${dragSize}px`;
        }

        if (divider >= 1) {
          $el[0].style.display = 'none';
        } else {
          $el[0].style.display = '';
        }

        if (swiper.params.scrollbar.hide) {
          $el[0].style.opacity = 0;
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
        }
      }

      function getPointerPosition(e) {
        if (swiper.isHorizontal()) {
          return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
        }

        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
      }

      function setDragPosition(e) {
        const {
          scrollbar,
          rtlTranslate: rtl
        } = swiper;
        const {
          $el
        } = scrollbar;
        let positionRatio;
        positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);

        if (rtl) {
          positionRatio = 1 - positionRatio;
        }

        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      function onDragStart(e) {
        const params = swiper.params.scrollbar;
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el,
          $dragEl
        } = scrollbar;
        isTouched = true;
        dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
        e.preventDefault();
        e.stopPropagation();
        $wrapperEl.transition(100);
        $dragEl.transition(100);
        setDragPosition(e);
        clearTimeout(dragTimeout);
        $el.transition(0);

        if (params.hide) {
          $el.css('opacity', 1);
        }

        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', 'none');
        }

        emit('scrollbarDragStart', e);
      }

      function onDragMove(e) {
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el,
          $dragEl
        } = scrollbar;
        if (!isTouched) return;
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        setDragPosition(e);
        $wrapperEl.transition(0);
        $el.transition(0);
        $dragEl.transition(0);
        emit('scrollbarDragMove', e);
      }

      function onDragEnd(e) {
        const params = swiper.params.scrollbar;
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el
        } = scrollbar;
        if (!isTouched) return;
        isTouched = false;

        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', '');
          $wrapperEl.transition('');
        }

        if (params.hide) {
          clearTimeout(dragTimeout);
          dragTimeout = nextTick(() => {
            $el.css('opacity', 0);
            $el.transition(400);
          }, 1000);
        }

        emit('scrollbarDragEnd', e);

        if (params.snapOnRelease) {
          swiper.slideToClosest();
        }
      }

      function events(method) {
        const {
          scrollbar,
          touchEventsTouch,
          touchEventsDesktop,
          params,
          support
        } = swiper;
        const $el = scrollbar.$el;
        if (!$el) return;
        const target = $el[0];
        const activeListener = support.passiveListener && params.passiveListeners ? {
          passive: false,
          capture: false
        } : false;
        const passiveListener = support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        if (!target) return;
        const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';

        if (!support.touch) {
          target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
          document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
          document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
        } else {
          target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
          target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
          target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
        }
      }

      function enableDraggable() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        events('on');
      }

      function disableDraggable() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        events('off');
      }

      function init() {
        const {
          scrollbar,
          $el: $swiperEl
        } = swiper;
        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
          el: 'swiper-scrollbar'
        });
        const params = swiper.params.scrollbar;
        if (!params.el) return;
        let $el = $(params.el);

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
          $el = $swiperEl.find(params.el);
        }

        $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);

        if ($dragEl.length === 0) {
          $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
          $el.append($dragEl);
        }

        Object.assign(scrollbar, {
          $el,
          el: $el[0],
          $dragEl,
          dragEl: $dragEl[0]
        });

        if (params.draggable) {
          enableDraggable();
        }

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      }

      function destroy() {
        const params = swiper.params.scrollbar;
        const $el = swiper.scrollbar.$el;

        if ($el) {
          $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        }

        disableDraggable();
      }

      on('init', () => {
        if (swiper.params.scrollbar.enabled === false) {
          // eslint-disable-next-line
          disable();
        } else {
          init();
          updateSize();
          setTranslate();
        }
      });
      on('update resize observerUpdate lock unlock', () => {
        updateSize();
      });
      on('setTranslate', () => {
        setTranslate();
      });
      on('setTransition', (_s, duration) => {
        setTransition(duration);
      });
      on('enable disable', () => {
        const {
          $el
        } = swiper.scrollbar;

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      });
      on('destroy', () => {
        destroy();
      });

      const enable = () => {
        swiper.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);

        if (swiper.scrollbar.$el) {
          swiper.scrollbar.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);
        }

        init();
        updateSize();
        setTranslate();
      };

      const disable = () => {
        swiper.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);

        if (swiper.scrollbar.$el) {
          swiper.scrollbar.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);
        }

        destroy();
      };

      Object.assign(swiper.scrollbar, {
        enable,
        disable,
        updateSize,
        setTranslate,
        init,
        destroy
      });
    }

    function Parallax(_ref) {
      let {
        swiper,
        extendParams,
        on
      } = _ref;
      extendParams({
        parallax: {
          enabled: false
        }
      });

      const setTransform = (el, progress) => {
        const {
          rtl
        } = swiper;
        const $el = $(el);
        const rtlFactor = rtl ? -1 : 1;
        const p = $el.attr('data-swiper-parallax') || '0';
        let x = $el.attr('data-swiper-parallax-x');
        let y = $el.attr('data-swiper-parallax-y');
        const scale = $el.attr('data-swiper-parallax-scale');
        const opacity = $el.attr('data-swiper-parallax-opacity');

        if (x || y) {
          x = x || '0';
          y = y || '0';
        } else if (swiper.isHorizontal()) {
          x = p;
          y = '0';
        } else {
          y = p;
          x = '0';
        }

        if (x.indexOf('%') >= 0) {
          x = `${parseInt(x, 10) * progress * rtlFactor}%`;
        } else {
          x = `${x * progress * rtlFactor}px`;
        }

        if (y.indexOf('%') >= 0) {
          y = `${parseInt(y, 10) * progress}%`;
        } else {
          y = `${y * progress}px`;
        }

        if (typeof opacity !== 'undefined' && opacity !== null) {
          const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
          $el[0].style.opacity = currentOpacity;
        }

        if (typeof scale === 'undefined' || scale === null) {
          $el.transform(`translate3d(${x}, ${y}, 0px)`);
        } else {
          const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
          $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
        }
      };

      const setTranslate = () => {
        const {
          $el,
          slides,
          progress,
          snapGrid
        } = swiper;
        $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
          setTransform(el, progress);
        });
        slides.each((slideEl, slideIndex) => {
          let slideProgress = slideEl.progress;

          if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
            slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
          }

          slideProgress = Math.min(Math.max(slideProgress, -1), 1);
          $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
            setTransform(el, slideProgress);
          });
        });
      };

      const setTransition = function (duration) {
        if (duration === void 0) {
          duration = swiper.params.speed;
        }

        const {
          $el
        } = swiper;
        $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(parallaxEl => {
          const $parallaxEl = $(parallaxEl);
          let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
          if (duration === 0) parallaxDuration = 0;
          $parallaxEl.transition(parallaxDuration);
        });
      };

      on('beforeInit', () => {
        if (!swiper.params.parallax.enabled) return;
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      });
      on('init', () => {
        if (!swiper.params.parallax.enabled) return;
        setTranslate();
      });
      on('setTranslate', () => {
        if (!swiper.params.parallax.enabled) return;
        setTranslate();
      });
      on('setTransition', (_swiper, duration) => {
        if (!swiper.params.parallax.enabled) return;
        setTransition(duration);
      });
    }

    /* eslint no-underscore-dangle: "off" */
    function Autoplay(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      let timeout;
      swiper.autoplay = {
        running: false,
        paused: false
      };
      extendParams({
        autoplay: {
          enabled: false,
          delay: 3000,
          waitForTransition: true,
          disableOnInteraction: true,
          stopOnLastSlide: false,
          reverseDirection: false,
          pauseOnMouseEnter: false
        }
      });

      function run() {
        if (!swiper.size) {
          swiper.autoplay.running = false;
          swiper.autoplay.paused = false;
          return;
        }

        const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
        let delay = swiper.params.autoplay.delay;

        if ($activeSlideEl.attr('data-swiper-autoplay')) {
          delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
        }

        clearTimeout(timeout);
        timeout = nextTick(() => {
          let autoplayResult;

          if (swiper.params.autoplay.reverseDirection) {
            if (swiper.params.loop) {
              swiper.loopFix();
              autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
              emit('autoplay');
            } else if (!swiper.isBeginning) {
              autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
              emit('autoplay');
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
              autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
              emit('autoplay');
            } else {
              stop();
            }
          } else if (swiper.params.loop) {
            swiper.loopFix();
            autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.isEnd) {
            autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
            emit('autoplay');
          } else {
            stop();
          }

          if (swiper.params.cssMode && swiper.autoplay.running) run();else if (autoplayResult === false) {
            run();
          }
        }, delay);
      }

      function start() {
        if (typeof timeout !== 'undefined') return false;
        if (swiper.autoplay.running) return false;
        swiper.autoplay.running = true;
        emit('autoplayStart');
        run();
        return true;
      }

      function stop() {
        if (!swiper.autoplay.running) return false;
        if (typeof timeout === 'undefined') return false;

        if (timeout) {
          clearTimeout(timeout);
          timeout = undefined;
        }

        swiper.autoplay.running = false;
        emit('autoplayStop');
        return true;
      }

      function pause(speed) {
        if (!swiper.autoplay.running) return;
        if (swiper.autoplay.paused) return;
        if (timeout) clearTimeout(timeout);
        swiper.autoplay.paused = true;

        if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
          swiper.autoplay.paused = false;
          run();
        } else {
          ['transitionend', 'webkitTransitionEnd'].forEach(event => {
            swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
          });
        }
      }

      function onVisibilityChange() {
        const document = getDocument();

        if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
          pause();
        }

        if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
          run();
          swiper.autoplay.paused = false;
        }
      }

      function onTransitionEnd(e) {
        if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
        if (e.target !== swiper.$wrapperEl[0]) return;
        ['transitionend', 'webkitTransitionEnd'].forEach(event => {
          swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
        });
        swiper.autoplay.paused = false;

        if (!swiper.autoplay.running) {
          stop();
        } else {
          run();
        }
      }

      function onMouseEnter() {
        if (swiper.params.autoplay.disableOnInteraction) {
          stop();
        } else {
          emit('autoplayPause');
          pause();
        }

        ['transitionend', 'webkitTransitionEnd'].forEach(event => {
          swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
        });
      }

      function onMouseLeave() {
        if (swiper.params.autoplay.disableOnInteraction) {
          return;
        }

        swiper.autoplay.paused = false;
        emit('autoplayResume');
        run();
      }

      function attachMouseEvents() {
        if (swiper.params.autoplay.pauseOnMouseEnter) {
          swiper.$el.on('mouseenter', onMouseEnter);
          swiper.$el.on('mouseleave', onMouseLeave);
        }
      }

      function detachMouseEvents() {
        swiper.$el.off('mouseenter', onMouseEnter);
        swiper.$el.off('mouseleave', onMouseLeave);
      }

      on('init', () => {
        if (swiper.params.autoplay.enabled) {
          start();
          const document = getDocument();
          document.addEventListener('visibilitychange', onVisibilityChange);
          attachMouseEvents();
        }
      });
      on('beforeTransitionStart', (_s, speed, internal) => {
        if (swiper.autoplay.running) {
          if (internal || !swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.pause(speed);
          } else {
            stop();
          }
        }
      });
      on('sliderFirstMove', () => {
        if (swiper.autoplay.running) {
          if (swiper.params.autoplay.disableOnInteraction) {
            stop();
          } else {
            pause();
          }
        }
      });
      on('touchEnd', () => {
        if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
          run();
        }
      });
      on('destroy', () => {
        detachMouseEvents();

        if (swiper.autoplay.running) {
          stop();
        }

        const document = getDocument();
        document.removeEventListener('visibilitychange', onVisibilityChange);
      });
      Object.assign(swiper.autoplay, {
        pause,
        run,
        start,
        stop
      });
    }

    function freeMode(_ref) {
      let {
        swiper,
        extendParams,
        emit,
        once
      } = _ref;
      extendParams({
        freeMode: {
          enabled: false,
          momentum: true,
          momentumRatio: 1,
          momentumBounce: true,
          momentumBounceRatio: 1,
          momentumVelocityRatio: 1,
          sticky: false,
          minimumVelocity: 0.02
        }
      });

      function onTouchStart() {
        const translate = swiper.getTranslate();
        swiper.setTranslate(translate);
        swiper.setTransition(0);
        swiper.touchEventsData.velocities.length = 0;
        swiper.freeMode.onTouchEnd({
          currentPos: swiper.rtl ? swiper.translate : -swiper.translate
        });
      }

      function onTouchMove() {
        const {
          touchEventsData: data,
          touches
        } = swiper; // Velocity

        if (data.velocities.length === 0) {
          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
            time: data.touchStartTime
          });
        }

        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
          time: now()
        });
      }

      function onTouchEnd(_ref2) {
        let {
          currentPos
        } = _ref2;
        const {
          params,
          $wrapperEl,
          rtlTranslate: rtl,
          snapGrid,
          touchEventsData: data
        } = swiper; // Time diff

        const touchEndTime = now();
        const timeDiff = touchEndTime - data.touchStartTime;

        if (currentPos < -swiper.minTranslate()) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (currentPos > -swiper.maxTranslate()) {
          if (swiper.slides.length < snapGrid.length) {
            swiper.slideTo(snapGrid.length - 1);
          } else {
            swiper.slideTo(swiper.slides.length - 1);
          }

          return;
        }

        if (params.freeMode.momentum) {
          if (data.velocities.length > 1) {
            const lastMoveEvent = data.velocities.pop();
            const velocityEvent = data.velocities.pop();
            const distance = lastMoveEvent.position - velocityEvent.position;
            const time = lastMoveEvent.time - velocityEvent.time;
            swiper.velocity = distance / time;
            swiper.velocity /= 2;

            if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
              swiper.velocity = 0;
            } // this implies that the user stopped moving a finger then released.
            // There would be no events with distance zero, so the last event is stale.


            if (time > 150 || now() - lastMoveEvent.time > 300) {
              swiper.velocity = 0;
            }
          } else {
            swiper.velocity = 0;
          }

          swiper.velocity *= params.freeMode.momentumVelocityRatio;
          data.velocities.length = 0;
          let momentumDuration = 1000 * params.freeMode.momentumRatio;
          const momentumDistance = swiper.velocity * momentumDuration;
          let newPosition = swiper.translate + momentumDistance;
          if (rtl) newPosition = -newPosition;
          let doBounce = false;
          let afterBouncePosition;
          const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
          let needsLoopFix;

          if (newPosition < swiper.maxTranslate()) {
            if (params.freeMode.momentumBounce) {
              if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                newPosition = swiper.maxTranslate() - bounceAmount;
              }

              afterBouncePosition = swiper.maxTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.maxTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (newPosition > swiper.minTranslate()) {
            if (params.freeMode.momentumBounce) {
              if (newPosition - swiper.minTranslate() > bounceAmount) {
                newPosition = swiper.minTranslate() + bounceAmount;
              }

              afterBouncePosition = swiper.minTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.minTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (params.freeMode.sticky) {
            let nextSlide;

            for (let j = 0; j < snapGrid.length; j += 1) {
              if (snapGrid[j] > -newPosition) {
                nextSlide = j;
                break;
              }
            }

            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
              newPosition = snapGrid[nextSlide];
            } else {
              newPosition = snapGrid[nextSlide - 1];
            }

            newPosition = -newPosition;
          }

          if (needsLoopFix) {
            once('transitionEnd', () => {
              swiper.loopFix();
            });
          } // Fix duration


          if (swiper.velocity !== 0) {
            if (rtl) {
              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
            } else {
              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
            }

            if (params.freeMode.sticky) {
              // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
              // event, then durations can be 20+ seconds to slide one (or zero!) slides.
              // It's easy to see this when simulating touch with mouse events. To fix this,
              // limit single-slide swipes to the default slide duration. This also has the
              // nice side effect of matching slide speed if the user stopped moving before
              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
              // For faster swipes, also apply limits (albeit higher ones).
              const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
              const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

              if (moveDistance < currentSlideSize) {
                momentumDuration = params.speed;
              } else if (moveDistance < 2 * currentSlideSize) {
                momentumDuration = params.speed * 1.5;
              } else {
                momentumDuration = params.speed * 2.5;
              }
            }
          } else if (params.freeMode.sticky) {
            swiper.slideToClosest();
            return;
          }

          if (params.freeMode.momentumBounce && doBounce) {
            swiper.updateProgress(afterBouncePosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            swiper.animating = true;
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
              emit('momentumBounce');
              swiper.setTransition(params.speed);
              setTimeout(() => {
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(() => {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }, 0);
            });
          } else if (swiper.velocity) {
            emit('_freeModeNoMomentumRelease');
            swiper.updateProgress(newPosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);

            if (!swiper.animating) {
              swiper.animating = true;
              $wrapperEl.transitionEnd(() => {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }
          } else {
            swiper.updateProgress(newPosition);
          }

          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        } else if (params.freeMode.sticky) {
          swiper.slideToClosest();
          return;
        } else if (params.freeMode) {
          emit('_freeModeNoMomentumRelease');
        }

        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }
      }

      Object.assign(swiper, {
        freeMode: {
          onTouchStart,
          onTouchMove,
          onTouchEnd
        }
      });
    }

    function createFashionSlider(el) {
      if (document.querySelector('.swiper-fashion')) {
        const swiperEl = el.querySelector('.swiper-fashion');
        let navigationLocked = false;
        let transitionDisabled = false;
        let frameId;

        const disableTransitions = $el => {
          $el.addClass('fashion-slider-no-transition');
          transitionDisabled = true;
          cancelAnimationFrame(frameId);
          frameId = requestAnimationFrame(() => {
            $el.removeClass('fashion-slider-no-transition');
            transitionDisabled = false;
            navigationLocked = false;
          });
        };

        const initNavigation = swiper => {
          // Use lock to control the button locking time without using the button component that comes with it
          swiper.$el.find('.fashion-slider-button-next').on('click', () => {
            if (!navigationLocked) {
              swiper.slideNext();
            }
          });
          swiper.$el.find('.fashion-slider-button-prev').on('click', () => {
            if (!navigationLocked) {
              swiper.slidePrev();
            }
          });
        };

        const destroyNavigation = swiper => {
          swiper.$el.find('.fashion-slider-button-next, .fashion-slider-button-prev').off('click');
        };

        const fashionSlider = new Swiper(swiperEl, {
          modules: [Parallax, Pagination, Autoplay],
          speed: 1300,
          allowTouchMove: false,
          // no touch swiping
          parallax: true,
          // text parallax
          on: {
            transitionStart(swiper) {
              const {
                slides,
                previousIndex,
                activeIndex,
                $el
              } = swiper;
              if (!transitionDisabled) navigationLocked = true; // lock navigation buttons

              const $activeSlide = slides.eq(activeIndex);
              const $previousSlide = slides.eq(previousIndex);
              const $previousImageScale = $previousSlide.find('.fashion-slider-scale'); // image wrapper

              const $previousImage = $previousSlide.find('img'); // current image

              const $activeImage = $activeSlide.find('img'); // next image

              const direction = activeIndex - previousIndex;
              const bgColor = $activeSlide.attr('data-slide-bg-color');
              $el.css('background-color', bgColor); // background color animation

              $previousImageScale.transform('scale(0.6)');
              $previousImage.transition(1000).transform('scale(1.2)'); // image scaling parallax

              $previousSlide.find('.fashion-slider-title-text').transition(1000).css('color', 'rgba(255,255,255,0)') // text transparency animation
              .css('opacity', '0'); // text transparency animation

              $previousImage.transitionEnd(() => {
                $activeImage.transition(1300).transform('translate3d(0, 0, 0) scale(1.2)'); // image shift parallax

                $previousImage.transition(1300).transform(`translate3d(${60 * direction}%, 0, 0)  scale(1.2)`);
              });
            },

            transitionEnd(swiper) {
              const {
                slides,
                activeIndex,
                $el
              } = swiper;
              const $activeSlide = slides.eq(activeIndex);
              const $activeImage = $activeSlide.find('img');
              $activeSlide.find('.fashion-slider-scale').transform('scale(1)');
              $activeImage.transition(1000).transform('scale(1)');
              $activeSlide.find('.fashion-slider-title-text').transition(1000).css('color', 'rgba(255,255,255,1)').css('opacity', '1'); // text transparency animation

              $activeImage.transitionEnd(() => {
                navigationLocked = false;
              }); // First and last, disable button

              if (activeIndex === 0) {
                $el.find('.fashion-slider-button-prev').addClass('fashion-slider-button-disabled');
              } else {
                $el.find('.fashion-slider-button-prev').removeClass('fashion-slider-button-disabled');
              }

              if (activeIndex === slides.length - 1) {
                $el.find('.fashion-slider-button-next').addClass('fashion-slider-button-disabled');
              } else {
                $el.find('.fashion-slider-button-next').removeClass('fashion-slider-button-disabled');
              }
            },

            init(swiper) {
              // Set initial slide bg color
              const {
                slides,
                activeIndex,
                $el
              } = swiper; // disable initial transition

              disableTransitions($el); // set current bg color

              const bgColor = slides.eq(activeIndex).attr('data-slide-bg-color');
              $el.css('background-color', bgColor); // background color animation
              // trigger the transitionEnd event once during initialization

              swiper.emit('transitionEnd'); // init navigation

              initNavigation(swiper);
            },

            resize(swiper) {
              disableTransitions(swiper.$el);
            },

            destroy(swiper) {
              destroyNavigation(swiper);
            }

          },
          pagination: {
            el: ".fashion-pagination",
            type: 'bullets',
            clickable: true
          },
          autoplay: {
            delay: 2500,
            disableOnInteraction: false
          }
        });
        return fashionSlider;
      }
    }

    // @fancyapps/ui/Fancybox v4.0.31
    const t = t => "object" == typeof t && null !== t && t.constructor === Object && "[object Object]" === Object.prototype.toString.call(t),
          e = (...i) => {
      let s = !1;
      "boolean" == typeof i[0] && (s = i.shift());
      let o = i[0];
      if (!o || "object" != typeof o) throw new Error("extendee must be an object");
      const n = i.slice(1),
            a = n.length;

      for (let i = 0; i < a; i++) {
        const a = n[i];

        for (let i in a) if (a.hasOwnProperty(i)) {
          const n = a[i];

          if (s && (Array.isArray(n) || t(n))) {
            const t = Array.isArray(n) ? [] : {};
            o[i] = e(!0, o.hasOwnProperty(i) ? o[i] : t, n);
          } else o[i] = n;
        }
      }

      return o;
    },
          i = (t, e = 1e4) => (t = parseFloat(t) || 0, Math.round((t + Number.EPSILON) * e) / e),
          s = function (t) {
      return !!(t && "object" == typeof t && t instanceof Element && t !== document.body) && !t.__Panzoom && (function (t) {
        const e = getComputedStyle(t)["overflow-y"],
              i = getComputedStyle(t)["overflow-x"],
              s = ("scroll" === e || "auto" === e) && Math.abs(t.scrollHeight - t.clientHeight) > 1,
              o = ("scroll" === i || "auto" === i) && Math.abs(t.scrollWidth - t.clientWidth) > 1;
        return s || o;
      }(t) ? t : s(t.parentNode));
    },
          o = "undefined" != typeof window && window.ResizeObserver || class {
      constructor(t) {
        this.observables = [], this.boundCheck = this.check.bind(this), this.boundCheck(), this.callback = t;
      }

      observe(t) {
        if (this.observables.some(e => e.el === t)) return;
        const e = {
          el: t,
          size: {
            height: t.clientHeight,
            width: t.clientWidth
          }
        };
        this.observables.push(e);
      }

      unobserve(t) {
        this.observables = this.observables.filter(e => e.el !== t);
      }

      disconnect() {
        this.observables = [];
      }

      check() {
        const t = this.observables.filter(t => {
          const e = t.el.clientHeight,
                i = t.el.clientWidth;
          if (t.size.height !== e || t.size.width !== i) return t.size.height = e, t.size.width = i, !0;
        }).map(t => t.el);
        t.length > 0 && this.callback(t), window.requestAnimationFrame(this.boundCheck);
      }

    };

    class n {
      constructor(t) {
        this.id = self.Touch && t instanceof Touch ? t.identifier : -1, this.pageX = t.pageX, this.pageY = t.pageY, this.clientX = t.clientX, this.clientY = t.clientY;
      }

    }

    const a = (t, e) => e ? Math.sqrt((e.clientX - t.clientX) ** 2 + (e.clientY - t.clientY) ** 2) : 0,
          r = (t, e) => e ? {
      clientX: (t.clientX + e.clientX) / 2,
      clientY: (t.clientY + e.clientY) / 2
    } : t;

    class h {
      constructor(t, {
        start: e = () => !0,
        move: i = () => {},
        end: s = () => {}
      } = {}) {
        this._element = t, this.startPointers = [], this.currentPointers = [], this._pointerStart = t => {
          if (t.buttons > 0 && 0 !== t.button) return;
          const e = new n(t);
          this.currentPointers.some(t => t.id === e.id) || this._triggerPointerStart(e, t) && (window.addEventListener("mousemove", this._move), window.addEventListener("mouseup", this._pointerEnd));
        }, this._touchStart = t => {
          for (const e of Array.from(t.changedTouches || [])) this._triggerPointerStart(new n(e), t);
        }, this._move = t => {
          const e = this.currentPointers.slice(),
                i = (t => "changedTouches" in t)(t) ? Array.from(t.changedTouches).map(t => new n(t)) : [new n(t)];

          for (const t of i) {
            const e = this.currentPointers.findIndex(e => e.id === t.id);
            e < 0 || (this.currentPointers[e] = t);
          }

          this._moveCallback(e, this.currentPointers.slice(), t);
        }, this._triggerPointerEnd = (t, e) => {
          const i = this.currentPointers.findIndex(e => e.id === t.id);
          return !(i < 0) && (this.currentPointers.splice(i, 1), this.startPointers.splice(i, 1), this._endCallback(t, e), !0);
        }, this._pointerEnd = t => {
          t.buttons > 0 && 0 !== t.button || this._triggerPointerEnd(new n(t), t) && (window.removeEventListener("mousemove", this._move, {
            passive: !1
          }), window.removeEventListener("mouseup", this._pointerEnd, {
            passive: !1
          }));
        }, this._touchEnd = t => {
          for (const e of Array.from(t.changedTouches || [])) this._triggerPointerEnd(new n(e), t);
        }, this._startCallback = e, this._moveCallback = i, this._endCallback = s, this._element.addEventListener("mousedown", this._pointerStart, {
          passive: !1
        }), this._element.addEventListener("touchstart", this._touchStart, {
          passive: !1
        }), this._element.addEventListener("touchmove", this._move, {
          passive: !1
        }), this._element.addEventListener("touchend", this._touchEnd), this._element.addEventListener("touchcancel", this._touchEnd);
      }

      stop() {
        this._element.removeEventListener("mousedown", this._pointerStart, {
          passive: !1
        }), this._element.removeEventListener("touchstart", this._touchStart, {
          passive: !1
        }), this._element.removeEventListener("touchmove", this._move, {
          passive: !1
        }), this._element.removeEventListener("touchend", this._touchEnd), this._element.removeEventListener("touchcancel", this._touchEnd), window.removeEventListener("mousemove", this._move), window.removeEventListener("mouseup", this._pointerEnd);
      }

      _triggerPointerStart(t, e) {
        return !!this._startCallback(t, e) && (this.currentPointers.push(t), this.startPointers.push(t), !0);
      }

    }

    class l {
      constructor(t = {}) {
        this.options = e(!0, {}, t), this.plugins = [], this.events = {};

        for (const t of ["on", "once"]) for (const e of Object.entries(this.options[t] || {})) this[t](...e);
      }

      option(t, e, ...i) {
        t = String(t);
        let s = (o = t, n = this.options, o.split(".").reduce(function (t, e) {
          return t && t[e];
        }, n));
        var o, n;
        return "function" == typeof s && (s = s.call(this, this, ...i)), void 0 === s ? e : s;
      }

      localize(t, e = []) {
        return t = (t = String(t).replace(/\{\{(\w+).?(\w+)?\}\}/g, (t, i, s) => {
          let o = "";
          s ? o = this.option(`${i[0] + i.toLowerCase().substring(1)}.l10n.${s}`) : i && (o = this.option(`l10n.${i}`)), o || (o = t);

          for (let t = 0; t < e.length; t++) o = o.split(e[t][0]).join(e[t][1]);

          return o;
        })).replace(/\{\{(.*)\}\}/, (t, e) => e);
      }

      on(e, i) {
        if (t(e)) {
          for (const t of Object.entries(e)) this.on(...t);

          return this;
        }

        return String(e).split(" ").forEach(t => {
          const e = this.events[t] = this.events[t] || [];
          -1 == e.indexOf(i) && e.push(i);
        }), this;
      }

      once(e, i) {
        if (t(e)) {
          for (const t of Object.entries(e)) this.once(...t);

          return this;
        }

        return String(e).split(" ").forEach(t => {
          const e = (...s) => {
            this.off(t, e), i.call(this, this, ...s);
          };

          e._ = i, this.on(t, e);
        }), this;
      }

      off(e, i) {
        if (!t(e)) return e.split(" ").forEach(t => {
          const e = this.events[t];
          if (!e || !e.length) return this;
          let s = -1;

          for (let t = 0, o = e.length; t < o; t++) {
            const o = e[t];

            if (o && (o === i || o._ === i)) {
              s = t;
              break;
            }
          }

          -1 != s && e.splice(s, 1);
        }), this;

        for (const t of Object.entries(e)) this.off(...t);
      }

      trigger(t, ...e) {
        for (const i of [...(this.events[t] || [])].slice()) if (i && !1 === i.call(this, this, ...e)) return !1;

        for (const i of [...(this.events["*"] || [])].slice()) if (i && !1 === i.call(this, t, this, ...e)) return !1;

        return !0;
      }

      attachPlugins(t) {
        const i = {};

        for (const [s, o] of Object.entries(t || {})) !1 === this.options[s] || this.plugins[s] || (this.options[s] = e({}, o.defaults || {}, this.options[s]), i[s] = new o(this));

        for (const [t, e] of Object.entries(i)) e.attach(this);

        return this.plugins = Object.assign({}, this.plugins, i), this;
      }

      detachPlugins() {
        for (const t in this.plugins) {
          let e;
          (e = this.plugins[t]) && "function" == typeof e.detach && e.detach(this);
        }

        return this.plugins = {}, this;
      }

    }

    const c = {
      touch: !0,
      zoom: !0,
      pinchToZoom: !0,
      panOnlyZoomed: !1,
      lockAxis: !1,
      friction: .64,
      decelFriction: .88,
      zoomFriction: .74,
      bounceForce: .2,
      baseScale: 1,
      minScale: 1,
      maxScale: 2,
      step: .5,
      textSelection: !1,
      click: "toggleZoom",
      wheel: "zoom",
      wheelFactor: 42,
      wheelLimit: 5,
      draggableClass: "is-draggable",
      draggingClass: "is-dragging",
      ratio: 1
    };

    class d extends l {
      constructor(t, i = {}) {
        super(e(!0, {}, c, i)), this.state = "init", this.$container = t;

        for (const t of ["onLoad", "onWheel", "onClick"]) this[t] = this[t].bind(this);

        this.initLayout(), this.resetValues(), this.attachPlugins(d.Plugins), this.trigger("init"), this.updateMetrics(), this.attachEvents(), this.trigger("ready"), !1 === this.option("centerOnStart") ? this.state = "ready" : this.panTo({
          friction: 0
        }), t.__Panzoom = this;
      }

      initLayout() {
        const t = this.$container;
        if (!(t instanceof HTMLElement)) throw new Error("Panzoom: Container not found");
        const e = this.option("content") || t.querySelector(".panzoom__content");
        if (!e) throw new Error("Panzoom: Content not found");
        this.$content = e;
        let i = this.option("viewport") || t.querySelector(".panzoom__viewport");
        i || !1 === this.option("wrapInner") || (i = document.createElement("div"), i.classList.add("panzoom__viewport"), i.append(...t.childNodes), t.appendChild(i)), this.$viewport = i || e.parentNode;
      }

      resetValues() {
        this.updateRate = this.option("updateRate", /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ? 250 : 24), this.container = {
          width: 0,
          height: 0
        }, this.viewport = {
          width: 0,
          height: 0
        }, this.content = {
          origWidth: 0,
          origHeight: 0,
          width: 0,
          height: 0,
          x: this.option("x", 0),
          y: this.option("y", 0),
          scale: this.option("baseScale")
        }, this.transform = {
          x: 0,
          y: 0,
          scale: 1
        }, this.resetDragPosition();
      }

      onLoad(t) {
        this.updateMetrics(), this.panTo({
          scale: this.option("baseScale"),
          friction: 0
        }), this.trigger("load", t);
      }

      onClick(t) {
        if (t.defaultPrevented) return;
        if (document.activeElement && document.activeElement.closest("[contenteditable]")) return;
        if (this.option("textSelection") && window.getSelection().toString().length && (!t.target || !t.target.hasAttribute("data-fancybox-close"))) return void t.stopPropagation();
        const e = this.$content.getClientRects()[0];
        if ("ready" !== this.state && (this.dragPosition.midPoint || Math.abs(e.top - this.dragStart.rect.top) > 1 || Math.abs(e.left - this.dragStart.rect.left) > 1)) return t.preventDefault(), void t.stopPropagation();
        !1 !== this.trigger("click", t) && this.option("zoom") && "toggleZoom" === this.option("click") && (t.preventDefault(), t.stopPropagation(), this.zoomWithClick(t));
      }

      onWheel(t) {
        !1 !== this.trigger("wheel", t) && this.option("zoom") && this.option("wheel") && this.zoomWithWheel(t);
      }

      zoomWithWheel(t) {
        void 0 === this.changedDelta && (this.changedDelta = 0);
        const e = Math.max(-1, Math.min(1, -t.deltaY || -t.deltaX || t.wheelDelta || -t.detail)),
              i = this.content.scale;
        let s = i * (100 + e * this.option("wheelFactor")) / 100;
        if (e < 0 && Math.abs(i - this.option("minScale")) < .01 || e > 0 && Math.abs(i - this.option("maxScale")) < .01 ? (this.changedDelta += Math.abs(e), s = i) : (this.changedDelta = 0, s = Math.max(Math.min(s, this.option("maxScale")), this.option("minScale"))), this.changedDelta > this.option("wheelLimit")) return;
        if (t.preventDefault(), s === i) return;
        const o = this.$content.getBoundingClientRect(),
              n = t.clientX - o.left,
              a = t.clientY - o.top;
        this.zoomTo(s, {
          x: n,
          y: a
        });
      }

      zoomWithClick(t) {
        const e = this.$content.getClientRects()[0],
              i = t.clientX - e.left,
              s = t.clientY - e.top;
        this.toggleZoom({
          x: i,
          y: s
        });
      }

      attachEvents() {
        this.$content.addEventListener("load", this.onLoad), this.$container.addEventListener("wheel", this.onWheel, {
          passive: !1
        }), this.$container.addEventListener("click", this.onClick, {
          passive: !1
        }), this.initObserver();
        const t = new h(this.$container, {
          start: (e, i) => {
            if (!this.option("touch")) return !1;
            if (this.velocity.scale < 0) return !1;
            const o = i.composedPath()[0];

            if (!t.currentPointers.length) {
              if (-1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(o.nodeName)) return !1;
              if (this.option("textSelection") && ((t, e, i) => {
                const s = t.childNodes,
                      o = document.createRange();

                for (let t = 0; t < s.length; t++) {
                  const n = s[t];
                  if (n.nodeType !== Node.TEXT_NODE) continue;
                  o.selectNodeContents(n);
                  const a = o.getBoundingClientRect();
                  if (e >= a.left && i >= a.top && e <= a.right && i <= a.bottom) return n;
                }

                return !1;
              })(o, e.clientX, e.clientY)) return !1;
            }

            return !s(o) && !1 !== this.trigger("touchStart", i) && ("mousedown" === i.type && i.preventDefault(), this.state = "pointerdown", this.resetDragPosition(), this.dragPosition.midPoint = null, this.dragPosition.time = Date.now(), !0);
          },
          move: (e, i, s) => {
            if ("pointerdown" !== this.state) return;
            if (!1 === this.trigger("touchMove", s)) return void s.preventDefault();
            if (i.length < 2 && !0 === this.option("panOnlyZoomed") && this.content.width <= this.viewport.width && this.content.height <= this.viewport.height && this.transform.scale <= this.option("baseScale")) return;
            if (i.length > 1 && (!this.option("zoom") || !1 === this.option("pinchToZoom"))) return;
            const o = r(e[0], e[1]),
                  n = r(i[0], i[1]),
                  h = n.clientX - o.clientX,
                  l = n.clientY - o.clientY,
                  c = a(e[0], e[1]),
                  d = a(i[0], i[1]),
                  u = c && d ? d / c : 1;
            this.dragOffset.x += h, this.dragOffset.y += l, this.dragOffset.scale *= u, this.dragOffset.time = Date.now() - this.dragPosition.time;
            const f = 1 === this.dragStart.scale && this.option("lockAxis");

            if (f && !this.lockAxis) {
              if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6) return void s.preventDefault();
              const t = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI);
              this.lockAxis = t > 45 && t < 135 ? "y" : "x";
            }

            if ("xy" === f || "y" !== this.lockAxis) {
              if (s.preventDefault(), s.stopPropagation(), s.stopImmediatePropagation(), this.lockAxis && (this.dragOffset["x" === this.lockAxis ? "y" : "x"] = 0), this.$container.classList.add(this.option("draggingClass")), this.transform.scale === this.option("baseScale") && "y" === this.lockAxis || (this.dragPosition.x = this.dragStart.x + this.dragOffset.x), this.transform.scale === this.option("baseScale") && "x" === this.lockAxis || (this.dragPosition.y = this.dragStart.y + this.dragOffset.y), this.dragPosition.scale = this.dragStart.scale * this.dragOffset.scale, i.length > 1) {
                const e = r(t.startPointers[0], t.startPointers[1]),
                      i = e.clientX - this.dragStart.rect.x,
                      s = e.clientY - this.dragStart.rect.y,
                      {
                  deltaX: o,
                  deltaY: a
                } = this.getZoomDelta(this.content.scale * this.dragOffset.scale, i, s);
                this.dragPosition.x -= o, this.dragPosition.y -= a, this.dragPosition.midPoint = n;
              } else this.setDragResistance();

              this.transform = {
                x: this.dragPosition.x,
                y: this.dragPosition.y,
                scale: this.dragPosition.scale
              }, this.startAnimation();
            }
          },
          end: (e, i) => {
            if ("pointerdown" !== this.state) return;
            if (this._dragOffset = { ...this.dragOffset
            }, t.currentPointers.length) return void this.resetDragPosition();
            if (this.state = "decel", this.friction = this.option("decelFriction"), this.recalculateTransform(), this.$container.classList.remove(this.option("draggingClass")), !1 === this.trigger("touchEnd", i)) return;
            if ("decel" !== this.state) return;
            const s = this.option("minScale");
            if (this.transform.scale < s) return void this.zoomTo(s, {
              friction: .64
            });
            const o = this.option("maxScale");

            if (this.transform.scale - o > .01) {
              const t = this.dragPosition.midPoint || e,
                    i = this.$content.getClientRects()[0];
              this.zoomTo(o, {
                friction: .64,
                x: t.clientX - i.left,
                y: t.clientY - i.top
              });
            }
          }
        });
        this.pointerTracker = t;
      }

      initObserver() {
        this.resizeObserver || (this.resizeObserver = new o(() => {
          this.updateTimer || (this.updateTimer = setTimeout(() => {
            const t = this.$container.getBoundingClientRect();
            t.width && t.height ? ((Math.abs(t.width - this.container.width) > 1 || Math.abs(t.height - this.container.height) > 1) && (this.isAnimating() && this.endAnimation(!0), this.updateMetrics(), this.panTo({
              x: this.content.x,
              y: this.content.y,
              scale: this.option("baseScale"),
              friction: 0
            })), this.updateTimer = null) : this.updateTimer = null;
          }, this.updateRate));
        }), this.resizeObserver.observe(this.$container));
      }

      resetDragPosition() {
        this.lockAxis = null, this.friction = this.option("friction"), this.velocity = {
          x: 0,
          y: 0,
          scale: 0
        };
        const {
          x: t,
          y: e,
          scale: i
        } = this.content;
        this.dragStart = {
          rect: this.$content.getBoundingClientRect(),
          x: t,
          y: e,
          scale: i
        }, this.dragPosition = { ...this.dragPosition,
          x: t,
          y: e,
          scale: i
        }, this.dragOffset = {
          x: 0,
          y: 0,
          scale: 1,
          time: 0
        };
      }

      updateMetrics(t) {
        !0 !== t && this.trigger("beforeUpdate");
        const e = this.$container,
              s = this.$content,
              o = this.$viewport,
              n = s instanceof HTMLImageElement,
              a = this.option("zoom"),
              r = this.option("resizeParent", a);
        let h = this.option("width"),
            l = this.option("height"),
            c = h || (d = s, Math.max(parseFloat(d.naturalWidth || 0), parseFloat(d.width && d.width.baseVal && d.width.baseVal.value || 0), parseFloat(d.offsetWidth || 0), parseFloat(d.scrollWidth || 0)));
        var d;

        let u = l || (t => Math.max(parseFloat(t.naturalHeight || 0), parseFloat(t.height && t.height.baseVal && t.height.baseVal.value || 0), parseFloat(t.offsetHeight || 0), parseFloat(t.scrollHeight || 0)))(s);

        Object.assign(s.style, {
          width: h ? `${h}px` : "",
          height: l ? `${l}px` : "",
          maxWidth: "",
          maxHeight: ""
        }), r && Object.assign(o.style, {
          width: "",
          height: ""
        });
        const f = this.option("ratio");
        c = i(c * f), u = i(u * f), h = c, l = u;
        const g = s.getBoundingClientRect(),
              p = o.getBoundingClientRect(),
              m = o == e ? p : e.getBoundingClientRect();
        let y = Math.max(o.offsetWidth, i(p.width)),
            v = Math.max(o.offsetHeight, i(p.height)),
            b = window.getComputedStyle(o);

        if (y -= parseFloat(b.paddingLeft) + parseFloat(b.paddingRight), v -= parseFloat(b.paddingTop) + parseFloat(b.paddingBottom), this.viewport.width = y, this.viewport.height = v, a) {
          if (Math.abs(c - g.width) > .1 || Math.abs(u - g.height) > .1) {
            const t = ((t, e, i, s) => {
              const o = Math.min(i / t || 0, s / e);
              return {
                width: t * o || 0,
                height: e * o || 0
              };
            })(c, u, Math.min(c, g.width), Math.min(u, g.height));

            h = i(t.width), l = i(t.height);
          }

          Object.assign(s.style, {
            width: `${h}px`,
            height: `${l}px`,
            transform: ""
          });
        }

        if (r && (Object.assign(o.style, {
          width: `${h}px`,
          height: `${l}px`
        }), this.viewport = { ...this.viewport,
          width: h,
          height: l
        }), n && a && "function" != typeof this.options.maxScale) {
          const t = this.option("maxScale");

          this.options.maxScale = function () {
            return this.content.origWidth > 0 && this.content.fitWidth > 0 ? this.content.origWidth / this.content.fitWidth : t;
          };
        }

        this.content = { ...this.content,
          origWidth: c,
          origHeight: u,
          fitWidth: h,
          fitHeight: l,
          width: h,
          height: l,
          scale: 1,
          isZoomable: a
        }, this.container = {
          width: m.width,
          height: m.height
        }, !0 !== t && this.trigger("afterUpdate");
      }

      zoomIn(t) {
        this.zoomTo(this.content.scale + (t || this.option("step")));
      }

      zoomOut(t) {
        this.zoomTo(this.content.scale - (t || this.option("step")));
      }

      toggleZoom(t = {}) {
        const e = this.option("maxScale"),
              i = this.option("baseScale"),
              s = this.content.scale > i + .5 * (e - i) ? i : e;
        this.zoomTo(s, t);
      }

      zoomTo(t = this.option("baseScale"), {
        x: e = null,
        y: s = null
      } = {}) {
        t = Math.max(Math.min(t, this.option("maxScale")), this.option("minScale"));
        const o = i(this.content.scale / (this.content.width / this.content.fitWidth), 1e7);
        null === e && (e = this.content.width * o * .5), null === s && (s = this.content.height * o * .5);
        const {
          deltaX: n,
          deltaY: a
        } = this.getZoomDelta(t, e, s);
        e = this.content.x - n, s = this.content.y - a, this.panTo({
          x: e,
          y: s,
          scale: t,
          friction: this.option("zoomFriction")
        });
      }

      getZoomDelta(t, e = 0, i = 0) {
        const s = this.content.fitWidth * this.content.scale,
              o = this.content.fitHeight * this.content.scale,
              n = e > 0 && s ? e / s : 0,
              a = i > 0 && o ? i / o : 0;
        return {
          deltaX: (this.content.fitWidth * t - s) * n,
          deltaY: (this.content.fitHeight * t - o) * a
        };
      }

      panTo({
        x: t = this.content.x,
        y: e = this.content.y,
        scale: i,
        friction: s = this.option("friction"),
        ignoreBounds: o = !1
      } = {}) {
        if (i = i || this.content.scale || 1, !o) {
          const {
            boundX: s,
            boundY: o
          } = this.getBounds(i);
          s && (t = Math.max(Math.min(t, s.to), s.from)), o && (e = Math.max(Math.min(e, o.to), o.from));
        }

        this.friction = s, this.transform = { ...this.transform,
          x: t,
          y: e,
          scale: i
        }, s ? (this.state = "panning", this.velocity = {
          x: (1 / this.friction - 1) * (t - this.content.x),
          y: (1 / this.friction - 1) * (e - this.content.y),
          scale: (1 / this.friction - 1) * (i - this.content.scale)
        }, this.startAnimation()) : this.endAnimation();
      }

      startAnimation() {
        this.rAF ? cancelAnimationFrame(this.rAF) : this.trigger("startAnimation"), this.rAF = requestAnimationFrame(() => this.animate());
      }

      animate() {
        if (this.setEdgeForce(), this.setDragForce(), this.velocity.x *= this.friction, this.velocity.y *= this.friction, this.velocity.scale *= this.friction, this.content.x += this.velocity.x, this.content.y += this.velocity.y, this.content.scale += this.velocity.scale, this.isAnimating()) this.setTransform();else if ("pointerdown" !== this.state) return void this.endAnimation();
        this.rAF = requestAnimationFrame(() => this.animate());
      }

      getBounds(t) {
        let e = this.boundX,
            s = this.boundY;
        if (void 0 !== e && void 0 !== s) return {
          boundX: e,
          boundY: s
        };
        e = {
          from: 0,
          to: 0
        }, s = {
          from: 0,
          to: 0
        }, t = t || this.transform.scale;
        const o = this.content.fitWidth * t,
              n = this.content.fitHeight * t,
              a = this.viewport.width,
              r = this.viewport.height;

        if (o < a) {
          const t = i(.5 * (a - o));
          e.from = t, e.to = t;
        } else e.from = i(a - o);

        if (n < r) {
          const t = .5 * (r - n);
          s.from = t, s.to = t;
        } else s.from = i(r - n);

        return {
          boundX: e,
          boundY: s
        };
      }

      setEdgeForce() {
        if ("decel" !== this.state) return;
        const t = this.option("bounceForce"),
              {
          boundX: e,
          boundY: i
        } = this.getBounds(Math.max(this.transform.scale, this.content.scale));
        let s, o, n, a;

        if (e && (s = this.content.x < e.from, o = this.content.x > e.to), i && (n = this.content.y < i.from, a = this.content.y > i.to), s || o) {
          let i = ((s ? e.from : e.to) - this.content.x) * t;
          const o = this.content.x + (this.velocity.x + i) / this.friction;
          o >= e.from && o <= e.to && (i += this.velocity.x), this.velocity.x = i, this.recalculateTransform();
        }

        if (n || a) {
          let e = ((n ? i.from : i.to) - this.content.y) * t;
          const s = this.content.y + (e + this.velocity.y) / this.friction;
          s >= i.from && s <= i.to && (e += this.velocity.y), this.velocity.y = e, this.recalculateTransform();
        }
      }

      setDragResistance() {
        if ("pointerdown" !== this.state) return;
        const {
          boundX: t,
          boundY: e
        } = this.getBounds(this.dragPosition.scale);
        let i, s, o, n;

        if (t && (i = this.dragPosition.x < t.from, s = this.dragPosition.x > t.to), e && (o = this.dragPosition.y < e.from, n = this.dragPosition.y > e.to), (i || s) && (!i || !s)) {
          const e = i ? t.from : t.to,
                s = e - this.dragPosition.x;
          this.dragPosition.x = e - .3 * s;
        }

        if ((o || n) && (!o || !n)) {
          const t = o ? e.from : e.to,
                i = t - this.dragPosition.y;
          this.dragPosition.y = t - .3 * i;
        }
      }

      setDragForce() {
        "pointerdown" === this.state && (this.velocity.x = this.dragPosition.x - this.content.x, this.velocity.y = this.dragPosition.y - this.content.y, this.velocity.scale = this.dragPosition.scale - this.content.scale);
      }

      recalculateTransform() {
        this.transform.x = this.content.x + this.velocity.x / (1 / this.friction - 1), this.transform.y = this.content.y + this.velocity.y / (1 / this.friction - 1), this.transform.scale = this.content.scale + this.velocity.scale / (1 / this.friction - 1);
      }

      isAnimating() {
        return !(!this.friction || !(Math.abs(this.velocity.x) > .05 || Math.abs(this.velocity.y) > .05 || Math.abs(this.velocity.scale) > .05));
      }

      setTransform(t) {
        let e, s, o;

        if (t ? (e = i(this.transform.x), s = i(this.transform.y), o = this.transform.scale, this.content = { ...this.content,
          x: e,
          y: s,
          scale: o
        }) : (e = i(this.content.x), s = i(this.content.y), o = this.content.scale / (this.content.width / this.content.fitWidth), this.content = { ...this.content,
          x: e,
          y: s
        }), this.trigger("beforeTransform"), e = i(this.content.x), s = i(this.content.y), t && this.option("zoom")) {
          let t, n;
          t = i(this.content.fitWidth * o), n = i(this.content.fitHeight * o), this.content.width = t, this.content.height = n, this.transform = { ...this.transform,
            width: t,
            height: n,
            scale: o
          }, Object.assign(this.$content.style, {
            width: `${t}px`,
            height: `${n}px`,
            maxWidth: "none",
            maxHeight: "none",
            transform: `translate3d(${e}px, ${s}px, 0) scale(1)`
          });
        } else this.$content.style.transform = `translate3d(${e}px, ${s}px, 0) scale(${o})`;

        this.trigger("afterTransform");
      }

      endAnimation(t) {
        cancelAnimationFrame(this.rAF), this.rAF = null, this.velocity = {
          x: 0,
          y: 0,
          scale: 0
        }, this.setTransform(!0), this.state = "ready", this.handleCursor(), !0 !== t && this.trigger("endAnimation");
      }

      handleCursor() {
        const t = this.option("draggableClass");
        t && this.option("touch") && (1 == this.option("panOnlyZoomed") && this.content.width <= this.viewport.width && this.content.height <= this.viewport.height && this.transform.scale <= this.option("baseScale") ? this.$container.classList.remove(t) : this.$container.classList.add(t));
      }

      detachEvents() {
        this.$content.removeEventListener("load", this.onLoad), this.$container.removeEventListener("wheel", this.onWheel, {
          passive: !1
        }), this.$container.removeEventListener("click", this.onClick, {
          passive: !1
        }), this.pointerTracker && (this.pointerTracker.stop(), this.pointerTracker = null), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null);
      }

      destroy() {
        "destroy" !== this.state && (this.state = "destroy", clearTimeout(this.updateTimer), this.updateTimer = null, cancelAnimationFrame(this.rAF), this.rAF = null, this.detachEvents(), this.detachPlugins(), this.resetDragPosition());
      }

    }

    d.version = "4.0.31", d.Plugins = {};

    const u = (t, e) => {
      let i = 0;
      return function (...s) {
        const o = new Date().getTime();
        if (!(o - i < e)) return i = o, t(...s);
      };
    };

    class f {
      constructor(t) {
        this.$container = null, this.$prev = null, this.$next = null, this.carousel = t, this.onRefresh = this.onRefresh.bind(this);
      }

      option(t) {
        return this.carousel.option(`Navigation.${t}`);
      }

      createButton(t) {
        const e = document.createElement("button");
        e.setAttribute("title", this.carousel.localize(`{{${t.toUpperCase()}}}`));
        const i = this.option("classNames.button") + " " + this.option(`classNames.${t}`);
        return e.classList.add(...i.split(" ")), e.setAttribute("tabindex", "0"), e.innerHTML = this.carousel.localize(this.option(`${t}Tpl`)), e.addEventListener("click", e => {
          e.preventDefault(), e.stopPropagation(), this.carousel["slide" + ("next" === t ? "Next" : "Prev")]();
        }), e;
      }

      build() {
        this.$container || (this.$container = document.createElement("div"), this.$container.classList.add(...this.option("classNames.main").split(" ")), this.carousel.$container.appendChild(this.$container)), this.$next || (this.$next = this.createButton("next"), this.$container.appendChild(this.$next)), this.$prev || (this.$prev = this.createButton("prev"), this.$container.appendChild(this.$prev));
      }

      onRefresh() {
        const t = this.carousel.pages.length;
        t <= 1 || t > 1 && this.carousel.elemDimWidth < this.carousel.wrapDimWidth && !Number.isInteger(this.carousel.option("slidesPerPage")) ? this.cleanup() : (this.build(), this.$prev.removeAttribute("disabled"), this.$next.removeAttribute("disabled"), this.carousel.option("infiniteX", this.carousel.option("infinite")) || (this.carousel.page <= 0 && this.$prev.setAttribute("disabled", ""), this.carousel.page >= t - 1 && this.$next.setAttribute("disabled", "")));
      }

      cleanup() {
        this.$prev && this.$prev.remove(), this.$prev = null, this.$next && this.$next.remove(), this.$next = null, this.$container && this.$container.remove(), this.$container = null;
      }

      attach() {
        this.carousel.on("refresh change", this.onRefresh);
      }

      detach() {
        this.carousel.off("refresh change", this.onRefresh), this.cleanup();
      }

    }

    f.defaults = {
      prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>',
      nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>',
      classNames: {
        main: "carousel__nav",
        button: "carousel__button",
        next: "is-next",
        prev: "is-prev"
      }
    };

    class g {
      constructor(t) {
        this.carousel = t, this.selectedIndex = null, this.friction = 0, this.onNavReady = this.onNavReady.bind(this), this.onNavClick = this.onNavClick.bind(this), this.onNavCreateSlide = this.onNavCreateSlide.bind(this), this.onTargetChange = this.onTargetChange.bind(this);
      }

      addAsTargetFor(t) {
        this.target = this.carousel, this.nav = t, this.attachEvents();
      }

      addAsNavFor(t) {
        this.target = t, this.nav = this.carousel, this.attachEvents();
      }

      attachEvents() {
        this.nav.options.initialSlide = this.target.options.initialPage, this.nav.on("ready", this.onNavReady), this.nav.on("createSlide", this.onNavCreateSlide), this.nav.on("Panzoom.click", this.onNavClick), this.target.on("change", this.onTargetChange), this.target.on("Panzoom.afterUpdate", this.onTargetChange);
      }

      onNavReady() {
        this.onTargetChange(!0);
      }

      onNavClick(t, e, i) {
        const s = i.target.closest(".carousel__slide");
        if (!s) return;
        i.stopPropagation();
        const o = parseInt(s.dataset.index, 10),
              n = this.target.findPageForSlide(o);
        this.target.page !== n && this.target.slideTo(n, {
          friction: this.friction
        }), this.markSelectedSlide(o);
      }

      onNavCreateSlide(t, e) {
        e.index === this.selectedIndex && this.markSelectedSlide(e.index);
      }

      onTargetChange() {
        const t = this.target.pages[this.target.page].indexes[0],
              e = this.nav.findPageForSlide(t);
        this.nav.slideTo(e), this.markSelectedSlide(t);
      }

      markSelectedSlide(t) {
        this.selectedIndex = t, [...this.nav.slides].filter(t => t.$el && t.$el.classList.remove("is-nav-selected"));
        const e = this.nav.slides[t];
        e && e.$el && e.$el.classList.add("is-nav-selected");
      }

      attach(t) {
        const e = t.options.Sync;
        (e.target || e.nav) && (e.target ? this.addAsNavFor(e.target) : e.nav && this.addAsTargetFor(e.nav), this.friction = e.friction);
      }

      detach() {
        this.nav && (this.nav.off("ready", this.onNavReady), this.nav.off("Panzoom.click", this.onNavClick), this.nav.off("createSlide", this.onNavCreateSlide)), this.target && (this.target.off("Panzoom.afterUpdate", this.onTargetChange), this.target.off("change", this.onTargetChange));
      }

    }

    g.defaults = {
      friction: .92
    };
    const p = {
      Navigation: f,
      Dots: class {
        constructor(t) {
          this.carousel = t, this.$list = null, this.events = {
            change: this.onChange.bind(this),
            refresh: this.onRefresh.bind(this)
          };
        }

        buildList() {
          if (this.carousel.pages.length < this.carousel.option("Dots.minSlideCount")) return;
          const t = document.createElement("ol");
          return t.classList.add("carousel__dots"), t.addEventListener("click", t => {
            if (!("page" in t.target.dataset)) return;
            t.preventDefault(), t.stopPropagation();
            const e = parseInt(t.target.dataset.page, 10),
                  i = this.carousel;
            e !== i.page && (i.pages.length < 3 && i.option("infinite") ? i[0 == e ? "slidePrev" : "slideNext"]() : i.slideTo(e));
          }), this.$list = t, this.carousel.$container.appendChild(t), this.carousel.$container.classList.add("has-dots"), t;
        }

        removeList() {
          this.$list && (this.$list.parentNode.removeChild(this.$list), this.$list = null), this.carousel.$container.classList.remove("has-dots");
        }

        rebuildDots() {
          let t = this.$list;
          const e = !!t,
                i = this.carousel.pages.length;
          if (i < 2) return void (e && this.removeList());
          e || (t = this.buildList());
          const s = this.$list.children.length;
          if (s > i) for (let t = i; t < s; t++) this.$list.removeChild(this.$list.lastChild);else {
            for (let t = s; t < i; t++) {
              const e = document.createElement("li");
              e.classList.add("carousel__dot"), e.dataset.page = t, e.setAttribute("role", "button"), e.setAttribute("tabindex", "0"), e.setAttribute("title", this.carousel.localize("{{GOTO}}", [["%d", t + 1]])), e.addEventListener("keydown", t => {
                const i = t.code;
                let s;
                "Enter" === i || "NumpadEnter" === i ? s = e : "ArrowRight" === i ? s = e.nextSibling : "ArrowLeft" === i && (s = e.previousSibling), s && s.click();
              }), this.$list.appendChild(e);
            }

            this.setActiveDot();
          }
        }

        setActiveDot() {
          if (!this.$list) return;
          this.$list.childNodes.forEach(t => {
            t.classList.remove("is-selected");
          });
          const t = this.$list.childNodes[this.carousel.page];
          t && t.classList.add("is-selected");
        }

        onChange() {
          this.setActiveDot();
        }

        onRefresh() {
          this.rebuildDots();
        }

        attach() {
          this.carousel.on(this.events);
        }

        detach() {
          this.removeList(), this.carousel.off(this.events), this.carousel = null;
        }

      },
      Sync: g
    };
    const m = {
      slides: [],
      preload: 0,
      slidesPerPage: "auto",
      initialPage: null,
      initialSlide: null,
      friction: .92,
      center: !0,
      infinite: !0,
      fill: !0,
      dragFree: !1,
      prefix: "",
      classNames: {
        viewport: "carousel__viewport",
        track: "carousel__track",
        slide: "carousel__slide",
        slideSelected: "is-selected"
      },
      l10n: {
        NEXT: "Next slide",
        PREV: "Previous slide",
        GOTO: "Go to slide #%d"
      }
    };

    class y extends l {
      constructor(t, i = {}) {
        if (super(i = e(!0, {}, m, i)), this.state = "init", this.$container = t, !(this.$container instanceof HTMLElement)) throw new Error("No root element provided");
        this.slideNext = u(this.slideNext.bind(this), 250), this.slidePrev = u(this.slidePrev.bind(this), 250), this.init(), t.__Carousel = this;
      }

      init() {
        this.pages = [], this.page = this.pageIndex = null, this.prevPage = this.prevPageIndex = null, this.attachPlugins(y.Plugins), this.trigger("init"), this.initLayout(), this.initSlides(), this.updateMetrics(), this.$track && this.pages.length && (this.$track.style.transform = `translate3d(${-1 * this.pages[this.page].left}px, 0px, 0) scale(1)`), this.manageSlideVisiblity(), this.initPanzoom(), this.state = "ready", this.trigger("ready");
      }

      initLayout() {
        const t = this.option("prefix"),
              e = this.option("classNames");
        this.$viewport = this.option("viewport") || this.$container.querySelector(`.${t}${e.viewport}`), this.$viewport || (this.$viewport = document.createElement("div"), this.$viewport.classList.add(...(t + e.viewport).split(" ")), this.$viewport.append(...this.$container.childNodes), this.$container.appendChild(this.$viewport)), this.$track = this.option("track") || this.$container.querySelector(`.${t}${e.track}`), this.$track || (this.$track = document.createElement("div"), this.$track.classList.add(...(t + e.track).split(" ")), this.$track.append(...this.$viewport.childNodes), this.$viewport.appendChild(this.$track));
      }

      initSlides() {
        this.slides = [];
        this.$viewport.querySelectorAll(`.${this.option("prefix")}${this.option("classNames.slide")}`).forEach(t => {
          const e = {
            $el: t,
            isDom: !0
          };
          this.slides.push(e), this.trigger("createSlide", e, this.slides.length);
        }), Array.isArray(this.options.slides) && (this.slides = e(!0, [...this.slides], this.options.slides));
      }

      updateMetrics() {
        let t,
            e = 0,
            s = [];
        this.slides.forEach((i, o) => {
          const n = i.$el,
                a = i.isDom || !t ? this.getSlideMetrics(n) : t;
          i.index = o, i.width = a, i.left = e, t = a, e += a, s.push(o);
        });
        let o = Math.max(this.$track.offsetWidth, i(this.$track.getBoundingClientRect().width)),
            n = getComputedStyle(this.$track);
        o -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight), this.contentWidth = e, this.viewportWidth = o;
        const a = [],
              r = this.option("slidesPerPage");
        if (Number.isInteger(r) && e > o) for (let t = 0; t < this.slides.length; t += r) a.push({
          indexes: s.slice(t, t + r),
          slides: this.slides.slice(t, t + r)
        });else {
          let t = 0,
              e = 0;

          for (let i = 0; i < this.slides.length; i += 1) {
            let s = this.slides[i];
            (!a.length || e + s.width > o) && (a.push({
              indexes: [],
              slides: []
            }), t = a.length - 1, e = 0), e += s.width, a[t].indexes.push(i), a[t].slides.push(s);
          }
        }
        const h = this.option("center"),
              l = this.option("fill");
        a.forEach((t, i) => {
          t.index = i, t.width = t.slides.reduce((t, e) => t + e.width, 0), t.left = t.slides[0].left, h && (t.left += .5 * (o - t.width) * -1), l && !this.option("infiniteX", this.option("infinite")) && e > o && (t.left = Math.max(t.left, 0), t.left = Math.min(t.left, e - o));
        });
        const c = [];
        let d;
        a.forEach(t => {
          const e = { ...t
          };
          d && e.left === d.left ? (d.width += e.width, d.slides = [...d.slides, ...e.slides], d.indexes = [...d.indexes, ...e.indexes]) : (e.index = c.length, d = e, c.push(e));
        }), this.pages = c;
        let u = this.page;

        if (null === u) {
          const t = this.option("initialSlide");
          u = null !== t ? this.findPageForSlide(t) : parseInt(this.option("initialPage", 0), 10) || 0, c[u] || (u = c.length && u > c.length ? c[c.length - 1].index : 0), this.page = u, this.pageIndex = u;
        }

        this.updatePanzoom(), this.trigger("refresh");
      }

      getSlideMetrics(t) {
        if (!t) {
          const e = this.slides[0];
          (t = document.createElement("div")).dataset.isTestEl = 1, t.style.visibility = "hidden", t.classList.add(...(this.option("prefix") + this.option("classNames.slide")).split(" ")), e.customClass && t.classList.add(...e.customClass.split(" ")), this.$track.prepend(t);
        }

        let e = Math.max(t.offsetWidth, i(t.getBoundingClientRect().width));
        const s = t.currentStyle || window.getComputedStyle(t);
        return e = e + (parseFloat(s.marginLeft) || 0) + (parseFloat(s.marginRight) || 0), t.dataset.isTestEl && t.remove(), e;
      }

      findPageForSlide(t) {
        t = parseInt(t, 10) || 0;
        const e = this.pages.find(e => e.indexes.indexOf(t) > -1);
        return e ? e.index : null;
      }

      slideNext() {
        this.slideTo(this.pageIndex + 1);
      }

      slidePrev() {
        this.slideTo(this.pageIndex - 1);
      }

      slideTo(t, e = {}) {
        const {
          x: i = -1 * this.setPage(t, !0),
          y: s = 0,
          friction: o = this.option("friction")
        } = e;
        this.Panzoom.content.x === i && !this.Panzoom.velocity.x && o || (this.Panzoom.panTo({
          x: i,
          y: s,
          friction: o,
          ignoreBounds: !0
        }), "ready" === this.state && "ready" === this.Panzoom.state && this.trigger("settle"));
      }

      initPanzoom() {
        this.Panzoom && this.Panzoom.destroy();
        const t = e(!0, {}, {
          content: this.$track,
          wrapInner: !1,
          resizeParent: !1,
          zoom: !1,
          click: !1,
          lockAxis: "x",
          x: this.pages.length ? -1 * this.pages[this.page].left : 0,
          centerOnStart: !1,
          textSelection: () => this.option("textSelection", !1),
          panOnlyZoomed: function () {
            return this.content.width <= this.viewport.width;
          }
        }, this.option("Panzoom"));
        this.Panzoom = new d(this.$container, t), this.Panzoom.on({
          "*": (t, ...e) => this.trigger(`Panzoom.${t}`, ...e),
          afterUpdate: () => {
            this.updatePage();
          },
          beforeTransform: this.onBeforeTransform.bind(this),
          touchEnd: this.onTouchEnd.bind(this),
          endAnimation: () => {
            this.trigger("settle");
          }
        }), this.updateMetrics(), this.manageSlideVisiblity();
      }

      updatePanzoom() {
        this.Panzoom && (this.Panzoom.content = { ...this.Panzoom.content,
          fitWidth: this.contentWidth,
          origWidth: this.contentWidth,
          width: this.contentWidth
        }, this.pages.length > 1 && this.option("infiniteX", this.option("infinite")) ? this.Panzoom.boundX = null : this.pages.length && (this.Panzoom.boundX = {
          from: -1 * this.pages[this.pages.length - 1].left,
          to: -1 * this.pages[0].left
        }), this.option("infiniteY", this.option("infinite")) ? this.Panzoom.boundY = null : this.Panzoom.boundY = {
          from: 0,
          to: 0
        }, this.Panzoom.handleCursor());
      }

      manageSlideVisiblity() {
        const t = this.contentWidth,
              e = this.viewportWidth;
        let i = this.Panzoom ? -1 * this.Panzoom.content.x : this.pages.length ? this.pages[this.page].left : 0;
        const s = this.option("preload"),
              o = this.option("infiniteX", this.option("infinite")),
              n = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-left")),
              a = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-right"));
        this.slides.forEach(r => {
          let h,
              l,
              c = 0;
          h = i - n, l = i + e + a, h -= s * (e + n + a), l += s * (e + n + a);
          const d = r.left + r.width > h && r.left < l;
          h = i + t - n, l = i + t + e + a, h -= s * (e + n + a);
          const u = o && r.left + r.width > h && r.left < l;
          h = i - t - n, l = i - t + e + a, h -= s * (e + n + a);
          const f = o && r.left + r.width > h && r.left < l;
          u || d || f ? (this.createSlideEl(r), d && (c = 0), u && (c = -1), f && (c = 1), r.left + r.width > i && r.left <= i + e + a && (c = 0)) : this.removeSlideEl(r), r.hasDiff = c;
        });
        let r = 0,
            h = 0;
        this.slides.forEach((e, i) => {
          let s = 0;
          e.$el ? (i !== r || e.hasDiff ? s = h + e.hasDiff * t : h = 0, e.$el.style.left = Math.abs(s) > .1 ? `${h + e.hasDiff * t}px` : "", r++) : h += e.width;
        }), this.markSelectedSlides();
      }

      createSlideEl(t) {
        if (!t) return;

        if (t.$el) {
          let e = t.$el.dataset.index;

          if (!e || parseInt(e, 10) !== t.index) {
            let e;
            t.$el.dataset.index = t.index, t.$el.querySelectorAll("[data-lazy-srcset]").forEach(t => {
              t.srcset = t.dataset.lazySrcset;
            }), t.$el.querySelectorAll("[data-lazy-src]").forEach(t => {
              let e = t.dataset.lazySrc;
              t instanceof HTMLImageElement ? t.src = e : t.style.backgroundImage = `url('${e}')`;
            }), (e = t.$el.dataset.lazySrc) && (t.$el.style.backgroundImage = `url('${e}')`), t.state = "ready";
          }

          return;
        }

        const e = document.createElement("div");
        e.dataset.index = t.index, e.classList.add(...(this.option("prefix") + this.option("classNames.slide")).split(" ")), t.customClass && e.classList.add(...t.customClass.split(" ")), t.html && (e.innerHTML = t.html);
        const i = [];
        this.slides.forEach((t, e) => {
          t.$el && i.push(e);
        });
        const s = t.index;
        let o = null;

        if (i.length) {
          let t = i.reduce((t, e) => Math.abs(e - s) < Math.abs(t - s) ? e : t);
          o = this.slides[t];
        }

        return this.$track.insertBefore(e, o && o.$el ? o.index < t.index ? o.$el.nextSibling : o.$el : null), t.$el = e, this.trigger("createSlide", t, s), t;
      }

      removeSlideEl(t) {
        t.$el && !t.isDom && (this.trigger("removeSlide", t), t.$el.remove(), t.$el = null);
      }

      markSelectedSlides() {
        const t = this.option("classNames.slideSelected"),
              e = "aria-hidden";
        this.slides.forEach((i, s) => {
          const o = i.$el;
          if (!o) return;
          const n = this.pages[this.page];
          n && n.indexes && n.indexes.indexOf(s) > -1 ? (t && !o.classList.contains(t) && (o.classList.add(t), this.trigger("selectSlide", i)), o.removeAttribute(e)) : (t && o.classList.contains(t) && (o.classList.remove(t), this.trigger("unselectSlide", i)), o.setAttribute(e, !0));
        });
      }

      updatePage() {
        this.updateMetrics(), this.slideTo(this.page, {
          friction: 0
        });
      }

      onBeforeTransform() {
        this.option("infiniteX", this.option("infinite")) && this.manageInfiniteTrack(), this.manageSlideVisiblity();
      }

      manageInfiniteTrack() {
        const t = this.contentWidth,
              e = this.viewportWidth;
        if (!this.option("infiniteX", this.option("infinite")) || this.pages.length < 2 || t < e) return;
        const i = this.Panzoom;
        let s = !1;
        return i.content.x < -1 * (t - e) && (i.content.x += t, this.pageIndex = this.pageIndex - this.pages.length, s = !0), i.content.x > e && (i.content.x -= t, this.pageIndex = this.pageIndex + this.pages.length, s = !0), s && "pointerdown" === i.state && i.resetDragPosition(), s;
      }

      onTouchEnd(t, e) {
        const i = this.option("dragFree");
        if (!i && this.pages.length > 1 && t.dragOffset.time < 350 && Math.abs(t.dragOffset.y) < 1 && Math.abs(t.dragOffset.x) > 5) this[t.dragOffset.x < 0 ? "slideNext" : "slidePrev"]();else if (i) {
          const [, e] = this.getPageFromPosition(-1 * t.transform.x);
          this.setPage(e);
        } else this.slideToClosest();
      }

      slideToClosest(t = {}) {
        let [, e] = this.getPageFromPosition(-1 * this.Panzoom.content.x);
        this.slideTo(e, t);
      }

      getPageFromPosition(t) {
        const e = this.pages.length;
        this.option("center") && (t += .5 * this.viewportWidth);
        const i = Math.floor(t / this.contentWidth);
        t -= i * this.contentWidth;
        let s = this.slides.find(e => e.left <= t && e.left + e.width > t);

        if (s) {
          let t = this.findPageForSlide(s.index);
          return [t, t + i * e];
        }

        return [0, 0];
      }

      setPage(t, e) {
        let i = 0,
            s = parseInt(t, 10) || 0;
        const o = this.page,
              n = this.pageIndex,
              a = this.pages.length,
              r = this.contentWidth,
              h = this.viewportWidth;

        if (t = (s % a + a) % a, this.option("infiniteX", this.option("infinite")) && r > h) {
          const o = Math.floor(s / a) || 0,
                n = r;

          if (i = this.pages[t].left + o * n, !0 === e && a > 2) {
            let t = -1 * this.Panzoom.content.x;
            const e = i - n,
                  o = i + n,
                  r = Math.abs(t - i),
                  h = Math.abs(t - e),
                  l = Math.abs(t - o);
            l < r && l <= h ? (i = o, s += a) : h < r && h < l && (i = e, s -= a);
          }
        } else t = s = Math.max(0, Math.min(s, a - 1)), i = this.pages.length ? this.pages[t].left : 0;

        return this.page = t, this.pageIndex = s, null !== o && t !== o && (this.prevPage = o, this.prevPageIndex = n, this.trigger("change", t, o)), i;
      }

      destroy() {
        this.state = "destroy", this.slides.forEach(t => {
          this.removeSlideEl(t);
        }), this.slides = [], this.Panzoom.destroy(), this.detachPlugins();
      }

    }

    y.version = "4.0.31", y.Plugins = p;
    const v = !("undefined" == typeof window || !window.document || !window.document.createElement);
    let b = null;

    const x = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden])", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])'],
          w = t => {
      if (t && v) {
        null === b && document.createElement("div").focus({
          get preventScroll() {
            return b = !0, !1;
          }

        });

        try {
          if (t.setActive) t.setActive();else if (b) t.focus({
            preventScroll: !0
          });else {
            const e = window.pageXOffset || document.body.scrollTop,
                  i = window.pageYOffset || document.body.scrollLeft;
            t.focus(), document.body.scrollTo({
              top: e,
              left: i,
              behavior: "auto"
            });
          }
        } catch (t) {}
      }
    };

    const $$1 = {
      minSlideCount: 2,
      minScreenHeight: 500,
      autoStart: !0,
      key: "t",
      Carousel: {},
      tpl: '<div class="fancybox__thumb" style="background-image:url(\'{{src}}\')"></div>'
    };

    class C {
      constructor(t) {
        this.fancybox = t, this.$container = null, this.state = "init";

        for (const t of ["onPrepare", "onClosing", "onKeydown"]) this[t] = this[t].bind(this);

        this.events = {
          prepare: this.onPrepare,
          closing: this.onClosing,
          keydown: this.onKeydown
        };
      }

      onPrepare() {
        this.getSlides().length < this.fancybox.option("Thumbs.minSlideCount") ? this.state = "disabled" : !0 === this.fancybox.option("Thumbs.autoStart") && this.fancybox.Carousel.Panzoom.content.height >= this.fancybox.option("Thumbs.minScreenHeight") && this.build();
      }

      onClosing() {
        this.Carousel && this.Carousel.Panzoom.detachEvents();
      }

      onKeydown(t, e) {
        e === t.option("Thumbs.key") && this.toggle();
      }

      build() {
        if (this.$container) return;
        const t = document.createElement("div");
        t.classList.add("fancybox__thumbs"), this.fancybox.$carousel.parentNode.insertBefore(t, this.fancybox.$carousel.nextSibling), this.Carousel = new y(t, e(!0, {
          Dots: !1,
          Navigation: !1,
          Sync: {
            friction: 0
          },
          infinite: !1,
          center: !0,
          fill: !0,
          dragFree: !0,
          slidesPerPage: 1,
          preload: 1
        }, this.fancybox.option("Thumbs.Carousel"), {
          Sync: {
            target: this.fancybox.Carousel
          },
          slides: this.getSlides()
        })), this.Carousel.Panzoom.on("wheel", (t, e) => {
          e.preventDefault(), this.fancybox[e.deltaY < 0 ? "prev" : "next"]();
        }), this.$container = t, this.state = "visible";
      }

      getSlides() {
        const t = [];

        for (const e of this.fancybox.items) {
          const i = e.thumb;
          i && t.push({
            html: this.fancybox.option("Thumbs.tpl").replace(/\{\{src\}\}/gi, i),
            customClass: `has-thumb has-${e.type || "image"}`
          });
        }

        return t;
      }

      toggle() {
        "visible" === this.state ? this.hide() : "hidden" === this.state ? this.show() : this.build();
      }

      show() {
        "hidden" === this.state && (this.$container.style.display = "", this.Carousel.Panzoom.attachEvents(), this.state = "visible");
      }

      hide() {
        "visible" === this.state && (this.Carousel.Panzoom.detachEvents(), this.$container.style.display = "none", this.state = "hidden");
      }

      cleanup() {
        this.Carousel && (this.Carousel.destroy(), this.Carousel = null), this.$container && (this.$container.remove(), this.$container = null), this.state = "init";
      }

      attach() {
        this.fancybox.on(this.events);
      }

      detach() {
        this.fancybox.off(this.events), this.cleanup();
      }

    }

    C.defaults = $$1;

    const S = (t, e) => {
      const i = new URL(t),
            s = new URLSearchParams(i.search);
      let o = new URLSearchParams();

      for (const [t, i] of [...s, ...Object.entries(e)]) "t" === t ? o.set("start", parseInt(i)) : o.set(t, i);

      o = o.toString();
      let n = t.match(/#t=((.*)?\d+s)/);
      return n && (o += `#t=${n[1]}`), o;
    },
          E = {
      video: {
        autoplay: !0,
        ratio: 16 / 9
      },
      youtube: {
        autohide: 1,
        fs: 1,
        rel: 0,
        hd: 1,
        wmode: "transparent",
        enablejsapi: 1,
        html5: 1
      },
      vimeo: {
        hd: 1,
        show_title: 1,
        show_byline: 1,
        show_portrait: 0,
        fullscreen: 1
      },
      html5video: {
        tpl: '<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">\n  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos.</video>',
        format: ""
      }
    };

    class P {
      constructor(t) {
        this.fancybox = t;

        for (const t of ["onInit", "onReady", "onCreateSlide", "onRemoveSlide", "onSelectSlide", "onUnselectSlide", "onRefresh", "onMessage"]) this[t] = this[t].bind(this);

        this.events = {
          init: this.onInit,
          ready: this.onReady,
          "Carousel.createSlide": this.onCreateSlide,
          "Carousel.removeSlide": this.onRemoveSlide,
          "Carousel.selectSlide": this.onSelectSlide,
          "Carousel.unselectSlide": this.onUnselectSlide,
          "Carousel.refresh": this.onRefresh
        };
      }

      onInit() {
        for (const t of this.fancybox.items) this.processType(t);
      }

      processType(t) {
        if (t.html) return t.src = t.html, t.type = "html", void delete t.html;
        const i = t.src || "";
        let s = t.type || this.fancybox.options.type,
            o = null;

        if (!i || "string" == typeof i) {
          if (o = i.match(/(?:youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) {
            const e = S(i, this.fancybox.option("Html.youtube")),
                  n = encodeURIComponent(o[1]);
            t.videoId = n, t.src = `https://www.youtube-nocookie.com/embed/${n}?${e}`, t.thumb = t.thumb || `https://i.ytimg.com/vi/${n}/mqdefault.jpg`, t.vendor = "youtube", s = "video";
          } else if (o = i.match(/^.+vimeo.com\/(?:\/)?([\d]+)(.*)?/)) {
            const e = S(i, this.fancybox.option("Html.vimeo")),
                  n = encodeURIComponent(o[1]);
            t.videoId = n, t.src = `https://player.vimeo.com/video/${n}?${e}`, t.vendor = "vimeo", s = "video";
          } else (o = i.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (t.src = `//maps.google.${o[1]}/?ll=${(o[2] ? o[2] + "&z=" + Math.floor(o[3]) + (o[4] ? o[4].replace(/^\//, "&") : "") : o[4] + "").replace(/\?/, "&")}&output=${o[4] && o[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, s = "map") : (o = i.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (t.src = `//maps.google.${o[1]}/maps?q=${o[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, s = "map");

          s || ("#" === i.charAt(0) ? s = "inline" : (o = i.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (s = "html5video", t.format = t.format || "video/" + ("ogv" === o[1] ? "ogg" : o[1])) : i.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? s = "image" : i.match(/\.(pdf)((\?|#).*)?$/i) && (s = "pdf")), t.type = s || this.fancybox.option("defaultType", "image"), "html5video" !== s && "video" !== s || (t.video = e({}, this.fancybox.option("Html.video"), t.video), t._width && t._height ? t.ratio = parseFloat(t._width) / parseFloat(t._height) : t.ratio = t.ratio || t.video.ratio || E.video.ratio);
        }
      }

      onReady() {
        this.fancybox.Carousel.slides.forEach(t => {
          t.$el && (this.setContent(t), t.index === this.fancybox.getSlide().index && this.playVideo(t));
        });
      }

      onCreateSlide(t, e, i) {
        "ready" === this.fancybox.state && this.setContent(i);
      }

      loadInlineContent(t) {
        let e;
        if (t.src instanceof HTMLElement) e = t.src;else if ("string" == typeof t.src) {
          const i = t.src.split("#", 2),
                s = 2 === i.length && "" === i[0] ? i[1] : i[0];
          e = document.getElementById(s);
        }

        if (e) {
          if ("clone" === t.type || e.$placeHolder) {
            e = e.cloneNode(!0);
            let i = e.getAttribute("id");
            i = i ? `${i}--clone` : `clone-${this.fancybox.id}-${t.index}`, e.setAttribute("id", i);
          } else {
            const t = document.createElement("div");
            t.classList.add("fancybox-placeholder"), e.parentNode.insertBefore(t, e), e.$placeHolder = t;
          }

          this.fancybox.setContent(t, e);
        } else this.fancybox.setError(t, "{{ELEMENT_NOT_FOUND}}");
      }

      loadAjaxContent(t) {
        const e = this.fancybox,
              i = new XMLHttpRequest();
        e.showLoading(t), i.onreadystatechange = function () {
          i.readyState === XMLHttpRequest.DONE && "ready" === e.state && (e.hideLoading(t), 200 === i.status ? e.setContent(t, i.responseText) : e.setError(t, 404 === i.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}"));
        };
        const s = t.ajax || null;
        i.open(s ? "POST" : "GET", t.src), i.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), i.setRequestHeader("X-Requested-With", "XMLHttpRequest"), i.send(s), t.xhr = i;
      }

      loadIframeContent(t) {
        const e = this.fancybox,
              i = document.createElement("iframe");
        if (i.className = "fancybox__iframe", i.setAttribute("id", `fancybox__iframe_${e.id}_${t.index}`), i.setAttribute("allow", "autoplay; fullscreen"), i.setAttribute("scrolling", "auto"), t.$iframe = i, "iframe" !== t.type || !1 === t.preload) return i.setAttribute("src", t.src), this.fancybox.setContent(t, i), void this.resizeIframe(t);
        e.showLoading(t);
        const s = document.createElement("div");
        s.style.visibility = "hidden", this.fancybox.setContent(t, s), s.appendChild(i), i.onerror = () => {
          e.setError(t, "{{IFRAME_ERROR}}");
        }, i.onload = () => {
          e.hideLoading(t);
          let s = !1;
          i.isReady || (i.isReady = !0, s = !0), i.src.length && (i.parentNode.style.visibility = "", this.resizeIframe(t), s && e.revealContent(t));
        }, i.setAttribute("src", t.src);
      }

      setAspectRatio(t) {
        const e = t.$content,
              i = t.ratio;
        if (!e) return;
        let s = t._width,
            o = t._height;

        if (i || s && o) {
          Object.assign(e.style, {
            width: s && o ? "100%" : "",
            height: s && o ? "100%" : "",
            maxWidth: "",
            maxHeight: ""
          });
          let t = e.offsetWidth,
              n = e.offsetHeight;

          if (s = s || t, o = o || n, s > t || o > n) {
            let e = Math.min(t / s, n / o);
            s *= e, o *= e;
          }

          Math.abs(s / o - i) > .01 && (i < s / o ? s = o * i : o = s / i), Object.assign(e.style, {
            width: `${s}px`,
            height: `${o}px`
          });
        }
      }

      resizeIframe(t) {
        const e = t.$iframe;
        if (!e) return;
        let i = t._width || 0,
            s = t._height || 0;
        i && s && (t.autoSize = !1);
        const o = e.parentNode,
              n = o && o.style;
        if (!1 !== t.preload && !1 !== t.autoSize && n) try {
          const t = window.getComputedStyle(o),
                a = parseFloat(t.paddingLeft) + parseFloat(t.paddingRight),
                r = parseFloat(t.paddingTop) + parseFloat(t.paddingBottom),
                h = e.contentWindow.document,
                l = h.getElementsByTagName("html")[0],
                c = h.body;
          n.width = "", c.style.overflow = "hidden", i = i || l.scrollWidth + a, n.width = `${i}px`, c.style.overflow = "", n.flex = "0 0 auto", n.height = `${c.scrollHeight}px`, s = l.scrollHeight + r;
        } catch (t) {}

        if (i || s) {
          const t = {
            flex: "0 1 auto"
          };
          i && (t.width = `${i}px`), s && (t.height = `${s}px`), Object.assign(n, t);
        }
      }

      onRefresh(t, e) {
        e.slides.forEach(t => {
          t.$el && (t.$iframe && this.resizeIframe(t), t.ratio && this.setAspectRatio(t));
        });
      }

      setContent(t) {
        if (t && !t.isDom) {
          switch (t.type) {
            case "html":
              this.fancybox.setContent(t, t.src);
              break;

            case "html5video":
              this.fancybox.setContent(t, this.fancybox.option("Html.html5video.tpl").replace(/\{\{src\}\}/gi, t.src).replace("{{format}}", t.format || t.html5video && t.html5video.format || "").replace("{{poster}}", t.poster || t.thumb || ""));
              break;

            case "inline":
            case "clone":
              this.loadInlineContent(t);
              break;

            case "ajax":
              this.loadAjaxContent(t);
              break;

            case "pdf":
            case "video":
            case "map":
              t.preload = !1;

            case "iframe":
              this.loadIframeContent(t);
          }

          t.ratio && this.setAspectRatio(t);
        }
      }

      onSelectSlide(t, e, i) {
        "ready" === t.state && this.playVideo(i);
      }

      playVideo(t) {
        if ("html5video" === t.type && t.video.autoplay) try {
          const e = t.$el.querySelector("video");

          if (e) {
            const t = e.play();
            void 0 !== t && t.then(() => {}).catch(t => {
              e.muted = !0, e.play();
            });
          }
        } catch (t) {}
        if ("video" !== t.type || !t.$iframe || !t.$iframe.contentWindow) return;

        const e = () => {
          if ("done" === t.state && t.$iframe && t.$iframe.contentWindow) {
            let e;
            if (t.$iframe.isReady) return t.video && t.video.autoplay && (e = "youtube" == t.vendor ? {
              event: "command",
              func: "playVideo"
            } : {
              method: "play",
              value: "true"
            }), void (e && t.$iframe.contentWindow.postMessage(JSON.stringify(e), "*"));
            "youtube" === t.vendor && (e = {
              event: "listening",
              id: t.$iframe.getAttribute("id")
            }, t.$iframe.contentWindow.postMessage(JSON.stringify(e), "*"));
          }

          t.poller = setTimeout(e, 250);
        };

        e();
      }

      onUnselectSlide(t, e, i) {
        if ("html5video" === i.type) {
          try {
            i.$el.querySelector("video").pause();
          } catch (t) {}

          return;
        }

        let s = !1;
        "vimeo" == i.vendor ? s = {
          method: "pause",
          value: "true"
        } : "youtube" === i.vendor && (s = {
          event: "command",
          func: "pauseVideo"
        }), s && i.$iframe && i.$iframe.contentWindow && i.$iframe.contentWindow.postMessage(JSON.stringify(s), "*"), clearTimeout(i.poller);
      }

      onRemoveSlide(t, e, i) {
        i.xhr && (i.xhr.abort(), i.xhr = null), i.$iframe && (i.$iframe.onload = i.$iframe.onerror = null, i.$iframe.src = "//about:blank", i.$iframe = null);
        const s = i.$content;
        "inline" === i.type && s && (s.classList.remove("fancybox__content"), "none" !== s.style.display && (s.style.display = "none")), i.$closeButton && (i.$closeButton.remove(), i.$closeButton = null);
        const o = s && s.$placeHolder;
        o && (o.parentNode.insertBefore(s, o), o.remove(), s.$placeHolder = null);
      }

      onMessage(t) {
        try {
          let e = JSON.parse(t.data);

          if ("https://player.vimeo.com" === t.origin) {
            if ("ready" === e.event) for (let e of document.getElementsByClassName("fancybox__iframe")) e.contentWindow === t.source && (e.isReady = 1);
          } else "https://www.youtube-nocookie.com" === t.origin && "onReady" === e.event && (document.getElementById(e.id).isReady = 1);
        } catch (t) {}
      }

      attach() {
        this.fancybox.on(this.events), window.addEventListener("message", this.onMessage, !1);
      }

      detach() {
        this.fancybox.off(this.events), window.removeEventListener("message", this.onMessage, !1);
      }

    }

    P.defaults = E;

    class T {
      constructor(t) {
        this.fancybox = t;

        for (const t of ["onReady", "onClosing", "onDone", "onPageChange", "onCreateSlide", "onRemoveSlide", "onImageStatusChange"]) this[t] = this[t].bind(this);

        this.events = {
          ready: this.onReady,
          closing: this.onClosing,
          done: this.onDone,
          "Carousel.change": this.onPageChange,
          "Carousel.createSlide": this.onCreateSlide,
          "Carousel.removeSlide": this.onRemoveSlide
        };
      }

      onReady() {
        this.fancybox.Carousel.slides.forEach(t => {
          t.$el && this.setContent(t);
        });
      }

      onDone(t, e) {
        this.handleCursor(e);
      }

      onClosing(t) {
        clearTimeout(this.clickTimer), this.clickTimer = null, t.Carousel.slides.forEach(t => {
          t.$image && (t.state = "destroy"), t.Panzoom && t.Panzoom.detachEvents();
        }), "closing" === this.fancybox.state && this.canZoom(t.getSlide()) && this.zoomOut();
      }

      onCreateSlide(t, e, i) {
        "ready" === this.fancybox.state && this.setContent(i);
      }

      onRemoveSlide(t, e, i) {
        i.$image && (i.$el.classList.remove(t.option("Image.canZoomInClass")), i.$image.remove(), i.$image = null), i.Panzoom && (i.Panzoom.destroy(), i.Panzoom = null), i.$el && i.$el.dataset && delete i.$el.dataset.imageFit;
      }

      setContent(t) {
        if (t.isDom || t.html || t.type && "image" !== t.type) return;
        if (t.$image) return;
        t.type = "image", t.state = "loading";
        const e = document.createElement("div");
        e.style.visibility = "hidden";
        const i = document.createElement("img");
        i.addEventListener("load", e => {
          e.stopImmediatePropagation(), this.onImageStatusChange(t);
        }), i.addEventListener("error", () => {
          this.onImageStatusChange(t);
        }), i.src = t.src, i.alt = "", i.draggable = !1, i.classList.add("fancybox__image"), t.srcset && i.setAttribute("srcset", t.srcset), t.sizes && i.setAttribute("sizes", t.sizes), t.$image = i;
        const s = this.fancybox.option("Image.wrap");

        if (s) {
          const o = document.createElement("div");
          o.classList.add("string" == typeof s ? s : "fancybox__image-wrap"), o.appendChild(i), e.appendChild(o), t.$wrap = o;
        } else e.appendChild(i);

        t.$el.dataset.imageFit = this.fancybox.option("Image.fit"), this.fancybox.setContent(t, e), i.complete || i.error ? this.onImageStatusChange(t) : this.fancybox.showLoading(t);
      }

      onImageStatusChange(t) {
        const e = t.$image;
        e && "loading" === t.state && (e.complete && e.naturalWidth && e.naturalHeight ? (this.fancybox.hideLoading(t), "contain" === this.fancybox.option("Image.fit") && this.initSlidePanzoom(t), t.$el.addEventListener("wheel", e => this.onWheel(t, e), {
          passive: !1
        }), t.$content.addEventListener("click", e => this.onClick(t, e), {
          passive: !1
        }), this.revealContent(t)) : this.fancybox.setError(t, "{{IMAGE_ERROR}}"));
      }

      initSlidePanzoom(t) {
        t.Panzoom || (t.Panzoom = new d(t.$el, e(!0, this.fancybox.option("Image.Panzoom", {}), {
          viewport: t.$wrap,
          content: t.$image,
          width: t._width,
          height: t._height,
          wrapInner: !1,
          textSelection: !0,
          touch: this.fancybox.option("Image.touch"),
          panOnlyZoomed: !0,
          click: !1,
          wheel: !1
        })), t.Panzoom.on("startAnimation", () => {
          this.fancybox.trigger("Image.startAnimation", t);
        }), t.Panzoom.on("endAnimation", () => {
          "zoomIn" === t.state && this.fancybox.done(t), this.handleCursor(t), this.fancybox.trigger("Image.endAnimation", t);
        }), t.Panzoom.on("afterUpdate", () => {
          this.handleCursor(t), this.fancybox.trigger("Image.afterUpdate", t);
        }));
      }

      revealContent(t) {
        null === this.fancybox.Carousel.prevPage && t.index === this.fancybox.options.startIndex && this.canZoom(t) ? this.zoomIn() : this.fancybox.revealContent(t);
      }

      getZoomInfo(t) {
        const e = t.$thumb.getBoundingClientRect(),
              i = e.width,
              s = e.height,
              o = t.$content.getBoundingClientRect(),
              n = o.width,
              a = o.height,
              r = o.top - e.top,
              h = o.left - e.left;
        let l = this.fancybox.option("Image.zoomOpacity");
        return "auto" === l && (l = Math.abs(i / s - n / a) > .1), {
          top: r,
          left: h,
          scale: n && i ? i / n : 1,
          opacity: l
        };
      }

      canZoom(t) {
        const e = this.fancybox,
              i = e.$container;
        if (window.visualViewport && 1 !== window.visualViewport.scale) return !1;
        if (t.Panzoom && !t.Panzoom.content.width) return !1;
        if (!e.option("Image.zoom") || "contain" !== e.option("Image.fit")) return !1;
        const s = t.$thumb;
        if (!s || "loading" === t.state) return !1;
        i.classList.add("fancybox__no-click");
        const o = s.getBoundingClientRect();
        let n;

        if (this.fancybox.option("Image.ignoreCoveredThumbnail")) {
          const t = document.elementFromPoint(o.left + 1, o.top + 1) === s,
                e = document.elementFromPoint(o.right - 1, o.bottom - 1) === s;
          n = t && e;
        } else n = document.elementFromPoint(o.left + .5 * o.width, o.top + .5 * o.height) === s;

        return i.classList.remove("fancybox__no-click"), n;
      }

      zoomIn() {
        const t = this.fancybox,
              e = t.getSlide(),
              i = e.Panzoom,
              {
          top: s,
          left: o,
          scale: n,
          opacity: a
        } = this.getZoomInfo(e);
        t.trigger("reveal", e), i.panTo({
          x: -1 * o,
          y: -1 * s,
          scale: n,
          friction: 0,
          ignoreBounds: !0
        }), e.$content.style.visibility = "", e.state = "zoomIn", !0 === a && i.on("afterTransform", t => {
          "zoomIn" !== e.state && "zoomOut" !== e.state || (t.$content.style.opacity = Math.min(1, 1 - (1 - t.content.scale) / (1 - n)));
        }), i.panTo({
          x: 0,
          y: 0,
          scale: 1,
          friction: this.fancybox.option("Image.zoomFriction")
        });
      }

      zoomOut() {
        const t = this.fancybox,
              e = t.getSlide(),
              i = e.Panzoom;
        if (!i) return;
        e.state = "zoomOut", t.state = "customClosing", e.$caption && (e.$caption.style.visibility = "hidden");
        let s = this.fancybox.option("Image.zoomFriction");

        const o = t => {
          const {
            top: o,
            left: n,
            scale: a,
            opacity: r
          } = this.getZoomInfo(e);
          t || r || (s *= .82), i.panTo({
            x: -1 * n,
            y: -1 * o,
            scale: a,
            friction: s,
            ignoreBounds: !0
          }), s *= .98;
        };

        window.addEventListener("scroll", o), i.once("endAnimation", () => {
          window.removeEventListener("scroll", o), t.destroy();
        }), o();
      }

      handleCursor(t) {
        if ("image" !== t.type || !t.$el) return;
        const e = t.Panzoom,
              i = this.fancybox.option("Image.click", !1, t),
              s = this.fancybox.option("Image.touch"),
              o = t.$el.classList,
              n = this.fancybox.option("Image.canZoomInClass"),
              a = this.fancybox.option("Image.canZoomOutClass");

        if (o.remove(a), o.remove(n), e && "toggleZoom" === i) {
          e && 1 === e.content.scale && e.option("maxScale") - e.content.scale > .01 ? o.add(n) : e.content.scale > 1 && !s && o.add(a);
        } else "close" === i && o.add(a);
      }

      onWheel(t, e) {
        if ("ready" === this.fancybox.state && !1 !== this.fancybox.trigger("Image.wheel", e)) switch (this.fancybox.option("Image.wheel")) {
          case "zoom":
            "done" === t.state && t.Panzoom && t.Panzoom.zoomWithWheel(e);
            break;

          case "close":
            this.fancybox.close();
            break;

          case "slide":
            this.fancybox[e.deltaY < 0 ? "prev" : "next"]();
        }
      }

      onClick(t, e) {
        if ("ready" !== this.fancybox.state) return;
        const i = t.Panzoom;
        if (i && (i.dragPosition.midPoint || 0 !== i.dragOffset.x || 0 !== i.dragOffset.y || 1 !== i.dragOffset.scale)) return;
        if (this.fancybox.Carousel.Panzoom.lockAxis) return !1;

        const s = i => {
          switch (i) {
            case "toggleZoom":
              e.stopPropagation(), t.Panzoom && t.Panzoom.zoomWithClick(e);
              break;

            case "close":
              this.fancybox.close();
              break;

            case "next":
              e.stopPropagation(), this.fancybox.next();
          }
        },
              o = this.fancybox.option("Image.click"),
              n = this.fancybox.option("Image.doubleClick");

        n ? this.clickTimer ? (clearTimeout(this.clickTimer), this.clickTimer = null, s(n)) : this.clickTimer = setTimeout(() => {
          this.clickTimer = null, s(o);
        }, 300) : s(o);
      }

      onPageChange(t, e) {
        const i = t.getSlide();
        e.slides.forEach(t => {
          t.Panzoom && "done" === t.state && t.index !== i.index && t.Panzoom.panTo({
            x: 0,
            y: 0,
            scale: 1,
            friction: .8
          });
        });
      }

      attach() {
        this.fancybox.on(this.events);
      }

      detach() {
        this.fancybox.off(this.events);
      }

    }

    T.defaults = {
      canZoomInClass: "can-zoom_in",
      canZoomOutClass: "can-zoom_out",
      zoom: !0,
      zoomOpacity: "auto",
      zoomFriction: .82,
      ignoreCoveredThumbnail: !1,
      touch: !0,
      click: "toggleZoom",
      doubleClick: null,
      wheel: "zoom",
      fit: "contain",
      wrap: !1,
      Panzoom: {
        ratio: 1
      }
    };

    class L {
      constructor(t) {
        this.fancybox = t;

        for (const t of ["onChange", "onClosing"]) this[t] = this[t].bind(this);

        this.events = {
          initCarousel: this.onChange,
          "Carousel.change": this.onChange,
          closing: this.onClosing
        }, this.hasCreatedHistory = !1, this.origHash = "", this.timer = null;
      }

      onChange(t) {
        const e = t.Carousel;
        this.timer && clearTimeout(this.timer);
        const i = null === e.prevPage,
              s = t.getSlide(),
              o = new URL(document.URL).hash;
        let n = !1;
        if (s.slug) n = "#" + s.slug;else {
          const i = s.$trigger && s.$trigger.dataset,
                o = t.option("slug") || i && i.fancybox;
          o && o.length && "true" !== o && (n = "#" + o + (e.slides.length > 1 ? "-" + (s.index + 1) : ""));
        }
        i && (this.origHash = o !== n ? o : ""), n && o !== n && (this.timer = setTimeout(() => {
          try {
            window.history[i ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + n), i && (this.hasCreatedHistory = !0);
          } catch (t) {}
        }, 300));
      }

      onClosing() {
        if (this.timer && clearTimeout(this.timer), !0 !== this.hasSilentClose) try {
          return void window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (this.origHash || ""));
        } catch (t) {}
      }

      attach(t) {
        t.on(this.events);
      }

      detach(t) {
        t.off(this.events);
      }

      static startFromUrl() {
        const t = L.Fancybox;
        if (!t || t.getInstance() || !1 === t.defaults.Hash) return;
        const {
          hash: e,
          slug: i,
          index: s
        } = L.getParsedURL();
        if (!i) return;
        let o = document.querySelector(`[data-slug="${e}"]`);
        if (o && o.dispatchEvent(new CustomEvent("click", {
          bubbles: !0,
          cancelable: !0
        })), t.getInstance()) return;
        const n = document.querySelectorAll(`[data-fancybox="${i}"]`);
        n.length && (null === s && 1 === n.length ? o = n[0] : s && (o = n[s - 1]), o && o.dispatchEvent(new CustomEvent("click", {
          bubbles: !0,
          cancelable: !0
        })));
      }

      static onHashChange() {
        const {
          slug: t,
          index: e
        } = L.getParsedURL(),
              i = L.Fancybox,
              s = i && i.getInstance();

        if (s && s.plugins.Hash) {
          if (t) {
            const i = s.Carousel;
            if (t === s.option("slug")) return i.slideTo(e - 1);

            for (let e of i.slides) if (e.slug && e.slug === t) return i.slideTo(e.index);

            const o = s.getSlide(),
                  n = o.$trigger && o.$trigger.dataset;
            if (n && n.fancybox === t) return i.slideTo(e - 1);
          }

          s.plugins.Hash.hasSilentClose = !0, s.close();
        }

        L.startFromUrl();
      }

      static create(t) {
        function e() {
          window.addEventListener("hashchange", L.onHashChange, !1), L.startFromUrl();
        }

        L.Fancybox = t, v && window.requestAnimationFrame(() => {
          /complete|interactive|loaded/.test(document.readyState) ? e() : document.addEventListener("DOMContentLoaded", e);
        });
      }

      static destroy() {
        window.removeEventListener("hashchange", L.onHashChange, !1);
      }

      static getParsedURL() {
        const t = window.location.hash.substr(1),
              e = t.split("-"),
              i = e.length > 1 && /^\+?\d+$/.test(e[e.length - 1]) && parseInt(e.pop(-1), 10) || null;
        return {
          hash: t,
          slug: e.join("-"),
          index: i
        };
      }

    }

    const _ = {
      pageXOffset: 0,
      pageYOffset: 0,
      element: () => document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement,

      activate(t) {
        _.pageXOffset = window.pageXOffset, _.pageYOffset = window.pageYOffset, t.requestFullscreen ? t.requestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.msRequestFullscreen && t.msRequestFullscreen();
      },

      deactivate() {
        document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen();
      }

    };

    class A {
      constructor(t) {
        this.fancybox = t, this.active = !1, this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
      }

      isActive() {
        return this.active;
      }

      setTimer() {
        if (!this.active || this.timer) return;
        const t = this.fancybox.option("slideshow.delay", 3e3);
        this.timer = setTimeout(() => {
          this.timer = null, this.fancybox.option("infinite") || this.fancybox.getSlide().index !== this.fancybox.Carousel.slides.length - 1 ? this.fancybox.next() : this.fancybox.jumpTo(0, {
            friction: 0
          });
        }, t);
        let e = this.$progress;
        e || (e = document.createElement("div"), e.classList.add("fancybox__progress"), this.fancybox.$carousel.parentNode.insertBefore(e, this.fancybox.$carousel), this.$progress = e, e.offsetHeight), e.style.transitionDuration = `${t}ms`, e.style.transform = "scaleX(1)";
      }

      clearTimer() {
        clearTimeout(this.timer), this.timer = null, this.$progress && (this.$progress.style.transitionDuration = "", this.$progress.style.transform = "", this.$progress.offsetHeight);
      }

      activate() {
        this.active || (this.active = !0, this.fancybox.$container.classList.add("has-slideshow"), "done" === this.fancybox.getSlide().state && this.setTimer(), document.addEventListener("visibilitychange", this.handleVisibilityChange, !1));
      }

      handleVisibilityChange() {
        this.deactivate();
      }

      deactivate() {
        this.active = !1, this.clearTimer(), this.fancybox.$container.classList.remove("has-slideshow"), document.removeEventListener("visibilitychange", this.handleVisibilityChange, !1);
      }

      toggle() {
        this.active ? this.deactivate() : this.fancybox.Carousel.slides.length > 1 && this.activate();
      }

    }

    const z = {
      display: ["counter", "zoom", "slideshow", "fullscreen", "thumbs", "close"],
      autoEnable: !0,
      items: {
        counter: {
          position: "left",
          type: "div",
          class: "fancybox__counter",
          html: '<span data-fancybox-index=""></span>&nbsp;/&nbsp;<span data-fancybox-count=""></span>',
          attr: {
            tabindex: -1
          }
        },
        prev: {
          type: "button",
          class: "fancybox__button--prev",
          label: "PREV",
          html: '<svg viewBox="0 0 24 24"><path d="M15 4l-8 8 8 8"/></svg>',
          attr: {
            "data-fancybox-prev": ""
          }
        },
        next: {
          type: "button",
          class: "fancybox__button--next",
          label: "NEXT",
          html: '<svg viewBox="0 0 24 24"><path d="M8 4l8 8-8 8"/></svg>',
          attr: {
            "data-fancybox-next": ""
          }
        },
        fullscreen: {
          type: "button",
          class: "fancybox__button--fullscreen",
          label: "TOGGLE_FULLSCREEN",
          html: '<svg viewBox="0 0 24 24">\n                <g><path d="M3 8 V3h5"></path><path d="M21 8V3h-5"></path><path d="M8 21H3v-5"></path><path d="M16 21h5v-5"></path></g>\n                <g><path d="M7 2v5H2M17 2v5h5M2 17h5v5M22 17h-5v5"/></g>\n            </svg>',
          click: function (t) {
            t.preventDefault(), _.element() ? _.deactivate() : _.activate(this.fancybox.$container);
          }
        },
        slideshow: {
          type: "button",
          class: "fancybox__button--slideshow",
          label: "TOGGLE_SLIDESHOW",
          html: '<svg viewBox="0 0 24 24">\n                <g><path d="M6 4v16"/><path d="M20 12L6 20"/><path d="M20 12L6 4"/></g>\n                <g><path d="M7 4v15M17 4v15"/></g>\n            </svg>',
          click: function (t) {
            t.preventDefault(), this.Slideshow.toggle();
          }
        },
        zoom: {
          type: "button",
          class: "fancybox__button--zoom",
          label: "TOGGLE_ZOOM",
          html: '<svg viewBox="0 0 24 24"><circle cx="10" cy="10" r="7"></circle><path d="M16 16 L21 21"></svg>',
          click: function (t) {
            t.preventDefault();
            const e = this.fancybox.getSlide().Panzoom;
            e && e.toggleZoom();
          }
        },
        download: {
          type: "link",
          label: "DOWNLOAD",
          class: "fancybox__button--download",
          html: '<svg viewBox="0 0 24 24"><path d="M12 15V3m0 12l-4-4m4 4l4-4M2 17l.62 2.48A2 2 0 004.56 21h14.88a2 2 0 001.94-1.51L22 17"/></svg>',
          click: function (t) {
            t.stopPropagation();
          }
        },
        thumbs: {
          type: "button",
          label: "TOGGLE_THUMBS",
          class: "fancybox__button--thumbs",
          html: '<svg viewBox="0 0 24 24"><circle cx="4" cy="4" r="1" /><circle cx="12" cy="4" r="1" transform="rotate(90 12 4)"/><circle cx="20" cy="4" r="1" transform="rotate(90 20 4)"/><circle cx="4" cy="12" r="1" transform="rotate(90 4 12)"/><circle cx="12" cy="12" r="1" transform="rotate(90 12 12)"/><circle cx="20" cy="12" r="1" transform="rotate(90 20 12)"/><circle cx="4" cy="20" r="1" transform="rotate(90 4 20)"/><circle cx="12" cy="20" r="1" transform="rotate(90 12 20)"/><circle cx="20" cy="20" r="1" transform="rotate(90 20 20)"/></svg>',
          click: function (t) {
            t.stopPropagation();
            const e = this.fancybox.plugins.Thumbs;
            e && e.toggle();
          }
        },
        close: {
          type: "button",
          label: "CLOSE",
          class: "fancybox__button--close",
          html: '<svg viewBox="0 0 24 24"><path d="M20 20L4 4m16 0L4 20"></path></svg>',
          attr: {
            "data-fancybox-close": "",
            tabindex: 0
          }
        }
      }
    };

    class k {
      constructor(t) {
        this.fancybox = t, this.$container = null, this.state = "init";

        for (const t of ["onInit", "onPrepare", "onDone", "onKeydown", "onClosing", "onChange", "onSettle", "onRefresh"]) this[t] = this[t].bind(this);

        this.events = {
          init: this.onInit,
          prepare: this.onPrepare,
          done: this.onDone,
          keydown: this.onKeydown,
          closing: this.onClosing,
          "Carousel.change": this.onChange,
          "Carousel.settle": this.onSettle,
          "Carousel.Panzoom.touchStart": () => this.onRefresh(),
          "Image.startAnimation": (t, e) => this.onRefresh(e),
          "Image.afterUpdate": (t, e) => this.onRefresh(e)
        };
      }

      onInit() {
        if (this.fancybox.option("Toolbar.autoEnable")) {
          let t = !1;

          for (const e of this.fancybox.items) if ("image" === e.type) {
            t = !0;
            break;
          }

          if (!t) return void (this.state = "disabled");
        }

        for (const e of this.fancybox.option("Toolbar.display")) {
          if ("close" === (t(e) ? e.id : e)) {
            this.fancybox.options.closeButton = !1;
            break;
          }
        }
      }

      onPrepare() {
        const t = this.fancybox;
        if ("init" === this.state && (this.build(), this.update(), this.Slideshow = new A(t), !t.Carousel.prevPage && (t.option("slideshow.autoStart") && this.Slideshow.activate(), t.option("fullscreen.autoStart") && !_.element()))) try {
          _.activate(t.$container);
        } catch (t) {}
      }

      onFsChange() {
        window.scrollTo(_.pageXOffset, _.pageYOffset);
      }

      onSettle() {
        const t = this.fancybox,
              e = this.Slideshow;
        e && e.isActive() && (t.getSlide().index !== t.Carousel.slides.length - 1 || t.option("infinite") ? "done" === t.getSlide().state && e.setTimer() : e.deactivate());
      }

      onChange() {
        this.update(), this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer();
      }

      onDone(t, e) {
        const i = this.Slideshow;
        e.index === t.getSlide().index && (this.update(), i && i.isActive() && (t.option("infinite") || e.index !== t.Carousel.slides.length - 1 ? i.setTimer() : i.deactivate()));
      }

      onRefresh(t) {
        t && t.index !== this.fancybox.getSlide().index || (this.update(), !this.Slideshow || !this.Slideshow.isActive() || t && "done" !== t.state || this.Slideshow.deactivate());
      }

      onKeydown(t, e, i) {
        " " === e && this.Slideshow && (this.Slideshow.toggle(), i.preventDefault());
      }

      onClosing() {
        this.Slideshow && this.Slideshow.deactivate(), document.removeEventListener("fullscreenchange", this.onFsChange);
      }

      createElement(t) {
        let e;
        "div" === t.type ? e = document.createElement("div") : (e = document.createElement("link" === t.type ? "a" : "button"), e.classList.add("carousel__button")), e.innerHTML = t.html, e.setAttribute("tabindex", t.tabindex || 0), t.class && e.classList.add(...t.class.split(" "));

        for (const i in t.attr) e.setAttribute(i, t.attr[i]);

        t.label && e.setAttribute("title", this.fancybox.localize(`{{${t.label}}}`)), t.click && e.addEventListener("click", t.click.bind(this)), "prev" === t.id && e.setAttribute("data-fancybox-prev", ""), "next" === t.id && e.setAttribute("data-fancybox-next", "");
        const i = e.querySelector("svg");
        return i && (i.setAttribute("role", "img"), i.setAttribute("tabindex", "-1"), i.setAttribute("xmlns", "http://www.w3.org/2000/svg")), e;
      }

      build() {
        this.cleanup();
        const i = this.fancybox.option("Toolbar.items"),
              s = [{
          position: "left",
          items: []
        }, {
          position: "center",
          items: []
        }, {
          position: "right",
          items: []
        }],
              o = this.fancybox.plugins.Thumbs;

        for (const n of this.fancybox.option("Toolbar.display")) {
          let a, r;
          if (t(n) ? (a = n.id, r = e({}, i[a], n)) : (a = n, r = i[a]), ["counter", "next", "prev", "slideshow"].includes(a) && this.fancybox.items.length < 2) continue;

          if ("fullscreen" === a) {
            if (!document.fullscreenEnabled || window.fullScreen) continue;
            document.addEventListener("fullscreenchange", this.onFsChange);
          }

          if ("thumbs" === a && (!o || "disabled" === o.state)) continue;
          if (!r) continue;
          let h = r.position || "right",
              l = s.find(t => t.position === h);
          l && l.items.push(r);
        }

        const n = document.createElement("div");
        n.classList.add("fancybox__toolbar");

        for (const t of s) if (t.items.length) {
          const e = document.createElement("div");
          e.classList.add("fancybox__toolbar__items"), e.classList.add(`fancybox__toolbar__items--${t.position}`);

          for (const i of t.items) e.appendChild(this.createElement(i));

          n.appendChild(e);
        }

        this.fancybox.$carousel.parentNode.insertBefore(n, this.fancybox.$carousel), this.$container = n;
      }

      update() {
        const t = this.fancybox.getSlide(),
              e = t.index,
              i = this.fancybox.items.length,
              s = t.downloadSrc || ("image" !== t.type || t.error ? null : t.src);

        for (const t of this.fancybox.$container.querySelectorAll("a.fancybox__button--download")) s ? (t.removeAttribute("disabled"), t.removeAttribute("tabindex"), t.setAttribute("href", s), t.setAttribute("download", s), t.setAttribute("target", "_blank")) : (t.setAttribute("disabled", ""), t.setAttribute("tabindex", -1), t.removeAttribute("href"), t.removeAttribute("download"));

        const o = t.Panzoom,
              n = o && o.option("maxScale") > o.option("baseScale");

        for (const t of this.fancybox.$container.querySelectorAll(".fancybox__button--zoom")) n ? t.removeAttribute("disabled") : t.setAttribute("disabled", "");

        for (const e of this.fancybox.$container.querySelectorAll("[data-fancybox-index]")) e.innerHTML = t.index + 1;

        for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-count]")) t.innerHTML = i;

        if (!this.fancybox.option("infinite")) {
          for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-prev]")) 0 === e ? t.setAttribute("disabled", "") : t.removeAttribute("disabled");

          for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-next]")) e === i - 1 ? t.setAttribute("disabled", "") : t.removeAttribute("disabled");
        }
      }

      cleanup() {
        this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer(), this.$container && this.$container.remove(), this.$container = null;
      }

      attach() {
        this.fancybox.on(this.events);
      }

      detach() {
        this.fancybox.off(this.events), this.cleanup();
      }

    }

    k.defaults = z;
    const O = {
      ScrollLock: class {
        constructor(t) {
          this.fancybox = t, this.viewport = null, this.pendingUpdate = null;

          for (const t of ["onReady", "onResize", "onTouchstart", "onTouchmove"]) this[t] = this[t].bind(this);
        }

        onReady() {
          const t = window.visualViewport;
          t && (this.viewport = t, this.startY = 0, t.addEventListener("resize", this.onResize), this.updateViewport()), window.addEventListener("touchstart", this.onTouchstart, {
            passive: !1
          }), window.addEventListener("touchmove", this.onTouchmove, {
            passive: !1
          }), window.addEventListener("wheel", this.onWheel, {
            passive: !1
          });
        }

        onResize() {
          this.updateViewport();
        }

        updateViewport() {
          const t = this.fancybox,
                e = this.viewport,
                i = e.scale || 1,
                s = t.$container;
          if (!s) return;
          let o = "",
              n = "",
              a = "";
          i - 1 > .1 && (o = e.width * i + "px", n = e.height * i + "px", a = `translate3d(${e.offsetLeft}px, ${e.offsetTop}px, 0) scale(${1 / i})`), s.style.width = o, s.style.height = n, s.style.transform = a;
        }

        onTouchstart(t) {
          this.startY = t.touches ? t.touches[0].screenY : t.screenY;
        }

        onTouchmove(t) {
          const e = this.startY,
                i = window.innerWidth / window.document.documentElement.clientWidth;
          if (!t.cancelable) return;
          if (t.touches.length > 1 || 1 !== i) return;
          const o = s(t.composedPath()[0]);
          if (!o) return void t.preventDefault();
          const n = window.getComputedStyle(o),
                a = parseInt(n.getPropertyValue("height"), 10),
                r = t.touches ? t.touches[0].screenY : t.screenY,
                h = e <= r && 0 === o.scrollTop,
                l = e >= r && o.scrollHeight - o.scrollTop === a;
          (h || l) && t.preventDefault();
        }

        onWheel(t) {
          s(t.composedPath()[0]) || t.preventDefault();
        }

        cleanup() {
          this.pendingUpdate && (cancelAnimationFrame(this.pendingUpdate), this.pendingUpdate = null);
          const t = this.viewport;
          t && (t.removeEventListener("resize", this.onResize), this.viewport = null), window.removeEventListener("touchstart", this.onTouchstart, !1), window.removeEventListener("touchmove", this.onTouchmove, !1), window.removeEventListener("wheel", this.onWheel, {
            passive: !1
          });
        }

        attach() {
          this.fancybox.on("initLayout", this.onReady);
        }

        detach() {
          this.fancybox.off("initLayout", this.onReady), this.cleanup();
        }

      },
      Thumbs: C,
      Html: P,
      Toolbar: k,
      Image: T,
      Hash: L
    };
    const M = {
      startIndex: 0,
      preload: 1,
      infinite: !0,
      showClass: "fancybox-zoomInUp",
      hideClass: "fancybox-fadeOut",
      animated: !0,
      hideScrollbar: !0,
      parentEl: null,
      mainClass: null,
      autoFocus: !0,
      trapFocus: !0,
      placeFocusBack: !0,
      click: "close",
      closeButton: "inside",
      dragToClose: !0,
      keyboard: {
        Escape: "close",
        Delete: "close",
        Backspace: "close",
        PageUp: "next",
        PageDown: "prev",
        ArrowUp: "next",
        ArrowDown: "prev",
        ArrowRight: "next",
        ArrowLeft: "prev"
      },
      template: {
        closeButton: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg>',
        spinner: '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="25 25 50 50" tabindex="-1"><circle cx="50" cy="50" r="20"/></svg>',
        main: null
      },
      l10n: {
        CLOSE: "Close",
        NEXT: "Next",
        PREV: "Previous",
        MODAL: "You can close this modal content with the ESC key",
        ERROR: "Something Went Wrong, Please Try Again Later",
        IMAGE_ERROR: "Image Not Found",
        ELEMENT_NOT_FOUND: "HTML Element Not Found",
        AJAX_NOT_FOUND: "Error Loading AJAX : Not Found",
        AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden",
        IFRAME_ERROR: "Error Loading Page",
        TOGGLE_ZOOM: "Toggle zoom level",
        TOGGLE_THUMBS: "Toggle thumbnails",
        TOGGLE_SLIDESHOW: "Toggle slideshow",
        TOGGLE_FULLSCREEN: "Toggle full-screen mode",
        DOWNLOAD: "Download"
      }
    },
          I = new Map();
    let F = 0;

    class R extends l {
      constructor(t, i = {}) {
        t = t.map(t => (t.width && (t._width = t.width), t.height && (t._height = t.height), t)), super(e(!0, {}, M, i)), this.bindHandlers(), this.state = "init", this.setItems(t), this.attachPlugins(R.Plugins), this.trigger("init"), !0 === this.option("hideScrollbar") && this.hideScrollbar(), this.initLayout(), this.initCarousel(), this.attachEvents(), I.set(this.id, this), this.trigger("prepare"), this.state = "ready", this.trigger("ready"), this.$container.setAttribute("aria-hidden", "false"), this.option("trapFocus") && this.focus();
      }

      option(t, ...e) {
        const i = this.getSlide();
        let s = i ? i[t] : void 0;
        return void 0 !== s ? ("function" == typeof s && (s = s.call(this, this, ...e)), s) : super.option(t, ...e);
      }

      bindHandlers() {
        for (const t of ["onMousedown", "onKeydown", "onClick", "onFocus", "onCreateSlide", "onSettle", "onTouchMove", "onTouchEnd", "onTransform"]) this[t] = this[t].bind(this);
      }

      attachEvents() {
        document.addEventListener("mousedown", this.onMousedown), document.addEventListener("keydown", this.onKeydown, !0), this.option("trapFocus") && document.addEventListener("focus", this.onFocus, !0), this.$container.addEventListener("click", this.onClick);
      }

      detachEvents() {
        document.removeEventListener("mousedown", this.onMousedown), document.removeEventListener("keydown", this.onKeydown, !0), document.removeEventListener("focus", this.onFocus, !0), this.$container.removeEventListener("click", this.onClick);
      }

      initLayout() {
        this.$root = this.option("parentEl") || document.body;
        let t = this.option("template.main");
        t && (this.$root.insertAdjacentHTML("beforeend", this.localize(t)), this.$container = this.$root.querySelector(".fancybox__container")), this.$container || (this.$container = document.createElement("div"), this.$root.appendChild(this.$container)), this.$container.onscroll = () => (this.$container.scrollLeft = 0, !1), Object.entries({
          class: "fancybox__container",
          role: "dialog",
          tabIndex: "-1",
          "aria-modal": "true",
          "aria-hidden": "true",
          "aria-label": this.localize("{{MODAL}}")
        }).forEach(t => this.$container.setAttribute(...t)), this.option("animated") && this.$container.classList.add("is-animated"), this.$backdrop = this.$container.querySelector(".fancybox__backdrop"), this.$backdrop || (this.$backdrop = document.createElement("div"), this.$backdrop.classList.add("fancybox__backdrop"), this.$container.appendChild(this.$backdrop)), this.$carousel = this.$container.querySelector(".fancybox__carousel"), this.$carousel || (this.$carousel = document.createElement("div"), this.$carousel.classList.add("fancybox__carousel"), this.$container.appendChild(this.$carousel)), this.$container.Fancybox = this, this.id = this.$container.getAttribute("id"), this.id || (this.id = this.options.id || ++F, this.$container.setAttribute("id", "fancybox-" + this.id));
        const e = this.option("mainClass");
        return e && this.$container.classList.add(...e.split(" ")), document.documentElement.classList.add("with-fancybox"), this.trigger("initLayout"), this;
      }

      setItems(t) {
        const e = [];

        for (const i of t) {
          const t = i.$trigger;

          if (t) {
            const e = t.dataset || {};
            i.src = e.src || t.getAttribute("href") || i.src, i.type = e.type || i.type, !i.src && t instanceof HTMLImageElement && (i.src = t.currentSrc || i.$trigger.src);
          }

          let s = i.$thumb;

          if (!s) {
            let t = i.$trigger && i.$trigger.origTarget;
            t && (s = t instanceof HTMLImageElement ? t : t.querySelector("img:not([aria-hidden])")), !s && i.$trigger && (s = i.$trigger instanceof HTMLImageElement ? i.$trigger : i.$trigger.querySelector("img:not([aria-hidden])"));
          }

          i.$thumb = s || null;
          let o = i.thumb;
          !o && s && (o = s.currentSrc || s.src, !o && s.dataset && (o = s.dataset.lazySrc || s.dataset.src)), o || "image" !== i.type || (o = i.src), i.thumb = o || null, i.caption = i.caption || "", e.push(i);
        }

        this.items = e;
      }

      initCarousel() {
        return this.Carousel = new y(this.$carousel, e(!0, {}, {
          prefix: "",
          classNames: {
            viewport: "fancybox__viewport",
            track: "fancybox__track",
            slide: "fancybox__slide"
          },
          textSelection: !0,
          preload: this.option("preload"),
          friction: .88,
          slides: this.items,
          initialPage: this.options.startIndex,
          slidesPerPage: 1,
          infiniteX: this.option("infinite"),
          infiniteY: !0,
          l10n: this.option("l10n"),
          Dots: !1,
          Navigation: {
            classNames: {
              main: "fancybox__nav",
              button: "carousel__button",
              next: "is-next",
              prev: "is-prev"
            }
          },
          Panzoom: {
            textSelection: !0,
            panOnlyZoomed: () => this.Carousel && this.Carousel.pages && this.Carousel.pages.length < 2 && !this.option("dragToClose"),
            lockAxis: () => {
              if (this.Carousel) {
                let t = "x";
                return this.option("dragToClose") && (t += "y"), t;
              }
            }
          },
          on: {
            "*": (t, ...e) => this.trigger(`Carousel.${t}`, ...e),
            init: t => this.Carousel = t,
            createSlide: this.onCreateSlide,
            settle: this.onSettle
          }
        }, this.option("Carousel"))), this.option("dragToClose") && this.Carousel.Panzoom.on({
          touchMove: this.onTouchMove,
          afterTransform: this.onTransform,
          touchEnd: this.onTouchEnd
        }), this.trigger("initCarousel"), this;
      }

      onCreateSlide(t, e) {
        let i = e.caption || "";

        if ("function" == typeof this.options.caption && (i = this.options.caption.call(this, this, this.Carousel, e)), "string" == typeof i && i.length) {
          const t = document.createElement("div"),
                s = `fancybox__caption_${this.id}_${e.index}`;
          t.className = "fancybox__caption", t.innerHTML = i, t.setAttribute("id", s), e.$caption = e.$el.appendChild(t), e.$el.classList.add("has-caption"), e.$el.setAttribute("aria-labelledby", s);
        }
      }

      onSettle() {
        this.option("autoFocus") && this.focus();
      }

      onFocus(t) {
        this.isTopmost() && this.focus(t);
      }

      onClick(t) {
        if (t.defaultPrevented) return;
        let e = t.composedPath()[0];
        if (e.matches("[data-fancybox-close]")) return t.preventDefault(), void R.close(!1, t);
        if (e.matches("[data-fancybox-next]")) return t.preventDefault(), void R.next();
        if (e.matches("[data-fancybox-prev]")) return t.preventDefault(), void R.prev();
        const i = document.activeElement;

        if (i) {
          if (i.closest("[contenteditable]")) return;
          e.matches(x) || i.blur();
        }

        if (e.closest(".fancybox__content")) return;
        if (getSelection().toString().length) return;
        if (!1 === this.trigger("click", t)) return;

        switch (this.option("click")) {
          case "close":
            this.close();
            break;

          case "next":
            this.next();
        }
      }

      onTouchMove() {
        const t = this.getSlide().Panzoom;
        return !t || 1 === t.content.scale;
      }

      onTouchEnd(t) {
        const e = t.dragOffset.y;
        Math.abs(e) >= 150 || Math.abs(e) >= 35 && t.dragOffset.time < 350 ? (this.option("hideClass") && (this.getSlide().hideClass = "fancybox-throwOut" + (t.content.y < 0 ? "Up" : "Down")), this.close()) : "y" === t.lockAxis && t.panTo({
          y: 0
        });
      }

      onTransform(t) {
        if (this.$backdrop) {
          const e = Math.abs(t.content.y),
                i = e < 1 ? "" : Math.max(.33, Math.min(1, 1 - e / t.content.fitHeight * 1.5));
          this.$container.style.setProperty("--fancybox-ts", i ? "0s" : ""), this.$container.style.setProperty("--fancybox-opacity", i);
        }
      }

      onMousedown() {
        "ready" === this.state && document.body.classList.add("is-using-mouse");
      }

      onKeydown(t) {
        if (!this.isTopmost()) return;
        document.body.classList.remove("is-using-mouse");
        const e = t.key,
              i = this.option("keyboard");
        if (!i || t.ctrlKey || t.altKey || t.shiftKey) return;
        const s = t.composedPath()[0],
              o = document.activeElement && document.activeElement.classList,
              n = o && o.contains("carousel__button");

        if ("Escape" !== e && !n) {
          if (t.target.isContentEditable || -1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(s.nodeName)) return;
        }

        if (!1 === this.trigger("keydown", e, t)) return;
        const a = i[e];
        "function" == typeof this[a] && this[a]();
      }

      getSlide() {
        const t = this.Carousel;
        if (!t) return null;
        const e = null === t.page ? t.option("initialPage") : t.page,
              i = t.pages || [];
        return i.length && i[e] ? i[e].slides[0] : null;
      }

      focus(t) {
        if (R.ignoreFocusChange) return;
        if (["init", "closing", "customClosing", "destroy"].indexOf(this.state) > -1) return;
        const e = this.$container,
              i = this.getSlide(),
              s = "done" === i.state ? i.$el : null;
        if (s && s.contains(document.activeElement)) return;
        t && t.preventDefault(), R.ignoreFocusChange = !0;
        const o = Array.from(e.querySelectorAll(x));
        let n,
            a = [];

        for (let t of o) {
          const e = t.offsetParent,
                i = s && s.contains(t),
                o = !this.Carousel.$viewport.contains(t);
          e && (i || o) ? (a.push(t), void 0 !== t.dataset.origTabindex && (t.tabIndex = t.dataset.origTabindex, t.removeAttribute("data-orig-tabindex")), (t.hasAttribute("autoFocus") || !n && i && !t.classList.contains("carousel__button")) && (n = t)) : (t.dataset.origTabindex = void 0 === t.dataset.origTabindex ? t.getAttribute("tabindex") : t.dataset.origTabindex, t.tabIndex = -1);
        }

        t ? a.indexOf(t.target) > -1 ? this.lastFocus = t.target : this.lastFocus === e ? w(a[a.length - 1]) : w(e) : this.option("autoFocus") && n ? w(n) : a.indexOf(document.activeElement) < 0 && w(e), this.lastFocus = document.activeElement, R.ignoreFocusChange = !1;
      }

      hideScrollbar() {
        if (!v) return;
        const t = window.innerWidth - document.documentElement.getBoundingClientRect().width,
              e = "fancybox-style-noscroll";
        let i = document.getElementById(e);
        i || t > 0 && (i = document.createElement("style"), i.id = e, i.type = "text/css", i.innerHTML = `.compensate-for-scrollbar {padding-right: ${t}px;}`, document.getElementsByTagName("head")[0].appendChild(i), document.body.classList.add("compensate-for-scrollbar"));
      }

      revealScrollbar() {
        document.body.classList.remove("compensate-for-scrollbar");
        const t = document.getElementById("fancybox-style-noscroll");
        t && t.remove();
      }

      clearContent(t) {
        this.Carousel.trigger("removeSlide", t), t.$content && (t.$content.remove(), t.$content = null), t.$closeButton && (t.$closeButton.remove(), t.$closeButton = null), t._className && t.$el.classList.remove(t._className);
      }

      setContent(t, e, i = {}) {
        let s;
        const o = t.$el;
        if (e instanceof HTMLElement) ["img", "iframe", "video", "audio"].indexOf(e.nodeName.toLowerCase()) > -1 ? (s = document.createElement("div"), s.appendChild(e)) : s = e;else {
          const t = document.createRange().createContextualFragment(e);
          s = document.createElement("div"), s.appendChild(t);
        }
        if (t.filter && !t.error && (s = s.querySelector(t.filter)), s instanceof Element) return t._className = `has-${i.suffix || t.type || "unknown"}`, o.classList.add(t._className), s.classList.add("fancybox__content"), "none" !== s.style.display && "none" !== getComputedStyle(s).getPropertyValue("display") || (s.style.display = t.display || this.option("defaultDisplay") || "flex"), t.id && s.setAttribute("id", t.id), t.$content = s, o.prepend(s), this.manageCloseButton(t), "loading" !== t.state && this.revealContent(t), s;
        this.setError(t, "{{ELEMENT_NOT_FOUND}}");
      }

      manageCloseButton(t) {
        const e = void 0 === t.closeButton ? this.option("closeButton") : t.closeButton;
        if (!e || "top" === e && this.$closeButton) return;
        const i = document.createElement("button");
        i.classList.add("carousel__button", "is-close"), i.setAttribute("title", this.options.l10n.CLOSE), i.innerHTML = this.option("template.closeButton"), i.addEventListener("click", t => this.close(t)), "inside" === e ? (t.$closeButton && t.$closeButton.remove(), t.$closeButton = t.$content.appendChild(i)) : this.$closeButton = this.$container.insertBefore(i, this.$container.firstChild);
      }

      revealContent(t) {
        this.trigger("reveal", t), t.$content.style.visibility = "";
        let e = !1;
        t.error || "loading" === t.state || null !== this.Carousel.prevPage || t.index !== this.options.startIndex || (e = void 0 === t.showClass ? this.option("showClass") : t.showClass), e ? (t.state = "animating", this.animateCSS(t.$content, e, () => {
          this.done(t);
        })) : this.done(t);
      }

      animateCSS(t, e, i) {
        if (t && t.dispatchEvent(new CustomEvent("animationend", {
          bubbles: !0,
          cancelable: !0
        })), !t || !e) return void ("function" == typeof i && i());

        const s = function (o) {
          o.currentTarget === this && (t.removeEventListener("animationend", s), i && i(), t.classList.remove(e));
        };

        t.addEventListener("animationend", s), t.classList.add(e);
      }

      done(t) {
        t.state = "done", this.trigger("done", t);
        const e = this.getSlide();
        e && t.index === e.index && this.option("autoFocus") && this.focus();
      }

      setError(t, e) {
        t.error = e, this.hideLoading(t), this.clearContent(t);
        const i = document.createElement("div");
        i.classList.add("fancybox-error"), i.innerHTML = this.localize(e || "<p>{{ERROR}}</p>"), this.setContent(t, i, {
          suffix: "error"
        });
      }

      showLoading(t) {
        t.state = "loading", t.$el.classList.add("is-loading");
        let e = t.$el.querySelector(".fancybox__spinner");
        e || (e = document.createElement("div"), e.classList.add("fancybox__spinner"), e.innerHTML = this.option("template.spinner"), e.addEventListener("click", () => {
          this.Carousel.Panzoom.velocity || this.close();
        }), t.$el.prepend(e));
      }

      hideLoading(t) {
        const e = t.$el && t.$el.querySelector(".fancybox__spinner");
        e && (e.remove(), t.$el.classList.remove("is-loading")), "loading" === t.state && (this.trigger("load", t), t.state = "ready");
      }

      next() {
        const t = this.Carousel;
        t && t.pages.length > 1 && t.slideNext();
      }

      prev() {
        const t = this.Carousel;
        t && t.pages.length > 1 && t.slidePrev();
      }

      jumpTo(...t) {
        this.Carousel && this.Carousel.slideTo(...t);
      }

      isClosing() {
        return ["closing", "customClosing", "destroy"].includes(this.state);
      }

      isTopmost() {
        return R.getInstance().id == this.id;
      }

      close(t) {
        if (t && t.preventDefault(), this.isClosing()) return;
        if (!1 === this.trigger("shouldClose", t)) return;
        if (this.state = "closing", this.Carousel.Panzoom.destroy(), this.detachEvents(), this.trigger("closing", t), "destroy" === this.state) return;
        this.$container.setAttribute("aria-hidden", "true"), this.$container.classList.add("is-closing");
        const e = this.getSlide();

        if (this.Carousel.slides.forEach(t => {
          t.$content && t.index !== e.index && this.Carousel.trigger("removeSlide", t);
        }), "closing" === this.state) {
          const t = void 0 === e.hideClass ? this.option("hideClass") : e.hideClass;
          this.animateCSS(e.$content, t, () => {
            this.destroy();
          }, !0);
        }
      }

      destroy() {
        if ("destroy" === this.state) return;
        this.state = "destroy", this.trigger("destroy");
        const t = this.option("placeFocusBack") ? this.option("triggerTarget", this.getSlide().$trigger) : null;
        this.Carousel.destroy(), this.detachPlugins(), this.Carousel = null, this.options = {}, this.events = {}, this.$container.remove(), this.$container = this.$backdrop = this.$carousel = null, t && w(t), I.delete(this.id);
        const e = R.getInstance();
        e ? e.focus() : (document.documentElement.classList.remove("with-fancybox"), document.body.classList.remove("is-using-mouse"), this.revealScrollbar());
      }

      static show(t, e = {}) {
        return new R(t, e);
      }

      static fromEvent(t, e = {}) {
        if (t.defaultPrevented) return;
        if (t.button && 0 !== t.button) return;
        if (t.ctrlKey || t.metaKey || t.shiftKey) return;
        const i = t.composedPath()[0];
        let s,
            o,
            n,
            a = i;

        if ((a.matches("[data-fancybox-trigger]") || (a = a.closest("[data-fancybox-trigger]"))) && (e.triggerTarget = a, s = a && a.dataset && a.dataset.fancyboxTrigger), s) {
          const t = document.querySelectorAll(`[data-fancybox="${s}"]`),
                e = parseInt(a.dataset.fancyboxIndex, 10) || 0;
          a = t.length ? t[e] : a;
        }

        Array.from(R.openers.keys()).reverse().some(e => {
          n = a || i;
          let s = !1;

          try {
            n instanceof Element && ("string" == typeof e || e instanceof String) && (s = n.matches(e) || (n = n.closest(e)));
          } catch (t) {}

          return !!s && (t.preventDefault(), o = e, !0);
        });
        let r = !1;

        if (o) {
          e.event = t, e.target = n, n.origTarget = i, r = R.fromOpener(o, e);
          const s = R.getInstance();
          s && "ready" === s.state && t.detail && document.body.classList.add("is-using-mouse");
        }

        return r;
      }

      static fromOpener(t, i = {}) {
        let s = [],
            o = i.startIndex || 0,
            n = i.target || null;
        const a = void 0 !== (i = e({}, i, R.openers.get(t))).groupAll && i.groupAll,
              r = void 0 === i.groupAttr ? "data-fancybox" : i.groupAttr,
              h = r && n ? n.getAttribute(`${r}`) : "";

        if (!n || h || a) {
          const e = i.root || (n ? n.getRootNode() : document.body);
          s = [].slice.call(e.querySelectorAll(t));
        }

        if (n && !a && (s = h ? s.filter(t => t.getAttribute(`${r}`) === h) : [n]), !s.length) return !1;
        const l = R.getInstance();
        return !(l && s.indexOf(l.options.$trigger) > -1) && (o = n ? s.indexOf(n) : o, s = s.map(function (t) {
          const e = ["false", "0", "no", "null", "undefined"],
                i = ["true", "1", "yes"],
                s = Object.assign({}, t.dataset),
                o = {};

          for (let [t, n] of Object.entries(s)) if ("fancybox" !== t) if ("width" === t || "height" === t) o[`_${t}`] = n;else if ("string" == typeof n || n instanceof String) {
            if (e.indexOf(n) > -1) o[t] = !1;else if (i.indexOf(o[t]) > -1) o[t] = !0;else try {
              o[t] = JSON.parse(n);
            } catch (e) {
              o[t] = n;
            }
          } else o[t] = n;

          return t instanceof Element && (o.$trigger = t), o;
        }), new R(s, e({}, i, {
          startIndex: o,
          $trigger: n
        })));
      }

      static bind(t, e = {}) {
        function i() {
          document.body.addEventListener("click", R.fromEvent, !1);
        }

        v && (R.openers.size || (/complete|interactive|loaded/.test(document.readyState) ? i() : document.addEventListener("DOMContentLoaded", i)), R.openers.set(t, e));
      }

      static unbind(t) {
        R.openers.delete(t), R.openers.size || R.destroy();
      }

      static destroy() {
        let t;

        for (; t = R.getInstance();) t.destroy();

        R.openers = new Map(), document.body.removeEventListener("click", R.fromEvent, !1);
      }

      static getInstance(t) {
        if (t) return I.get(t);
        return Array.from(I.values()).reverse().find(t => !t.isClosing() && t) || null;
      }

      static close(t = !0, e) {
        if (t) for (const t of I.values()) t.close(e);else {
          const t = R.getInstance();
          t && t.close(e);
        }
      }

      static next() {
        const t = R.getInstance();
        t && t.next();
      }

      static prev() {
        const t = R.getInstance();
        t && t.prev();
      }

    }

    R.version = "4.0.31", R.defaults = M, R.openers = new Map(), R.Plugins = O, R.bind("[data-fancybox]");

    for (const [t, e] of Object.entries(R.Plugins || {})) "function" == typeof e.create && e.create(R);

    var wpcf7Elm = document.querySelector('.wpcf7');

    if (wpcf7Elm) {
      wpcf7Elm.addEventListener('wpcf7mailsent', function (event) {
         close();
      }, false);
      wpcf7Elm.addEventListener('wpcf7submit', function (event) {
        console.log('submitted');
        console.log(event.detail.apiResponse.message);
        R.show([{
          src: event.detail.apiResponse.message,
          type: "html"
        }]);
      }, false);
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var nouislider = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       factory(exports) ;
    })(commonjsGlobal, function (exports) {

      exports.PipsMode = void 0;

      (function (PipsMode) {
        PipsMode["Range"] = "range";
        PipsMode["Steps"] = "steps";
        PipsMode["Positions"] = "positions";
        PipsMode["Count"] = "count";
        PipsMode["Values"] = "values";
      })(exports.PipsMode || (exports.PipsMode = {}));

      exports.PipsType = void 0;

      (function (PipsType) {
        PipsType[PipsType["None"] = -1] = "None";
        PipsType[PipsType["NoValue"] = 0] = "NoValue";
        PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
        PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
      })(exports.PipsType || (exports.PipsType = {})); //region Helper Methods


      function isValidFormatter(entry) {
        return isValidPartialFormatter(entry) && typeof entry.from === "function";
      }

      function isValidPartialFormatter(entry) {
        // partial formatters only need a to function and not a from function
        return typeof entry === "object" && typeof entry.to === "function";
      }

      function removeElement(el) {
        el.parentElement.removeChild(el);
      }

      function isSet(value) {
        return value !== null && value !== undefined;
      } // Bindable version


      function preventDefault(e) {
        e.preventDefault();
      } // Removes duplicates from an array.


      function unique(array) {
        return array.filter(function (a) {
          return !this[a] ? this[a] = true : false;
        }, {});
      } // Round a value to the closest 'to'.


      function closest(value, to) {
        return Math.round(value / to) * to;
      } // Current position of an element relative to the document.


      function offset(elem, orientation) {
        var rect = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var docElem = doc.documentElement;
        var pageOffset = getPageOffset(doc); // getBoundingClientRect contains left scroll in Chrome on Android.
        // I haven't found a feature detection that proves this. Worst case
        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.

        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
          pageOffset.x = 0;
        }

        return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
      } // Checks whether a value is numerical.


      function isNumeric(a) {
        return typeof a === "number" && !isNaN(a) && isFinite(a);
      } // Sets a class and removes it after [duration] ms.


      function addClassFor(element, className, duration) {
        if (duration > 0) {
          addClass(element, className);
          setTimeout(function () {
            removeClass(element, className);
          }, duration);
        }
      } // Limits a value to 0 - 100


      function limit(a) {
        return Math.max(Math.min(a, 100), 0);
      } // Wraps a variable as an array, if it isn't one yet.
      // Note that an input array is returned by reference!


      function asArray(a) {
        return Array.isArray(a) ? a : [a];
      } // Counts decimals


      function countDecimals(numStr) {
        numStr = String(numStr);
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
      } // http://youmightnotneedjquery.com/#add_class


      function addClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.add(className);
        } else {
          el.className += " " + className;
        }
      } // http://youmightnotneedjquery.com/#remove_class


      function removeClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.remove(className);
        } else {
          el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
        }
      } // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/


      function hasClass(el, className) {
        return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
      } // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes


      function getPageOffset(doc) {
        var supportPageOffset = window.pageXOffset !== undefined;
        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
        var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
        var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
        return {
          x: x,
          y: y
        };
      } // we provide a function to compute constants instead
      // of accessing window.* as soon as the module needs it
      // so that we do not compute anything if not needed


      function getActions() {
        // Determine the events to bind. IE11 implements pointerEvents without
        // a prefix, which breaks compatibility with the IE10 implementation.
        return window.navigator.pointerEnabled ? {
          start: "pointerdown",
          move: "pointermove",
          end: "pointerup"
        } : window.navigator.msPointerEnabled ? {
          start: "MSPointerDown",
          move: "MSPointerMove",
          end: "MSPointerUp"
        } : {
          start: "mousedown touchstart",
          move: "mousemove touchmove",
          end: "mouseup touchend"
        };
      } // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
      // Issue #785


      function getSupportsPassive() {
        var supportsPassive = false;
        /* eslint-disable */

        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function () {
              supportsPassive = true;
            }
          }); // @ts-ignore

          window.addEventListener("test", null, opts);
        } catch (e) {}
        /* eslint-enable */


        return supportsPassive;
      }

      function getSupportsTouchActionNone() {
        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
      } //endregion
      //region Range Calculation
      // Determine the size of a sub-range in relation to a full range.


      function subRangeRatio(pa, pb) {
        return 100 / (pb - pa);
      } // (percentage) How many percent is this value of this range?


      function fromPercentage(range, value, startRange) {
        return value * 100 / (range[startRange + 1] - range[startRange]);
      } // (percentage) Where is this value on this range?


      function toPercentage(range, value) {
        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
      } // (value) How much is this percentage on this range?


      function isPercentage(range, value) {
        return value * (range[1] - range[0]) / 100 + range[0];
      }

      function getJ(value, arr) {
        var j = 1;

        while (value >= arr[j]) {
          j += 1;
        }

        return j;
      } // (percentage) Input a value, find where, on a scale of 0-100, it applies.


      function toStepping(xVal, xPct, value) {
        if (value >= xVal.slice(-1)[0]) {
          return 100;
        }

        var j = getJ(value, xVal);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];
        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
      } // (value) Input a percentage, find where it is on the specified range.


      function fromStepping(xVal, xPct, value) {
        // There is no range group that fits 100
        if (value >= 100) {
          return xVal.slice(-1)[0];
        }

        var j = getJ(value, xPct);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];
        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
      } // (percentage) Get the step that applies at a certain value.


      function getStep(xPct, xSteps, snap, value) {
        if (value === 100) {
          return value;
        }

        var j = getJ(value, xPct);
        var a = xPct[j - 1];
        var b = xPct[j]; // If 'snap' is set, steps are used as fixed points on the slider.

        if (snap) {
          // Find the closest position, a or b.
          if (value - a > (b - a) / 2) {
            return b;
          }

          return a;
        }

        if (!xSteps[j - 1]) {
          return value;
        }

        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
      } //endregion
      //region Spectrum


      var Spectrum =
      /** @class */
      function () {
        function Spectrum(entry, snap, singleStep) {
          this.xPct = [];
          this.xVal = [];
          this.xSteps = [];
          this.xNumSteps = [];
          this.xHighestCompleteStep = [];
          this.xSteps = [singleStep || false];
          this.xNumSteps = [false];
          this.snap = snap;
          var index;
          var ordered = []; // Map the object keys to an array.

          Object.keys(entry).forEach(function (index) {
            ordered.push([asArray(entry[index]), index]);
          }); // Sort all entries by value (numeric sort).

          ordered.sort(function (a, b) {
            return a[0][0] - b[0][0];
          }); // Convert all entries to subranges.

          for (index = 0; index < ordered.length; index++) {
            this.handleEntryPoint(ordered[index][1], ordered[index][0]);
          } // Store the actual step values.
          // xSteps is sorted in the same order as xPct and xVal.


          this.xNumSteps = this.xSteps.slice(0); // Convert all numeric steps to the percentage of the subrange they represent.

          for (index = 0; index < this.xNumSteps.length; index++) {
            this.handleStepPoint(index, this.xNumSteps[index]);
          }
        }

        Spectrum.prototype.getDistance = function (value) {
          var distances = [];

          for (var index = 0; index < this.xNumSteps.length - 1; index++) {
            distances[index] = fromPercentage(this.xVal, value, index);
          }

          return distances;
        }; // Calculate the percentual distance over the whole scale of ranges.
        // direction: 0 = backwards / 1 = forwards


        Spectrum.prototype.getAbsoluteDistance = function (value, distances, direction) {
          var xPct_index = 0; // Calculate range where to start calculation

          if (value < this.xPct[this.xPct.length - 1]) {
            while (value > this.xPct[xPct_index + 1]) {
              xPct_index++;
            }
          } else if (value === this.xPct[this.xPct.length - 1]) {
            xPct_index = this.xPct.length - 2;
          } // If looking backwards and the value is exactly at a range separator then look one range further


          if (!direction && value === this.xPct[xPct_index + 1]) {
            xPct_index++;
          }

          if (distances === null) {
            distances = [];
          }

          var start_factor;
          var rest_factor = 1;
          var rest_rel_distance = distances[xPct_index];
          var range_pct = 0;
          var rel_range_distance = 0;
          var abs_distance_counter = 0;
          var range_counter = 0; // Calculate what part of the start range the value is

          if (direction) {
            start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
          } else {
            start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
          } // Do until the complete distance across ranges is calculated


          while (rest_rel_distance > 0) {
            // Calculate the percentage of total range
            range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter]; // Detect if the margin, padding or limit is larger then the current range and calculate

            if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
              // If larger then take the percentual distance of the whole range
              rel_range_distance = range_pct * start_factor; // Rest factor of relative percentual distance still to be calculated

              rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter]; // Set start factor to 1 as for next range it does not apply.

              start_factor = 1;
            } else {
              // If smaller or equal then take the percentual distance of the calculate percentual part of that range
              rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor; // No rest left as the rest fits in current range

              rest_factor = 0;
            }

            if (direction) {
              abs_distance_counter = abs_distance_counter - rel_range_distance; // Limit range to first range when distance becomes outside of minimum range

              if (this.xPct.length + range_counter >= 1) {
                range_counter--;
              }
            } else {
              abs_distance_counter = abs_distance_counter + rel_range_distance; // Limit range to last range when distance becomes outside of maximum range

              if (this.xPct.length - range_counter >= 1) {
                range_counter++;
              }
            } // Rest of relative percentual distance still to be calculated


            rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
          }

          return value + abs_distance_counter;
        };

        Spectrum.prototype.toStepping = function (value) {
          value = toStepping(this.xVal, this.xPct, value);
          return value;
        };

        Spectrum.prototype.fromStepping = function (value) {
          return fromStepping(this.xVal, this.xPct, value);
        };

        Spectrum.prototype.getStep = function (value) {
          value = getStep(this.xPct, this.xSteps, this.snap, value);
          return value;
        };

        Spectrum.prototype.getDefaultStep = function (value, isDown, size) {
          var j = getJ(value, this.xPct); // When at the top or stepping down, look at the previous sub-range

          if (value === 100 || isDown && value === this.xPct[j - 1]) {
            j = Math.max(j - 1, 1);
          }

          return (this.xVal[j] - this.xVal[j - 1]) / size;
        };

        Spectrum.prototype.getNearbySteps = function (value) {
          var j = getJ(value, this.xPct);
          return {
            stepBefore: {
              startValue: this.xVal[j - 2],
              step: this.xNumSteps[j - 2],
              highestStep: this.xHighestCompleteStep[j - 2]
            },
            thisStep: {
              startValue: this.xVal[j - 1],
              step: this.xNumSteps[j - 1],
              highestStep: this.xHighestCompleteStep[j - 1]
            },
            stepAfter: {
              startValue: this.xVal[j],
              step: this.xNumSteps[j],
              highestStep: this.xHighestCompleteStep[j]
            }
          };
        };

        Spectrum.prototype.countStepDecimals = function () {
          var stepDecimals = this.xNumSteps.map(countDecimals);
          return Math.max.apply(null, stepDecimals);
        };

        Spectrum.prototype.hasNoSize = function () {
          return this.xVal[0] === this.xVal[this.xVal.length - 1];
        }; // Outside testing


        Spectrum.prototype.convert = function (value) {
          return this.getStep(this.toStepping(value));
        };

        Spectrum.prototype.handleEntryPoint = function (index, value) {
          var percentage; // Covert min/max syntax to 0 and 100.

          if (index === "min") {
            percentage = 0;
          } else if (index === "max") {
            percentage = 100;
          } else {
            percentage = parseFloat(index);
          } // Check for correct input.


          if (!isNumeric(percentage) || !isNumeric(value[0])) {
            throw new Error("noUiSlider: 'range' value isn't numeric.");
          } // Store values.


          this.xPct.push(percentage);
          this.xVal.push(value[0]);
          var value1 = Number(value[1]); // NaN will evaluate to false too, but to keep
          // logging clear, set step explicitly. Make sure
          // not to override the 'step' setting with false.

          if (!percentage) {
            if (!isNaN(value1)) {
              this.xSteps[0] = value1;
            }
          } else {
            this.xSteps.push(isNaN(value1) ? false : value1);
          }

          this.xHighestCompleteStep.push(0);
        };

        Spectrum.prototype.handleStepPoint = function (i, n) {
          // Ignore 'false' stepping.
          if (!n) {
            return;
          } // Step over zero-length ranges (#948);


          if (this.xVal[i] === this.xVal[i + 1]) {
            this.xSteps[i] = this.xHighestCompleteStep[i] = this.xVal[i];
            return;
          } // Factor to range ratio


          this.xSteps[i] = fromPercentage([this.xVal[i], this.xVal[i + 1]], n, 0) / subRangeRatio(this.xPct[i], this.xPct[i + 1]);
          var totalSteps = (this.xVal[i + 1] - this.xVal[i]) / this.xNumSteps[i];
          var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
          var step = this.xVal[i] + this.xNumSteps[i] * highestStep;
          this.xHighestCompleteStep[i] = step;
        };

        return Spectrum;
      }(); //endregion
      //region Options

      /*	Every input option is tested and parsed. This will prevent
          endless validation in internal methods. These tests are
          structured with an item for every option available. An
          option can be marked as required by setting the 'r' flag.
          The testing function is provided with three arguments:
              - The provided value for the option;
              - A reference to the options object;
              - The name for the option;
           The testing function returns false when an error is detected,
          or true when everything is OK. It can also modify the option
          object, to make sure all values can be correctly looped elsewhere. */
      //region Defaults


      var defaultFormatter = {
        to: function (value) {
          return value === undefined ? "" : value.toFixed(2);
        },
        from: Number
      };
      var cssClasses = {
        target: "target",
        base: "base",
        origin: "origin",
        handle: "handle",
        handleLower: "handle-lower",
        handleUpper: "handle-upper",
        touchArea: "touch-area",
        horizontal: "horizontal",
        vertical: "vertical",
        background: "background",
        connect: "connect",
        connects: "connects",
        ltr: "ltr",
        rtl: "rtl",
        textDirectionLtr: "txt-dir-ltr",
        textDirectionRtl: "txt-dir-rtl",
        draggable: "draggable",
        drag: "state-drag",
        tap: "state-tap",
        active: "active",
        tooltip: "tooltip",
        pips: "pips",
        pipsHorizontal: "pips-horizontal",
        pipsVertical: "pips-vertical",
        marker: "marker",
        markerHorizontal: "marker-horizontal",
        markerVertical: "marker-vertical",
        markerNormal: "marker-normal",
        markerLarge: "marker-large",
        markerSub: "marker-sub",
        value: "value",
        valueHorizontal: "value-horizontal",
        valueVertical: "value-vertical",
        valueNormal: "value-normal",
        valueLarge: "value-large",
        valueSub: "value-sub"
      }; // Namespaces of internal event listeners

      var INTERNAL_EVENT_NS = {
        tooltips: ".__tooltips",
        aria: ".__aria"
      }; //endregion

      function testStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'step' is not numeric.");
        } // The step option can still be used to set stepping
        // for linear sliders. Overwritten if set in 'range'.


        parsed.singleStep = entry;
      }

      function testKeyboardPageMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
        }

        parsed.keyboardPageMultiplier = entry;
      }

      function testKeyboardMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
        }

        parsed.keyboardMultiplier = entry;
      }

      function testKeyboardDefaultStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
        }

        parsed.keyboardDefaultStep = entry;
      }

      function testRange(parsed, entry) {
        // Filter incorrect input.
        if (typeof entry !== "object" || Array.isArray(entry)) {
          throw new Error("noUiSlider: 'range' is not an object.");
        } // Catch missing start or end.


        if (entry.min === undefined || entry.max === undefined) {
          throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
        }

        parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
      }

      function testStart(parsed, entry) {
        entry = asArray(entry); // Validate input. Values aren't tested, as the public .val method
        // will always provide a valid location.

        if (!Array.isArray(entry) || !entry.length) {
          throw new Error("noUiSlider: 'start' option is incorrect.");
        } // Store the number of handles.


        parsed.handles = entry.length; // When the slider is initialized, the .val method will
        // be called with the start options.

        parsed.start = entry;
      }

      function testSnap(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'snap' option must be a boolean.");
        } // Enforce 100% stepping within subranges.


        parsed.snap = entry;
      }

      function testAnimate(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'animate' option must be a boolean.");
        } // Enforce 100% stepping within subranges.


        parsed.animate = entry;
      }

      function testAnimationDuration(parsed, entry) {
        if (typeof entry !== "number") {
          throw new Error("noUiSlider: 'animationDuration' option must be a number.");
        }

        parsed.animationDuration = entry;
      }

      function testConnect(parsed, entry) {
        var connect = [false];
        var i; // Map legacy options

        if (entry === "lower") {
          entry = [true, false];
        } else if (entry === "upper") {
          entry = [false, true];
        } // Handle boolean options


        if (entry === true || entry === false) {
          for (i = 1; i < parsed.handles; i++) {
            connect.push(entry);
          }

          connect.push(false);
        } // Reject invalid input
        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
          throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        } else {
          connect = entry;
        }

        parsed.connect = connect;
      }

      function testOrientation(parsed, entry) {
        // Set orientation to an a numerical value for easy
        // array selection.
        switch (entry) {
          case "horizontal":
            parsed.ort = 0;
            break;

          case "vertical":
            parsed.ort = 1;
            break;

          default:
            throw new Error("noUiSlider: 'orientation' option is invalid.");
        }
      }

      function testMargin(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'margin' option must be numeric.");
        } // Issue #582


        if (entry === 0) {
          return;
        }

        parsed.margin = parsed.spectrum.getDistance(entry);
      }

      function testLimit(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'limit' option must be numeric.");
        }

        parsed.limit = parsed.spectrum.getDistance(entry);

        if (!parsed.limit || parsed.handles < 2) {
          throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
        }
      }

      function testPadding(parsed, entry) {
        var index;

        if (!isNumeric(entry) && !Array.isArray(entry)) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }

        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }

        if (entry === 0) {
          return;
        }

        if (!Array.isArray(entry)) {
          entry = [entry, entry];
        } // 'getDistance' returns false for invalid values.


        parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];

        for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) {
          // last "range" can't contain step size as it is purely an endpoint.
          if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) {
            throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
          }
        }

        var totalPadding = entry[0] + entry[1];
        var firstValue = parsed.spectrum.xVal[0];
        var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];

        if (totalPadding / (lastValue - firstValue) > 1) {
          throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
        }
      }

      function testDirection(parsed, entry) {
        // Set direction as a numerical value for easy parsing.
        // Invert connection for RTL sliders, so that the proper
        // handles get the connect/background classes.
        switch (entry) {
          case "ltr":
            parsed.dir = 0;
            break;

          case "rtl":
            parsed.dir = 1;
            break;

          default:
            throw new Error("noUiSlider: 'direction' option was not recognized.");
        }
      }

      function testBehaviour(parsed, entry) {
        // Make sure the input is a string.
        if (typeof entry !== "string") {
          throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
        } // Check if the string contains any keywords.
        // None are required.


        var tap = entry.indexOf("tap") >= 0;
        var drag = entry.indexOf("drag") >= 0;
        var fixed = entry.indexOf("fixed") >= 0;
        var snap = entry.indexOf("snap") >= 0;
        var hover = entry.indexOf("hover") >= 0;
        var unconstrained = entry.indexOf("unconstrained") >= 0;
        var dragAll = entry.indexOf("drag-all") >= 0;
        var smoothSteps = entry.indexOf("smooth-steps") >= 0;

        if (fixed) {
          if (parsed.handles !== 2) {
            throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
          } // Use margin to enforce fixed state


          testMargin(parsed, parsed.start[1] - parsed.start[0]);
        }

        if (unconstrained && (parsed.margin || parsed.limit)) {
          throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
        }

        parsed.events = {
          tap: tap || snap,
          drag: drag,
          dragAll: dragAll,
          smoothSteps: smoothSteps,
          fixed: fixed,
          snap: snap,
          hover: hover,
          unconstrained: unconstrained
        };
      }

      function testTooltips(parsed, entry) {
        if (entry === false) {
          return;
        }

        if (entry === true || isValidPartialFormatter(entry)) {
          parsed.tooltips = [];

          for (var i = 0; i < parsed.handles; i++) {
            parsed.tooltips.push(entry);
          }
        } else {
          entry = asArray(entry);

          if (entry.length !== parsed.handles) {
            throw new Error("noUiSlider: must pass a formatter for all handles.");
          }

          entry.forEach(function (formatter) {
            if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
              throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
            }
          });
          parsed.tooltips = entry;
        }
      }

      function testHandleAttributes(parsed, entry) {
        if (entry.length !== parsed.handles) {
          throw new Error("noUiSlider: must pass a attributes for all handles.");
        }

        parsed.handleAttributes = entry;
      }

      function testAriaFormat(parsed, entry) {
        if (!isValidPartialFormatter(entry)) {
          throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
        }

        parsed.ariaFormat = entry;
      }

      function testFormat(parsed, entry) {
        if (!isValidFormatter(entry)) {
          throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
        }

        parsed.format = entry;
      }

      function testKeyboardSupport(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
        }

        parsed.keyboardSupport = entry;
      }

      function testDocumentElement(parsed, entry) {
        // This is an advanced option. Passed values are used without validation.
        parsed.documentElement = entry;
      }

      function testCssPrefix(parsed, entry) {
        if (typeof entry !== "string" && entry !== false) {
          throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
        }

        parsed.cssPrefix = entry;
      }

      function testCssClasses(parsed, entry) {
        if (typeof entry !== "object") {
          throw new Error("noUiSlider: 'cssClasses' must be an object.");
        }

        if (typeof parsed.cssPrefix === "string") {
          parsed.cssClasses = {};
          Object.keys(entry).forEach(function (key) {
            parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
          });
        } else {
          parsed.cssClasses = entry;
        }
      } // Test all developer settings and parse to assumption-safe values.


      function testOptions(options) {
        // To prove a fix for #537, freeze options here.
        // If the object is modified, an error will be thrown.
        // Object.freeze(options);
        var parsed = {
          margin: null,
          limit: null,
          padding: null,
          animate: true,
          animationDuration: 300,
          ariaFormat: defaultFormatter,
          format: defaultFormatter
        }; // Tests are executed in the order they are presented here.

        var tests = {
          step: {
            r: false,
            t: testStep
          },
          keyboardPageMultiplier: {
            r: false,
            t: testKeyboardPageMultiplier
          },
          keyboardMultiplier: {
            r: false,
            t: testKeyboardMultiplier
          },
          keyboardDefaultStep: {
            r: false,
            t: testKeyboardDefaultStep
          },
          start: {
            r: true,
            t: testStart
          },
          connect: {
            r: true,
            t: testConnect
          },
          direction: {
            r: true,
            t: testDirection
          },
          snap: {
            r: false,
            t: testSnap
          },
          animate: {
            r: false,
            t: testAnimate
          },
          animationDuration: {
            r: false,
            t: testAnimationDuration
          },
          range: {
            r: true,
            t: testRange
          },
          orientation: {
            r: false,
            t: testOrientation
          },
          margin: {
            r: false,
            t: testMargin
          },
          limit: {
            r: false,
            t: testLimit
          },
          padding: {
            r: false,
            t: testPadding
          },
          behaviour: {
            r: true,
            t: testBehaviour
          },
          ariaFormat: {
            r: false,
            t: testAriaFormat
          },
          format: {
            r: false,
            t: testFormat
          },
          tooltips: {
            r: false,
            t: testTooltips
          },
          keyboardSupport: {
            r: true,
            t: testKeyboardSupport
          },
          documentElement: {
            r: false,
            t: testDocumentElement
          },
          cssPrefix: {
            r: true,
            t: testCssPrefix
          },
          cssClasses: {
            r: true,
            t: testCssClasses
          },
          handleAttributes: {
            r: false,
            t: testHandleAttributes
          }
        };
        var defaults = {
          connect: false,
          direction: "ltr",
          behaviour: "tap",
          orientation: "horizontal",
          keyboardSupport: true,
          cssPrefix: "noUi-",
          cssClasses: cssClasses,
          keyboardPageMultiplier: 5,
          keyboardMultiplier: 1,
          keyboardDefaultStep: 10
        }; // AriaFormat defaults to regular format, if any.

        if (options.format && !options.ariaFormat) {
          options.ariaFormat = options.format;
        } // Run all options through a testing mechanism to ensure correct
        // input. It should be noted that options might get modified to
        // be handled properly. E.g. wrapping integers in arrays.


        Object.keys(tests).forEach(function (name) {
          // If the option isn't set, but it is required, throw an error.
          if (!isSet(options[name]) && defaults[name] === undefined) {
            if (tests[name].r) {
              throw new Error("noUiSlider: '" + name + "' is required.");
            }

            return;
          }

          tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
        }); // Forward pips options

        parsed.pips = options.pips; // All recent browsers accept unprefixed transform.
        // We need -ms- for IE9 and -webkit- for older Android;
        // Assume use of -webkit- if unprefixed and -ms- are not supported.
        // https://caniuse.com/#feat=transforms2d

        var d = document.createElement("div");
        var msPrefix = d.style.msTransform !== undefined;
        var noPrefix = d.style.transform !== undefined;
        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform"; // Pips don't move, so we can place them using left/top.

        var styles = [["left", "top"], ["right", "bottom"]];
        parsed.style = styles[parsed.dir][parsed.ort];
        return parsed;
      } //endregion


      function scope(target, options, originalOptions) {
        var actions = getActions();
        var supportsTouchActionNone = getSupportsTouchActionNone();
        var supportsPassive = supportsTouchActionNone && getSupportsPassive(); // All variables local to 'scope' are prefixed with 'scope_'
        // Slider DOM Nodes

        var scope_Target = target;
        var scope_Base;
        var scope_Handles;
        var scope_Connects;
        var scope_Pips;
        var scope_Tooltips; // Slider state values

        var scope_Spectrum = options.spectrum;
        var scope_Values = [];
        var scope_Locations = [];
        var scope_HandleNumbers = [];
        var scope_ActiveHandlesCount = 0;
        var scope_Events = {}; // Document Nodes

        var scope_Document = target.ownerDocument;
        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
        var scope_Body = scope_Document.body; // For horizontal sliders in standard ltr documents,
        // make .noUi-origin overflow to the left so the document doesn't scroll.

        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100; // Creates a node, adds it to target, returns the new node.

        function addNodeTo(addTarget, className) {
          var div = scope_Document.createElement("div");

          if (className) {
            addClass(div, className);
          }

          addTarget.appendChild(div);
          return div;
        } // Append a origin to the base


        function addOrigin(base, handleNumber) {
          var origin = addNodeTo(base, options.cssClasses.origin);
          var handle = addNodeTo(origin, options.cssClasses.handle);
          addNodeTo(handle, options.cssClasses.touchArea);
          handle.setAttribute("data-handle", String(handleNumber));

          if (options.keyboardSupport) {
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
            // 0 = focusable and reachable
            handle.setAttribute("tabindex", "0");
            handle.addEventListener("keydown", function (event) {
              return eventKeydown(event, handleNumber);
            });
          }

          if (options.handleAttributes !== undefined) {
            var attributes_1 = options.handleAttributes[handleNumber];
            Object.keys(attributes_1).forEach(function (attribute) {
              handle.setAttribute(attribute, attributes_1[attribute]);
            });
          }

          handle.setAttribute("role", "slider");
          handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");

          if (handleNumber === 0) {
            addClass(handle, options.cssClasses.handleLower);
          } else if (handleNumber === options.handles - 1) {
            addClass(handle, options.cssClasses.handleUpper);
          }

          return origin;
        } // Insert nodes for connect elements


        function addConnect(base, add) {
          if (!add) {
            return false;
          }

          return addNodeTo(base, options.cssClasses.connect);
        } // Add handles to the slider base.


        function addElements(connectOptions, base) {
          var connectBase = addNodeTo(base, options.cssClasses.connects);
          scope_Handles = [];
          scope_Connects = [];
          scope_Connects.push(addConnect(connectBase, connectOptions[0])); // [::::O====O====O====]
          // connectOptions = [0, 1, 1, 1]

          for (var i = 0; i < options.handles; i++) {
            // Keep a list of all added handles.
            scope_Handles.push(addOrigin(base, i));
            scope_HandleNumbers[i] = i;
            scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
          }
        } // Initialize a single slider.


        function addSlider(addTarget) {
          // Apply classes and data to the target.
          addClass(addTarget, options.cssClasses.target);

          if (options.dir === 0) {
            addClass(addTarget, options.cssClasses.ltr);
          } else {
            addClass(addTarget, options.cssClasses.rtl);
          }

          if (options.ort === 0) {
            addClass(addTarget, options.cssClasses.horizontal);
          } else {
            addClass(addTarget, options.cssClasses.vertical);
          }

          var textDirection = getComputedStyle(addTarget).direction;

          if (textDirection === "rtl") {
            addClass(addTarget, options.cssClasses.textDirectionRtl);
          } else {
            addClass(addTarget, options.cssClasses.textDirectionLtr);
          }

          return addNodeTo(addTarget, options.cssClasses.base);
        }

        function addTooltip(handle, handleNumber) {
          if (!options.tooltips || !options.tooltips[handleNumber]) {
            return false;
          }

          return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
        }

        function isSliderDisabled() {
          return scope_Target.hasAttribute("disabled");
        } // Disable the slider dragging if any handle is disabled


        function isHandleDisabled(handleNumber) {
          var handleOrigin = scope_Handles[handleNumber];
          return handleOrigin.hasAttribute("disabled");
        }

        function removeTooltips() {
          if (scope_Tooltips) {
            removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
            scope_Tooltips.forEach(function (tooltip) {
              if (tooltip) {
                removeElement(tooltip);
              }
            });
            scope_Tooltips = null;
          }
        } // The tooltips option is a shorthand for using the 'update' event.


        function tooltips() {
          removeTooltips(); // Tooltips are added with options.tooltips in original order.

          scope_Tooltips = scope_Handles.map(addTooltip);
          bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function (values, handleNumber, unencoded) {
            if (!scope_Tooltips || !options.tooltips) {
              return;
            }

            if (scope_Tooltips[handleNumber] === false) {
              return;
            }

            var formattedValue = values[handleNumber];

            if (options.tooltips[handleNumber] !== true) {
              formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
            }

            scope_Tooltips[handleNumber].innerHTML = formattedValue;
          });
        }

        function aria() {
          removeEvent("update" + INTERNAL_EVENT_NS.aria);
          bindEvent("update" + INTERNAL_EVENT_NS.aria, function (values, handleNumber, unencoded, tap, positions) {
            // Update Aria Values for all handles, as a change in one changes min and max values for the next.
            scope_HandleNumbers.forEach(function (index) {
              var handle = scope_Handles[index];
              var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);
              var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);
              var now = positions[index]; // Formatted value for display

              var text = String(options.ariaFormat.to(unencoded[index])); // Map to slider range values

              min = scope_Spectrum.fromStepping(min).toFixed(1);
              max = scope_Spectrum.fromStepping(max).toFixed(1);
              now = scope_Spectrum.fromStepping(now).toFixed(1);
              handle.children[0].setAttribute("aria-valuemin", min);
              handle.children[0].setAttribute("aria-valuemax", max);
              handle.children[0].setAttribute("aria-valuenow", now);
              handle.children[0].setAttribute("aria-valuetext", text);
            });
          });
        }

        function getGroup(pips) {
          // Use the range.
          if (pips.mode === exports.PipsMode.Range || pips.mode === exports.PipsMode.Steps) {
            return scope_Spectrum.xVal;
          }

          if (pips.mode === exports.PipsMode.Count) {
            if (pips.values < 2) {
              throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
            } // Divide 0 - 100 in 'count' parts.


            var interval = pips.values - 1;
            var spread = 100 / interval;
            var values = []; // List these parts and have them handled as 'positions'.

            while (interval--) {
              values[interval] = interval * spread;
            }

            values.push(100);
            return mapToRange(values, pips.stepped);
          }

          if (pips.mode === exports.PipsMode.Positions) {
            // Map all percentages to on-range values.
            return mapToRange(pips.values, pips.stepped);
          }

          if (pips.mode === exports.PipsMode.Values) {
            // If the value must be stepped, it needs to be converted to a percentage first.
            if (pips.stepped) {
              return pips.values.map(function (value) {
                // Convert to percentage, apply step, return to value.
                return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
              });
            } // Otherwise, we can simply use the values.


            return pips.values;
          }

          return []; // pips.mode = never
        }

        function mapToRange(values, stepped) {
          return values.map(function (value) {
            return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
          });
        }

        function generateSpread(pips) {
          function safeIncrement(value, increment) {
            // Avoid floating point variance by dropping the smallest decimal places.
            return Number((value + increment).toFixed(7));
          }

          var group = getGroup(pips);
          var indexes = {};
          var firstInRange = scope_Spectrum.xVal[0];
          var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
          var ignoreFirst = false;
          var ignoreLast = false;
          var prevPct = 0; // Create a copy of the group, sort it and filter away all duplicates.

          group = unique(group.slice().sort(function (a, b) {
            return a - b;
          })); // Make sure the range starts with the first element.

          if (group[0] !== firstInRange) {
            group.unshift(firstInRange);
            ignoreFirst = true;
          } // Likewise for the last one.


          if (group[group.length - 1] !== lastInRange) {
            group.push(lastInRange);
            ignoreLast = true;
          }

          group.forEach(function (current, index) {
            // Get the current step and the lower + upper positions.
            var step;
            var i;
            var q;
            var low = current;
            var high = group[index + 1];
            var newPct;
            var pctDifference;
            var pctPos;
            var type;
            var steps;
            var realSteps;
            var stepSize;
            var isSteps = pips.mode === exports.PipsMode.Steps; // When using 'steps' mode, use the provided steps.
            // Otherwise, we'll step on to the next subrange.

            if (isSteps) {
              step = scope_Spectrum.xNumSteps[index];
            } // Default to a 'full' step.


            if (!step) {
              step = high - low;
            } // If high is undefined we are at the last subrange. Make sure it iterates once (#1088)


            if (high === undefined) {
              high = low;
            } // Make sure step isn't 0, which would cause an infinite loop (#654)


            step = Math.max(step, 0.0000001); // Find all steps in the subrange.

            for (i = low; i <= high; i = safeIncrement(i, step)) {
              // Get the percentage value for the current step,
              // calculate the size for the subrange.
              newPct = scope_Spectrum.toStepping(i);
              pctDifference = newPct - prevPct;
              steps = pctDifference / (pips.density || 1);
              realSteps = Math.round(steps); // This ratio represents the amount of percentage-space a point indicates.
              // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.
              // Round the percentage offset to an even number, then divide by two
              // to spread the offset on both sides of the range.

              stepSize = pctDifference / realSteps; // Divide all points evenly, adding the correct number to this subrange.
              // Run up to <= so that 100% gets a point, event if ignoreLast is set.

              for (q = 1; q <= realSteps; q += 1) {
                // The ratio between the rounded value and the actual size might be ~1% off.
                // Correct the percentage offset by the number of points
                // per subrange. density = 1 will result in 100 points on the
                // full range, 2 for 50, 4 for 25, etc.
                pctPos = prevPct + q * stepSize;
                indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
              } // Determine the point type.


              type = group.indexOf(i) > -1 ? exports.PipsType.LargeValue : isSteps ? exports.PipsType.SmallValue : exports.PipsType.NoValue; // Enforce the 'ignoreFirst' option by overwriting the type for 0.

              if (!index && ignoreFirst && i !== high) {
                type = 0;
              }

              if (!(i === high && ignoreLast)) {
                // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.
                indexes[newPct.toFixed(5)] = [i, type];
              } // Update the percentage count.


              prevPct = newPct;
            }
          });
          return indexes;
        }

        function addMarking(spread, filterFunc, formatter) {
          var _a, _b;

          var element = scope_Document.createElement("div");
          var valueSizeClasses = (_a = {}, _a[exports.PipsType.None] = "", _a[exports.PipsType.NoValue] = options.cssClasses.valueNormal, _a[exports.PipsType.LargeValue] = options.cssClasses.valueLarge, _a[exports.PipsType.SmallValue] = options.cssClasses.valueSub, _a);
          var markerSizeClasses = (_b = {}, _b[exports.PipsType.None] = "", _b[exports.PipsType.NoValue] = options.cssClasses.markerNormal, _b[exports.PipsType.LargeValue] = options.cssClasses.markerLarge, _b[exports.PipsType.SmallValue] = options.cssClasses.markerSub, _b);
          var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
          var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
          addClass(element, options.cssClasses.pips);
          addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);

          function getClasses(type, source) {
            var a = source === options.cssClasses.value;
            var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
            var sizeClasses = a ? valueSizeClasses : markerSizeClasses;
            return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
          }

          function addSpread(offset, value, type) {
            // Apply the filter function, if it is set.
            type = filterFunc ? filterFunc(value, type) : type;

            if (type === exports.PipsType.None) {
              return;
            } // Add a marker for every point


            var node = addNodeTo(element, false);
            node.className = getClasses(type, options.cssClasses.marker);
            node.style[options.style] = offset + "%"; // Values are only appended for points marked '1' or '2'.

            if (type > exports.PipsType.NoValue) {
              node = addNodeTo(element, false);
              node.className = getClasses(type, options.cssClasses.value);
              node.setAttribute("data-value", String(value));
              node.style[options.style] = offset + "%";
              node.innerHTML = String(formatter.to(value));
            }
          } // Append all points.


          Object.keys(spread).forEach(function (offset) {
            addSpread(offset, spread[offset][0], spread[offset][1]);
          });
          return element;
        }

        function removePips() {
          if (scope_Pips) {
            removeElement(scope_Pips);
            scope_Pips = null;
          }
        }

        function pips(pips) {
          // Fix #669
          removePips();
          var spread = generateSpread(pips);
          var filter = pips.filter;
          var format = pips.format || {
            to: function (value) {
              return String(Math.round(value));
            }
          };
          scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));
          return scope_Pips;
        } // Shorthand for base dimensions.


        function baseSize() {
          var rect = scope_Base.getBoundingClientRect();
          var alt = "offset" + ["Width", "Height"][options.ort];
          return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
        } // Handler for attaching events trough a proxy.


        function attachEvent(events, element, callback, data) {
          // This function can be used to 'filter' events to the slider.
          // element is a node, not a nodeList
          var method = function (event) {
            var e = fixEvent(event, data.pageOffset, data.target || element); // fixEvent returns false if this event has a different target
            // when handling (multi-) touch events;

            if (!e) {
              return false;
            } // doNotReject is passed by all end events to make sure released touches
            // are not rejected, leaving the slider "stuck" to the cursor;


            if (isSliderDisabled() && !data.doNotReject) {
              return false;
            } // Stop if an active 'tap' transition is taking place.


            if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
              return false;
            } // Ignore right or middle clicks on start #454


            if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {
              return false;
            } // Ignore right or middle clicks on start #454


            if (data.hover && e.buttons) {
              return false;
            } // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.
            // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support
            // touch-action: manipulation, but that allows panning, which breaks
            // sliders after zooming/on non-responsive pages.
            // See: https://bugs.webkit.org/show_bug.cgi?id=133112


            if (!supportsPassive) {
              e.preventDefault();
            }

            e.calcPoint = e.points[options.ort]; // Call the event handler with the event [ and additional data ].

            callback(e, data);
            return;
          };

          var methods = []; // Bind a closure on the target for every event type.

          events.split(" ").forEach(function (eventName) {
            element.addEventListener(eventName, method, supportsPassive ? {
              passive: true
            } : false);
            methods.push([eventName, method]);
          });
          return methods;
        } // Provide a clean event with standardized offset values.


        function fixEvent(e, pageOffset, eventTarget) {
          // Filter the event to register the type, which can be
          // touch, mouse or pointer. Offset changes need to be
          // made on an event specific basis.
          var touch = e.type.indexOf("touch") === 0;
          var mouse = e.type.indexOf("mouse") === 0;
          var pointer = e.type.indexOf("pointer") === 0;
          var x = 0;
          var y = 0; // IE10 implemented pointer events with a prefix;

          if (e.type.indexOf("MSPointer") === 0) {
            pointer = true;
          } // Erroneous events seem to be passed in occasionally on iOS/iPadOS after user finishes interacting with
          // the slider. They appear to be of type MouseEvent, yet they don't have usual properties set. Ignore
          // events that have no touches or buttons associated with them. (#1057, #1079, #1095)


          if (e.type === "mousedown" && !e.buttons && !e.touches) {
            return false;
          } // The only thing one handle should be concerned about is the touches that originated on top of it.


          if (touch) {
            // Returns true if a touch originated on the target.
            var isTouchOnTarget = function (checkTouch) {
              var target = checkTouch.target;
              return target === eventTarget || eventTarget.contains(target) || e.composed && e.composedPath().shift() === eventTarget;
            }; // In the case of touchstart events, we need to make sure there is still no more than one
            // touch on the target so we look amongst all touches.


            if (e.type === "touchstart") {
              var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget); // Do not support more than one touch per handle.

              if (targetTouches.length > 1) {
                return false;
              }

              x = targetTouches[0].pageX;
              y = targetTouches[0].pageY;
            } else {
              // In the other cases, find on changedTouches is enough.
              var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget); // Cancel if the target touch has not moved.

              if (!targetTouch) {
                return false;
              }

              x = targetTouch.pageX;
              y = targetTouch.pageY;
            }
          }

          pageOffset = pageOffset || getPageOffset(scope_Document);

          if (mouse || pointer) {
            x = e.clientX + pageOffset.x;
            y = e.clientY + pageOffset.y;
          }

          e.pageOffset = pageOffset;
          e.points = [x, y];
          e.cursor = mouse || pointer; // Fix #435

          return e;
        } // Translate a coordinate in the document to a percentage on the slider


        function calcPointToPercentage(calcPoint) {
          var location = calcPoint - offset(scope_Base, options.ort);
          var proposal = location * 100 / baseSize(); // Clamp proposal between 0% and 100%
          // Out-of-bound coordinates may occur when .noUi-base pseudo-elements
          // are used (e.g. contained handles feature)

          proposal = limit(proposal);
          return options.dir ? 100 - proposal : proposal;
        } // Find handle closest to a certain percentage on the slider


        function getClosestHandle(clickedPosition) {
          var smallestDifference = 100;
          var handleNumber = false;
          scope_Handles.forEach(function (handle, index) {
            // Disabled handles are ignored
            if (isHandleDisabled(index)) {
              return;
            }

            var handlePosition = scope_Locations[index];
            var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition); // Initial state

            var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100; // Difference with this handle is smaller than the previously checked handle

            var isCloser = differenceWithThisHandle < smallestDifference;
            var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;

            if (isCloser || isCloserAfter || clickAtEdge) {
              handleNumber = index;
              smallestDifference = differenceWithThisHandle;
            }
          });
          return handleNumber;
        } // Fire 'end' when a mouse or pen leaves the document.


        function documentLeave(event, data) {
          if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
            eventEnd(event, data);
          }
        } // Handle movement on document for handle and range drag.


        function eventMove(event, data) {
          // Fix #498
          // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).
          // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero
          // IE9 has .buttons and .which zero on mousemove.
          // Firefox breaks the spec MDN defines.
          if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
            return eventEnd(event, data);
          } // Check if we are moving up or down


          var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint); // Convert the movement into a percentage of the slider width/height

          var proposal = movement * 100 / data.baseSize;
          moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
        } // Unbind move events on document, call callbacks.


        function eventEnd(event, data) {
          // The handle is no longer active, so remove the class.
          if (data.handle) {
            removeClass(data.handle, options.cssClasses.active);
            scope_ActiveHandlesCount -= 1;
          } // Unbind the move and end events, which are added on 'start'.


          data.listeners.forEach(function (c) {
            scope_DocumentElement.removeEventListener(c[0], c[1]);
          });

          if (scope_ActiveHandlesCount === 0) {
            // Remove dragging class.
            removeClass(scope_Target, options.cssClasses.drag);
            setZindex(); // Remove cursor styles and text-selection events bound to the body.

            if (event.cursor) {
              scope_Body.style.cursor = "";
              scope_Body.removeEventListener("selectstart", preventDefault);
            }
          }

          if (options.events.smoothSteps) {
            data.handleNumbers.forEach(function (handleNumber) {
              setHandle(handleNumber, scope_Locations[handleNumber], true, true, false, false);
            });
            data.handleNumbers.forEach(function (handleNumber) {
              fireEvent("update", handleNumber);
            });
          }

          data.handleNumbers.forEach(function (handleNumber) {
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);
            fireEvent("end", handleNumber);
          });
        } // Bind move events on document.


        function eventStart(event, data) {
          // Ignore event if any handle is disabled
          if (data.handleNumbers.some(isHandleDisabled)) {
            return;
          }

          var handle;

          if (data.handleNumbers.length === 1) {
            var handleOrigin = scope_Handles[data.handleNumbers[0]];
            handle = handleOrigin.children[0];
            scope_ActiveHandlesCount += 1; // Mark the handle as 'active' so it can be styled.

            addClass(handle, options.cssClasses.active);
          } // A drag should never propagate up to the 'tap' event.


          event.stopPropagation(); // Record the event listeners.

          var listeners = []; // Attach the move and end events.

          var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
            // The event target has changed so we need to propagate the original one so that we keep
            // relying on it to extract target touches.
            target: event.target,
            handle: handle,
            connect: data.connect,
            listeners: listeners,
            startCalcPoint: event.calcPoint,
            baseSize: baseSize(),
            pageOffset: event.pageOffset,
            handleNumbers: data.handleNumbers,
            buttonsProperty: event.buttons,
            locations: scope_Locations.slice()
          });
          var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
            target: event.target,
            handle: handle,
            listeners: listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          });
          var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
            target: event.target,
            handle: handle,
            listeners: listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          }); // We want to make sure we pushed the listeners in the listener list rather than creating
          // a new one as it has already been passed to the event handlers.

          listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent)); // Text selection isn't an issue on touch devices,
          // so adding cursor styles can be skipped.

          if (event.cursor) {
            // Prevent the 'I' cursor and extend the range-drag cursor.
            scope_Body.style.cursor = getComputedStyle(event.target).cursor; // Mark the target with a dragging state.

            if (scope_Handles.length > 1) {
              addClass(scope_Target, options.cssClasses.drag);
            } // Prevent text selection when dragging the handles.
            // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,
            // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,
            // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.
            // The 'cursor' flag is false.
            // See: http://caniuse.com/#search=selectstart


            scope_Body.addEventListener("selectstart", preventDefault, false);
          }

          data.handleNumbers.forEach(function (handleNumber) {
            fireEvent("start", handleNumber);
          });
        } // Move closest handle to tapped location.


        function eventTap(event) {
          // The tap event shouldn't propagate up
          event.stopPropagation();
          var proposal = calcPointToPercentage(event.calcPoint);
          var handleNumber = getClosestHandle(proposal); // Tackle the case that all handles are 'disabled'.

          if (handleNumber === false) {
            return;
          } // Flag the slider as it is now in a transitional state.
          // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.


          if (!options.events.snap) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          }

          setHandle(handleNumber, proposal, true, true);
          setZindex();
          fireEvent("slide", handleNumber, true);
          fireEvent("update", handleNumber, true);

          if (!options.events.snap) {
            fireEvent("change", handleNumber, true);
            fireEvent("set", handleNumber, true);
          } else {
            eventStart(event, {
              handleNumbers: [handleNumber]
            });
          }
        } // Fires a 'hover' event for a hovered mouse/pen position.


        function eventHover(event) {
          var proposal = calcPointToPercentage(event.calcPoint);
          var to = scope_Spectrum.getStep(proposal);
          var value = scope_Spectrum.fromStepping(to);
          Object.keys(scope_Events).forEach(function (targetEvent) {
            if ("hover" === targetEvent.split(".")[0]) {
              scope_Events[targetEvent].forEach(function (callback) {
                callback.call(scope_Self, value);
              });
            }
          });
        } // Handles keydown on focused handles
        // Don't move the document when pressing arrow keys on focused handles


        function eventKeydown(event, handleNumber) {
          if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
            return false;
          }

          var horizontalKeys = ["Left", "Right"];
          var verticalKeys = ["Down", "Up"];
          var largeStepKeys = ["PageDown", "PageUp"];
          var edgeKeys = ["Home", "End"];

          if (options.dir && !options.ort) {
            // On an right-to-left slider, the left and right keys act inverted
            horizontalKeys.reverse();
          } else if (options.ort && !options.dir) {
            // On a top-to-bottom slider, the up and down keys act inverted
            verticalKeys.reverse();
            largeStepKeys.reverse();
          } // Strip "Arrow" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key


          var key = event.key.replace("Arrow", "");
          var isLargeDown = key === largeStepKeys[0];
          var isLargeUp = key === largeStepKeys[1];
          var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
          var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
          var isMin = key === edgeKeys[0];
          var isMax = key === edgeKeys[1];

          if (!isDown && !isUp && !isMin && !isMax) {
            return true;
          }

          event.preventDefault();
          var to;

          if (isUp || isDown) {
            var direction = isDown ? 0 : 1;
            var steps = getNextStepsForHandle(handleNumber);
            var step = steps[direction]; // At the edge of a slider, do nothing

            if (step === null) {
              return false;
            } // No step set, use the default of 10% of the sub-range


            if (step === false) {
              step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
            }

            if (isLargeUp || isLargeDown) {
              step *= options.keyboardPageMultiplier;
            } else {
              step *= options.keyboardMultiplier;
            } // Step over zero-length ranges (#948);


            step = Math.max(step, 0.0000001); // Decrement for down steps

            step = (isDown ? -1 : 1) * step;
            to = scope_Values[handleNumber] + step;
          } else if (isMax) {
            // End key
            to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
          } else {
            // Home key
            to = options.spectrum.xVal[0];
          }

          setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
          fireEvent("slide", handleNumber);
          fireEvent("update", handleNumber);
          fireEvent("change", handleNumber);
          fireEvent("set", handleNumber);
          return false;
        } // Attach events to several slider parts.


        function bindSliderEvents(behaviour) {
          // Attach the standard drag event to the handles.
          if (!behaviour.fixed) {
            scope_Handles.forEach(function (handle, index) {
              // These events are only bound to the visual handle
              // element, not the 'real' origin element.
              attachEvent(actions.start, handle.children[0], eventStart, {
                handleNumbers: [index]
              });
            });
          } // Attach the tap event to the slider base.


          if (behaviour.tap) {
            attachEvent(actions.start, scope_Base, eventTap, {});
          } // Fire hover events


          if (behaviour.hover) {
            attachEvent(actions.move, scope_Base, eventHover, {
              hover: true
            });
          } // Make the range draggable.


          if (behaviour.drag) {
            scope_Connects.forEach(function (connect, index) {
              if (connect === false || index === 0 || index === scope_Connects.length - 1) {
                return;
              }

              var handleBefore = scope_Handles[index - 1];
              var handleAfter = scope_Handles[index];
              var eventHolders = [connect];
              var handlesToDrag = [handleBefore, handleAfter];
              var handleNumbersToDrag = [index - 1, index];
              addClass(connect, options.cssClasses.draggable); // When the range is fixed, the entire range can
              // be dragged by the handles. The handle in the first
              // origin will propagate the start event upward,
              // but it needs to be bound manually on the other.

              if (behaviour.fixed) {
                eventHolders.push(handleBefore.children[0]);
                eventHolders.push(handleAfter.children[0]);
              }

              if (behaviour.dragAll) {
                handlesToDrag = scope_Handles;
                handleNumbersToDrag = scope_HandleNumbers;
              }

              eventHolders.forEach(function (eventHolder) {
                attachEvent(actions.start, eventHolder, eventStart, {
                  handles: handlesToDrag,
                  handleNumbers: handleNumbersToDrag,
                  connect: connect
                });
              });
            });
          }
        } // Attach an event to this slider, possibly including a namespace


        function bindEvent(namespacedEvent, callback) {
          scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
          scope_Events[namespacedEvent].push(callback); // If the event bound is 'update,' fire it immediately for all handles.

          if (namespacedEvent.split(".")[0] === "update") {
            scope_Handles.forEach(function (a, index) {
              fireEvent("update", index);
            });
          }
        }

        function isInternalNamespace(namespace) {
          return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
        } // Undo attachment of event


        function removeEvent(namespacedEvent) {
          var event = namespacedEvent && namespacedEvent.split(".")[0];
          var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
          Object.keys(scope_Events).forEach(function (bind) {
            var tEvent = bind.split(".")[0];
            var tNamespace = bind.substring(tEvent.length);

            if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
              // only delete protected internal event if intentional
              if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                delete scope_Events[bind];
              }
            }
          });
        } // External event handling


        function fireEvent(eventName, handleNumber, tap) {
          Object.keys(scope_Events).forEach(function (targetEvent) {
            var eventType = targetEvent.split(".")[0];

            if (eventName === eventType) {
              scope_Events[targetEvent].forEach(function (callback) {
                callback.call( // Use the slider public API as the scope ('this')
                scope_Self, // Return values as array, so arg_1[arg_2] is always valid.
                scope_Values.map(options.format.to), // Handle index, 0 or 1
                handleNumber, // Un-formatted slider values
                scope_Values.slice(), // Event is fired by tap, true or false
                tap || false, // Left offset of the handle, in relation to the slider
                scope_Locations.slice(), // add the slider public API to an accessible parameter when this is unavailable
                scope_Self);
              });
            }
          });
        } // Split out the handle positioning logic so the Move event can use it, too


        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue, smoothSteps) {
          var distance; // For sliders with multiple handles, limit movement to the other handle.
          // Apply the margin option by adding it to the handle positions.

          if (scope_Handles.length > 1 && !options.events.unconstrained) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
              to = Math.max(to, distance);
            }

            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
              to = Math.min(to, distance);
            }
          } // The limit option has the opposite effect, limiting handles to a
          // maximum distance from another. Limit must be > 0, as otherwise
          // handles would be unmovable.


          if (scope_Handles.length > 1 && options.limit) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
              to = Math.min(to, distance);
            }

            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
              to = Math.max(to, distance);
            }
          } // The padding option keeps the handles a certain distance from the
          // edges of the slider. Padding must be > 0.


          if (options.padding) {
            if (handleNumber === 0) {
              distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
              to = Math.max(to, distance);
            }

            if (handleNumber === scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
              to = Math.min(to, distance);
            }
          }

          if (!smoothSteps) {
            to = scope_Spectrum.getStep(to);
          } // Limit percentage to the 0 - 100 range


          to = limit(to); // Return false if handle can't move

          if (to === reference[handleNumber] && !getValue) {
            return false;
          }

          return to;
        } // Uses slider orientation to create CSS rules. a = base value;


        function inRuleOrder(v, a) {
          var o = options.ort;
          return (o ? a : v) + ", " + (o ? v : a);
        } // Moves handle(s) by a percentage
        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])


        function moveHandles(upward, proposal, locations, handleNumbers, connect) {
          var proposals = locations.slice(); // Store first handle now, so we still have it in case handleNumbers is reversed

          var firstHandle = handleNumbers[0];
          var smoothSteps = options.events.smoothSteps;
          var b = [!upward, upward];
          var f = [upward, !upward]; // Copy handleNumbers so we don't change the dataset

          handleNumbers = handleNumbers.slice(); // Check to see which handle is 'leading'.
          // If that one can't move the second can't either.

          if (upward) {
            handleNumbers.reverse();
          } // Step 1: get the maximum percentage that any of the handles can move


          if (handleNumbers.length > 1) {
            handleNumbers.forEach(function (handleNumber, o) {
              var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false, smoothSteps); // Stop if one of the handles can't move.

              if (to === false) {
                proposal = 0;
              } else {
                proposal = to - proposals[handleNumber];
                proposals[handleNumber] = to;
              }
            });
          } // If using one handle, check backward AND forward
          else {
            b = f = [true];
          }

          var state = false; // Step 2: Try to set the handles with the found percentage

          handleNumbers.forEach(function (handleNumber, o) {
            state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o], false, smoothSteps) || state;
          }); // Step 3: If a handle moved, fire events

          if (state) {
            handleNumbers.forEach(function (handleNumber) {
              fireEvent("update", handleNumber);
              fireEvent("slide", handleNumber);
            }); // If target is a connect, then fire drag event

            if (connect != undefined) {
              fireEvent("drag", firstHandle);
            }
          }
        } // Takes a base value and an offset. This offset is used for the connect bar size.
        // In the initial design for this feature, the origin element was 1% wide.
        // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature
        // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223


        function transformDirection(a, b) {
          return options.dir ? 100 - a - b : a;
        } // Updates scope_Locations and scope_Values, updates visual state


        function updateHandlePosition(handleNumber, to) {
          // Update locations.
          scope_Locations[handleNumber] = to; // Convert the value to the slider stepping/range.

          scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
          var translation = transformDirection(to, 0) - scope_DirOffset;
          var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
          scope_Handles[handleNumber].style[options.transformRule] = translateRule;
          updateConnect(handleNumber);
          updateConnect(handleNumber + 1);
        } // Handles before the slider middle are stacked later = higher,
        // Handles after the middle later is lower
        // [[7] [8] .......... | .......... [5] [4]


        function setZindex() {
          scope_HandleNumbers.forEach(function (handleNumber) {
            var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
            var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
            scope_Handles[handleNumber].style.zIndex = String(zIndex);
          });
        } // Test suggested values and apply margin, step.
        // if exactInput is true, don't run checkHandlePosition, then the handle can be placed in between steps (#436)


        function setHandle(handleNumber, to, lookBackward, lookForward, exactInput, smoothSteps) {
          if (!exactInput) {
            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false, smoothSteps);
          }

          if (to === false) {
            return false;
          }

          updateHandlePosition(handleNumber, to);
          return true;
        } // Updates style attribute for connect nodes


        function updateConnect(index) {
          // Skip connects set to false
          if (!scope_Connects[index]) {
            return;
          }

          var l = 0;
          var h = 100;

          if (index !== 0) {
            l = scope_Locations[index - 1];
          }

          if (index !== scope_Connects.length - 1) {
            h = scope_Locations[index];
          } // We use two rules:
          // 'translate' to change the left/top offset;
          // 'scale' to change the width of the element;
          // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)


          var connectWidth = h - l;
          var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
          var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
          scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;
        } // Parses value passed to .set method. Returns current value if not parse-able.


        function resolveToValue(to, handleNumber) {
          // Setting with null indicates an 'ignore'.
          // Inputting 'false' is invalid.
          if (to === null || to === false || to === undefined) {
            return scope_Locations[handleNumber];
          } // If a formatted number was passed, attempt to decode it.


          if (typeof to === "number") {
            to = String(to);
          }

          to = options.format.from(to);

          if (to !== false) {
            to = scope_Spectrum.toStepping(to);
          } // If parsing the number failed, use the current value.


          if (to === false || isNaN(to)) {
            return scope_Locations[handleNumber];
          }

          return to;
        } // Set the slider value.


        function valueSet(input, fireSetEvent, exactInput) {
          var values = asArray(input);
          var isInit = scope_Locations[0] === undefined; // Event fires by default

          fireSetEvent = fireSetEvent === undefined ? true : fireSetEvent; // Animation is optional.
          // Make sure the initial values were set before using animated placement.

          if (options.animate && !isInit) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          } // First pass, without lookAhead but with lookBackward. Values are set from left to right.


          scope_HandleNumbers.forEach(function (handleNumber) {
            setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);
          });
          var i = scope_HandleNumbers.length === 1 ? 0 : 1; // Spread handles evenly across the slider if the range has no size (min=max)

          if (isInit && scope_Spectrum.hasNoSize()) {
            exactInput = true;
            scope_Locations[0] = 0;

            if (scope_HandleNumbers.length > 1) {
              var space_1 = 100 / (scope_HandleNumbers.length - 1);
              scope_HandleNumbers.forEach(function (handleNumber) {
                scope_Locations[handleNumber] = handleNumber * space_1;
              });
            }
          } // Secondary passes. Now that all base values are set, apply constraints.
          // Iterate all handles to ensure constraints are applied for the entire slider (Issue #1009)


          for (; i < scope_HandleNumbers.length; ++i) {
            scope_HandleNumbers.forEach(function (handleNumber) {
              setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
            });
          }

          setZindex();
          scope_HandleNumbers.forEach(function (handleNumber) {
            fireEvent("update", handleNumber); // Fire the event only for handles that received a new value, as per #579

            if (values[handleNumber] !== null && fireSetEvent) {
              fireEvent("set", handleNumber);
            }
          });
        } // Reset slider to initial values


        function valueReset(fireSetEvent) {
          valueSet(options.start, fireSetEvent);
        } // Set value for a single handle


        function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
          // Ensure numeric input
          handleNumber = Number(handleNumber);

          if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
            throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
          } // Look both backward and forward, since we don't want this handle to "push" other handles (#960);
          // The exactInput argument can be used to ignore slider stepping (#436)


          setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
          fireEvent("update", handleNumber);

          if (fireSetEvent) {
            fireEvent("set", handleNumber);
          }
        } // Get the slider value.


        function valueGet(unencoded) {
          if (unencoded === void 0) {
            unencoded = false;
          }

          if (unencoded) {
            // return a copy of the raw values
            return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
          }

          var values = scope_Values.map(options.format.to); // If only one handle is used, return a single value.

          if (values.length === 1) {
            return values[0];
          }

          return values;
        } // Removes classes from the root and empties it.


        function destroy() {
          // remove protected internal listeners
          removeEvent(INTERNAL_EVENT_NS.aria);
          removeEvent(INTERNAL_EVENT_NS.tooltips);
          Object.keys(options.cssClasses).forEach(function (key) {
            removeClass(scope_Target, options.cssClasses[key]);
          });

          while (scope_Target.firstChild) {
            scope_Target.removeChild(scope_Target.firstChild);
          }

          delete scope_Target.noUiSlider;
        }

        function getNextStepsForHandle(handleNumber) {
          var location = scope_Locations[handleNumber];
          var nearbySteps = scope_Spectrum.getNearbySteps(location);
          var value = scope_Values[handleNumber];
          var increment = nearbySteps.thisStep.step;
          var decrement = null; // If snapped, directly use defined step value

          if (options.snap) {
            return [value - nearbySteps.stepBefore.startValue || null, nearbySteps.stepAfter.startValue - value || null];
          } // If the next value in this step moves into the next step,
          // the increment is the start of the next step - the current value


          if (increment !== false) {
            if (value + increment > nearbySteps.stepAfter.startValue) {
              increment = nearbySteps.stepAfter.startValue - value;
            }
          } // If the value is beyond the starting point


          if (value > nearbySteps.thisStep.startValue) {
            decrement = nearbySteps.thisStep.step;
          } else if (nearbySteps.stepBefore.step === false) {
            decrement = false;
          } // If a handle is at the start of a step, it always steps back into the previous step first
          else {
            decrement = value - nearbySteps.stepBefore.highestStep;
          } // Now, if at the slider edges, there is no in/decrement


          if (location === 100) {
            increment = null;
          } else if (location === 0) {
            decrement = null;
          } // As per #391, the comparison for the decrement step can have some rounding issues.


          var stepDecimals = scope_Spectrum.countStepDecimals(); // Round per #391

          if (increment !== null && increment !== false) {
            increment = Number(increment.toFixed(stepDecimals));
          }

          if (decrement !== null && decrement !== false) {
            decrement = Number(decrement.toFixed(stepDecimals));
          }

          return [decrement, increment];
        } // Get the current step size for the slider.


        function getNextSteps() {
          return scope_HandleNumbers.map(getNextStepsForHandle);
        } // Updatable: margin, limit, padding, step, range, animate, snap


        function updateOptions(optionsToUpdate, fireSetEvent) {
          // Spectrum is created using the range, snap, direction and step options.
          // 'snap' and 'step' can be updated.
          // If 'snap' and 'step' are not passed, they should remain unchanged.
          var v = valueGet();
          var updateAble = ["margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips"]; // Only change options that we're actually passed to update.

          updateAble.forEach(function (name) {
            // Check for undefined. null removes the value.
            if (optionsToUpdate[name] !== undefined) {
              originalOptions[name] = optionsToUpdate[name];
            }
          });
          var newOptions = testOptions(originalOptions); // Load new options into the slider state

          updateAble.forEach(function (name) {
            if (optionsToUpdate[name] !== undefined) {
              options[name] = newOptions[name];
            }
          });
          scope_Spectrum = newOptions.spectrum; // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)

          options.margin = newOptions.margin;
          options.limit = newOptions.limit;
          options.padding = newOptions.padding; // Update pips, removes existing.

          if (options.pips) {
            pips(options.pips);
          } else {
            removePips();
          } // Update tooltips, removes existing.


          if (options.tooltips) {
            tooltips();
          } else {
            removeTooltips();
          } // Invalidate the current positioning so valueSet forces an update.


          scope_Locations = [];
          valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);
        } // Initialization steps


        function setupSlider() {
          // Create the base element, initialize HTML and set classes.
          // Add handles and connect elements.
          scope_Base = addSlider(scope_Target);
          addElements(options.connect, scope_Base); // Attach user events.

          bindSliderEvents(options.events); // Use the public value method to set the start values.

          valueSet(options.start);

          if (options.pips) {
            pips(options.pips);
          }

          if (options.tooltips) {
            tooltips();
          }

          aria();
        }

        setupSlider();
        var scope_Self = {
          destroy: destroy,
          steps: getNextSteps,
          on: bindEvent,
          off: removeEvent,
          get: valueGet,
          set: valueSet,
          setHandle: valueSetHandle,
          reset: valueReset,
          // Exposed for unit testing, don't use this in your application.
          __moveHandles: function (upward, proposal, handleNumbers) {
            moveHandles(upward, proposal, scope_Locations, handleNumbers);
          },
          options: originalOptions,
          updateOptions: updateOptions,
          target: scope_Target,
          removePips: removePips,
          removeTooltips: removeTooltips,
          getPositions: function () {
            return scope_Locations.slice();
          },
          getTooltips: function () {
            return scope_Tooltips;
          },
          getOrigins: function () {
            return scope_Handles;
          },
          pips: pips // Issue #594

        };
        return scope_Self;
      } // Run the standard initializer


      function initialize(target, originalOptions) {
        if (!target || !target.nodeName) {
          throw new Error("noUiSlider: create requires a single element, got: " + target);
        } // Throw an error if the slider was already initialized.


        if (target.noUiSlider) {
          throw new Error("noUiSlider: Slider was already initialized.");
        } // Test the options and create the slider environment;


        var options = testOptions(originalOptions);
        var api = scope(target, options, originalOptions);
        target.noUiSlider = api;
        return api;
      }

      var nouislider = {
        // Exposed for unit testing, don't use this in your application.
        __spectrum: Spectrum,
        // A reference to the default classes, allows global changes.
        // Use the cssClasses option for changes to one slider.
        cssClasses: cssClasses,
        create: initialize
      };
      exports.create = initialize;
      exports.cssClasses = cssClasses;
      exports["default"] = nouislider;
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
    });
    });

    var noUiSlider = unwrapExports(nouislider);

    /**
     * import main Fashion Slider function
     */

    /*end of inludes*/

    document.addEventListener("DOMContentLoaded", ready);

    function ready() {
      /**
       * Fashion Slider element
       */
      const sliderEl = document.querySelector('.fashion-slider');
      /**
       * Init Fashion Slider
       *
       * argument: pass .fashion-slider element
       */

      createFashionSlider(sliderEl); // =======================

      let burgerBtns = [...document.querySelectorAll(".burger")];
      let body = document.querySelector("body");
      let html = document.querySelector("html");

      for (const burgerBtn of burgerBtns) {
        burgerBtn.addEventListener("click", function () {
          body.classList.toggle("active");
          html.classList.toggle("active");
        });
      }

      if (document.querySelector('.prise-slider')) {
        let sliderPrise = new Swiper(".prise-slider", {
          modules: [Navigation, Autoplay],
          watchOverflow: true,
          speed: 800,
          observer: true,
          observeParents: true,
          observeSlideChildren: true,
          grabCursor: true,
          navigation: {
            nextEl: ".plans-navigation .button-next",
            prevEl: ".plans-navigation .button-prev"
          },
          autoplay: {
            delay: 2500,
            disableOnInteraction: false
          },
          on: {
            init() {
              this.el.addEventListener('mouseenter', () => {
                this.autoplay.stop();
              });
              this.el.addEventListener('mouseleave', () => {
                this.autoplay.start();
              });
            }

          },
          breakpoints: {
            320: {
              slidesPerView: 1.35,
              spaceBetween: 15,
              centeredSlides: true,
              loop: true
            },
            639: {
              slidesPerView: 1,
              spaceBetween: 15,
              centeredSlides: true,
              loop: true
            },
            768: {
              slidesPerView: 1,
              spaceBetween: 30,
              centeredSlides: false,
              loop: true
            },
            1024: {
              slidesPerView: 2,
              spaceBetween: 30,
              centeredSlides: false,
              loop: false
            },
            1280: {
              slidesPerView: 3,
              spaceBetween: 30
            }
          }
        });
      }

      if (document.querySelector('.reviews-slider')) {
        let sliderReview = new Swiper(".reviews-slider", {
          modules: [Navigation, Autoplay],
          watchOverflow: true,
          speed: 800,
          observer: true,
          observeParents: true,
          observeSlideChildren: true,
          grabCursor: true,
          navigation: {
            nextEl: ".reviews-navigation .button-next",
            prevEl: ".reviews-navigation .button-prev"
          },
          autoplay: {
            delay: 2500,
            disableOnInteraction: false
          },
          on: {
            init() {
              this.el.addEventListener('mouseenter', () => {
                this.autoplay.stop();
              });
              this.el.addEventListener('mouseleave', () => {
                this.autoplay.start();
              });
            }

          },
          breakpoints: {
            320: {
              slidesPerView: 1.35,
              spaceBetween: 15,
              centeredSlides: true,
              loop: true
            },
            639: {
              slidesPerView: 2,
              spaceBetween: 15,
              centeredSlides: false,
              loop: true
            },
            1024: {
              slidesPerView: 3,
              spaceBetween: 30,
              centeredSlides: false,
              loop: false
            },
            1280: {
              slidesPerView: 3,
              spaceBetween: 60
            }
          }
        });
      }

      if (document.querySelector('.page-swiper')) {
        let pageSwiper = new Swiper(".page-swiper", {
          modules: [Pagination, Scrollbar, freeMode, Mousewheel],
          wrapperClass: "page__wrapper",
          slideClass: "page__screen",
          direction: 'vertical',
          slidesPerView: 'auto',
          mousewheel: {
            sensitiviti: 1
          },
          init: false,
          watchOverflow: true,
          speed: 800,
          observer: true,
          observeParents: true,
          observeSlideChildren: true,
          on: {
            init: function () {
              setScrollType();
              screenContentPagging();
              hideToTopBtn();
            },
            resize: function () {
              setScrollType();
              screenContentPagging();
              setWidthPage();
            },
            afterInit: function () {
              hideToTopBtn();
            }
          },
          scrollbar: {
            el: '.page__scroll',
            dragClass: 'page__drag-scroll',
            draggable: true
          }
        });
        pageSwiper.init();

        function setScrollType() {
          let wrapper = document.querySelector('.page__wrapper');
          let page = document.querySelector('main.page');

          if (wrapper.classList.contains('_free')) {
            wrapper.classList.remove('_free');
            page.classList.remove('_free');
            pageSwiper.params.freeMode.enabled = false;
          }

          for (let index = 0; index < pageSwiper.slides.length; index++) {
            const pageSlide = pageSwiper.slides[index];
            const pageSlideContent = pageSlide.querySelector('.screen__content');

            if (pageSlideContent) {
              const pageSlideContentHeight = pageSlideContent.offsetHeight;

              if (pageSlideContentHeight > window.innerHeight) {
                console.log(pageSlideContentHeight);
                console.log(pageSlideContent);
                wrapper.classList.add('_free');
                page.classList.add('_free');
                pageSwiper.params.freeMode.enabled = true;
                break;
              }
            }

            if (window.innerWidth > 1920 || window.innerHeight <= 767) {
              wrapper.classList.add('_free');
              page.classList.add('_free');
              pageSwiper.params.freeMode.enabled = true;
            }
          }
        }

        function setWidthPage() {
          let windowWidth = window.innerWidth;

          if (windowWidth < 1280) {
            pageSwiper.destroy();
          } else {
            pageSwiper.init();
          }
        }

        function screenContentPagging() {
          let wrapper = document.querySelector('.page__wrapper');
          let header = document.querySelector('header');
          let screenContents = document.querySelectorAll('.screen__content');
          let headerHeight = header.clientHeight;

          for (const screenContent of screenContents) {
            if (!wrapper.classList.contains('_free')) {
              screenContent.style.paddingTop = headerHeight + 'px';
            } else {
              screenContent.style.paddingTop = '0px';
            }
          }
        }

        let toTopPage = document.querySelector('.to-top-page');

        if (toTopPage) {
          toTopPage.addEventListener('click', e => {
            pageSwiper.slideTo(0, 800);

            if (window.innerWidth < 1279) {
              let body = 'body';
              scrollToBlock(e, body);
            }
          });
        }

        pageSwiper.on('slideChange', function () {
          hideToTopBtn();
        });
        window.addEventListener('scroll', e => {
          hideToTopBtn();
        });

        function hideToTopBtn() {
          let activeIndexSlide = pageSwiper.activeIndex;

          if (activeIndexSlide === 0) {
            let toTopPage = document.querySelector('.to-top-page');
            toTopPage.style.display = 'none';
          } else {
            toTopPage.style.display = 'flex';
          }
        }
      } // scroll rio


      let toTopPage = document.querySelector('.to-top-page');

      if (toTopPage && !document.querySelector('.page-swiper')) {
        toTopPage.addEventListener('click', e => {
          let body = 'body';
          scrollToBlock(e, body);
        });
      }

      function scrollToBlock(e, id) {
        e.preventDefault();
        document.getElementById(id).scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });
      } // scroll rio end


      var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);

      if (isIOS) {
        let videos = document.querySelectorAll('.video');
        videos.forEach(e => {
          var canvasVideo = new CanvasVideoPlayer({
            videoSelector: '#' + e.getAttribute('id') + ' .video__video',
            canvasSelector: '#' + e.getAttribute('id') + ' .video__canvas',
            timelineSelector: false,
            autoplay: true,
            makeLoop: true,
            pauseOnClick: false,
            audio: false
          });
        });
      } else {
        // Use HTML5 video
        document.querySelectorAll('.video__canvas')[0].style.display = 'none';
      } // screnn process


      let workItems = document.querySelectorAll('.work-items .item');
      let pageScreenProcess = document.querySelector('.page__screen--process');
      let deley = 200;

      if (pageScreenProcess) {
        function animScrenProcess() {
          workItems.forEach(item => {
            item.style.transitionDelay = deley + 'ms';
            deley += 100;

            if (window.innerWidth < 1024) {
              item.style.transitionDelay = 0 + 'ms';
            }
          });
        }

        animScrenProcess();
        window.addEventListener('resize', () => {
          if (window.innerWidth < 1024) {
            let workItems = document.querySelectorAll('.work-items .item');
            workItems.forEach(item => {
              item.style.transitionDelay = 0 + 'ms';
            });
            deley = 200;
          }
        });
        window.addEventListener('scroll', () => {
          if (window.pageYOffset + 100 >= offset(pageScreenProcess)) {
            pageScreenProcess.classList.add('active-anim');
          } else {
            pageScreenProcess.classList.remove('active-anim');
          }
        });

        function offset(el) {
          var rect = el.getBoundingClientRect(),
              scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          return rect.top + scrollTop;
        }
      } // checkbox input


      let inputCheckbox = document.querySelectorAll('[type="checkbox"]');

      for (let i = 0; i < inputCheckbox.length; i++) {
        const element = inputCheckbox[i];
        addClassToLabel(element);
        element.addEventListener('change', e => {
          let targetElement = e.target;
          addClassToLabel(targetElement);
        });
      }

      function addClassToLabel(input) {
        let parentLabel = input.closest('label');

        if (input.checked === true) {
          parentLabel.classList.add('checked');
        } else {
          parentLabel.classList.remove('checked');
        }
      } // checkbox input end
      // required input


      let inputRequired = document.querySelectorAll('.wpcf7-validates-as-required');

      if (inputRequired) {
        for (let i = 0; i < inputRequired.length; i++) {
          const element = inputRequired[i];
          let parentFieldset = element.closest('fieldset');

          if (parentFieldset) {
            parentFieldset.classList.add('required');
          }
        }
      } // required input end
      // range input


      var pipsRange = document.querySelectorAll('#pips-range');

      if (pipsRange) {
        pipsRange.forEach(rangeElement => {
          var range = {
            'min': [1, 1],
            '11.11%': [2, 1],
            '22.22%': [3, 1],
            '33.33%': [4, 1],
            '44.44%': [5, 1],
            '55.55%': [6, 1],
            '66.66%': [7, 1],
            '77.77%': [8, 1],
            '88.88%': [9, 1],
            'max': [10, 1]
          };
          noUiSlider.create(rangeElement, {
            range: range,
            start: 0,
            connect: 'lower',
            step: 1,
            pips: {
              mode: 'range',
              density: 'none'
            }
          });
          rangeElement.noUiSlider.on('update', function (values, handle) {
            let pipsRangeFieldset = rangeElement.closest('fieldset');
            let pipsRangeInput = pipsRangeFieldset.querySelector('#pips-range-input');
            pipsRangeInput.value = Math.round(values[handle]);
          });
        });
      } // range input end


      const spollersArray = document.querySelectorAll('[data-spollers]');

      if (spollersArray.length > 0) {
        // Получение обычных слойлеров
        const spollersRegular = Array.from(spollersArray).filter(function (item, index, self) {
          return !item.dataset.spollers.split(",")[0];
        }); // Инициализация обычных слойлеров

        if (spollersRegular.length > 0) {
          initSpollers(spollersRegular);
        } // Получение слойлеров с медиа запросами


        const spollersMedia = Array.from(spollersArray).filter(function (item, index, self) {
          return item.dataset.spollers.split(",")[0];
        }); // Инициализация слойлеров с медиа запросами

        if (spollersMedia.length > 0) {
          const breakpointsArray = [];
          spollersMedia.forEach(item => {
            const params = item.dataset.spollers;
            const breakpoint = {};
            const paramsArray = params.split(",");
            breakpoint.value = paramsArray[0];
            breakpoint.type = paramsArray[1] ? paramsArray[1].trim() : "max";
            breakpoint.item = item;
            breakpointsArray.push(breakpoint);
          }); // Получаем уникальные брейкпоинты

          let mediaQueries = breakpointsArray.map(function (item) {
            return '(' + item.type + "-width: " + item.value + "px)," + item.value + ',' + item.type;
          });
          mediaQueries = mediaQueries.filter(function (item, index, self) {
            return self.indexOf(item) === index;
          }); // Работаем с каждым брейкпоинтом

          mediaQueries.forEach(breakpoint => {
            const paramsArray = breakpoint.split(",");
            const mediaBreakpoint = paramsArray[1];
            const mediaType = paramsArray[2];
            const matchMedia = window.matchMedia(paramsArray[0]); // Объекты с нужными условиями

            const spollersArray = breakpointsArray.filter(function (item) {
              if (item.value === mediaBreakpoint && item.type === mediaType) {
                return true;
              }
            }); // Событие

            matchMedia.addListener(function () {
              initSpollers(spollersArray, matchMedia);
            });
            initSpollers(spollersArray, matchMedia);
          });
        } // Инициализация


        function initSpollers(spollersArray, matchMedia = false) {
          spollersArray.forEach(spollersBlock => {
            spollersBlock = matchMedia ? spollersBlock.item : spollersBlock;

            if (matchMedia.matches || !matchMedia) {
              spollersBlock.classList.add('_init');
              initSpollerBody(spollersBlock);
              spollersBlock.addEventListener("click", setSpollerAction);
            } else {
              spollersBlock.classList.remove('_init');
              initSpollerBody(spollersBlock, false);
              spollersBlock.removeEventListener("click", setSpollerAction);
            }
          });
        } // Работа с контентом


        function initSpollerBody(spollersBlock, hideSpollerBody = true) {
          const spollerTitles = spollersBlock.querySelectorAll('[data-spoller]');

          if (spollerTitles.length > 0) {
            spollerTitles.forEach(spollerTitle => {
              if (hideSpollerBody) {
                spollerTitle.removeAttribute('tabindex');

                if (!spollerTitle.classList.contains('_active')) {
                  spollerTitle.nextElementSibling.hidden = true;
                }
              } else {
                spollerTitle.setAttribute('tabindex', '-1');
                spollerTitle.nextElementSibling.hidden = false;
              }
            });
          }
        }

        function setSpollerAction(e) {
          const el = e.target;

          if (el.hasAttribute('data-spoller') || el.closest('[data-spoller]')) {
            const spollerTitle = el.hasAttribute('data-spoller') ? el : el.closest('[data-spoller]');
            const spollersBlock = spollerTitle.closest('[data-spollers]');
            const oneSpoller = spollersBlock.hasAttribute('data-one-spoller') ? true : false;

            if (!spollersBlock.querySelectorAll('._slide').length) {
              if (oneSpoller && !spollerTitle.classList.contains('_active')) {
                hideSpollersBody(spollersBlock);
              }

              spollerTitle.classList.toggle('_active');

              _slideToggle(spollerTitle.nextElementSibling, 500);
            }

            e.preventDefault();
          }
        }

        function hideSpollersBody(spollersBlock) {
          const spollerActiveTitle = spollersBlock.querySelector('[data-spoller]._active');

          if (spollerActiveTitle) {
            spollerActiveTitle.classList.remove('_active');

            _slideUp(spollerActiveTitle.nextElementSibling, 500);
          }
        }
      } //========================================================================================================================================================
      //SlideToggle


      let _slideUp = (target, duration = 500) => {
        if (!target.classList.contains('_slide')) {
          target.classList.add('_slide');
          target.style.transitionProperty = 'height, margin, padding';
          target.style.transitionDuration = duration + 'ms';
          target.style.height = target.offsetHeight + 'px';
          target.offsetHeight;
          target.style.overflow = 'hidden';
          target.style.height = 0;
          target.style.paddingTop = 0;
          target.style.paddingBottom = 0;
          target.style.marginTop = 0;
          target.style.marginBottom = 0;
          window.setTimeout(() => {
            target.hidden = true;
            target.style.removeProperty('height');
            target.style.removeProperty('padding-top');
            target.style.removeProperty('padding-bottom');
            target.style.removeProperty('margin-top');
            target.style.removeProperty('margin-bottom');
            target.style.removeProperty('overflow');
            target.style.removeProperty('transition-duration');
            target.style.removeProperty('transition-property');
            target.classList.remove('_slide');
          }, duration);
        }
      };

      let _slideDown = (target, duration = 500) => {
        if (!target.classList.contains('_slide')) {
          target.classList.add('_slide');

          if (target.hidden) {
            target.hidden = false;
          }

          let height = target.offsetHeight;
          target.style.overflow = 'hidden';
          target.style.height = 0;
          target.style.paddingTop = 0;
          target.style.paddingBottom = 0;
          target.style.marginTop = 0;
          target.style.marginBottom = 0;
          target.offsetHeight;
          target.style.transitionProperty = "height, margin, padding";
          target.style.transitionDuration = duration + 'ms';
          target.style.height = height + 'px';
          target.style.removeProperty('padding-top');
          target.style.removeProperty('padding-bottom');
          target.style.removeProperty('margin-top');
          target.style.removeProperty('margin-bottom');
          window.setTimeout(() => {
            target.style.removeProperty('height');
            target.style.removeProperty('overflow');
            target.style.removeProperty('transition-duration');
            target.style.removeProperty('transition-property');
            target.classList.remove('_slide');
          }, duration);
        }
      };

      let _slideToggle = (target, duration = 500) => {
        if (target.hidden) {
          return _slideDown(target, duration);
        } else {
          return _slideUp(target, duration);
        }
      }; //========================================================================================================================================================

      /*
      Для родителя слойлеров пишем атрибут data-spollers
      Для заголовков слойлеров пишем атрибут data-spoller
      Если нужно включать\выключать работу спойлеров на разных размерах экранов
      пишем параметры ширины и типа брейкпоинта.
      Например:
      data-spollers="992,max" - спойлеры будут работать только на экранах меньше или равно 992px
      data-spollers="768,min" - спойлеры будут работать только на экранах больше или равно 768px
      
      Если нужно что бы в блоке открывался болько один слойлер добавляем атрибут data-one-spoller
      */

    }

})));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJtYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnbWFpbicsIGZhY3RvcnkpIDpcbiAgICBmYWN0b3J5KCk7XG59KChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIFNTUiBXaW5kb3cgNC4wLjJcbiAgICAgKiBCZXR0ZXIgaGFuZGxpbmcgZm9yIHdpbmRvdyBvYmplY3QgaW4gU1NSIGVudmlyb25tZW50XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vbGltaXRzNHdlYi9zc3Itd2luZG93XG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgMjAyMSwgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICAgICAqXG4gICAgICogUmVsZWFzZWQgb246IERlY2VtYmVyIDEzLCAyMDIxXG4gICAgICovXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAnY29uc3RydWN0b3InIGluIG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0ID0ge30sIHNyYyA9IHt9KSB7XG4gICAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHRhcmdldFtrZXldID0gc3JjW2tleV07ZWxzZSBpZiAoaXNPYmplY3Qoc3JjW2tleV0pICYmIGlzT2JqZWN0KHRhcmdldFtrZXldKSAmJiBPYmplY3Qua2V5cyhzcmNba2V5XSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGV4dGVuZCh0YXJnZXRba2V5XSwgc3JjW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBzc3JEb2N1bWVudCA9IHtcbiAgICAgIGJvZHk6IHt9LFxuXG4gICAgICBhZGRFdmVudExpc3RlbmVyKCkge30sXG5cbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7fSxcblxuICAgICAgYWN0aXZlRWxlbWVudDoge1xuICAgICAgICBibHVyKCkge30sXG5cbiAgICAgICAgbm9kZU5hbWU6ICcnXG4gICAgICB9LFxuXG4gICAgICBxdWVyeVNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIHF1ZXJ5U2VsZWN0b3JBbGwoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG5cbiAgICAgIGdldEVsZW1lbnRCeUlkKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZUV2ZW50KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluaXRFdmVudCgpIHt9XG5cbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgIHN0eWxlOiB7fSxcblxuICAgICAgICAgIHNldEF0dHJpYnV0ZSgpIHt9LFxuXG4gICAgICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICBjcmVhdGVFbGVtZW50TlMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0sXG5cbiAgICAgIGltcG9ydE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcblxuICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgaGFzaDogJycsXG4gICAgICAgIGhvc3Q6ICcnLFxuICAgICAgICBob3N0bmFtZTogJycsXG4gICAgICAgIGhyZWY6ICcnLFxuICAgICAgICBvcmlnaW46ICcnLFxuICAgICAgICBwYXRobmFtZTogJycsXG4gICAgICAgIHByb3RvY29sOiAnJyxcbiAgICAgICAgc2VhcmNoOiAnJ1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHt9O1xuICAgICAgZXh0ZW5kKGRvYywgc3NyRG9jdW1lbnQpO1xuICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG5cbiAgICBjb25zdCBzc3JXaW5kb3cgPSB7XG4gICAgICBkb2N1bWVudDogc3NyRG9jdW1lbnQsXG4gICAgICBuYXZpZ2F0b3I6IHtcbiAgICAgICAgdXNlckFnZW50OiAnJ1xuICAgICAgfSxcbiAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgIGhhc2g6ICcnLFxuICAgICAgICBob3N0OiAnJyxcbiAgICAgICAgaG9zdG5hbWU6ICcnLFxuICAgICAgICBocmVmOiAnJyxcbiAgICAgICAgb3JpZ2luOiAnJyxcbiAgICAgICAgcGF0aG5hbWU6ICcnLFxuICAgICAgICBwcm90b2NvbDogJycsXG4gICAgICAgIHNlYXJjaDogJydcbiAgICAgIH0sXG4gICAgICBoaXN0b3J5OiB7XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgpIHt9LFxuXG4gICAgICAgIHB1c2hTdGF0ZSgpIHt9LFxuXG4gICAgICAgIGdvKCkge30sXG5cbiAgICAgICAgYmFjaygpIHt9XG5cbiAgICAgIH0sXG4gICAgICBDdXN0b21FdmVudDogZnVuY3Rpb24gQ3VzdG9tRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcigpIHt9LFxuXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKCkge30sXG5cbiAgICAgIGdldENvbXB1dGVkU3R5bGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZ2V0UHJvcGVydHlWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIEltYWdlKCkge30sXG5cbiAgICAgIERhdGUoKSB7fSxcblxuICAgICAgc2NyZWVuOiB7fSxcblxuICAgICAgc2V0VGltZW91dCgpIHt9LFxuXG4gICAgICBjbGVhclRpbWVvdXQoKSB7fSxcblxuICAgICAgbWF0Y2hNZWRpYSgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSxcblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgICAgfSxcblxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93KCkge1xuICAgICAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fTtcbiAgICAgIGV4dGVuZCh3aW4sIHNzcldpbmRvdyk7XG4gICAgICByZXR1cm4gd2luO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvbTcgNC4wLjRcbiAgICAgKiBNaW5pbWFsaXN0aWMgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBET00gbWFuaXB1bGF0aW9uLCB3aXRoIGEgalF1ZXJ5LWNvbXBhdGlibGUgQVBJXG4gICAgICogaHR0cHM6Ly9mcmFtZXdvcms3LmlvL2RvY3MvZG9tNy5odG1sXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgMjAyMiwgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICAgICAqXG4gICAgICogUmVsZWFzZWQgb246IEphbnVhcnkgMTEsIDIwMjJcbiAgICAgKi9cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4gICAgZnVuY3Rpb24gbWFrZVJlYWN0aXZlKG9iaikge1xuICAgICAgY29uc3QgcHJvdG8gPSBvYmouX19wcm90b19fO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ19fcHJvdG9fXycsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICBwcm90by5fX3Byb3RvX18gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGFzcyBEb203IGV4dGVuZHMgQXJyYXkge1xuICAgICAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzdXBlcihpdGVtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VwZXIoLi4uKGl0ZW1zIHx8IFtdKSk7XG4gICAgICAgICAgbWFrZVJlYWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheUZsYXQoYXJyID0gW10pIHtcbiAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgYXJyLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgICAgICByZXMucHVzaCguLi5hcnJheUZsYXQoZWwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMucHVzaChlbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnIsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGFyciwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFycmF5VW5pcXVlKGFycikge1xuICAgICAgY29uc3QgdW5pcXVlQXJyYXkgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHVuaXF1ZUFycmF5LmluZGV4T2YoYXJyW2ldKSA9PT0gLTEpIHVuaXF1ZUFycmF5LnB1c2goYXJyW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuaXF1ZUFycmF5O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcXNhKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gW3NlbGVjdG9yXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgY29uc3QgcmVzID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYS5wdXNoKHJlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgbGV0IGFyciA9IFtdO1xuXG4gICAgICBpZiAoIWNvbnRleHQgJiYgc2VsZWN0b3IgaW5zdGFuY2VvZiBEb203KSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IERvbTcoYXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgaHRtbCA9IHNlbGVjdG9yLnRyaW0oKTtcblxuICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8JykgPj0gMCAmJiBodG1sLmluZGV4T2YoJz4nKSA+PSAwKSB7XG4gICAgICAgICAgbGV0IHRvQ3JlYXRlID0gJ2Rpdic7XG4gICAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPGxpJykgPT09IDApIHRvQ3JlYXRlID0gJ3VsJztcbiAgICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8dHInKSA9PT0gMCkgdG9DcmVhdGUgPSAndGJvZHknO1xuICAgICAgICAgIGlmIChodG1sLmluZGV4T2YoJzx0ZCcpID09PSAwIHx8IGh0bWwuaW5kZXhPZignPHRoJykgPT09IDApIHRvQ3JlYXRlID0gJ3RyJztcbiAgICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8dGJvZHknKSA9PT0gMCkgdG9DcmVhdGUgPSAndGFibGUnO1xuICAgICAgICAgIGlmIChodG1sLmluZGV4T2YoJzxvcHRpb24nKSA9PT0gMCkgdG9DcmVhdGUgPSAnc2VsZWN0JztcbiAgICAgICAgICBjb25zdCB0ZW1wUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0b0NyZWF0ZSk7XG4gICAgICAgICAgdGVtcFBhcmVudC5pbm5lckhUTUwgPSBodG1sO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHRlbXBQYXJlbnQuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyciA9IHFzYShzZWxlY3Rvci50cmltKCksIGNvbnRleHQgfHwgZG9jdW1lbnQpO1xuICAgICAgICB9IC8vIGFyciA9IHFzYShzZWxlY3RvciwgZG9jdW1lbnQpO1xuXG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLm5vZGVUeXBlIHx8IHNlbGVjdG9yID09PSB3aW5kb3cgfHwgc2VsZWN0b3IgPT09IGRvY3VtZW50KSB7XG4gICAgICAgIGFyci5wdXNoKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RvcikpIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgRG9tNykgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgICBhcnIgPSBzZWxlY3RvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEb203KGFycmF5VW5pcXVlKGFycikpO1xuICAgIH1cblxuICAgICQuZm4gPSBEb203LnByb3RvdHlwZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICBmdW5jdGlvbiBhZGRDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gYXJyYXlGbGF0KGNsYXNzZXMubWFwKGMgPT4gYy5zcGxpdCgnICcpKSk7XG4gICAgICB0aGlzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gYXJyYXlGbGF0KGNsYXNzZXMubWFwKGMgPT4gYy5zcGxpdCgnICcpKSk7XG4gICAgICB0aGlzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gYXJyYXlGbGF0KGNsYXNzZXMubWFwKGMgPT4gYy5zcGxpdCgnICcpKSk7XG4gICAgICB0aGlzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBjbGFzc05hbWVzLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3MoLi4uY2xhc3Nlcykge1xuICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IGFycmF5RmxhdChjbGFzc2VzLm1hcChjID0+IGMuc3BsaXQoJyAnKSkpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHRoaXMsIGVsID0+IHtcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXMuZmlsdGVyKGNsYXNzTmFtZSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkubGVuZ3RoID4gMDtcbiAgICAgIH0pLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0cihhdHRycywgdmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gR2V0IGF0dHJcbiAgICAgICAgaWYgKHRoaXNbMF0pIHJldHVybiB0aGlzWzBdLmdldEF0dHJpYnV0ZShhdHRycyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IC8vIFNldCBhdHRyc1xuXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIC8vIFN0cmluZ1xuICAgICAgICAgIHRoaXNbaV0uc2V0QXR0cmlidXRlKGF0dHJzLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgICAgZm9yIChjb25zdCBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICAgICAgdGhpc1tpXVthdHRyTmFtZV0gPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgICB0aGlzW2ldLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0cnNbYXR0ck5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQXR0cihhdHRyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdGhpc1tpXS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0aGlzW2ldLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbihkdXJhdGlvbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRoaXNbaV0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uICE9PSAnc3RyaW5nJyA/IGAke2R1cmF0aW9ufW1zYCA6IGR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbiguLi5hcmdzKSB7XG4gICAgICBsZXQgW2V2ZW50VHlwZSwgdGFyZ2V0U2VsZWN0b3IsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBbZXZlbnRUeXBlLCBsaXN0ZW5lciwgY2FwdHVyZV0gPSBhcmdzO1xuICAgICAgICB0YXJnZXRTZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYXB0dXJlKSBjYXB0dXJlID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUxpdmVFdmVudChlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBldmVudERhdGEgPSBlLnRhcmdldC5kb203RXZlbnREYXRhIHx8IFtdO1xuXG4gICAgICAgIGlmIChldmVudERhdGEuaW5kZXhPZihlKSA8IDApIHtcbiAgICAgICAgICBldmVudERhdGEudW5zaGlmdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkKHRhcmdldCkuaXModGFyZ2V0U2VsZWN0b3IpKSBsaXN0ZW5lci5hcHBseSh0YXJnZXQsIGV2ZW50RGF0YSk7ZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50cyA9ICQodGFyZ2V0KS5wYXJlbnRzKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcGFyZW50cy5sZW5ndGg7IGsgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCQocGFyZW50c1trXSkuaXModGFyZ2V0U2VsZWN0b3IpKSBsaXN0ZW5lci5hcHBseShwYXJlbnRzW2tdLCBldmVudERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFdmVudChlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGUgJiYgZS50YXJnZXQgPyBlLnRhcmdldC5kb203RXZlbnREYXRhIHx8IFtdIDogW107XG5cbiAgICAgICAgaWYgKGV2ZW50RGF0YS5pbmRleE9mKGUpIDwgMCkge1xuICAgICAgICAgIGV2ZW50RGF0YS51bnNoaWZ0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgZXZlbnREYXRhKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXZlbnRzID0gZXZlbnRUeXBlLnNwbGl0KCcgJyk7XG4gICAgICBsZXQgajtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpc1tpXTtcblxuICAgICAgICBpZiAoIXRhcmdldFNlbGVjdG9yKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGV2ZW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbal07XG4gICAgICAgICAgICBpZiAoIWVsLmRvbTdMaXN0ZW5lcnMpIGVsLmRvbTdMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICghZWwuZG9tN0xpc3RlbmVyc1tldmVudF0pIGVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICBlbC5kb203TGlzdGVuZXJzW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICAgIHByb3h5TGlzdGVuZXI6IGhhbmRsZUV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZUV2ZW50LCBjYXB0dXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTGl2ZSBldmVudHNcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZXZlbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tqXTtcbiAgICAgICAgICAgIGlmICghZWwuZG9tN0xpdmVMaXN0ZW5lcnMpIGVsLmRvbTdMaXZlTGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICBpZiAoIWVsLmRvbTdMaXZlTGlzdGVuZXJzW2V2ZW50XSkgZWwuZG9tN0xpdmVMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICBlbC5kb203TGl2ZUxpc3RlbmVyc1tldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICBwcm94eUxpc3RlbmVyOiBoYW5kbGVMaXZlRXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlTGl2ZUV2ZW50LCBjYXB0dXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2ZmKC4uLmFyZ3MpIHtcbiAgICAgIGxldCBbZXZlbnRUeXBlLCB0YXJnZXRTZWxlY3RvciwgbGlzdGVuZXIsIGNhcHR1cmVdID0gYXJncztcblxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIFtldmVudFR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG4gICAgICAgIHRhcmdldFNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNhcHR1cmUpIGNhcHR1cmUgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGV2ZW50VHlwZS5zcGxpdCgnICcpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpXTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBlbCA9IHRoaXNbal07XG4gICAgICAgICAgbGV0IGhhbmRsZXJzO1xuXG4gICAgICAgICAgaWYgKCF0YXJnZXRTZWxlY3RvciAmJiBlbC5kb203TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBoYW5kbGVycyA9IGVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0U2VsZWN0b3IgJiYgZWwuZG9tN0xpdmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzID0gZWwuZG9tN0xpdmVMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBoYW5kbGVycy5sZW5ndGggLSAxOyBrID49IDA7IGsgLT0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNba107XG5cbiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGhhbmRsZXIubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlci5wcm94eUxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXIgJiYgaGFuZGxlci5saXN0ZW5lciAmJiBoYW5kbGVyLmxpc3RlbmVyLmRvbTdwcm94eSAmJiBoYW5kbGVyLmxpc3RlbmVyLmRvbTdwcm94eSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLnByb3h5TGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLnByb3h5TGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgZXZlbnRzID0gYXJnc1swXS5zcGxpdCgnICcpO1xuICAgICAgY29uc3QgZXZlbnREYXRhID0gYXJnc1sxXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSB0aGlzW2pdO1xuXG4gICAgICAgICAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCkge1xuICAgICAgICAgICAgY29uc3QgZXZ0ID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChldmVudCwge1xuICAgICAgICAgICAgICBkZXRhaWw6IGV2ZW50RGF0YSxcbiAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbC5kb203RXZlbnREYXRhID0gYXJncy5maWx0ZXIoKGRhdGEsIGRhdGFJbmRleCkgPT4gZGF0YUluZGV4ID4gMCk7XG4gICAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgICAgICBlbC5kb203RXZlbnREYXRhID0gW107XG4gICAgICAgICAgICBkZWxldGUgZWwuZG9tN0V2ZW50RGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZChjYWxsYmFjaykge1xuICAgICAgY29uc3QgZG9tID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gZmlyZUNhbGxCYWNrKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZSk7XG4gICAgICAgIGRvbS5vZmYoJ3RyYW5zaXRpb25lbmQnLCBmaXJlQ2FsbEJhY2spO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgZG9tLm9uKCd0cmFuc2l0aW9uZW5kJywgZmlyZUNhbGxCYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3V0ZXJXaWR0aChpbmNsdWRlTWFyZ2lucykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoaW5jbHVkZU1hcmdpbnMpIHtcbiAgICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLnN0eWxlcygpO1xuICAgICAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldFdpZHRoICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JykpICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWxlZnQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3V0ZXJIZWlnaHQoaW5jbHVkZU1hcmdpbnMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluY2x1ZGVNYXJnaW5zKSB7XG4gICAgICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5zdHlsZXMoKTtcbiAgICAgICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykpICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWJvdHRvbScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXNbMF07XG4gICAgICAgIGNvbnN0IGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgY29uc3QgY2xpZW50VG9wID0gZWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gICAgICAgIGNvbnN0IGNsaWVudExlZnQgPSBlbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBlbCA9PT0gd2luZG93ID8gd2luZG93LnNjcm9sbFkgOiBlbC5zY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IHNjcm9sbExlZnQgPSBlbCA9PT0gd2luZG93ID8gd2luZG93LnNjcm9sbFggOiBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcCxcbiAgICAgICAgICBsZWZ0OiBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgaWYgKHRoaXNbMF0pIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLCBudWxsKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjc3MocHJvcHMsIHZhbHVlKSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgIGxldCBpO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3BzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIC5jc3MoJ3dpZHRoJylcbiAgICAgICAgICBpZiAodGhpc1swXSkgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXNbMF0sIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIC5jc3MoeyB3aWR0aDogJzEwMHB4JyB9KVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgdGhpc1tpXS5zdHlsZVtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gLmNzcygnd2lkdGgnLCAnMTAwcHgnKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXNbaV0uc3R5bGVbcHJvcHNdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xuICAgICAgICBjYWxsYmFjay5hcHBseShlbCwgW2VsLCBpbmRleF0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFycmF5RmlsdGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiAkKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHRtbChodG1sKSB7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5pbm5lckhUTUwgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdGhpc1tpXS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXh0KHRleHQpIHtcbiAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdLnRleHRDb250ZW50LnRyaW0oKSA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0aGlzW2ldLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXMoc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3QgZWwgPSB0aGlzWzBdO1xuICAgICAgbGV0IGNvbXBhcmVXaXRoO1xuICAgICAgbGV0IGk7XG4gICAgICBpZiAoIWVsIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGVsLm1hdGNoZXMpIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIGlmIChlbC5tc01hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgY29tcGFyZVdpdGggPSAkKHNlbGVjdG9yKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcGFyZVdpdGgubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZVdpdGhbaV0gPT09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdG9yID09PSBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZWwgPT09IGRvY3VtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0b3IgPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gZWwgPT09IHdpbmRvdztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdG9yLm5vZGVUeXBlIHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgRG9tNykge1xuICAgICAgICBjb21wYXJlV2l0aCA9IHNlbGVjdG9yLm5vZGVUeXBlID8gW3NlbGVjdG9yXSA6IHNlbGVjdG9yO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wYXJlV2l0aC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChjb21wYXJlV2l0aFtpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZXgoKSB7XG4gICAgICBsZXQgY2hpbGQgPSB0aGlzWzBdO1xuICAgICAgbGV0IGk7XG5cbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBpID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgd2hpbGUgKChjaGlsZCA9IGNoaWxkLnByZXZpb3VzU2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxKGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHRoaXM7XG4gICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gJChbXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgY29uc3QgcmV0dXJuSW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICAgICAgaWYgKHJldHVybkluZGV4IDwgMCkgcmV0dXJuICQoW10pO1xuICAgICAgICByZXR1cm4gJChbdGhpc1tyZXR1cm5JbmRleF1dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoW3RoaXNbaW5kZXhdXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kKC4uLmVscykge1xuICAgICAgbGV0IG5ld0NoaWxkO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGVscy5sZW5ndGg7IGsgKz0gMSkge1xuICAgICAgICBuZXdDaGlsZCA9IGVsc1trXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBuZXdDaGlsZDtcblxuICAgICAgICAgICAgd2hpbGUgKHRlbXBEaXYuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICB0aGlzW2ldLmFwcGVuZENoaWxkKHRlbXBEaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZCBpbnN0YW5jZW9mIERvbTcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmV3Q2hpbGQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgdGhpc1tpXS5hcHBlbmRDaGlsZChuZXdDaGlsZFtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbaV0uYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwZW5kKG5ld0NoaWxkKSB7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IG5ld0NoaWxkO1xuXG4gICAgICAgICAgZm9yIChqID0gdGVtcERpdi5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICB0aGlzW2ldLmluc2VydEJlZm9yZSh0ZW1wRGl2LmNoaWxkTm9kZXNbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tNykge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuZXdDaGlsZC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdGhpc1tpXS5pbnNlcnRCZWZvcmUobmV3Q2hpbGRbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbaV0uaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCB0aGlzW2ldLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHQoc2VsZWN0b3IpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nICYmICQodGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuICQoW3RoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICQoW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKSByZXR1cm4gJChbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgcmV0dXJuICQoW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChbXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dEFsbChzZWxlY3Rvcikge1xuICAgICAgY29uc3QgbmV4dEVscyA9IFtdO1xuICAgICAgbGV0IGVsID0gdGhpc1swXTtcbiAgICAgIGlmICghZWwpIHJldHVybiAkKFtdKTtcblxuICAgICAgd2hpbGUgKGVsLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgICBjb25zdCBuZXh0ID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKCQobmV4dCkuaXMoc2VsZWN0b3IpKSBuZXh0RWxzLnB1c2gobmV4dCk7XG4gICAgICAgIH0gZWxzZSBuZXh0RWxzLnB1c2gobmV4dCk7XG5cbiAgICAgICAgZWwgPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChuZXh0RWxzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmV2KHNlbGVjdG9yKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpc1swXTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZyAmJiAkKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuICQoW2VsLnByZXZpb3VzRWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJChbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykgcmV0dXJuICQoW2VsLnByZXZpb3VzRWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgcmV0dXJuICQoW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChbXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJldkFsbChzZWxlY3Rvcikge1xuICAgICAgY29uc3QgcHJldkVscyA9IFtdO1xuICAgICAgbGV0IGVsID0gdGhpc1swXTtcbiAgICAgIGlmICghZWwpIHJldHVybiAkKFtdKTtcblxuICAgICAgd2hpbGUgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoJChwcmV2KS5pcyhzZWxlY3RvcikpIHByZXZFbHMucHVzaChwcmV2KTtcbiAgICAgICAgfSBlbHNlIHByZXZFbHMucHVzaChwcmV2KTtcblxuICAgICAgICBlbCA9IHByZXY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkKHByZXZFbHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudChzZWxlY3Rvcikge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpc1tpXS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzW2ldLnBhcmVudE5vZGUpLmlzKHNlbGVjdG9yKSkgcGFyZW50cy5wdXNoKHRoaXNbaV0ucGFyZW50Tm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaCh0aGlzW2ldLnBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChwYXJlbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzW2ldLnBhcmVudE5vZGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoJChwYXJlbnQpLmlzKHNlbGVjdG9yKSkgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkKHBhcmVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcbiAgICAgIGxldCBjbG9zZXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gJChbXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2xvc2VzdC5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgY2xvc2VzdCA9IGNsb3Nlc3QucGFyZW50cyhzZWxlY3RvcikuZXEoMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9zZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IGZvdW5kRWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gdGhpc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgZm91bmRFbGVtZW50cy5wdXNoKGZvdW5kW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChmb3VuZEVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXNbaV0uY2hpbGRyZW47XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCAkKGNoaWxkTm9kZXNbal0pLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZE5vZGVzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpc1tpXS5wYXJlbnROb2RlKSB0aGlzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IE1ldGhvZHMgPSB7XG4gICAgICBhZGRDbGFzcyxcbiAgICAgIHJlbW92ZUNsYXNzLFxuICAgICAgaGFzQ2xhc3MsXG4gICAgICB0b2dnbGVDbGFzcyxcbiAgICAgIGF0dHIsXG4gICAgICByZW1vdmVBdHRyLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG9uLFxuICAgICAgb2ZmLFxuICAgICAgdHJpZ2dlcixcbiAgICAgIHRyYW5zaXRpb25FbmQsXG4gICAgICBvdXRlcldpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQsXG4gICAgICBzdHlsZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBjc3MsXG4gICAgICBlYWNoLFxuICAgICAgaHRtbCxcbiAgICAgIHRleHQsXG4gICAgICBpcyxcbiAgICAgIGluZGV4LFxuICAgICAgZXEsXG4gICAgICBhcHBlbmQsXG4gICAgICBwcmVwZW5kLFxuICAgICAgbmV4dCxcbiAgICAgIG5leHRBbGwsXG4gICAgICBwcmV2LFxuICAgICAgcHJldkFsbCxcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudHMsXG4gICAgICBjbG9zZXN0LFxuICAgICAgZmluZCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZmlsdGVyLFxuICAgICAgcmVtb3ZlXG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhNZXRob2RzKS5mb3JFYWNoKG1ldGhvZE5hbWUgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCQuZm4sIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgdmFsdWU6IE1ldGhvZHNbbWV0aG9kTmFtZV0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZVByb3BzKG9iaikge1xuICAgICAgY29uc3Qgb2JqZWN0ID0gb2JqO1xuICAgICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2JqZWN0W2tleV0gPSBudWxsO1xuICAgICAgICB9IGNhdGNoIChlKSB7Ly8gbm8gZ2V0dGVyIGZvciBvYmplY3RcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVsZXRlIG9iamVjdFtrZXldO1xuICAgICAgICB9IGNhdGNoIChlKSB7Ly8gc29tZXRoaW5nIGdvdCB3cm9uZ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0VGljayhjYWxsYmFjaywgZGVsYXkpIHtcbiAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGF5ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3coKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlJDEoZWwpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgbGV0IHN0eWxlO1xuXG4gICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3R5bGUgJiYgZWwuY3VycmVudFN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2xhdGUoZWwsIGF4aXMpIHtcbiAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHtcbiAgICAgICAgYXhpcyA9ICd4JztcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBsZXQgbWF0cml4O1xuICAgICAgbGV0IGN1clRyYW5zZm9ybTtcbiAgICAgIGxldCB0cmFuc2Zvcm1NYXRyaXg7XG4gICAgICBjb25zdCBjdXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUkMShlbCk7XG5cbiAgICAgIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSB7XG4gICAgICAgIGN1clRyYW5zZm9ybSA9IGN1clN0eWxlLnRyYW5zZm9ybSB8fCBjdXJTdHlsZS53ZWJraXRUcmFuc2Zvcm07XG5cbiAgICAgICAgaWYgKGN1clRyYW5zZm9ybS5zcGxpdCgnLCcpLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICBjdXJUcmFuc2Zvcm0gPSBjdXJUcmFuc2Zvcm0uc3BsaXQoJywgJykubWFwKGEgPT4gYS5yZXBsYWNlKCcsJywgJy4nKSkuam9pbignLCAnKTtcbiAgICAgICAgfSAvLyBTb21lIG9sZCB2ZXJzaW9ucyBvZiBXZWJraXQgY2hva2Ugd2hlbiAnbm9uZScgaXMgcGFzc2VkOyBwYXNzXG4gICAgICAgIC8vIGVtcHR5IHN0cmluZyBpbnN0ZWFkIGluIHRoaXMgY2FzZVxuXG5cbiAgICAgICAgdHJhbnNmb3JtTWF0cml4ID0gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoY3VyVHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IGN1clRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1NYXRyaXggPSBjdXJTdHlsZS5Nb3pUcmFuc2Zvcm0gfHwgY3VyU3R5bGUuT1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5Nc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5tc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNmb3JtJykucmVwbGFjZSgndHJhbnNsYXRlKCcsICdtYXRyaXgoMSwgMCwgMCwgMSwnKTtcbiAgICAgICAgbWF0cml4ID0gdHJhbnNmb3JtTWF0cml4LnRvU3RyaW5nKCkuc3BsaXQoJywnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgICAvLyBMYXRlc3QgQ2hyb21lIGFuZCB3ZWJraXRzIEZpeFxuICAgICAgICBpZiAod2luZG93LldlYktpdENTU01hdHJpeCkgY3VyVHJhbnNmb3JtID0gdHJhbnNmb3JtTWF0cml4Lm00MTsgLy8gQ3JhenkgSUUxMCBNYXRyaXhcbiAgICAgICAgZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMTYpIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzEyXSk7IC8vIE5vcm1hbCBCcm93c2Vyc1xuICAgICAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzRdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgICAvLyBMYXRlc3QgQ2hyb21lIGFuZCB3ZWJraXRzIEZpeFxuICAgICAgICBpZiAod2luZG93LldlYktpdENTU01hdHJpeCkgY3VyVHJhbnNmb3JtID0gdHJhbnNmb3JtTWF0cml4Lm00MjsgLy8gQ3JhenkgSUUxMCBNYXRyaXhcbiAgICAgICAgZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMTYpIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzEzXSk7IC8vIE5vcm1hbCBCcm93c2Vyc1xuICAgICAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1clRyYW5zZm9ybSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0JDEobykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBvICE9PSBudWxsICYmIG8uY29uc3RydWN0b3IgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKSA9PT0gJ09iamVjdCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlICYmIChub2RlLm5vZGVUeXBlID09PSAxIHx8IG5vZGUubm9kZVR5cGUgPT09IDExKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQkMSgpIHtcbiAgICAgIGNvbnN0IHRvID0gT2JqZWN0KGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gICAgICBjb25zdCBub0V4dGVuZCA9IFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddO1xuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBuZXh0U291cmNlID0gaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGlmIChuZXh0U291cmNlICE9PSB1bmRlZmluZWQgJiYgbmV4dFNvdXJjZSAhPT0gbnVsbCAmJiAhaXNOb2RlKG5leHRTb3VyY2UpKSB7XG4gICAgICAgICAgY29uc3Qga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKS5maWx0ZXIoa2V5ID0+IG5vRXh0ZW5kLmluZGV4T2Yoa2V5KSA8IDApO1xuXG4gICAgICAgICAgZm9yIChsZXQgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG5cbiAgICAgICAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICAgIGlmIChpc09iamVjdCQxKHRvW25leHRLZXldKSAmJiBpc09iamVjdCQxKG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTb3VyY2VbbmV4dEtleV0uX19zd2lwZXJfXykge1xuICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHRlbmQkMSh0b1tuZXh0S2V5XSwgbmV4dFNvdXJjZVtuZXh0S2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc09iamVjdCQxKHRvW25leHRLZXldKSAmJiBpc09iamVjdCQxKG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSB7fTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0U291cmNlW25leHRLZXldLl9fc3dpcGVyX18pIHtcbiAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXh0ZW5kJDEodG9bbmV4dEtleV0sIG5leHRTb3VyY2VbbmV4dEtleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldENTU1Byb3BlcnR5KGVsLCB2YXJOYW1lLCB2YXJWYWx1ZSkge1xuICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFyVmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFuaW1hdGVDU1NNb2RlU2Nyb2xsKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIHNpZGVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gLXN3aXBlci50cmFuc2xhdGU7XG4gICAgICBsZXQgc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgIGxldCB0aW1lO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICdub25lJztcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShzd2lwZXIuY3NzTW9kZUZyYW1lSUQpO1xuICAgICAgY29uc3QgZGlyID0gdGFyZ2V0UG9zaXRpb24gPiBzdGFydFBvc2l0aW9uID8gJ25leHQnIDogJ3ByZXYnO1xuXG4gICAgICBjb25zdCBpc091dE9mQm91bmQgPSAoY3VycmVudCwgdGFyZ2V0KSA9PiB7XG4gICAgICAgIHJldHVybiBkaXIgPT09ICduZXh0JyAmJiBjdXJyZW50ID49IHRhcmdldCB8fCBkaXIgPT09ICdwcmV2JyAmJiBjdXJyZW50IDw9IHRhcmdldDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICAgIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnRUaW1lID0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5tYXgoTWF0aC5taW4oKHRpbWUgLSBzdGFydFRpbWUpIC8gZHVyYXRpb24sIDEpLCAwKTtcbiAgICAgICAgY29uc3QgZWFzZVByb2dyZXNzID0gMC41IC0gTWF0aC5jb3MocHJvZ3Jlc3MgKiBNYXRoLlBJKSAvIDI7XG4gICAgICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uICsgZWFzZVByb2dyZXNzICogKHRhcmdldFBvc2l0aW9uIC0gc3RhcnRQb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGlzT3V0T2ZCb3VuZChjdXJyZW50UG9zaXRpb24sIHRhcmdldFBvc2l0aW9uKSkge1xuICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zY3JvbGxUbyh7XG4gICAgICAgICAgW3NpZGVdOiBjdXJyZW50UG9zaXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzT3V0T2ZCb3VuZChjdXJyZW50UG9zaXRpb24sIHRhcmdldFBvc2l0aW9uKSkge1xuICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gJyc7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgW3NpZGVdOiBjdXJyZW50UG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShzd2lwZXIuY3NzTW9kZUZyYW1lSUQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci5jc3NNb2RlRnJhbWVJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICB9O1xuXG4gICAgICBhbmltYXRlKCk7XG4gICAgfVxuXG4gICAgbGV0IHN1cHBvcnQ7XG5cbiAgICBmdW5jdGlvbiBjYWxjU3VwcG9ydCgpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc21vb3RoU2Nyb2xsOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgJ3Njcm9sbEJlaGF2aW9yJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHRvdWNoOiAhISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCksXG4gICAgICAgIHBhc3NpdmVMaXN0ZW5lcjogZnVuY3Rpb24gY2hlY2tQYXNzaXZlTGlzdGVuZXIoKSB7XG4gICAgICAgICAgbGV0IHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVMaXN0ZW5lcicsIG51bGwsIG9wdHMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBObyBzdXBwb3J0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbiAgICAgICAgfSgpLFxuICAgICAgICBnZXN0dXJlczogZnVuY3Rpb24gY2hlY2tHZXN0dXJlcygpIHtcbiAgICAgICAgICByZXR1cm4gJ29uZ2VzdHVyZXN0YXJ0JyBpbiB3aW5kb3c7XG4gICAgICAgIH0oKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0KCkge1xuICAgICAgaWYgKCFzdXBwb3J0KSB7XG4gICAgICAgIHN1cHBvcnQgPSBjYWxjU3VwcG9ydCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3VwcG9ydDtcbiAgICB9XG5cbiAgICBsZXQgZGV2aWNlQ2FjaGVkO1xuXG4gICAgZnVuY3Rpb24gY2FsY0RldmljZShfdGVtcCkge1xuICAgICAgbGV0IHtcbiAgICAgICAgdXNlckFnZW50XG4gICAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgICBjb25zdCBzdXBwb3J0ID0gZ2V0U3VwcG9ydCgpO1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBjb25zdCBwbGF0Zm9ybSA9IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm07XG4gICAgICBjb25zdCB1YSA9IHVzZXJBZ2VudCB8fCB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgIGNvbnN0IGRldmljZSA9IHtcbiAgICAgICAgaW9zOiBmYWxzZSxcbiAgICAgICAgYW5kcm9pZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb25zdCBzY3JlZW5XaWR0aCA9IHdpbmRvdy5zY3JlZW4ud2lkdGg7XG4gICAgICBjb25zdCBzY3JlZW5IZWlnaHQgPSB3aW5kb3cuc2NyZWVuLmhlaWdodDtcbiAgICAgIGNvbnN0IGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgbGV0IGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pO1xuICAgICAgY29uc3QgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gICAgICBjb25zdCBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcc09TfGlPUylcXHMoW1xcZF9dKykvKTtcbiAgICAgIGNvbnN0IHdpbmRvd3MgPSBwbGF0Zm9ybSA9PT0gJ1dpbjMyJztcbiAgICAgIGxldCBtYWNvcyA9IHBsYXRmb3JtID09PSAnTWFjSW50ZWwnOyAvLyBpUGFkT3MgMTMgZml4XG5cbiAgICAgIGNvbnN0IGlQYWRTY3JlZW5zID0gWycxMDI0eDEzNjYnLCAnMTM2NngxMDI0JywgJzgzNHgxMTk0JywgJzExOTR4ODM0JywgJzgzNHgxMTEyJywgJzExMTJ4ODM0JywgJzc2OHgxMDI0JywgJzEwMjR4NzY4JywgJzgyMHgxMTgwJywgJzExODB4ODIwJywgJzgxMHgxMDgwJywgJzEwODB4ODEwJ107XG5cbiAgICAgIGlmICghaXBhZCAmJiBtYWNvcyAmJiBzdXBwb3J0LnRvdWNoICYmIGlQYWRTY3JlZW5zLmluZGV4T2YoYCR7c2NyZWVuV2lkdGh9eCR7c2NyZWVuSGVpZ2h0fWApID49IDApIHtcbiAgICAgICAgaXBhZCA9IHVhLm1hdGNoKC8oVmVyc2lvbilcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgaWYgKCFpcGFkKSBpcGFkID0gWzAsIDEsICcxM18wXzAnXTtcbiAgICAgICAgbWFjb3MgPSBmYWxzZTtcbiAgICAgIH0gLy8gQW5kcm9pZFxuXG5cbiAgICAgIGlmIChhbmRyb2lkICYmICF3aW5kb3dzKSB7XG4gICAgICAgIGRldmljZS5vcyA9ICdhbmRyb2lkJztcbiAgICAgICAgZGV2aWNlLmFuZHJvaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXBhZCB8fCBpcGhvbmUgfHwgaXBvZCkge1xuICAgICAgICBkZXZpY2Uub3MgPSAnaW9zJztcbiAgICAgICAgZGV2aWNlLmlvcyA9IHRydWU7XG4gICAgICB9IC8vIEV4cG9ydCBvYmplY3RcblxuXG4gICAgICByZXR1cm4gZGV2aWNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERldmljZShvdmVycmlkZXMpIHtcbiAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkge1xuICAgICAgICBvdmVycmlkZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZXZpY2VDYWNoZWQpIHtcbiAgICAgICAgZGV2aWNlQ2FjaGVkID0gY2FsY0RldmljZShvdmVycmlkZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGV2aWNlQ2FjaGVkO1xuICAgIH1cblxuICAgIGxldCBicm93c2VyO1xuXG4gICAgZnVuY3Rpb24gY2FsY0Jyb3dzZXIoKSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcblxuICAgICAgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgICAgIGNvbnN0IHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHVhLmluZGV4T2YoJ3NhZmFyaScpID49IDAgJiYgdWEuaW5kZXhPZignY2hyb21lJykgPCAwICYmIHVhLmluZGV4T2YoJ2FuZHJvaWQnKSA8IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzU2FmYXJpOiBpc1NhZmFyaSgpLFxuICAgICAgICBpc1dlYlZpZXc6IC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QnJvd3NlcigpIHtcbiAgICAgIGlmICghYnJvd3Nlcikge1xuICAgICAgICBicm93c2VyID0gY2FsY0Jyb3dzZXIoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVzaXplKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgb24sXG4gICAgICAgIGVtaXRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBsZXQgb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgbGV0IGFuaW1hdGlvbkZyYW1lID0gbnVsbDtcblxuICAgICAgY29uc3QgcmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgICAgIGVtaXQoJ2JlZm9yZVJlc2l6ZScpO1xuICAgICAgICBlbWl0KCdyZXNpemUnKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNyZWF0ZU9ic2VydmVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICAgICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodFxuICAgICAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgICAgIGxldCBuZXdXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgbGV0IG5ld0hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChfcmVmMiA9PiB7XG4gICAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgICAgY29udGVudEJveFNpemUsXG4gICAgICAgICAgICAgICAgY29udGVudFJlY3QsXG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQgIT09IHN3aXBlci5lbCkgcmV0dXJuO1xuICAgICAgICAgICAgICBuZXdXaWR0aCA9IGNvbnRlbnRSZWN0ID8gY29udGVudFJlY3Qud2lkdGggOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmlubGluZVNpemU7XG4gICAgICAgICAgICAgIG5ld0hlaWdodCA9IGNvbnRlbnRSZWN0ID8gY29udGVudFJlY3QuaGVpZ2h0IDogKGNvbnRlbnRCb3hTaXplWzBdIHx8IGNvbnRlbnRCb3hTaXplKS5ibG9ja1NpemU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG5ld1dpZHRoICE9PSB3aWR0aCB8fCBuZXdIZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgICByZXNpemVIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHN3aXBlci5lbCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZW1vdmVPYnNlcnZlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYnNlcnZlciAmJiBvYnNlcnZlci51bm9ic2VydmUgJiYgc3dpcGVyLmVsKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKHN3aXBlci5lbCk7XG4gICAgICAgICAgb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5pbml0aWFsaXplZCkgcmV0dXJuO1xuICAgICAgICBlbWl0KCdvcmllbnRhdGlvbmNoYW5nZScpO1xuICAgICAgfTtcblxuICAgICAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnJlc2l6ZU9ic2VydmVyICYmIHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICByZW1vdmVPYnNlcnZlcigpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPYnNlcnZlcihfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICBzd2lwZXIsXG4gICAgICAgIGV4dGVuZFBhcmFtcyxcbiAgICAgICAgb24sXG4gICAgICAgIGVtaXRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3Qgb2JzZXJ2ZXJzID0gW107XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcblxuICAgICAgY29uc3QgYXR0YWNoID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgT2JzZXJ2ZXJGdW5jID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYmtpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE9ic2VydmVyRnVuYyhtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgIC8vIFRoZSBvYnNlcnZlclVwZGF0ZSBldmVudCBzaG91bGQgb25seSBiZSB0cmlnZ2VyZWRcbiAgICAgICAgICAvLyBvbmNlIGRlc3BpdGUgdGhlIG51bWJlciBvZiBtdXRhdGlvbnMuICBBZGRpdGlvbmFsXG4gICAgICAgICAgLy8gdHJpZ2dlcnMgYXJlIHJlZHVuZGFudCBhbmQgYXJlIHZlcnkgY29zdGx5XG4gICAgICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGVtaXQoJ29ic2VydmVyVXBkYXRlJywgbXV0YXRpb25zWzBdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvYnNlcnZlclVwZGF0ZSA9IGZ1bmN0aW9uIG9ic2VydmVyVXBkYXRlKCkge1xuICAgICAgICAgICAgZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvYnNlcnZlclVwZGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KG9ic2VydmVyVXBkYXRlLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgICAgICBjaGlsZExpc3Q6IHR5cGVvZiBvcHRpb25zLmNoaWxkTGlzdCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5jaGlsZExpc3QsXG4gICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHlwZW9mIG9wdGlvbnMuY2hhcmFjdGVyRGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5jaGFyYWN0ZXJEYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMub2JzZXJ2ZXIpIHJldHVybjtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5vYnNlcnZlUGFyZW50cykge1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclBhcmVudHMgPSBzd2lwZXIuJGVsLnBhcmVudHMoKTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVyUGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYXR0YWNoKGNvbnRhaW5lclBhcmVudHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBPYnNlcnZlIGNvbnRhaW5lclxuXG5cbiAgICAgICAgYXR0YWNoKHN3aXBlci4kZWxbMF0sIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHN3aXBlci5wYXJhbXMub2JzZXJ2ZVNsaWRlQ2hpbGRyZW5cbiAgICAgICAgfSk7IC8vIE9ic2VydmUgd3JhcHBlclxuXG4gICAgICAgIGF0dGFjaChzd2lwZXIuJHdyYXBwZXJFbFswXSwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xuICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9ic2VydmVycy5zcGxpY2UoMCwgb2JzZXJ2ZXJzLmxlbmd0aCk7XG4gICAgICB9O1xuXG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBvYnNlcnZlcjogZmFsc2UsXG4gICAgICAgIG9ic2VydmVQYXJlbnRzOiBmYWxzZSxcbiAgICAgICAgb2JzZXJ2ZVNsaWRlQ2hpbGRyZW46IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIG9uKCdpbml0JywgaW5pdCk7XG4gICAgICBvbignZGVzdHJveScsIGRlc3Ryb3kpO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG4gICAgdmFyIGV2ZW50c0VtaXR0ZXIgPSB7XG4gICAgICBvbihldmVudHMsIGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcHJpb3JpdHkgPyAndW5zaGlmdCcgOiAncHVzaCc7XG4gICAgICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdKSBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF1bbWV0aG9kXShoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfSxcblxuICAgICAgb25jZShldmVudHMsIGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcblxuICAgICAgICBmdW5jdGlvbiBvbmNlSGFuZGxlcigpIHtcbiAgICAgICAgICBzZWxmLm9mZihldmVudHMsIG9uY2VIYW5kbGVyKTtcblxuICAgICAgICAgIGlmIChvbmNlSGFuZGxlci5fX2VtaXR0ZXJQcm94eSkge1xuICAgICAgICAgICAgZGVsZXRlIG9uY2VIYW5kbGVyLl9fZW1pdHRlclByb3h5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgb25jZUhhbmRsZXIuX19lbWl0dGVyUHJveHkgPSBoYW5kbGVyO1xuICAgICAgICByZXR1cm4gc2VsZi5vbihldmVudHMsIG9uY2VIYW5kbGVyLCBwcmlvcml0eSk7XG4gICAgICB9LFxuXG4gICAgICBvbkFueShoYW5kbGVyLCBwcmlvcml0eSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycyB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGY7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHByaW9yaXR5ID8gJ3Vuc2hpZnQnIDogJ3B1c2gnO1xuXG4gICAgICAgIGlmIChzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpIDwgMCkge1xuICAgICAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzW21ldGhvZF0oaGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH0sXG5cbiAgICAgIG9mZkFueShoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKCFzZWxmLmV2ZW50c0FueUxpc3RlbmVycykgcmV0dXJuIHNlbGY7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH0sXG5cbiAgICAgIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICAgICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKChldmVudEhhbmRsZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXIgPT09IGhhbmRsZXIgfHwgZXZlbnRIYW5kbGVyLl9fZW1pdHRlclByb3h5ICYmIGV2ZW50SGFuZGxlci5fX2VtaXR0ZXJQcm94eSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH0sXG5cbiAgICAgIGVtaXQoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycykgcmV0dXJuIHNlbGY7XG4gICAgICAgIGxldCBldmVudHM7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgY29udGV4dDtcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICBldmVudHMgPSBhcmdzWzBdO1xuICAgICAgICAgIGRhdGEgPSBhcmdzLnNsaWNlKDEsIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgICBjb250ZXh0ID0gc2VsZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudHMgPSBhcmdzWzBdLmV2ZW50cztcbiAgICAgICAgICBkYXRhID0gYXJnc1swXS5kYXRhO1xuICAgICAgICAgIGNvbnRleHQgPSBhcmdzWzBdLmNvbnRleHQgfHwgc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudW5zaGlmdChjb250ZXh0KTtcbiAgICAgICAgY29uc3QgZXZlbnRzQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoJyAnKTtcbiAgICAgICAgZXZlbnRzQXJyYXkuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzICYmIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuZm9yRWFjaChldmVudEhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgICBldmVudEhhbmRsZXIuYXBwbHkoY29udGV4dCwgW2V2ZW50LCAuLi5kYXRhXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5ldmVudHNMaXN0ZW5lcnMgJiYgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uZm9yRWFjaChldmVudEhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgICBldmVudEhhbmRsZXIuYXBwbHkoY29udGV4dCwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTaXplKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGxldCB3aWR0aDtcbiAgICAgIGxldCBoZWlnaHQ7XG4gICAgICBjb25zdCAkZWwgPSBzd2lwZXIuJGVsO1xuXG4gICAgICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMud2lkdGggIT09ICd1bmRlZmluZWQnICYmIHN3aXBlci5wYXJhbXMud2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgd2lkdGggPSBzd2lwZXIucGFyYW1zLndpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSAkZWxbMF0uY2xpZW50V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc3dpcGVyLnBhcmFtcy5oZWlnaHQgIT09ICd1bmRlZmluZWQnICYmIHN3aXBlci5wYXJhbXMuaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIGhlaWdodCA9IHN3aXBlci5wYXJhbXMuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gJGVsWzBdLmNsaWVudEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpZHRoID09PSAwICYmIHN3aXBlci5pc0hvcml6b250YWwoKSB8fCBoZWlnaHQgPT09IDAgJiYgc3dpcGVyLmlzVmVydGljYWwoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFN1YnRyYWN0IHBhZGRpbmdzXG5cblxuICAgICAgd2lkdGggPSB3aWR0aCAtIHBhcnNlSW50KCRlbC5jc3MoJ3BhZGRpbmctbGVmdCcpIHx8IDAsIDEwKSAtIHBhcnNlSW50KCRlbC5jc3MoJ3BhZGRpbmctcmlnaHQnKSB8fCAwLCAxMCk7XG4gICAgICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLXRvcCcpIHx8IDAsIDEwKSAtIHBhcnNlSW50KCRlbC5jc3MoJ3BhZGRpbmctYm90dG9tJykgfHwgMCwgMTApO1xuICAgICAgaWYgKE51bWJlci5pc05hTih3aWR0aCkpIHdpZHRoID0gMDtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oaGVpZ2h0KSkgaGVpZ2h0ID0gMDtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHNpemU6IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHdpZHRoIDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTbGlkZXMoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBnZXREaXJlY3Rpb25MYWJlbChwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgICAgICB9IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAnd2lkdGgnOiAnaGVpZ2h0JyxcbiAgICAgICAgICAnbWFyZ2luLXRvcCc6ICdtYXJnaW4tbGVmdCcsXG4gICAgICAgICAgJ21hcmdpbi1ib3R0b20gJzogJ21hcmdpbi1yaWdodCcsXG4gICAgICAgICAgJ21hcmdpbi1sZWZ0JzogJ21hcmdpbi10b3AnLFxuICAgICAgICAgICdtYXJnaW4tcmlnaHQnOiAnbWFyZ2luLWJvdHRvbScsXG4gICAgICAgICAgJ3BhZGRpbmctbGVmdCc6ICdwYWRkaW5nLXRvcCcsXG4gICAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAncGFkZGluZy1ib3R0b20nLFxuICAgICAgICAgICdtYXJnaW5SaWdodCc6ICdtYXJnaW5Cb3R0b20nXG4gICAgICAgIH1bcHJvcGVydHldO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKG5vZGUsIGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG5vZGUuZ2V0UHJvcGVydHlWYWx1ZShnZXREaXJlY3Rpb25MYWJlbChsYWJlbCkpIHx8IDApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xuICAgICAgY29uc3Qge1xuICAgICAgICAkd3JhcHBlckVsLFxuICAgICAgICBzaXplOiBzd2lwZXJTaXplLFxuICAgICAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICAgICAgd3JvbmdSVExcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgICAgY29uc3QgcHJldmlvdXNTbGlkZXNMZW5ndGggPSBpc1ZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG4gICAgICBjb25zdCBzbGlkZXMgPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9YCk7XG4gICAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBpc1ZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc2xpZGVzLmxlbmd0aDtcbiAgICAgIGxldCBzbmFwR3JpZCA9IFtdO1xuICAgICAgY29uc3Qgc2xpZGVzR3JpZCA9IFtdO1xuICAgICAgY29uc3Qgc2xpZGVzU2l6ZXNHcmlkID0gW107XG4gICAgICBsZXQgb2Zmc2V0QmVmb3JlID0gcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZTtcblxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXRCZWZvcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2Zmc2V0QmVmb3JlID0gcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZS5jYWxsKHN3aXBlcik7XG4gICAgICB9XG5cbiAgICAgIGxldCBvZmZzZXRBZnRlciA9IHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlcjtcblxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXRBZnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvZmZzZXRBZnRlciA9IHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlci5jYWxsKHN3aXBlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByZXZpb3VzU25hcEdyaWRMZW5ndGggPSBzd2lwZXIuc25hcEdyaWQubGVuZ3RoO1xuICAgICAgY29uc3QgcHJldmlvdXNTbGlkZXNHcmlkTGVuZ3RoID0gc3dpcGVyLnNsaWRlc0dyaWQubGVuZ3RoO1xuICAgICAgbGV0IHNwYWNlQmV0d2VlbiA9IHBhcmFtcy5zcGFjZUJldHdlZW47XG4gICAgICBsZXQgc2xpZGVQb3NpdGlvbiA9IC1vZmZzZXRCZWZvcmU7XG4gICAgICBsZXQgcHJldlNsaWRlU2l6ZSA9IDA7XG4gICAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgICBpZiAodHlwZW9mIHN3aXBlclNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzcGFjZUJldHdlZW4gPT09ICdzdHJpbmcnICYmIHNwYWNlQmV0d2Vlbi5pbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbi5yZXBsYWNlKCclJywgJycpKSAvIDEwMCAqIHN3aXBlclNpemU7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci52aXJ0dWFsU2l6ZSA9IC1zcGFjZUJldHdlZW47IC8vIHJlc2V0IG1hcmdpbnNcblxuICAgICAgaWYgKHJ0bCkgc2xpZGVzLmNzcyh7XG4gICAgICAgIG1hcmdpbkxlZnQ6ICcnLFxuICAgICAgICBtYXJnaW5Cb3R0b206ICcnLFxuICAgICAgICBtYXJnaW5Ub3A6ICcnXG4gICAgICB9KTtlbHNlIHNsaWRlcy5jc3Moe1xuICAgICAgICBtYXJnaW5SaWdodDogJycsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogJycsXG4gICAgICAgIG1hcmdpblRvcDogJydcbiAgICAgIH0pOyAvLyByZXNldCBjc3NNb2RlIG9mZnNldHNcblxuICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICBzZXRDU1NQcm9wZXJ0eShzd2lwZXIud3JhcHBlckVsLCAnLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWJlZm9yZScsICcnKTtcbiAgICAgICAgc2V0Q1NTUHJvcGVydHkoc3dpcGVyLndyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcicsICcnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ3JpZEVuYWJsZWQgPSBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMSAmJiBzd2lwZXIuZ3JpZDtcblxuICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgIHN3aXBlci5ncmlkLmluaXRTbGlkZXMoc2xpZGVzTGVuZ3RoKTtcbiAgICAgIH0gLy8gQ2FsYyBzbGlkZXNcblxuXG4gICAgICBsZXQgc2xpZGVTaXplO1xuICAgICAgY29uc3Qgc2hvdWxkUmVzZXRTbGlkZVNpemUgPSBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5icmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhwYXJhbXMuYnJlYWtwb2ludHMpLmZpbHRlcihrZXkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhcmFtcy5icmVha3BvaW50c1trZXldLnNsaWRlc1BlclZpZXcgIT09ICd1bmRlZmluZWQnO1xuICAgICAgfSkubGVuZ3RoID4gMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzbGlkZVNpemUgPSAwO1xuICAgICAgICBjb25zdCBzbGlkZSA9IHNsaWRlcy5lcShpKTtcblxuICAgICAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgICAgICBzd2lwZXIuZ3JpZC51cGRhdGVTbGlkZShpLCBzbGlkZSwgc2xpZGVzTGVuZ3RoLCBnZXREaXJlY3Rpb25MYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2xpZGUuY3NzKCdkaXNwbGF5JykgPT09ICdub25lJykgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJykge1xuICAgICAgICAgIGlmIChzaG91bGRSZXNldFNsaWRlU2l6ZSkge1xuICAgICAgICAgICAgc2xpZGVzW2ldLnN0eWxlW2dldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IGBgO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHNsaWRlU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZVswXSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IHNsaWRlWzBdLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50V2ViS2l0VHJhbnNmb3JtID0gc2xpZGVbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHNsaWRlWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICdub25lJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudFdlYktpdFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgc2xpZGVbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSB7XG4gICAgICAgICAgICBzbGlkZVNpemUgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBzbGlkZS5vdXRlcldpZHRoKHRydWUpIDogc2xpZGUub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnd2lkdGgnKTtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdMZWZ0ID0gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShzbGlkZVN0eWxlcywgJ3BhZGRpbmctbGVmdCcpO1xuICAgICAgICAgICAgY29uc3QgcGFkZGluZ1JpZ2h0ID0gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShzbGlkZVN0eWxlcywgJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnbWFyZ2luLWxlZnQnKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpblJpZ2h0ID0gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShzbGlkZVN0eWxlcywgJ21hcmdpbi1yaWdodCcpO1xuICAgICAgICAgICAgY29uc3QgYm94U2l6aW5nID0gc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnYm94LXNpemluZycpO1xuXG4gICAgICAgICAgICBpZiAoYm94U2l6aW5nICYmIGJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XG4gICAgICAgICAgICAgIHNsaWRlU2l6ZSA9IHdpZHRoICsgbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG9mZnNldFdpZHRoXG4gICAgICAgICAgICAgIH0gPSBzbGlkZVswXTtcbiAgICAgICAgICAgICAgc2xpZGVTaXplID0gd2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodCArIChvZmZzZXRXaWR0aCAtIGNsaWVudFdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgc2xpZGVbMF0uc3R5bGUudHJhbnNmb3JtID0gY3VycmVudFRyYW5zZm9ybTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudFdlYktpdFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgc2xpZGVbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gY3VycmVudFdlYktpdFRyYW5zZm9ybTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVTaXplID0gTWF0aC5mbG9vcihzbGlkZVNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNsaWRlU2l6ZSA9IChzd2lwZXJTaXplIC0gKHBhcmFtcy5zbGlkZXNQZXJWaWV3IC0gMSkgKiBzcGFjZUJldHdlZW4pIC8gcGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gICAgICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcblxuICAgICAgICAgIGlmIChzbGlkZXNbaV0pIHtcbiAgICAgICAgICAgIHNsaWRlc1tpXS5zdHlsZVtnZXREaXJlY3Rpb25MYWJlbCgnd2lkdGgnKV0gPSBgJHtzbGlkZVNpemV9cHhgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbGlkZXNbaV0pIHtcbiAgICAgICAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplID0gc2xpZGVTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgc2xpZGVzU2l6ZXNHcmlkLnB1c2goc2xpZGVTaXplKTtcblxuICAgICAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gKyBzbGlkZVNpemUgLyAyICsgcHJldlNsaWRlU2l6ZSAvIDIgKyBzcGFjZUJldHdlZW47XG4gICAgICAgICAgaWYgKHByZXZTbGlkZVNpemUgPT09IDAgJiYgaSAhPT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSBzd2lwZXJTaXplIC8gMiAtIHNwYWNlQmV0d2VlbjtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSBzd2lwZXJTaXplIC8gMiAtIHNwYWNlQmV0d2VlbjtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoc2xpZGVQb3NpdGlvbikgPCAxIC8gMTAwMCkgc2xpZGVQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xuICAgICAgICAgIGlmIChpbmRleCAlIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMCkgc25hcEdyaWQucHVzaChzbGlkZVBvc2l0aW9uKTtcbiAgICAgICAgICBzbGlkZXNHcmlkLnB1c2goc2xpZGVQb3NpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xuICAgICAgICAgIGlmICgoaW5kZXggLSBNYXRoLm1pbihzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgaW5kZXgpKSAlIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDApIHNuYXBHcmlkLnB1c2goc2xpZGVQb3NpdGlvbik7XG4gICAgICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgICAgIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uICsgc2xpZGVTaXplICsgc3BhY2VCZXR3ZWVuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLnZpcnR1YWxTaXplICs9IHNsaWRlU2l6ZSArIHNwYWNlQmV0d2VlbjtcbiAgICAgICAgcHJldlNsaWRlU2l6ZSA9IHNsaWRlU2l6ZTtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLnZpcnR1YWxTaXplID0gTWF0aC5tYXgoc3dpcGVyLnZpcnR1YWxTaXplLCBzd2lwZXJTaXplKSArIG9mZnNldEFmdGVyO1xuXG4gICAgICBpZiAocnRsICYmIHdyb25nUlRMICYmIChwYXJhbXMuZWZmZWN0ID09PSAnc2xpZGUnIHx8IHBhcmFtcy5lZmZlY3QgPT09ICdjb3ZlcmZsb3cnKSkge1xuICAgICAgICAkd3JhcHBlckVsLmNzcyh7XG4gICAgICAgICAgd2lkdGg6IGAke3N3aXBlci52aXJ0dWFsU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW59cHhgXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnNldFdyYXBwZXJTaXplKSB7XG4gICAgICAgICR3cmFwcGVyRWwuY3NzKHtcbiAgICAgICAgICBbZ2V0RGlyZWN0aW9uTGFiZWwoJ3dpZHRoJyldOiBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVufXB4YFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgIHN3aXBlci5ncmlkLnVwZGF0ZVdyYXBwZXJTaXplKHNsaWRlU2l6ZSwgc25hcEdyaWQsIGdldERpcmVjdGlvbkxhYmVsKTtcbiAgICAgIH0gLy8gUmVtb3ZlIGxhc3QgZ3JpZCBlbGVtZW50cyBkZXBlbmRpbmcgb24gd2lkdGhcblxuXG4gICAgICBpZiAoIXBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICBjb25zdCBuZXdTbGlkZXNHcmlkID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFwR3JpZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGxldCBzbGlkZXNHcmlkSXRlbSA9IHNuYXBHcmlkW2ldO1xuICAgICAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZXNHcmlkSXRlbSA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZEl0ZW0pO1xuXG4gICAgICAgICAgaWYgKHNuYXBHcmlkW2ldIDw9IHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIHtcbiAgICAgICAgICAgIG5ld1NsaWRlc0dyaWQucHVzaChzbGlkZXNHcmlkSXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc25hcEdyaWQgPSBuZXdTbGlkZXNHcmlkO1xuXG4gICAgICAgIGlmIChNYXRoLmZsb29yKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIC0gTWF0aC5mbG9vcihzbmFwR3JpZFtzbmFwR3JpZC5sZW5ndGggLSAxXSkgPiAxKSB7XG4gICAgICAgICAgc25hcEdyaWQucHVzaChzd2lwZXIudmlydHVhbFNpemUgLSBzd2lwZXJTaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc25hcEdyaWQubGVuZ3RoID09PSAwKSBzbmFwR3JpZCA9IFswXTtcblxuICAgICAgaWYgKHBhcmFtcy5zcGFjZUJldHdlZW4gIT09IDApIHtcbiAgICAgICAgY29uc3Qga2V5ID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpICYmIHJ0bCA/ICdtYXJnaW5MZWZ0JyA6IGdldERpcmVjdGlvbkxhYmVsKCdtYXJnaW5SaWdodCcpO1xuICAgICAgICBzbGlkZXMuZmlsdGVyKChfLCBzbGlkZUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCFwYXJhbXMuY3NzTW9kZSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICBpZiAoc2xpZGVJbmRleCA9PT0gc2xpZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSkuY3NzKHtcbiAgICAgICAgICBba2V5XTogYCR7c3BhY2VCZXR3ZWVufXB4YFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXNCb3VuZHMpIHtcbiAgICAgICAgbGV0IGFsbFNsaWRlc1NpemUgPSAwO1xuICAgICAgICBzbGlkZXNTaXplc0dyaWQuZm9yRWFjaChzbGlkZVNpemVWYWx1ZSA9PiB7XG4gICAgICAgICAgYWxsU2xpZGVzU2l6ZSArPSBzbGlkZVNpemVWYWx1ZSArIChwYXJhbXMuc3BhY2VCZXR3ZWVuID8gcGFyYW1zLnNwYWNlQmV0d2VlbiA6IDApO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsU2xpZGVzU2l6ZSAtPSBwYXJhbXMuc3BhY2VCZXR3ZWVuO1xuICAgICAgICBjb25zdCBtYXhTbmFwID0gYWxsU2xpZGVzU2l6ZSAtIHN3aXBlclNpemU7XG4gICAgICAgIHNuYXBHcmlkID0gc25hcEdyaWQubWFwKHNuYXAgPT4ge1xuICAgICAgICAgIGlmIChzbmFwIDwgMCkgcmV0dXJuIC1vZmZzZXRCZWZvcmU7XG4gICAgICAgICAgaWYgKHNuYXAgPiBtYXhTbmFwKSByZXR1cm4gbWF4U25hcCArIG9mZnNldEFmdGVyO1xuICAgICAgICAgIHJldHVybiBzbmFwO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5jZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMpIHtcbiAgICAgICAgbGV0IGFsbFNsaWRlc1NpemUgPSAwO1xuICAgICAgICBzbGlkZXNTaXplc0dyaWQuZm9yRWFjaChzbGlkZVNpemVWYWx1ZSA9PiB7XG4gICAgICAgICAgYWxsU2xpZGVzU2l6ZSArPSBzbGlkZVNpemVWYWx1ZSArIChwYXJhbXMuc3BhY2VCZXR3ZWVuID8gcGFyYW1zLnNwYWNlQmV0d2VlbiA6IDApO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsU2xpZGVzU2l6ZSAtPSBwYXJhbXMuc3BhY2VCZXR3ZWVuO1xuXG4gICAgICAgIGlmIChhbGxTbGlkZXNTaXplIDwgc3dpcGVyU2l6ZSkge1xuICAgICAgICAgIGNvbnN0IGFsbFNsaWRlc09mZnNldCA9IChzd2lwZXJTaXplIC0gYWxsU2xpZGVzU2l6ZSkgLyAyO1xuICAgICAgICAgIHNuYXBHcmlkLmZvckVhY2goKHNuYXAsIHNuYXBJbmRleCkgPT4ge1xuICAgICAgICAgICAgc25hcEdyaWRbc25hcEluZGV4XSA9IHNuYXAgLSBhbGxTbGlkZXNPZmZzZXQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2xpZGVzR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgICAgICAgIHNsaWRlc0dyaWRbc25hcEluZGV4XSA9IHNuYXAgKyBhbGxTbGlkZXNPZmZzZXQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgc2xpZGVzLFxuICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgc2xpZGVzR3JpZCxcbiAgICAgICAgc2xpZGVzU2l6ZXNHcmlkXG4gICAgICB9KTtcblxuICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuY3NzTW9kZSAmJiAhcGFyYW1zLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XG4gICAgICAgIHNldENTU1Byb3BlcnR5KHN3aXBlci53cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYmVmb3JlJywgYCR7LXNuYXBHcmlkWzBdfXB4YCk7XG4gICAgICAgIHNldENTU1Byb3BlcnR5KHN3aXBlci53cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYWZ0ZXInLCBgJHtzd2lwZXIuc2l6ZSAvIDIgLSBzbGlkZXNTaXplc0dyaWRbc2xpZGVzU2l6ZXNHcmlkLmxlbmd0aCAtIDFdIC8gMn1weGApO1xuICAgICAgICBjb25zdCBhZGRUb1NuYXBHcmlkID0gLXN3aXBlci5zbmFwR3JpZFswXTtcbiAgICAgICAgY29uc3QgYWRkVG9TbGlkZXNHcmlkID0gLXN3aXBlci5zbGlkZXNHcmlkWzBdO1xuICAgICAgICBzd2lwZXIuc25hcEdyaWQgPSBzd2lwZXIuc25hcEdyaWQubWFwKHYgPT4gdiArIGFkZFRvU25hcEdyaWQpO1xuICAgICAgICBzd2lwZXIuc2xpZGVzR3JpZCA9IHN3aXBlci5zbGlkZXNHcmlkLm1hcCh2ID0+IHYgKyBhZGRUb1NsaWRlc0dyaWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2xpZGVzTGVuZ3RoICE9PSBwcmV2aW91c1NsaWRlc0xlbmd0aCkge1xuICAgICAgICBzd2lwZXIuZW1pdCgnc2xpZGVzTGVuZ3RoQ2hhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzbmFwR3JpZC5sZW5ndGggIT09IHByZXZpb3VzU25hcEdyaWRMZW5ndGgpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdykgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3NuYXBHcmlkTGVuZ3RoQ2hhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzbGlkZXNHcmlkLmxlbmd0aCAhPT0gcHJldmlvdXNTbGlkZXNHcmlkTGVuZ3RoKSB7XG4gICAgICAgIHN3aXBlci5lbWl0KCdzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcykge1xuICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzT2Zmc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNWaXJ0dWFsICYmICFwYXJhbXMuY3NzTW9kZSAmJiAocGFyYW1zLmVmZmVjdCA9PT0gJ3NsaWRlJyB8fCBwYXJhbXMuZWZmZWN0ID09PSAnZmFkZScpKSB7XG4gICAgICAgIGNvbnN0IGJhY2tGYWNlSGlkZGVuQ2xhc3MgPSBgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31iYWNrZmFjZS1oaWRkZW5gO1xuICAgICAgICBjb25zdCBoYXNDbGFzc0JhY2tmYWNlQ2xhc3NBZGRlZCA9IHN3aXBlci4kZWwuaGFzQ2xhc3MoYmFja0ZhY2VIaWRkZW5DbGFzcyk7XG5cbiAgICAgICAgaWYgKHNsaWRlc0xlbmd0aCA8PSBwYXJhbXMubWF4QmFja2ZhY2VIaWRkZW5TbGlkZXMpIHtcbiAgICAgICAgICBpZiAoIWhhc0NsYXNzQmFja2ZhY2VDbGFzc0FkZGVkKSBzd2lwZXIuJGVsLmFkZENsYXNzKGJhY2tGYWNlSGlkZGVuQ2xhc3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0NsYXNzQmFja2ZhY2VDbGFzc0FkZGVkKSB7XG4gICAgICAgICAgc3dpcGVyLiRlbC5yZW1vdmVDbGFzcyhiYWNrRmFjZUhpZGRlbkNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUF1dG9IZWlnaHQoc3BlZWQpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBhY3RpdmVTbGlkZXMgPSBbXTtcbiAgICAgIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgICAgbGV0IG5ld0hlaWdodCA9IDA7XG4gICAgICBsZXQgaTtcblxuICAgICAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xuICAgICAgfSBlbHNlIGlmIChzcGVlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzd2lwZXIucGFyYW1zLnNwZWVkKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ2V0U2xpZGVCeUluZGV4ID0gaW5kZXggPT4ge1xuICAgICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZXMuZmlsdGVyKGVsID0+IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApID09PSBpbmRleClbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3dpcGVyLnNsaWRlcy5lcShpbmRleClbMF07XG4gICAgICB9OyAvLyBGaW5kIHNsaWRlcyBjdXJyZW50bHkgaW4gdmlld1xuXG5cbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgIT09ICdhdXRvJyAmJiBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgKHN3aXBlci52aXNpYmxlU2xpZGVzIHx8ICQoW10pKS5lYWNoKHNsaWRlID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZVNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTWF0aC5jZWlsKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyk7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggKyBpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGggJiYgIWlzVmlydHVhbCkgYnJlYWs7XG4gICAgICAgICAgICBhY3RpdmVTbGlkZXMucHVzaChnZXRTbGlkZUJ5SW5kZXgoaW5kZXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZVNsaWRlcy5wdXNoKGdldFNsaWRlQnlJbmRleChzd2lwZXIuYWN0aXZlSW5kZXgpKTtcbiAgICAgIH0gLy8gRmluZCBuZXcgaGVpZ2h0IGZyb20gaGlnaGVzdCBzbGlkZSBpbiB2aWV3XG5cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZVNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIGFjdGl2ZVNsaWRlc1tpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBhY3RpdmVTbGlkZXNbaV0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIG5ld0hlaWdodCA9IGhlaWdodCA+IG5ld0hlaWdodCA/IGhlaWdodCA6IG5ld0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBVcGRhdGUgSGVpZ2h0XG5cblxuICAgICAgaWYgKG5ld0hlaWdodCB8fCBuZXdIZWlnaHQgPT09IDApIHN3aXBlci4kd3JhcHBlckVsLmNzcygnaGVpZ2h0JywgYCR7bmV3SGVpZ2h0fXB4YCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2xpZGVzT2Zmc2V0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHNsaWRlcyA9IHN3aXBlci5zbGlkZXM7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHNsaWRlc1tpXS5zd2lwZXJTbGlkZU9mZnNldCA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHNsaWRlc1tpXS5vZmZzZXRMZWZ0IDogc2xpZGVzW2ldLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTbGlkZXNQcm9ncmVzcyh0cmFuc2xhdGUpIHtcbiAgICAgIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICB0cmFuc2xhdGUgPSB0aGlzICYmIHRoaXMudHJhbnNsYXRlIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbGlkZXMsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgICAgICBzbmFwR3JpZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmIChzbGlkZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHNsaWRlc1swXS5zd2lwZXJTbGlkZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHN3aXBlci51cGRhdGVTbGlkZXNPZmZzZXQoKTtcbiAgICAgIGxldCBvZmZzZXRDZW50ZXIgPSAtdHJhbnNsYXRlO1xuICAgICAgaWYgKHJ0bCkgb2Zmc2V0Q2VudGVyID0gdHJhbnNsYXRlOyAvLyBWaXNpYmxlIFNsaWRlc1xuXG4gICAgICBzbGlkZXMucmVtb3ZlQ2xhc3MocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcbiAgICAgIHN3aXBlci52aXNpYmxlU2xpZGVzSW5kZXhlcyA9IFtdO1xuICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgc2xpZGUgPSBzbGlkZXNbaV07XG4gICAgICAgIGxldCBzbGlkZU9mZnNldCA9IHNsaWRlLnN3aXBlclNsaWRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgICAgICBzbGlkZU9mZnNldCAtPSBzbGlkZXNbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzbGlkZVByb2dyZXNzID0gKG9mZnNldENlbnRlciArIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBzd2lwZXIubWluVHJhbnNsYXRlKCkgOiAwKSAtIHNsaWRlT2Zmc2V0KSAvIChzbGlkZS5zd2lwZXJTbGlkZVNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVuKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTbGlkZVByb2dyZXNzID0gKG9mZnNldENlbnRlciAtIHNuYXBHcmlkWzBdICsgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5taW5UcmFuc2xhdGUoKSA6IDApIC0gc2xpZGVPZmZzZXQpIC8gKHNsaWRlLnN3aXBlclNsaWRlU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW4pO1xuICAgICAgICBjb25zdCBzbGlkZUJlZm9yZSA9IC0ob2Zmc2V0Q2VudGVyIC0gc2xpZGVPZmZzZXQpO1xuICAgICAgICBjb25zdCBzbGlkZUFmdGVyID0gc2xpZGVCZWZvcmUgKyBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW2ldO1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBzbGlkZUJlZm9yZSA+PSAwICYmIHNsaWRlQmVmb3JlIDwgc3dpcGVyLnNpemUgLSAxIHx8IHNsaWRlQWZ0ZXIgPiAxICYmIHNsaWRlQWZ0ZXIgPD0gc3dpcGVyLnNpemUgfHwgc2xpZGVCZWZvcmUgPD0gMCAmJiBzbGlkZUFmdGVyID49IHN3aXBlci5zaXplO1xuXG4gICAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgICBzd2lwZXIudmlzaWJsZVNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAgICAgICBzd2lwZXIudmlzaWJsZVNsaWRlc0luZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICBzbGlkZXMuZXEoaSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNsaWRlLnByb2dyZXNzID0gcnRsID8gLXNsaWRlUHJvZ3Jlc3MgOiBzbGlkZVByb2dyZXNzO1xuICAgICAgICBzbGlkZS5vcmlnaW5hbFByb2dyZXNzID0gcnRsID8gLW9yaWdpbmFsU2xpZGVQcm9ncmVzcyA6IG9yaWdpbmFsU2xpZGVQcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXMgPSAkKHN3aXBlci52aXNpYmxlU2xpZGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcyh0cmFuc2xhdGUpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgdHJhbnNsYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IC0xIDogMTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgdHJhbnNsYXRlID0gc3dpcGVyICYmIHN3aXBlci50cmFuc2xhdGUgJiYgc3dpcGVyLnRyYW5zbGF0ZSAqIG11bHRpcGxpZXIgfHwgMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgbGV0IHtcbiAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgIGlzQmVnaW5uaW5nLFxuICAgICAgICBpc0VuZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGNvbnN0IHdhc0JlZ2lubmluZyA9IGlzQmVnaW5uaW5nO1xuICAgICAgY29uc3Qgd2FzRW5kID0gaXNFbmQ7XG5cbiAgICAgIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgICAgICBwcm9ncmVzcyA9IDA7XG4gICAgICAgIGlzQmVnaW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgaXNFbmQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSAodHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xuICAgICAgICBpc0JlZ2lubmluZyA9IHByb2dyZXNzIDw9IDA7XG4gICAgICAgIGlzRW5kID0gcHJvZ3Jlc3MgPj0gMTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgIGlzQmVnaW5uaW5nLFxuICAgICAgICBpc0VuZFxuICAgICAgfSk7XG4gICAgICBpZiAocGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfHwgcGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmIHBhcmFtcy5hdXRvSGVpZ2h0KSBzd2lwZXIudXBkYXRlU2xpZGVzUHJvZ3Jlc3ModHJhbnNsYXRlKTtcblxuICAgICAgaWYgKGlzQmVnaW5uaW5nICYmICF3YXNCZWdpbm5pbmcpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3JlYWNoQmVnaW5uaW5nIHRvRWRnZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFbmQgJiYgIXdhc0VuZCkge1xuICAgICAgICBzd2lwZXIuZW1pdCgncmVhY2hFbmQgdG9FZGdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3YXNCZWdpbm5pbmcgJiYgIWlzQmVnaW5uaW5nIHx8IHdhc0VuZCAmJiAhaXNFbmQpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ2Zyb21FZGdlJyk7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KCdwcm9ncmVzcycsIHByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTbGlkZXNDbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2xpZGVzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICByZWFsSW5kZXhcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgICAgc2xpZGVzLnJlbW92ZUNsYXNzKGAke3BhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzfSAke3BhcmFtcy5zbGlkZU5leHRDbGFzc30gJHtwYXJhbXMuc2xpZGVQcmV2Q2xhc3N9ICR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3N9ICR7cGFyYW1zLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzfSAke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzc31gKTtcbiAgICAgIGxldCBhY3RpdmVTbGlkZTtcblxuICAgICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgICBhY3RpdmVTbGlkZSA9IHN3aXBlci4kd3JhcHBlckVsLmZpbmQoYC4ke3BhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7YWN0aXZlSW5kZXh9XCJdYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVTbGlkZSA9IHNsaWRlcy5lcShhY3RpdmVJbmRleCk7XG4gICAgICB9IC8vIEFjdGl2ZSBjbGFzc2VzXG5cblxuICAgICAgYWN0aXZlU2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MpO1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgLy8gRHVwbGljYXRlIHRvIGFsbCBsb29wZWQgc2xpZGVzXG4gICAgICAgIGlmIChhY3RpdmVTbGlkZS5oYXNDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc306bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl1gKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyZWFsSW5kZXh9XCJdYCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9IC8vIE5leHQgU2xpZGVcblxuXG4gICAgICBsZXQgbmV4dFNsaWRlID0gYWN0aXZlU2xpZGUubmV4dEFsbChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCkuZXEoMCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcblxuICAgICAgaWYgKHBhcmFtcy5sb29wICYmIG5leHRTbGlkZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbmV4dFNsaWRlID0gc2xpZGVzLmVxKDApO1xuICAgICAgICBuZXh0U2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcbiAgICAgIH0gLy8gUHJldiBTbGlkZVxuXG5cbiAgICAgIGxldCBwcmV2U2xpZGUgPSBhY3RpdmVTbGlkZS5wcmV2QWxsKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKS5lcSgwKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVQcmV2Q2xhc3MpO1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3AgJiYgcHJldlNsaWRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwcmV2U2xpZGUgPSBzbGlkZXMuZXEoLTEpO1xuICAgICAgICBwcmV2U2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlUHJldkNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgIC8vIER1cGxpY2F0ZSB0byBhbGwgbG9vcGVkIHNsaWRlc1xuICAgICAgICBpZiAobmV4dFNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgICAgICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7bmV4dFNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyl9XCJdYCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke25leHRTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVwiXWApLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZU5leHRDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgICAgICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cHJldlNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyl9XCJdYCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlUHJldkNsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3ByZXZTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVwiXWApLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXRTbGlkZXNDbGFzc2VzKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQWN0aXZlSW5kZXgobmV3QWN0aXZlSW5kZXgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB0cmFuc2xhdGUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbGlkZXNHcmlkLFxuICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBhY3RpdmVJbmRleDogcHJldmlvdXNJbmRleCxcbiAgICAgICAgcmVhbEluZGV4OiBwcmV2aW91c1JlYWxJbmRleCxcbiAgICAgICAgc25hcEluZGV4OiBwcmV2aW91c1NuYXBJbmRleFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGxldCBhY3RpdmVJbmRleCA9IG5ld0FjdGl2ZUluZGV4O1xuICAgICAgbGV0IHNuYXBJbmRleDtcblxuICAgICAgaWYgKHR5cGVvZiBhY3RpdmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzbGlkZXNHcmlkW2kgKyAxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSAmJiB0cmFuc2xhdGUgPCBzbGlkZXNHcmlkW2kgKyAxXSAtIChzbGlkZXNHcmlkW2kgKyAxXSAtIHNsaWRlc0dyaWRbaV0pIC8gMikge1xuICAgICAgICAgICAgICBhY3RpdmVJbmRleCA9IGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldICYmIHRyYW5zbGF0ZSA8IHNsaWRlc0dyaWRbaSArIDFdKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZUluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSkge1xuICAgICAgICAgICAgYWN0aXZlSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBOb3JtYWxpemUgc2xpZGVJbmRleFxuXG5cbiAgICAgICAgaWYgKHBhcmFtcy5ub3JtYWxpemVTbGlkZUluZGV4KSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZUluZGV4IDwgMCB8fCB0eXBlb2YgYWN0aXZlSW5kZXggPT09ICd1bmRlZmluZWQnKSBhY3RpdmVJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKSA+PSAwKSB7XG4gICAgICAgIHNuYXBJbmRleCA9IHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNraXAgPSBNYXRoLm1pbihwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBhY3RpdmVJbmRleCk7XG4gICAgICAgIHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChhY3RpdmVJbmRleCAtIHNraXApIC8gcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNuYXBJbmRleCA+PSBzbmFwR3JpZC5sZW5ndGgpIHNuYXBJbmRleCA9IHNuYXBHcmlkLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICBpZiAoc25hcEluZGV4ICE9PSBwcmV2aW91c1NuYXBJbmRleCkge1xuICAgICAgICAgIHN3aXBlci5zbmFwSW5kZXggPSBzbmFwSW5kZXg7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ3NuYXBJbmRleENoYW5nZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBHZXQgcmVhbCBpbmRleFxuXG5cbiAgICAgIGNvbnN0IHJlYWxJbmRleCA9IHBhcnNlSW50KHN3aXBlci5zbGlkZXMuZXEoYWN0aXZlSW5kZXgpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgfHwgYWN0aXZlSW5kZXgsIDEwKTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgICAgIHNuYXBJbmRleCxcbiAgICAgICAgcmVhbEluZGV4LFxuICAgICAgICBwcmV2aW91c0luZGV4LFxuICAgICAgICBhY3RpdmVJbmRleFxuICAgICAgfSk7XG4gICAgICBzd2lwZXIuZW1pdCgnYWN0aXZlSW5kZXhDaGFuZ2UnKTtcbiAgICAgIHN3aXBlci5lbWl0KCdzbmFwSW5kZXhDaGFuZ2UnKTtcblxuICAgICAgaWYgKHByZXZpb3VzUmVhbEluZGV4ICE9PSByZWFsSW5kZXgpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3JlYWxJbmRleENoYW5nZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGVyLmluaXRpYWxpemVkIHx8IHN3aXBlci5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0KSB7XG4gICAgICAgIHN3aXBlci5lbWl0KCdzbGlkZUNoYW5nZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNsaWNrZWRTbGlkZShlKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgICAgIGNvbnN0IHNsaWRlID0gJChlKS5jbG9zZXN0KGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKVswXTtcbiAgICAgIGxldCBzbGlkZUZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgc2xpZGVJbmRleDtcblxuICAgICAgaWYgKHNsaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChzd2lwZXIuc2xpZGVzW2ldID09PSBzbGlkZSkge1xuICAgICAgICAgICAgc2xpZGVGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBzbGlkZUluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2xpZGUgJiYgc2xpZGVGb3VuZCkge1xuICAgICAgICBzd2lwZXIuY2xpY2tlZFNsaWRlID0gc2xpZGU7XG5cbiAgICAgICAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgICAgICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHBhcnNlSW50KCQoc2xpZGUpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gc2xpZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLmNsaWNrZWRTbGlkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnNsaWRlVG9DbGlja2VkU2xpZGUgJiYgc3dpcGVyLmNsaWNrZWRJbmRleCAhPT0gdW5kZWZpbmVkICYmIHN3aXBlci5jbGlja2VkSW5kZXggIT09IHN3aXBlci5hY3RpdmVJbmRleCkge1xuICAgICAgICBzd2lwZXIuc2xpZGVUb0NsaWNrZWRTbGlkZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICB1cGRhdGVTaXplLFxuICAgICAgdXBkYXRlU2xpZGVzLFxuICAgICAgdXBkYXRlQXV0b0hlaWdodCxcbiAgICAgIHVwZGF0ZVNsaWRlc09mZnNldCxcbiAgICAgIHVwZGF0ZVNsaWRlc1Byb2dyZXNzLFxuICAgICAgdXBkYXRlUHJvZ3Jlc3MsXG4gICAgICB1cGRhdGVTbGlkZXNDbGFzc2VzLFxuICAgICAgdXBkYXRlQWN0aXZlSW5kZXgsXG4gICAgICB1cGRhdGVDbGlja2VkU2xpZGVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0U3dpcGVyVHJhbnNsYXRlKGF4aXMpIHtcbiAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHtcbiAgICAgICAgYXhpcyA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyAneCcgOiAneSc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgJHdyYXBwZXJFbFxuICAgICAgfSA9IHN3aXBlcjtcblxuICAgICAgaWYgKHBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlKSB7XG4gICAgICAgIHJldHVybiBydGwgPyAtdHJhbnNsYXRlIDogdHJhbnNsYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGN1cnJlbnRUcmFuc2xhdGUgPSBnZXRUcmFuc2xhdGUoJHdyYXBwZXJFbFswXSwgYXhpcyk7XG4gICAgICBpZiAocnRsKSBjdXJyZW50VHJhbnNsYXRlID0gLWN1cnJlbnRUcmFuc2xhdGU7XG4gICAgICByZXR1cm4gY3VycmVudFRyYW5zbGF0ZSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZSh0cmFuc2xhdGUsIGJ5Q29udHJvbGxlcikge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgJHdyYXBwZXJFbCxcbiAgICAgICAgd3JhcHBlckVsLFxuICAgICAgICBwcm9ncmVzc1xuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGxldCB4ID0gMDtcbiAgICAgIGxldCB5ID0gMDtcbiAgICAgIGNvbnN0IHogPSAwO1xuXG4gICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHggPSBydGwgPyAtdHJhbnNsYXRlIDogdHJhbnNsYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHRyYW5zbGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHtcbiAgICAgICAgeCA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgIHkgPSBNYXRoLmZsb29yKHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgd3JhcHBlckVsW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IC14IDogLXk7XG4gICAgICB9IGVsc2UgaWYgKCFwYXJhbXMudmlydHVhbFRyYW5zbGF0ZSkge1xuICAgICAgICAkd3JhcHBlckVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsICR7en1weClgKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLnByZXZpb3VzVHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICAgIHN3aXBlci50cmFuc2xhdGUgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB4IDogeTsgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byB1cGRhdGUgcHJvZ3Jlc3NcblxuICAgICAgbGV0IG5ld1Byb2dyZXNzO1xuICAgICAgY29uc3QgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG5cbiAgICAgIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgICAgICBuZXdQcm9ncmVzcyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdQcm9ncmVzcyA9ICh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIC8gdHJhbnNsYXRlc0RpZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdQcm9ncmVzcyAhPT0gcHJvZ3Jlc3MpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHRyYW5zbGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KCdzZXRUcmFuc2xhdGUnLCBzd2lwZXIudHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1pblRyYW5zbGF0ZSgpIHtcbiAgICAgIHJldHVybiAtdGhpcy5zbmFwR3JpZFswXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXhUcmFuc2xhdGUoKSB7XG4gICAgICByZXR1cm4gLXRoaXMuc25hcEdyaWRbdGhpcy5zbmFwR3JpZC5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVUbyh0cmFuc2xhdGUsIHNwZWVkLCBydW5DYWxsYmFja3MsIHRyYW5zbGF0ZUJvdW5kcywgaW50ZXJuYWwpIHtcbiAgICAgIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICB0cmFuc2xhdGUgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlZWQgPT09IHZvaWQgMCkge1xuICAgICAgICBzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkO1xuICAgICAgfVxuXG4gICAgICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICAgICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zbGF0ZUJvdW5kcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRyYW5zbGF0ZUJvdW5kcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgd3JhcHBlckVsXG4gICAgICB9ID0gc3dpcGVyO1xuXG4gICAgICBpZiAoc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWluVHJhbnNsYXRlID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgY29uc3QgbWF4VHJhbnNsYXRlID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICAgICAgbGV0IG5ld1RyYW5zbGF0ZTtcbiAgICAgIGlmICh0cmFuc2xhdGVCb3VuZHMgJiYgdHJhbnNsYXRlID4gbWluVHJhbnNsYXRlKSBuZXdUcmFuc2xhdGUgPSBtaW5UcmFuc2xhdGU7ZWxzZSBpZiAodHJhbnNsYXRlQm91bmRzICYmIHRyYW5zbGF0ZSA8IG1heFRyYW5zbGF0ZSkgbmV3VHJhbnNsYXRlID0gbWF4VHJhbnNsYXRlO2Vsc2UgbmV3VHJhbnNsYXRlID0gdHJhbnNsYXRlOyAvLyBVcGRhdGUgcHJvZ3Jlc3NcblxuICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKG5ld1RyYW5zbGF0ZSk7XG5cbiAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICBjb25zdCBpc0ggPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XG5cbiAgICAgICAgaWYgKHNwZWVkID09PSAwKSB7XG4gICAgICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IC1uZXdUcmFuc2xhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzd2lwZXIuc3VwcG9ydC5zbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgICAgIGFuaW1hdGVDU1NNb2RlU2Nyb2xsKHtcbiAgICAgICAgICAgICAgc3dpcGVyLFxuICAgICAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogLW5ld1RyYW5zbGF0ZSxcbiAgICAgICAgICAgICAgc2lkZTogaXNIID8gJ2xlZnQnIDogJ3RvcCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgICAgICAgIFtpc0ggPyAnbGVmdCcgOiAndG9wJ106IC1uZXdUcmFuc2xhdGUsXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcblxuICAgICAgICBpZiAocnVuQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIHNwZWVkLCBpbnRlcm5hbCk7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25FbmQnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1RyYW5zbGF0ZSk7XG5cbiAgICAgICAgaWYgKHJ1bkNhbGxiYWNrcykge1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uU3RhcnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSB7XG4gICAgICAgICAgICBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gdHJhbnNpdGlvbkVuZChlKSB7XG4gICAgICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgICBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgZGVsZXRlIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQ7XG5cbiAgICAgICAgICAgICAgaWYgKHJ1bkNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uRW5kJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgZ2V0VHJhbnNsYXRlOiBnZXRTd2lwZXJUcmFuc2xhdGUsXG4gICAgICBzZXRUcmFuc2xhdGUsXG4gICAgICBtaW5UcmFuc2xhdGUsXG4gICAgICBtYXhUcmFuc2xhdGUsXG4gICAgICB0cmFuc2xhdGVUb1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIHN3aXBlci4kd3JhcHBlckVsLnRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNpdGlvbicsIGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25FbWl0KF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgcnVuQ2FsbGJhY2tzLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHN0ZXBcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgcHJldmlvdXNJbmRleFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGxldCBkaXIgPSBkaXJlY3Rpb247XG5cbiAgICAgIGlmICghZGlyKSB7XG4gICAgICAgIGlmIChhY3RpdmVJbmRleCA+IHByZXZpb3VzSW5kZXgpIGRpciA9ICduZXh0JztlbHNlIGlmIChhY3RpdmVJbmRleCA8IHByZXZpb3VzSW5kZXgpIGRpciA9ICdwcmV2JztlbHNlIGRpciA9ICdyZXNldCc7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KGB0cmFuc2l0aW9uJHtzdGVwfWApO1xuXG4gICAgICBpZiAocnVuQ2FsbGJhY2tzICYmIGFjdGl2ZUluZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIGlmIChkaXIgPT09ICdyZXNldCcpIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdChgc2xpZGVSZXNldFRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmVtaXQoYHNsaWRlQ2hhbmdlVHJhbnNpdGlvbiR7c3RlcH1gKTtcblxuICAgICAgICBpZiAoZGlyID09PSAnbmV4dCcpIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdChgc2xpZGVOZXh0VHJhbnNpdGlvbiR7c3RlcH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdChgc2xpZGVQcmV2VHJhbnNpdGlvbiR7c3RlcH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtc1xuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuXG4gICAgICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbkVtaXQoe1xuICAgICAgICBzd2lwZXIsXG4gICAgICAgIHJ1bkNhbGxiYWNrcyxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBzdGVwOiAnU3RhcnQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kJDEocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pIHtcbiAgICAgIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgICAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBzd2lwZXIuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHJldHVybjtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuICAgICAgdHJhbnNpdGlvbkVtaXQoe1xuICAgICAgICBzd2lwZXIsXG4gICAgICAgIHJ1bkNhbGxiYWNrcyxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBzdGVwOiAnRW5kJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb24kMSA9IHtcbiAgICAgIHNldFRyYW5zaXRpb24sXG4gICAgICB0cmFuc2l0aW9uU3RhcnQsXG4gICAgICB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kJDFcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2xpZGVUbyhpbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwsIGluaXRpYWwpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWVkID09PSB2b2lkIDApIHtcbiAgICAgICAgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInICYmIHR5cGVvZiBpbmRleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2luZGV4JyBhcmd1bWVudCBjYW5ub3QgaGF2ZSB0eXBlIG90aGVyIHRoYW4gJ251bWJlcicgb3IgJ3N0cmluZycuIFske3R5cGVvZiBpbmRleH1dIGdpdmVuLmApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBpbmRleGAgYXJndW1lbnQgY29udmVydGVkIGZyb20gYHN0cmluZ2AgdG8gYG51bWJlcmAuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpbmRleEFzTnVtYmVyID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYGluZGV4YCBhcmd1bWVudCBpcyBhIHZhbGlkIGBudW1iZXJgXG4gICAgICAgICAqIGFmdGVyIGJlaW5nIGNvbnZlcnRlZCBmcm9tIHRoZSBgc3RyaW5nYCB0eXBlLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICAgICAgY29uc3QgaXNWYWxpZE51bWJlciA9IGlzRmluaXRlKGluZGV4QXNOdW1iZXIpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZE51bWJlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHBhc3NlZC1pbiAnaW5kZXgnIChzdHJpbmcpIGNvdWxkbid0IGJlIGNvbnZlcnRlZCB0byAnbnVtYmVyJy4gWyR7aW5kZXh9XSBnaXZlbi5gKTtcbiAgICAgICAgfSAvLyBLbm93aW5nIHRoYXQgdGhlIGNvbnZlcnRlZCBgaW5kZXhgIGlzIGEgdmFsaWQgbnVtYmVyLFxuICAgICAgICAvLyB3ZSBjYW4gdXBkYXRlIHRoZSBvcmlnaW5hbCBhcmd1bWVudCdzIHZhbHVlLlxuXG5cbiAgICAgICAgaW5kZXggPSBpbmRleEFzTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgbGV0IHNsaWRlSW5kZXggPSBpbmRleDtcbiAgICAgIGlmIChzbGlkZUluZGV4IDwgMCkgc2xpZGVJbmRleCA9IDA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgc25hcEdyaWQsXG4gICAgICAgIHNsaWRlc0dyaWQsXG4gICAgICAgIHByZXZpb3VzSW5kZXgsXG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICAgICAgd3JhcHBlckVsLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9ID0gc3dpcGVyO1xuXG4gICAgICBpZiAoc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uIHx8ICFlbmFibGVkICYmICFpbnRlcm5hbCAmJiAhaW5pdGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNraXAgPSBNYXRoLm1pbihzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgc2xpZGVJbmRleCk7XG4gICAgICBsZXQgc25hcEluZGV4ID0gc2tpcCArIE1hdGguZmxvb3IoKHNsaWRlSW5kZXggLSBza2lwKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgaWYgKHNuYXBJbmRleCA+PSBzbmFwR3JpZC5sZW5ndGgpIHNuYXBJbmRleCA9IHNuYXBHcmlkLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmICgoYWN0aXZlSW5kZXggfHwgcGFyYW1zLmluaXRpYWxTbGlkZSB8fCAwKSA9PT0gKHByZXZpb3VzSW5kZXggfHwgMCkgJiYgcnVuQ2FsbGJhY2tzKSB7XG4gICAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVTbGlkZUNoYW5nZVN0YXJ0Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IC1zbmFwR3JpZFtzbmFwSW5kZXhdOyAvLyBVcGRhdGUgcHJvZ3Jlc3NcblxuICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHRyYW5zbGF0ZSk7IC8vIE5vcm1hbGl6ZSBzbGlkZUluZGV4XG5cbiAgICAgIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkVHJhbnNsYXRlID0gLU1hdGguZmxvb3IodHJhbnNsYXRlICogMTAwKTtcbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkR3JpZCA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZFtpXSAqIDEwMCk7XG4gICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEdyaWROZXh0ID0gTWF0aC5mbG9vcihzbGlkZXNHcmlkW2kgKyAxXSAqIDEwMCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNsaWRlc0dyaWRbaSArIDFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRUcmFuc2xhdGUgPj0gbm9ybWFsaXplZEdyaWQgJiYgbm9ybWFsaXplZFRyYW5zbGF0ZSA8IG5vcm1hbGl6ZWRHcmlkTmV4dCAtIChub3JtYWxpemVkR3JpZE5leHQgLSBub3JtYWxpemVkR3JpZCkgLyAyKSB7XG4gICAgICAgICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHcmlkICYmIG5vcm1hbGl6ZWRUcmFuc2xhdGUgPCBub3JtYWxpemVkR3JpZE5leHQpIHtcbiAgICAgICAgICAgICAgc2xpZGVJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZFRyYW5zbGF0ZSA+PSBub3JtYWxpemVkR3JpZCkge1xuICAgICAgICAgICAgc2xpZGVJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIERpcmVjdGlvbnMgbG9ja3NcblxuXG4gICAgICBpZiAoc3dpcGVyLmluaXRpYWxpemVkICYmIHNsaWRlSW5kZXggIT09IGFjdGl2ZUluZGV4KSB7XG4gICAgICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmIHRyYW5zbGF0ZSA8IHN3aXBlci50cmFuc2xhdGUgJiYgdHJhbnNsYXRlIDwgc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgdHJhbnNsYXRlID4gc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPiBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgICAgICBpZiAoKGFjdGl2ZUluZGV4IHx8IDApICE9PSBzbGlkZUluZGV4KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGRpcmVjdGlvbjtcbiAgICAgIGlmIChzbGlkZUluZGV4ID4gYWN0aXZlSW5kZXgpIGRpcmVjdGlvbiA9ICduZXh0JztlbHNlIGlmIChzbGlkZUluZGV4IDwgYWN0aXZlSW5kZXgpIGRpcmVjdGlvbiA9ICdwcmV2JztlbHNlIGRpcmVjdGlvbiA9ICdyZXNldCc7IC8vIFVwZGF0ZSBJbmRleFxuXG4gICAgICBpZiAocnRsICYmIC10cmFuc2xhdGUgPT09IHN3aXBlci50cmFuc2xhdGUgfHwgIXJ0bCAmJiB0cmFuc2xhdGUgPT09IHN3aXBlci50cmFuc2xhdGUpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpOyAvLyBVcGRhdGUgSGVpZ2h0XG5cbiAgICAgICAgaWYgKHBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5lZmZlY3QgIT09ICdzbGlkZScpIHtcbiAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAncmVzZXQnKSB7XG4gICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgY29uc3QgaXNIID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICBjb25zdCB0ID0gcnRsID8gdHJhbnNsYXRlIDogLXRyYW5zbGF0ZTtcblxuICAgICAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcblxuICAgICAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSAnbm9uZSc7XG4gICAgICAgICAgICBzd2lwZXIuX2ltbWVkaWF0ZVZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdyYXBwZXJFbFtpc0ggPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10gPSB0O1xuXG4gICAgICAgICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICcnO1xuICAgICAgICAgICAgICBzd2lwZXIuX3N3aXBlckltbWVkaWF0ZVZpcnR1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXN3aXBlci5zdXBwb3J0LnNtb290aFNjcm9sbCkge1xuICAgICAgICAgICAgYW5pbWF0ZUNTU01vZGVTY3JvbGwoe1xuICAgICAgICAgICAgICBzd2lwZXIsXG4gICAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uOiB0LFxuICAgICAgICAgICAgICBzaWRlOiBpc0ggPyAnbGVmdCcgOiAndG9wJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgW2lzSCA/ICdsZWZ0JyA6ICd0b3AnXTogdCxcbiAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHNwZWVkKTtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleChzbGlkZUluZGV4KTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcbiAgICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuXG4gICAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkge1xuICAgICAgICAgIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoZSkge1xuICAgICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgICAgIGRlbGV0ZSBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQ7XG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2xpZGVUb0xvb3AoaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgICAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBpbmRleGAgYXJndW1lbnQgY29udmVydGVkIGZyb20gYHN0cmluZ2AgdG8gYG51bWJlcmAuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpbmRleEFzTnVtYmVyID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYGluZGV4YCBhcmd1bWVudCBpcyBhIHZhbGlkIGBudW1iZXJgXG4gICAgICAgICAqIGFmdGVyIGJlaW5nIGNvbnZlcnRlZCBmcm9tIHRoZSBgc3RyaW5nYCB0eXBlLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICAgICAgY29uc3QgaXNWYWxpZE51bWJlciA9IGlzRmluaXRlKGluZGV4QXNOdW1iZXIpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZE51bWJlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHBhc3NlZC1pbiAnaW5kZXgnIChzdHJpbmcpIGNvdWxkbid0IGJlIGNvbnZlcnRlZCB0byAnbnVtYmVyJy4gWyR7aW5kZXh9XSBnaXZlbi5gKTtcbiAgICAgICAgfSAvLyBLbm93aW5nIHRoYXQgdGhlIGNvbnZlcnRlZCBgaW5kZXhgIGlzIGEgdmFsaWQgbnVtYmVyLFxuICAgICAgICAvLyB3ZSBjYW4gdXBkYXRlIHRoZSBvcmlnaW5hbCBhcmd1bWVudCdzIHZhbHVlLlxuXG5cbiAgICAgICAgaW5kZXggPSBpbmRleEFzTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgbGV0IG5ld0luZGV4ID0gaW5kZXg7XG5cbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgbmV3SW5kZXggKz0gc3dpcGVyLmxvb3BlZFNsaWRlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKG5ld0luZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gICAgfVxuXG4gICAgLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG4gICAgZnVuY3Rpb24gc2xpZGVOZXh0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gICAgICBpZiAoc3BlZWQgPT09IHZvaWQgMCkge1xuICAgICAgICBzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkO1xuICAgICAgfVxuXG4gICAgICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICAgICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYW5pbWF0aW5nLFxuICAgICAgICBlbmFibGVkLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBpZiAoIWVuYWJsZWQpIHJldHVybiBzd2lwZXI7XG4gICAgICBsZXQgcGVyR3JvdXAgPSBwYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG5cbiAgICAgIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXBBdXRvKSB7XG4gICAgICAgIHBlckdyb3VwID0gTWF0aC5tYXgoc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCdjdXJyZW50JywgdHJ1ZSksIDEpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmNyZW1lbnQgPSBzd2lwZXIuYWN0aXZlSW5kZXggPCBwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwID8gMSA6IHBlckdyb3VwO1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgaWYgKGFuaW1hdGluZyAmJiBwYXJhbXMubG9vcFByZXZlbnRzU2xpZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgc3dpcGVyLl9jbGllbnRMZWZ0ID0gc3dpcGVyLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5yZXdpbmQgJiYgc3dpcGVyLmlzRW5kKSB7XG4gICAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbygwLCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBpbmNyZW1lbnQsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbiAgICBmdW5jdGlvbiBzbGlkZVByZXYoc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpIHtcbiAgICAgIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgICAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGFuaW1hdGluZyxcbiAgICAgICAgc25hcEdyaWQsXG4gICAgICAgIHNsaWRlc0dyaWQsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZSxcbiAgICAgICAgZW5hYmxlZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIHN3aXBlcjtcblxuICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgIGlmIChhbmltYXRpbmcgJiYgcGFyYW1zLmxvb3BQcmV2ZW50c1NsaWRlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN3aXBlci5sb29wRml4KCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gICAgICAgIHN3aXBlci5fY2xpZW50TGVmdCA9IHN3aXBlci4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcblxuICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKHZhbCkge1xuICAgICAgICBpZiAodmFsIDwgMCkgcmV0dXJuIC1NYXRoLmZsb29yKE1hdGguYWJzKHZhbCkpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWwpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub3JtYWxpemVkVHJhbnNsYXRlID0gbm9ybWFsaXplKHRyYW5zbGF0ZSk7XG4gICAgICBjb25zdCBub3JtYWxpemVkU25hcEdyaWQgPSBzbmFwR3JpZC5tYXAodmFsID0+IG5vcm1hbGl6ZSh2YWwpKTtcbiAgICAgIGxldCBwcmV2U25hcCA9IHNuYXBHcmlkW25vcm1hbGl6ZWRTbmFwR3JpZC5pbmRleE9mKG5vcm1hbGl6ZWRUcmFuc2xhdGUpIC0gMV07XG5cbiAgICAgIGlmICh0eXBlb2YgcHJldlNuYXAgPT09ICd1bmRlZmluZWQnICYmIHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIGxldCBwcmV2U25hcEluZGV4O1xuICAgICAgICBzbmFwR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAobm9ybWFsaXplZFRyYW5zbGF0ZSA+PSBzbmFwKSB7XG4gICAgICAgICAgICAvLyBwcmV2U25hcCA9IHNuYXA7XG4gICAgICAgICAgICBwcmV2U25hcEluZGV4ID0gc25hcEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmV2U25hcEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHByZXZTbmFwID0gc25hcEdyaWRbcHJldlNuYXBJbmRleCA+IDAgPyBwcmV2U25hcEluZGV4IC0gMSA6IHByZXZTbmFwSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBwcmV2SW5kZXggPSAwO1xuXG4gICAgICBpZiAodHlwZW9mIHByZXZTbmFwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcmV2SW5kZXggPSBzbGlkZXNHcmlkLmluZGV4T2YocHJldlNuYXApO1xuICAgICAgICBpZiAocHJldkluZGV4IDwgMCkgcHJldkluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4IC0gMTtcblxuICAgICAgICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDEgJiYgcGFyYW1zLnNsaWRlc1Blckdyb3VwQXV0bykge1xuICAgICAgICAgIHByZXZJbmRleCA9IHByZXZJbmRleCAtIHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygncHJldmlvdXMnLCB0cnVlKSArIDE7XG4gICAgICAgICAgcHJldkluZGV4ID0gTWF0aC5tYXgocHJldkluZGV4LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnJld2luZCAmJiBzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gc3dpcGVyLnBhcmFtcy52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHN3aXBlci52aXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCAtIDEgOiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbyhsYXN0SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHByZXZJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICAgIH1cblxuICAgIC8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuICAgIGZ1bmN0aW9uIHNsaWRlUmVzZXQoc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpIHtcbiAgICAgIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgICAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICAgIH1cblxuICAgIC8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuICAgIGZ1bmN0aW9uIHNsaWRlVG9DbG9zZXN0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsLCB0aHJlc2hvbGQpIHtcbiAgICAgIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgICAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyZXNob2xkID0gMC41O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgbGV0IGluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICAgICAgY29uc3Qgc2tpcCA9IE1hdGgubWluKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBpbmRleCk7XG4gICAgICBjb25zdCBzbmFwSW5kZXggPSBza2lwICsgTWF0aC5mbG9vcigoaW5kZXggLSBza2lwKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcblxuICAgICAgaWYgKHRyYW5zbGF0ZSA+PSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XSkge1xuICAgICAgICAvLyBUaGUgY3VycmVudCB0cmFuc2xhdGUgaXMgb24gb3IgYWZ0ZXIgdGhlIGN1cnJlbnQgc25hcCBpbmRleCwgc28gdGhlIGNob2ljZVxuICAgICAgICAvLyBpcyBiZXR3ZWVuIHRoZSBjdXJyZW50IGluZGV4IGFuZCB0aGUgb25lIGFmdGVyIGl0LlxuICAgICAgICBjb25zdCBjdXJyZW50U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXhdO1xuICAgICAgICBjb25zdCBuZXh0U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXggKyAxXTtcblxuICAgICAgICBpZiAodHJhbnNsYXRlIC0gY3VycmVudFNuYXAgPiAobmV4dFNuYXAgLSBjdXJyZW50U25hcCkgKiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBpbmRleCArPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgY3VycmVudCB0cmFuc2xhdGUgaXMgYmVmb3JlIHRoZSBjdXJyZW50IHNuYXAgaW5kZXgsIHNvIHRoZSBjaG9pY2VcbiAgICAgICAgLy8gaXMgYmV0d2VlbiB0aGUgY3VycmVudCBpbmRleCBhbmQgdGhlIG9uZSBiZWZvcmUgaXQuXG4gICAgICAgIGNvbnN0IHByZXZTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleCAtIDFdO1xuICAgICAgICBjb25zdCBjdXJyZW50U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXhdO1xuXG4gICAgICAgIGlmICh0cmFuc2xhdGUgLSBwcmV2U25hcCA8PSAoY3VycmVudFNuYXAgLSBwcmV2U25hcCkgKiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBpbmRleCAtPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoaW5kZXgsIDApO1xuICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgc3dpcGVyLnNsaWRlc0dyaWQubGVuZ3RoIC0gMSk7XG4gICAgICByZXR1cm4gc3dpcGVyLnNsaWRlVG8oaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbGlkZVRvQ2xpY2tlZFNsaWRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAkd3JhcHBlckVsXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgY29uc3Qgc2xpZGVzUGVyVmlldyA9IHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgPyBzd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoKSA6IHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgbGV0IHNsaWRlVG9JbmRleCA9IHN3aXBlci5jbGlja2VkSW5kZXg7XG4gICAgICBsZXQgcmVhbEluZGV4O1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgaWYgKHN3aXBlci5hbmltYXRpbmcpIHJldHVybjtcbiAgICAgICAgcmVhbEluZGV4ID0gcGFyc2VJbnQoJChzd2lwZXIuY2xpY2tlZFNsaWRlKS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgIGlmIChzbGlkZVRvSW5kZXggPCBzd2lwZXIubG9vcGVkU2xpZGVzIC0gc2xpZGVzUGVyVmlldyAvIDIgfHwgc2xpZGVUb0luZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGggLSBzd2lwZXIubG9vcGVkU2xpZGVzICsgc2xpZGVzUGVyVmlldyAvIDIpIHtcbiAgICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICAgICAgICBzbGlkZVRvSW5kZXggPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl06bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlgKS5lcSgwKS5pbmRleCgpO1xuICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNsaWRlVG9JbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc2xpZGVzUGVyVmlldykge1xuICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICAgICAgc2xpZGVUb0luZGV4ID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyZWFsSW5kZXh9XCJdOm5vdCguJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pYCkuZXEoMCkuaW5kZXgoKTtcbiAgICAgICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsaWRlID0ge1xuICAgICAgc2xpZGVUbyxcbiAgICAgIHNsaWRlVG9Mb29wLFxuICAgICAgc2xpZGVOZXh0LFxuICAgICAgc2xpZGVQcmV2LFxuICAgICAgc2xpZGVSZXNldCxcbiAgICAgIHNsaWRlVG9DbG9zZXN0LFxuICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb29wQ3JlYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAkd3JhcHBlckVsXG4gICAgICB9ID0gc3dpcGVyOyAvLyBSZW1vdmUgZHVwbGljYXRlZCBzbGlkZXNcblxuICAgICAgY29uc3QgJHNlbGVjdG9yID0gJHdyYXBwZXJFbC5jaGlsZHJlbigpLmxlbmd0aCA+IDAgPyAkKCR3cmFwcGVyRWwuY2hpbGRyZW4oKVswXS5wYXJlbnROb2RlKSA6ICR3cmFwcGVyRWw7XG4gICAgICAkc2VsZWN0b3IuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfS4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfWApLnJlbW92ZSgpO1xuICAgICAgbGV0IHNsaWRlcyA9ICRzZWxlY3Rvci5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCk7XG5cbiAgICAgIGlmIChwYXJhbXMubG9vcEZpbGxHcm91cFdpdGhCbGFuaykge1xuICAgICAgICBjb25zdCBibGFua1NsaWRlc051bSA9IHBhcmFtcy5zbGlkZXNQZXJHcm91cCAtIHNsaWRlcy5sZW5ndGggJSBwYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG5cbiAgICAgICAgaWYgKGJsYW5rU2xpZGVzTnVtICE9PSBwYXJhbXMuc2xpZGVzUGVyR3JvdXApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsYW5rU2xpZGVzTnVtOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsYW5rTm9kZSA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpLmFkZENsYXNzKGAke3BhcmFtcy5zbGlkZUNsYXNzfSAke3BhcmFtcy5zbGlkZUJsYW5rQ2xhc3N9YCk7XG4gICAgICAgICAgICAkc2VsZWN0b3IuYXBwZW5kKGJsYW5rTm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2xpZGVzID0gJHNlbGVjdG9yLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiAhcGFyYW1zLmxvb3BlZFNsaWRlcykgcGFyYW1zLmxvb3BlZFNsaWRlcyA9IHNsaWRlcy5sZW5ndGg7XG4gICAgICBzd2lwZXIubG9vcGVkU2xpZGVzID0gTWF0aC5jZWlsKHBhcnNlRmxvYXQocGFyYW1zLmxvb3BlZFNsaWRlcyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldywgMTApKTtcbiAgICAgIHN3aXBlci5sb29wZWRTbGlkZXMgKz0gcGFyYW1zLmxvb3BBZGRpdGlvbmFsU2xpZGVzO1xuXG4gICAgICBpZiAoc3dpcGVyLmxvb3BlZFNsaWRlcyA+IHNsaWRlcy5sZW5ndGggJiYgc3dpcGVyLnBhcmFtcy5sb29wZWRTbGlkZXNMaW1pdCkge1xuICAgICAgICBzd2lwZXIubG9vcGVkU2xpZGVzID0gc2xpZGVzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJlcGVuZFNsaWRlcyA9IFtdO1xuICAgICAgY29uc3QgYXBwZW5kU2xpZGVzID0gW107XG4gICAgICBzbGlkZXMuZWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICAgICQoZWwpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JywgaW5kZXgpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLmxvb3BlZFNsaWRlczsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaSAtIE1hdGguZmxvb3IoaSAvIHNsaWRlcy5sZW5ndGgpICogc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgYXBwZW5kU2xpZGVzLnB1c2goc2xpZGVzLmVxKGluZGV4KVswXSk7XG4gICAgICAgIHByZXBlbmRTbGlkZXMudW5zaGlmdChzbGlkZXMuZXEoc2xpZGVzLmxlbmd0aCAtIGluZGV4IC0gMSlbMF0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFwcGVuZFNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAkc2VsZWN0b3IuYXBwZW5kKCQoYXBwZW5kU2xpZGVzW2ldLmNsb25lTm9kZSh0cnVlKSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IHByZXBlbmRTbGlkZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgJHNlbGVjdG9yLnByZXBlbmQoJChwcmVwZW5kU2xpZGVzW2ldLmNsb25lTm9kZSh0cnVlKSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29wRml4KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVMb29wRml4Jyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICBzbGlkZXMsXG4gICAgICAgIGxvb3BlZFNsaWRlcyxcbiAgICAgICAgYWxsb3dTbGlkZVByZXYsXG4gICAgICAgIGFsbG93U2xpZGVOZXh0LFxuICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgcnRsVHJhbnNsYXRlOiBydGxcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBsZXQgbmV3SW5kZXg7XG4gICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSB0cnVlO1xuICAgICAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHNuYXBUcmFuc2xhdGUgPSAtc25hcEdyaWRbYWN0aXZlSW5kZXhdO1xuICAgICAgY29uc3QgZGlmZiA9IHNuYXBUcmFuc2xhdGUgLSBzd2lwZXIuZ2V0VHJhbnNsYXRlKCk7IC8vIEZpeCBGb3IgTmVnYXRpdmUgT3ZlcnNsaWRpbmdcblxuICAgICAgaWYgKGFjdGl2ZUluZGV4IDwgbG9vcGVkU2xpZGVzKSB7XG4gICAgICAgIG5ld0luZGV4ID0gc2xpZGVzLmxlbmd0aCAtIGxvb3BlZFNsaWRlcyAqIDMgKyBhY3RpdmVJbmRleDtcbiAgICAgICAgbmV3SW5kZXggKz0gbG9vcGVkU2xpZGVzO1xuICAgICAgICBjb25zdCBzbGlkZUNoYW5nZWQgPSBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIGlmIChzbGlkZUNoYW5nZWQgJiYgZGlmZiAhPT0gMCkge1xuICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoKHJ0bCA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZSkgLSBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhY3RpdmVJbmRleCA+PSBzbGlkZXMubGVuZ3RoIC0gbG9vcGVkU2xpZGVzKSB7XG4gICAgICAgIC8vIEZpeCBGb3IgUG9zaXRpdmUgT3ZlcnNsaWRpbmdcbiAgICAgICAgbmV3SW5kZXggPSAtc2xpZGVzLmxlbmd0aCArIGFjdGl2ZUluZGV4ICsgbG9vcGVkU2xpZGVzO1xuICAgICAgICBuZXdJbmRleCArPSBsb29wZWRTbGlkZXM7XG4gICAgICAgIGNvbnN0IHNsaWRlQ2hhbmdlZCA9IHN3aXBlci5zbGlkZVRvKG5ld0luZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNsaWRlQ2hhbmdlZCAmJiBkaWZmICE9PSAwKSB7XG4gICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZSgocnRsID8gLXN3aXBlci50cmFuc2xhdGUgOiBzd2lwZXIudHJhbnNsYXRlKSAtIGRpZmYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xuICAgICAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gYWxsb3dTbGlkZU5leHQ7XG4gICAgICBzd2lwZXIuZW1pdCgnbG9vcEZpeCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BEZXN0cm95KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgJHdyYXBwZXJFbCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBzbGlkZXNcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30sLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlQmxhbmtDbGFzc31gKS5yZW1vdmUoKTtcbiAgICAgIHNsaWRlcy5yZW1vdmVBdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xuICAgIH1cblxuICAgIHZhciBsb29wID0ge1xuICAgICAgbG9vcENyZWF0ZSxcbiAgICAgIGxvb3BGaXgsXG4gICAgICBsb29wRGVzdHJveVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRHcmFiQ3Vyc29yKG1vdmluZykge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIuc3VwcG9ydC50b3VjaCB8fCAhc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoIHx8IHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSByZXR1cm47XG4gICAgICBjb25zdCBlbCA9IHN3aXBlci5wYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICdjb250YWluZXInID8gc3dpcGVyLmVsIDogc3dpcGVyLndyYXBwZXJFbDtcbiAgICAgIGVsLnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcbiAgICAgIGVsLnN0eWxlLmN1cnNvciA9IG1vdmluZyA/ICdncmFiYmluZycgOiAnZ3JhYic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5zZXRHcmFiQ3Vyc29yKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcblxuICAgICAgaWYgKHN3aXBlci5zdXBwb3J0LnRvdWNoIHx8IHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyW3N3aXBlci5wYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICdjb250YWluZXInID8gJ2VsJyA6ICd3cmFwcGVyRWwnXS5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICB9XG5cbiAgICB2YXIgZ3JhYkN1cnNvciA9IHtcbiAgICAgIHNldEdyYWJDdXJzb3IsXG4gICAgICB1bnNldEdyYWJDdXJzb3JcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnQoc2VsZWN0b3IsIGJhc2UpIHtcbiAgICAgIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgYmFzZSA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF9fY2xvc2VzdEZyb20oZWwpIHtcbiAgICAgICAgaWYgKCFlbCB8fCBlbCA9PT0gZ2V0RG9jdW1lbnQoKSB8fCBlbCA9PT0gZ2V0V2luZG93KCkpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZWwuYXNzaWduZWRTbG90KSBlbCA9IGVsLmFzc2lnbmVkU2xvdDtcbiAgICAgICAgY29uc3QgZm91bmQgPSBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcblxuICAgICAgICBpZiAoIWZvdW5kICYmICFlbC5nZXRSb290Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kIHx8IF9fY2xvc2VzdEZyb20oZWwuZ2V0Um9vdE5vZGUoKS5ob3N0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9fY2xvc2VzdEZyb20oYmFzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBjb25zdCBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB0b3VjaGVzLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG5cbiAgICAgIGlmIChzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLmNzc01vZGUgJiYgcGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGUgPSBldmVudDtcbiAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICBsZXQgJHRhcmdldEVsID0gJChlLnRhcmdldCk7XG5cbiAgICAgIGlmIChwYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICd3cmFwcGVyJykge1xuICAgICAgICBpZiAoISR0YXJnZXRFbC5jbG9zZXN0KHN3aXBlci53cmFwcGVyRWwpLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmlzVG91Y2hFdmVudCA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnO1xuICAgICAgaWYgKCFkYXRhLmlzVG91Y2hFdmVudCAmJiAnd2hpY2gnIGluIGUgJiYgZS53aGljaCA9PT0gMykgcmV0dXJuO1xuICAgICAgaWYgKCFkYXRhLmlzVG91Y2hFdmVudCAmJiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uID4gMCkgcmV0dXJuO1xuICAgICAgaWYgKGRhdGEuaXNUb3VjaGVkICYmIGRhdGEuaXNNb3ZlZCkgcmV0dXJuOyAvLyBjaGFuZ2UgdGFyZ2V0IGVsIGZvciBzaGFkb3cgcm9vdCBjb21wb25lbnRcblxuICAgICAgY29uc3Qgc3dpcGluZ0NsYXNzSGFzVmFsdWUgPSAhIXBhcmFtcy5ub1N3aXBpbmdDbGFzcyAmJiBwYXJhbXMubm9Td2lwaW5nQ2xhc3MgIT09ICcnO1xuXG4gICAgICBpZiAoc3dpcGluZ0NsYXNzSGFzVmFsdWUgJiYgZS50YXJnZXQgJiYgZS50YXJnZXQuc2hhZG93Um9vdCAmJiBldmVudC5wYXRoICYmIGV2ZW50LnBhdGhbMF0pIHtcbiAgICAgICAgJHRhcmdldEVsID0gJChldmVudC5wYXRoWzBdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9Td2lwaW5nU2VsZWN0b3IgPSBwYXJhbXMubm9Td2lwaW5nU2VsZWN0b3IgPyBwYXJhbXMubm9Td2lwaW5nU2VsZWN0b3IgOiBgLiR7cGFyYW1zLm5vU3dpcGluZ0NsYXNzfWA7XG4gICAgICBjb25zdCBpc1RhcmdldFNoYWRvdyA9ICEhKGUudGFyZ2V0ICYmIGUudGFyZ2V0LnNoYWRvd1Jvb3QpOyAvLyB1c2UgY2xvc2VzdEVsZW1lbnQgZm9yIHNoYWRvdyByb290IGVsZW1lbnQgdG8gZ2V0IHRoZSBhY3R1YWwgY2xvc2VzdCBmb3IgbmVzdGVkIHNoYWRvdyByb290IGVsZW1lbnRcblxuICAgICAgaWYgKHBhcmFtcy5ub1N3aXBpbmcgJiYgKGlzVGFyZ2V0U2hhZG93ID8gY2xvc2VzdEVsZW1lbnQobm9Td2lwaW5nU2VsZWN0b3IsICR0YXJnZXRFbFswXSkgOiAkdGFyZ2V0RWwuY2xvc2VzdChub1N3aXBpbmdTZWxlY3RvcilbMF0pKSB7XG4gICAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnN3aXBlSGFuZGxlcikge1xuICAgICAgICBpZiAoISR0YXJnZXRFbC5jbG9zZXN0KHBhcmFtcy5zd2lwZUhhbmRsZXIpWzBdKSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRvdWNoZXMuY3VycmVudFggPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICB0b3VjaGVzLmN1cnJlbnRZID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgICAgY29uc3Qgc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgICAgIGNvbnN0IHN0YXJ0WSA9IHRvdWNoZXMuY3VycmVudFk7IC8vIERvIE5PVCBzdGFydCBpZiBpT1MgZWRnZSBzd2lwZSBpcyBkZXRlY3RlZC4gT3RoZXJ3aXNlIGlPUyBhcHAgY2Fubm90IHN3aXBlLXRvLWdvLWJhY2sgYW55bW9yZVxuXG4gICAgICBjb25zdCBlZGdlU3dpcGVEZXRlY3Rpb24gPSBwYXJhbXMuZWRnZVN3aXBlRGV0ZWN0aW9uIHx8IHBhcmFtcy5pT1NFZGdlU3dpcGVEZXRlY3Rpb247XG4gICAgICBjb25zdCBlZGdlU3dpcGVUaHJlc2hvbGQgPSBwYXJhbXMuZWRnZVN3aXBlVGhyZXNob2xkIHx8IHBhcmFtcy5pT1NFZGdlU3dpcGVUaHJlc2hvbGQ7XG5cbiAgICAgIGlmIChlZGdlU3dpcGVEZXRlY3Rpb24gJiYgKHN0YXJ0WCA8PSBlZGdlU3dpcGVUaHJlc2hvbGQgfHwgc3RhcnRYID49IHdpbmRvdy5pbm5lcldpZHRoIC0gZWRnZVN3aXBlVGhyZXNob2xkKSkge1xuICAgICAgICBpZiAoZWRnZVN3aXBlRGV0ZWN0aW9uID09PSAncHJldmVudCcpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgICAgaXNUb3VjaGVkOiB0cnVlLFxuICAgICAgICBpc01vdmVkOiBmYWxzZSxcbiAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdHJ1ZSxcbiAgICAgICAgaXNTY3JvbGxpbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnRNb3Zpbmc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICB0b3VjaGVzLnN0YXJ0WCA9IHN0YXJ0WDtcbiAgICAgIHRvdWNoZXMuc3RhcnRZID0gc3RhcnRZO1xuICAgICAgZGF0YS50b3VjaFN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgc3dpcGVyLmFsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgICAgIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChwYXJhbXMudGhyZXNob2xkID4gMCkgZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUgPSBmYWxzZTtcblxuICAgICAgaWYgKGUudHlwZSAhPT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIGxldCBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCR0YXJnZXRFbC5pcyhkYXRhLmZvY3VzYWJsZUVsZW1lbnRzKSkge1xuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoJHRhcmdldEVsWzBdLm5vZGVOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09ICR0YXJnZXRFbFswXSkge1xuICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2hvdWxkUHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdCAmJiBzd2lwZXIuYWxsb3dUb3VjaE1vdmUgJiYgcGFyYW1zLnRvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdDtcblxuICAgICAgICBpZiAoKHBhcmFtcy50b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdCB8fCBzaG91bGRQcmV2ZW50RGVmYXVsdCkgJiYgISR0YXJnZXRFbFswXS5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBzd2lwZXIucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgc3dpcGVyLmZyZWVNb2RlICYmIHN3aXBlci5hbmltYXRpbmcgJiYgIXBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIHN3aXBlci5mcmVlTW9kZS5vblRvdWNoU3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXQoJ3RvdWNoU3RhcnQnLCBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZShldmVudCkge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHRvdWNoZXMsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgICBsZXQgZSA9IGV2ZW50O1xuICAgICAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcblxuICAgICAgaWYgKCFkYXRhLmlzVG91Y2hlZCkge1xuICAgICAgICBpZiAoZGF0YS5zdGFydE1vdmluZyAmJiBkYXRhLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ3RvdWNoTW92ZU9wcG9zaXRlJywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmlzVG91Y2hFdmVudCAmJiBlLnR5cGUgIT09ICd0b3VjaG1vdmUnKSByZXR1cm47XG4gICAgICBjb25zdCB0YXJnZXRUb3VjaCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZS50YXJnZXRUb3VjaGVzICYmIChlLnRhcmdldFRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICBjb25zdCBwYWdlWCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyB0YXJnZXRUb3VjaC5wYWdlWCA6IGUucGFnZVg7XG4gICAgICBjb25zdCBwYWdlWSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyB0YXJnZXRUb3VjaC5wYWdlWSA6IGUucGFnZVk7XG5cbiAgICAgIGlmIChlLnByZXZlbnRlZEJ5TmVzdGVkU3dpcGVyKSB7XG4gICAgICAgIHRvdWNoZXMuc3RhcnRYID0gcGFnZVg7XG4gICAgICAgIHRvdWNoZXMuc3RhcnRZID0gcGFnZVk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzd2lwZXIuYWxsb3dUb3VjaE1vdmUpIHtcbiAgICAgICAgaWYgKCEkKGUudGFyZ2V0KS5pcyhkYXRhLmZvY3VzYWJsZUVsZW1lbnRzKSkge1xuICAgICAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5pc1RvdWNoZWQpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRvdWNoZXMsIHtcbiAgICAgICAgICAgIHN0YXJ0WDogcGFnZVgsXG4gICAgICAgICAgICBzdGFydFk6IHBhZ2VZLFxuICAgICAgICAgICAgY3VycmVudFg6IHBhZ2VYLFxuICAgICAgICAgICAgY3VycmVudFk6IHBhZ2VZXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGF0YS50b3VjaFN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5pc1RvdWNoRXZlbnQgJiYgcGFyYW1zLnRvdWNoUmVsZWFzZU9uRWRnZXMgJiYgIXBhcmFtcy5sb29wKSB7XG4gICAgICAgIGlmIChzd2lwZXIuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICAgICAgLy8gVmVydGljYWxcbiAgICAgICAgICBpZiAocGFnZVkgPCB0b3VjaGVzLnN0YXJ0WSAmJiBzd2lwZXIudHJhbnNsYXRlIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSB8fCBwYWdlWSA+IHRvdWNoZXMuc3RhcnRZICYmIHN3aXBlci50cmFuc2xhdGUgPj0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgICAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhZ2VYIDwgdG91Y2hlcy5zdGFydFggJiYgc3dpcGVyLnRyYW5zbGF0ZSA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgfHwgcGFnZVggPiB0b3VjaGVzLnN0YXJ0WCAmJiBzd2lwZXIudHJhbnNsYXRlID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5pc1RvdWNoRXZlbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgJChlLnRhcmdldCkuaXMoZGF0YS5mb2N1c2FibGVFbGVtZW50cykpIHtcbiAgICAgICAgICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuICAgICAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmFsbG93VG91Y2hDYWxsYmFja3MpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3RvdWNoTW92ZScsIGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSByZXR1cm47XG4gICAgICB0b3VjaGVzLmN1cnJlbnRYID0gcGFnZVg7XG4gICAgICB0b3VjaGVzLmN1cnJlbnRZID0gcGFnZVk7XG4gICAgICBjb25zdCBkaWZmWCA9IHRvdWNoZXMuY3VycmVudFggLSB0b3VjaGVzLnN0YXJ0WDtcbiAgICAgIGNvbnN0IGRpZmZZID0gdG91Y2hlcy5jdXJyZW50WSAtIHRvdWNoZXMuc3RhcnRZO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMudGhyZXNob2xkICYmIE1hdGguc3FydChkaWZmWCAqKiAyICsgZGlmZlkgKiogMikgPCBzd2lwZXIucGFyYW1zLnRocmVzaG9sZCkgcmV0dXJuO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEuaXNTY3JvbGxpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxldCB0b3VjaEFuZ2xlO1xuXG4gICAgICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgdG91Y2hlcy5jdXJyZW50WSA9PT0gdG91Y2hlcy5zdGFydFkgfHwgc3dpcGVyLmlzVmVydGljYWwoKSAmJiB0b3VjaGVzLmN1cnJlbnRYID09PSB0b3VjaGVzLnN0YXJ0WCkge1xuICAgICAgICAgIGRhdGEuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICBpZiAoZGlmZlggKiBkaWZmWCArIGRpZmZZICogZGlmZlkgPj0gMjUpIHtcbiAgICAgICAgICAgIHRvdWNoQW5nbGUgPSBNYXRoLmF0YW4yKE1hdGguYWJzKGRpZmZZKSwgTWF0aC5hYnMoZGlmZlgpKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgICAgICBkYXRhLmlzU2Nyb2xsaW5nID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gdG91Y2hBbmdsZSA+IHBhcmFtcy50b3VjaEFuZ2xlIDogOTAgLSB0b3VjaEFuZ2xlID4gcGFyYW1zLnRvdWNoQW5nbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmVPcHBvc2l0ZScsIGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRhdGEuc3RhcnRNb3ZpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0b3VjaGVzLmN1cnJlbnRYICE9PSB0b3VjaGVzLnN0YXJ0WCB8fCB0b3VjaGVzLmN1cnJlbnRZICE9PSB0b3VjaGVzLnN0YXJ0WSkge1xuICAgICAgICAgIGRhdGEuc3RhcnRNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhLnN0YXJ0TW92aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcblxuICAgICAgaWYgKCFwYXJhbXMuY3NzTW9kZSAmJiBlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiAmJiAhcGFyYW1zLm5lc3RlZCkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEuaXNNb3ZlZCkge1xuICAgICAgICBpZiAocGFyYW1zLmxvb3AgJiYgIXBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuc3RhcnRUcmFuc2xhdGUgPSBzd2lwZXIuZ2V0VHJhbnNsYXRlKCk7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuXG4gICAgICAgIGlmIChzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwudHJpZ2dlcignd2Via2l0VHJhbnNpdGlvbkVuZCB0cmFuc2l0aW9uZW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSBmYWxzZTsgLy8gR3JhYiBDdXJzb3JcblxuICAgICAgICBpZiAocGFyYW1zLmdyYWJDdXJzb3IgJiYgKHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9PT0gdHJ1ZSB8fCBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPT09IHRydWUpKSB7XG4gICAgICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnc2xpZGVyRmlyc3RNb3ZlJywgZSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZXJNb3ZlJywgZSk7XG4gICAgICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuICAgICAgbGV0IGRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBkaWZmWCA6IGRpZmZZO1xuICAgICAgdG91Y2hlcy5kaWZmID0gZGlmZjtcbiAgICAgIGRpZmYgKj0gcGFyYW1zLnRvdWNoUmF0aW87XG4gICAgICBpZiAocnRsKSBkaWZmID0gLWRpZmY7XG4gICAgICBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPSBkaWZmID4gMCA/ICdwcmV2JyA6ICduZXh0JztcbiAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRpZmYgKyBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICAgICAgbGV0IGRpc2FibGVQYXJlbnRTd2lwZXIgPSB0cnVlO1xuICAgICAgbGV0IHJlc2lzdGFuY2VSYXRpbyA9IHBhcmFtcy5yZXNpc3RhbmNlUmF0aW87XG5cbiAgICAgIGlmIChwYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcykge1xuICAgICAgICByZXNpc3RhbmNlUmF0aW8gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZiA+IDAgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlID4gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgIGRpc2FibGVQYXJlbnRTd2lwZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmFtcy5yZXNpc3RhbmNlKSBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBzd2lwZXIubWluVHJhbnNsYXRlKCkgLSAxICsgKC1zd2lwZXIubWluVHJhbnNsYXRlKCkgKyBkYXRhLnN0YXJ0VHJhbnNsYXRlICsgZGlmZikgKiogcmVzaXN0YW5jZVJhdGlvO1xuICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPCBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xuICAgICAgICBpZiAocGFyYW1zLnJlc2lzdGFuY2UpIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSArIDEgLSAoc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gZGF0YS5zdGFydFRyYW5zbGF0ZSAtIGRpZmYpICoqIHJlc2lzdGFuY2VSYXRpbztcbiAgICAgIH1cblxuICAgICAgaWYgKGRpc2FibGVQYXJlbnRTd2lwZXIpIHtcbiAgICAgICAgZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciA9IHRydWU7XG4gICAgICB9IC8vIERpcmVjdGlvbnMgbG9ja3NcblxuXG4gICAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlTmV4dCAmJiBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0JyAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPCBkYXRhLnN0YXJ0VHJhbnNsYXRlKSB7XG4gICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA+IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgIXN3aXBlci5hbGxvd1NsaWRlTmV4dCkge1xuICAgICAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICAgICAgfSAvLyBUaHJlc2hvbGRcblxuXG4gICAgICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID4gcGFyYW1zLnRocmVzaG9sZCB8fCBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xuICAgICAgICAgIGlmICghZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUpIHtcbiAgICAgICAgICAgIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRvdWNoZXMuc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgICAgICAgICAgIHRvdWNoZXMuc3RhcnRZID0gdG91Y2hlcy5jdXJyZW50WTtcbiAgICAgICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICAgICAgICB0b3VjaGVzLmRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5zdGFydFggOiB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyYW1zLmZvbGxvd0ZpbmdlciB8fCBwYXJhbXMuY3NzTW9kZSkgcmV0dXJuOyAvLyBVcGRhdGUgYWN0aXZlIGluZGV4IGluIGZyZWUgbW9kZVxuXG4gICAgICBpZiAocGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkICYmIHN3aXBlci5mcmVlTW9kZSB8fCBwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcykge1xuICAgICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgc3dpcGVyLmZyZWVNb2RlKSB7XG4gICAgICAgIHN3aXBlci5mcmVlTW9kZS5vblRvdWNoTW92ZSgpO1xuICAgICAgfSAvLyBVcGRhdGUgcHJvZ3Jlc3NcblxuXG4gICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoZGF0YS5jdXJyZW50VHJhbnNsYXRlKTsgLy8gVXBkYXRlIHRyYW5zbGF0ZVxuXG4gICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKGRhdGEuY3VycmVudFRyYW5zbGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaEVuZChldmVudCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHRvdWNoZXMsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgICAgICBzbGlkZXNHcmlkLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgICBsZXQgZSA9IGV2ZW50O1xuICAgICAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcblxuICAgICAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xuICAgICAgICBzd2lwZXIuZW1pdCgndG91Y2hFbmQnLCBlKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5hbGxvd1RvdWNoQ2FsbGJhY2tzID0gZmFsc2U7XG5cbiAgICAgIGlmICghZGF0YS5pc1RvdWNoZWQpIHtcbiAgICAgICAgaWYgKGRhdGEuaXNNb3ZlZCAmJiBwYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUmV0dXJuIEdyYWIgQ3Vyc29yXG5cblxuICAgICAgaWYgKHBhcmFtcy5ncmFiQ3Vyc29yICYmIGRhdGEuaXNNb3ZlZCAmJiBkYXRhLmlzVG91Y2hlZCAmJiAoc3dpcGVyLmFsbG93U2xpZGVOZXh0ID09PSB0cnVlIHx8IHN3aXBlci5hbGxvd1NsaWRlUHJldiA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoZmFsc2UpO1xuICAgICAgfSAvLyBUaW1lIGRpZmZcblxuXG4gICAgICBjb25zdCB0b3VjaEVuZFRpbWUgPSBub3coKTtcbiAgICAgIGNvbnN0IHRpbWVEaWZmID0gdG91Y2hFbmRUaW1lIC0gZGF0YS50b3VjaFN0YXJ0VGltZTsgLy8gVGFwLCBkb3VibGVUYXAsIENsaWNrXG5cbiAgICAgIGlmIChzd2lwZXIuYWxsb3dDbGljaykge1xuICAgICAgICBjb25zdCBwYXRoVHJlZSA9IGUucGF0aCB8fCBlLmNvbXBvc2VkUGF0aCAmJiBlLmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICBzd2lwZXIudXBkYXRlQ2xpY2tlZFNsaWRlKHBhdGhUcmVlICYmIHBhdGhUcmVlWzBdIHx8IGUudGFyZ2V0KTtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3RhcCBjbGljaycsIGUpO1xuXG4gICAgICAgIGlmICh0aW1lRGlmZiA8IDMwMCAmJiB0b3VjaEVuZFRpbWUgLSBkYXRhLmxhc3RDbGlja1RpbWUgPCAzMDApIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdCgnZG91YmxlVGFwIGRvdWJsZUNsaWNrJywgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGF0YS5sYXN0Q2xpY2tUaW1lID0gbm93KCk7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLmRlc3Ryb3llZCkgc3dpcGVyLmFsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghZGF0YS5pc1RvdWNoZWQgfHwgIWRhdGEuaXNNb3ZlZCB8fCAhc3dpcGVyLnN3aXBlRGlyZWN0aW9uIHx8IHRvdWNoZXMuZGlmZiA9PT0gMCB8fCBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPT09IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgICAgIGRhdGEuc3RhcnRNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gICAgICBsZXQgY3VycmVudFBvcztcblxuICAgICAgaWYgKHBhcmFtcy5mb2xsb3dGaW5nZXIpIHtcbiAgICAgICAgY3VycmVudFBvcyA9IHJ0bCA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRQb3MgPSAtZGF0YS5jdXJyZW50VHJhbnNsYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuZnJlZU1vZGUub25Ub3VjaEVuZCh7XG4gICAgICAgICAgY3VycmVudFBvc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGaW5kIGN1cnJlbnQgc2xpZGVcblxuXG4gICAgICBsZXQgc3RvcEluZGV4ID0gMDtcbiAgICAgIGxldCBncm91cFNpemUgPSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkWzBdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IGkgPCBwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cCkge1xuICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSBpIDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCAtIDEgPyAxIDogcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2xpZGVzR3JpZFtpICsgaW5jcmVtZW50XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoY3VycmVudFBvcyA+PSBzbGlkZXNHcmlkW2ldICYmIGN1cnJlbnRQb3MgPCBzbGlkZXNHcmlkW2kgKyBpbmNyZW1lbnRdKSB7XG4gICAgICAgICAgICBzdG9wSW5kZXggPSBpO1xuICAgICAgICAgICAgZ3JvdXBTaXplID0gc2xpZGVzR3JpZFtpICsgaW5jcmVtZW50XSAtIHNsaWRlc0dyaWRbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQb3MgPj0gc2xpZGVzR3JpZFtpXSkge1xuICAgICAgICAgIHN0b3BJbmRleCA9IGk7XG4gICAgICAgICAgZ3JvdXBTaXplID0gc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDFdIC0gc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDJdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCByZXdpbmRGaXJzdEluZGV4ID0gbnVsbDtcbiAgICAgIGxldCByZXdpbmRMYXN0SW5kZXggPSBudWxsO1xuXG4gICAgICBpZiAocGFyYW1zLnJld2luZCkge1xuICAgICAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nKSB7XG4gICAgICAgICAgcmV3aW5kTGFzdEluZGV4ID0gc3dpcGVyLnBhcmFtcy52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHN3aXBlci52aXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCAtIDEgOiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLmlzRW5kKSB7XG4gICAgICAgICAgcmV3aW5kRmlyc3RJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRmluZCBjdXJyZW50IHNsaWRlIHNpemVcblxuXG4gICAgICBjb25zdCByYXRpbyA9IChjdXJyZW50UG9zIC0gc2xpZGVzR3JpZFtzdG9wSW5kZXhdKSAvIGdyb3VwU2l6ZTtcbiAgICAgIGNvbnN0IGluY3JlbWVudCA9IHN0b3BJbmRleCA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgLSAxID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcblxuICAgICAgaWYgKHRpbWVEaWZmID4gcGFyYW1zLmxvbmdTd2lwZXNNcykge1xuICAgICAgICAvLyBMb25nIHRvdWNoZXNcbiAgICAgICAgaWYgKCFwYXJhbXMubG9uZ1N3aXBlcykge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgICAgICAgaWYgKHJhdGlvID49IHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHN3aXBlci5zbGlkZVRvKHBhcmFtcy5yZXdpbmQgJiYgc3dpcGVyLmlzRW5kID8gcmV3aW5kRmlyc3RJbmRleCA6IHN0b3BJbmRleCArIGluY3JlbWVudCk7ZWxzZSBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgICAgICAgaWYgKHJhdGlvID4gMSAtIHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIGluY3JlbWVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXdpbmRMYXN0SW5kZXggIT09IG51bGwgJiYgcmF0aW8gPCAwICYmIE1hdGguYWJzKHJhdGlvKSA+IHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHJld2luZExhc3RJbmRleCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaG9ydCBzd2lwZXNcbiAgICAgICAgaWYgKCFwYXJhbXMuc2hvcnRTd2lwZXMpIHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzTmF2QnV0dG9uVGFyZ2V0ID0gc3dpcGVyLm5hdmlnYXRpb24gJiYgKGUudGFyZ2V0ID09PSBzd2lwZXIubmF2aWdhdGlvbi5uZXh0RWwgfHwgZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLnByZXZFbCk7XG5cbiAgICAgICAgaWYgKCFpc05hdkJ1dHRvblRhcmdldCkge1xuICAgICAgICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG8ocmV3aW5kRmlyc3RJbmRleCAhPT0gbnVsbCA/IHJld2luZEZpcnN0SW5kZXggOiBzdG9wSW5kZXggKyBpbmNyZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG8ocmV3aW5kTGFzdEluZGV4ICE9PSBudWxsID8gcmV3aW5kTGFzdEluZGV4IDogc3RvcEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCkge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIGluY3JlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBlbFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmIChlbCAmJiBlbC5vZmZzZXRXaWR0aCA9PT0gMCkgcmV0dXJuOyAvLyBCcmVha3BvaW50c1xuXG4gICAgICBpZiAocGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgICAgIHN3aXBlci5zZXRCcmVha3BvaW50KCk7XG4gICAgICB9IC8vIFNhdmUgbG9ja3NcblxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93U2xpZGVOZXh0LFxuICAgICAgICBhbGxvd1NsaWRlUHJldixcbiAgICAgICAgc25hcEdyaWRcbiAgICAgIH0gPSBzd2lwZXI7IC8vIERpc2FibGUgbG9ja3Mgb24gcmVzaXplXG5cbiAgICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XG4gICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSB0cnVlO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG5cbiAgICAgIGlmICgocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpICYmIHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkgJiYgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkge1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkucnVuKCk7XG4gICAgICB9IC8vIFJldHVybiBsb2NrcyBhZnRlciByZXNpemVcblxuXG4gICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSBhbGxvd1NsaWRlUHJldjtcbiAgICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHNuYXBHcmlkICE9PSBzd2lwZXIuc25hcEdyaWQpIHtcbiAgICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5lbmFibGVkKSByZXR1cm47XG5cbiAgICAgIGlmICghc3dpcGVyLmFsbG93Q2xpY2spIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMucHJldmVudENsaWNrcykgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbiAmJiBzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TY3JvbGwoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3cmFwcGVyRWwsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZSxcbiAgICAgICAgZW5hYmxlZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgc3dpcGVyLnByZXZpb3VzVHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcblxuICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICBzd2lwZXIudHJhbnNsYXRlID0gLXdyYXBwZXJFbC5zY3JvbGxMZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnRyYW5zbGF0ZSA9IC13cmFwcGVyRWwuc2Nyb2xsVG9wO1xuICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuXG4gICAgICBpZiAoc3dpcGVyLnRyYW5zbGF0ZSA9PT0gMCkgc3dpcGVyLnRyYW5zbGF0ZSA9IDA7XG4gICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICBsZXQgbmV3UHJvZ3Jlc3M7XG4gICAgICBjb25zdCB0cmFuc2xhdGVzRGlmZiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKTtcblxuICAgICAgaWYgKHRyYW5zbGF0ZXNEaWZmID09PSAwKSB7XG4gICAgICAgIG5ld1Byb2dyZXNzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1Byb2dyZXNzID0gKHN3aXBlci50cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIC8gdHJhbnNsYXRlc0RpZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdQcm9ncmVzcyAhPT0gc3dpcGVyLnByb2dyZXNzKSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhydGxUcmFuc2xhdGUgPyAtc3dpcGVyLnRyYW5zbGF0ZSA6IHN3aXBlci50cmFuc2xhdGUpO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNsYXRlJywgc3dpcGVyLnRyYW5zbGF0ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGxldCBkdW1teUV2ZW50QXR0YWNoZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGR1bW15RXZlbnRMaXN0ZW5lcigpIHt9XG5cbiAgICBjb25zdCBldmVudHMgPSAoc3dpcGVyLCBtZXRob2QpID0+IHtcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB0b3VjaEV2ZW50cyxcbiAgICAgICAgZWwsXG4gICAgICAgIHdyYXBwZXJFbCxcbiAgICAgICAgZGV2aWNlLFxuICAgICAgICBzdXBwb3J0XG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgY29uc3QgY2FwdHVyZSA9ICEhcGFyYW1zLm5lc3RlZDtcbiAgICAgIGNvbnN0IGRvbU1ldGhvZCA9IG1ldGhvZCA9PT0gJ29uJyA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICAgIGNvbnN0IHN3aXBlck1ldGhvZCA9IG1ldGhvZDsgLy8gVG91Y2ggRXZlbnRzXG5cbiAgICAgIGlmICghc3VwcG9ydC50b3VjaCkge1xuICAgICAgICBlbFtkb21NZXRob2RdKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50W2RvbU1ldGhvZF0odG91Y2hFdmVudHMubW92ZSwgc3dpcGVyLm9uVG91Y2hNb3ZlLCBjYXB0dXJlKTtcbiAgICAgICAgZG9jdW1lbnRbZG9tTWV0aG9kXSh0b3VjaEV2ZW50cy5lbmQsIHN3aXBlci5vblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwYXNzaXZlTGlzdGVuZXIgPSB0b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIHN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzID8ge1xuICAgICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICAgICAgfSA6IGZhbHNlO1xuICAgICAgICBlbFtkb21NZXRob2RdKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICBlbFtkb21NZXRob2RdKHRvdWNoRXZlbnRzLm1vdmUsIHN3aXBlci5vblRvdWNoTW92ZSwgc3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgPyB7XG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZVxuICAgICAgICB9IDogY2FwdHVyZSk7XG4gICAgICAgIGVsW2RvbU1ldGhvZF0odG91Y2hFdmVudHMuZW5kLCBzd2lwZXIub25Ub3VjaEVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcblxuICAgICAgICBpZiAodG91Y2hFdmVudHMuY2FuY2VsKSB7XG4gICAgICAgICAgZWxbZG9tTWV0aG9kXSh0b3VjaEV2ZW50cy5jYW5jZWwsIHN3aXBlci5vblRvdWNoRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFByZXZlbnQgTGlua3MgQ2xpY2tzXG5cblxuICAgICAgaWYgKHBhcmFtcy5wcmV2ZW50Q2xpY2tzIHx8IHBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZWxbZG9tTWV0aG9kXSgnY2xpY2snLCBzd2lwZXIub25DbGljaywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICB3cmFwcGVyRWxbZG9tTWV0aG9kXSgnc2Nyb2xsJywgc3dpcGVyLm9uU2Nyb2xsKTtcbiAgICAgIH0gLy8gUmVzaXplIGhhbmRsZXJcblxuXG4gICAgICBpZiAocGFyYW1zLnVwZGF0ZU9uV2luZG93UmVzaXplKSB7XG4gICAgICAgIHN3aXBlcltzd2lwZXJNZXRob2RdKGRldmljZS5pb3MgfHwgZGV2aWNlLmFuZHJvaWQgPyAncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlIG9ic2VydmVyVXBkYXRlJyA6ICdyZXNpemUgb2JzZXJ2ZXJVcGRhdGUnLCBvblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXJbc3dpcGVyTWV0aG9kXSgnb2JzZXJ2ZXJVcGRhdGUnLCBvblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgc3VwcG9ydFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIHN3aXBlci5vblRvdWNoU3RhcnQgPSBvblRvdWNoU3RhcnQuYmluZChzd2lwZXIpO1xuICAgICAgc3dpcGVyLm9uVG91Y2hNb3ZlID0gb25Ub3VjaE1vdmUuYmluZChzd2lwZXIpO1xuICAgICAgc3dpcGVyLm9uVG91Y2hFbmQgPSBvblRvdWNoRW5kLmJpbmQoc3dpcGVyKTtcblxuICAgICAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIHN3aXBlci5vblNjcm9sbCA9IG9uU2Nyb2xsLmJpbmQoc3dpcGVyKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLm9uQ2xpY2sgPSBvbkNsaWNrLmJpbmQoc3dpcGVyKTtcblxuICAgICAgaWYgKHN1cHBvcnQudG91Y2ggJiYgIWR1bW15RXZlbnRBdHRhY2hlZCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZHVtbXlFdmVudExpc3RlbmVyKTtcbiAgICAgICAgZHVtbXlFdmVudEF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzKHN3aXBlciwgJ29uJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0YWNoRXZlbnRzKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGV2ZW50cyhzd2lwZXIsICdvZmYnKTtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRzJDEgPSB7XG4gICAgICBhdHRhY2hFdmVudHMsXG4gICAgICBkZXRhY2hFdmVudHNcbiAgICB9O1xuXG4gICAgY29uc3QgaXNHcmlkRW5hYmxlZCA9IChzd2lwZXIsIHBhcmFtcykgPT4ge1xuICAgICAgcmV0dXJuIHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRCcmVha3BvaW50KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlSW5kZXgsXG4gICAgICAgIGluaXRpYWxpemVkLFxuICAgICAgICBsb29wZWRTbGlkZXMgPSAwLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgICRlbFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGNvbnN0IGJyZWFrcG9pbnRzID0gcGFyYW1zLmJyZWFrcG9pbnRzO1xuICAgICAgaWYgKCFicmVha3BvaW50cyB8fCBicmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhicmVha3BvaW50cykubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIEdldCBicmVha3BvaW50IGZvciB3aW5kb3cgd2lkdGggYW5kIHVwZGF0ZSBwYXJhbWV0ZXJzXG5cbiAgICAgIGNvbnN0IGJyZWFrcG9pbnQgPSBzd2lwZXIuZ2V0QnJlYWtwb2ludChicmVha3BvaW50cywgc3dpcGVyLnBhcmFtcy5icmVha3BvaW50c0Jhc2UsIHN3aXBlci5lbCk7XG4gICAgICBpZiAoIWJyZWFrcG9pbnQgfHwgc3dpcGVyLmN1cnJlbnRCcmVha3BvaW50ID09PSBicmVha3BvaW50KSByZXR1cm47XG4gICAgICBjb25zdCBicmVha3BvaW50T25seVBhcmFtcyA9IGJyZWFrcG9pbnQgaW4gYnJlYWtwb2ludHMgPyBicmVha3BvaW50c1ticmVha3BvaW50XSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGJyZWFrcG9pbnRQYXJhbXMgPSBicmVha3BvaW50T25seVBhcmFtcyB8fCBzd2lwZXIub3JpZ2luYWxQYXJhbXM7XG4gICAgICBjb25zdCB3YXNNdWx0aVJvdyA9IGlzR3JpZEVuYWJsZWQoc3dpcGVyLCBwYXJhbXMpO1xuICAgICAgY29uc3QgaXNNdWx0aVJvdyA9IGlzR3JpZEVuYWJsZWQoc3dpcGVyLCBicmVha3BvaW50UGFyYW1zKTtcbiAgICAgIGNvbnN0IHdhc0VuYWJsZWQgPSBwYXJhbXMuZW5hYmxlZDtcblxuICAgICAgaWYgKHdhc011bHRpUm93ICYmICFpc011bHRpUm93KSB7XG4gICAgICAgICRlbC5yZW1vdmVDbGFzcyhgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkICR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKTtcbiAgICAgICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgICB9IGVsc2UgaWYgKCF3YXNNdWx0aVJvdyAmJiBpc011bHRpUm93KSB7XG4gICAgICAgICRlbC5hZGRDbGFzcyhgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkYCk7XG5cbiAgICAgICAgaWYgKGJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsICYmIGJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsID09PSAnY29sdW1uJyB8fCAhYnJlYWtwb2ludFBhcmFtcy5ncmlkLmZpbGwgJiYgcGFyYW1zLmdyaWQuZmlsbCA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAkZWwuYWRkQ2xhc3MoYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICAgICAgfSAvLyBUb2dnbGUgbmF2aWdhdGlvbiwgcGFnaW5hdGlvbiwgc2Nyb2xsYmFyXG5cblxuICAgICAgWyduYXZpZ2F0aW9uJywgJ3BhZ2luYXRpb24nLCAnc2Nyb2xsYmFyJ10uZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgY29uc3Qgd2FzTW9kdWxlRW5hYmxlZCA9IHBhcmFtc1twcm9wXSAmJiBwYXJhbXNbcHJvcF0uZW5hYmxlZDtcbiAgICAgICAgY29uc3QgaXNNb2R1bGVFbmFibGVkID0gYnJlYWtwb2ludFBhcmFtc1twcm9wXSAmJiBicmVha3BvaW50UGFyYW1zW3Byb3BdLmVuYWJsZWQ7XG5cbiAgICAgICAgaWYgKHdhc01vZHVsZUVuYWJsZWQgJiYgIWlzTW9kdWxlRW5hYmxlZCkge1xuICAgICAgICAgIHN3aXBlcltwcm9wXS5kaXNhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXdhc01vZHVsZUVuYWJsZWQgJiYgaXNNb2R1bGVFbmFibGVkKSB7XG4gICAgICAgICAgc3dpcGVyW3Byb3BdLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbkNoYW5nZWQgPSBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAmJiBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAhPT0gcGFyYW1zLmRpcmVjdGlvbjtcbiAgICAgIGNvbnN0IG5lZWRzUmVMb29wID0gcGFyYW1zLmxvb3AgJiYgKGJyZWFrcG9pbnRQYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gcGFyYW1zLnNsaWRlc1BlclZpZXcgfHwgZGlyZWN0aW9uQ2hhbmdlZCk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb25DaGFuZ2VkICYmIGluaXRpYWxpemVkKSB7XG4gICAgICAgIHN3aXBlci5jaGFuZ2VEaXJlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgZXh0ZW5kJDEoc3dpcGVyLnBhcmFtcywgYnJlYWtwb2ludFBhcmFtcyk7XG4gICAgICBjb25zdCBpc0VuYWJsZWQgPSBzd2lwZXIucGFyYW1zLmVuYWJsZWQ7XG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcbiAgICAgICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXG4gICAgICAgIGFsbG93U2xpZGVQcmV2OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVQcmV2XG4gICAgICB9KTtcblxuICAgICAgaWYgKHdhc0VuYWJsZWQgJiYgIWlzRW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuZGlzYWJsZSgpO1xuICAgICAgfSBlbHNlIGlmICghd2FzRW5hYmxlZCAmJiBpc0VuYWJsZWQpIHtcbiAgICAgICAgc3dpcGVyLmVuYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIuY3VycmVudEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xuICAgICAgc3dpcGVyLmVtaXQoJ19iZWZvcmVCcmVha3BvaW50JywgYnJlYWtwb2ludFBhcmFtcyk7XG5cbiAgICAgIGlmIChuZWVkc1JlTG9vcCAmJiBpbml0aWFsaXplZCkge1xuICAgICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCAtIGxvb3BlZFNsaWRlcyArIHN3aXBlci5sb29wZWRTbGlkZXMsIDAsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXQoJ2JyZWFrcG9pbnQnLCBicmVha3BvaW50UGFyYW1zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCcmVha3BvaW50KGJyZWFrcG9pbnRzLCBiYXNlLCBjb250YWluZXJFbCkge1xuICAgICAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBiYXNlID0gJ3dpbmRvdyc7XG4gICAgICB9XG5cbiAgICAgIGlmICghYnJlYWtwb2ludHMgfHwgYmFzZSA9PT0gJ2NvbnRhaW5lcicgJiYgIWNvbnRhaW5lckVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgbGV0IGJyZWFrcG9pbnQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgY3VycmVudEhlaWdodCA9IGJhc2UgPT09ICd3aW5kb3cnID8gd2luZG93LmlubmVySGVpZ2h0IDogY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3QgcG9pbnRzID0gT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLm1hcChwb2ludCA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICdzdHJpbmcnICYmIHBvaW50LmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IG1pblJhdGlvID0gcGFyc2VGbG9hdChwb2ludC5zdWJzdHIoMSkpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudEhlaWdodCAqIG1pblJhdGlvO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHBvaW50XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHBvaW50LFxuICAgICAgICAgIHBvaW50XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHBvaW50cy5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhLnZhbHVlLCAxMCkgLSBwYXJzZUludChiLnZhbHVlLCAxMCkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSA9IHBvaW50c1tpXTtcblxuICAgICAgICBpZiAoYmFzZSA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEoYChtaW4td2lkdGg6ICR7dmFsdWV9cHgpYCkubWF0Y2hlcykge1xuICAgICAgICAgICAgYnJlYWtwb2ludCA9IHBvaW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8PSBjb250YWluZXJFbC5jbGllbnRXaWR0aCkge1xuICAgICAgICAgIGJyZWFrcG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJlYWtwb2ludCB8fCAnbWF4JztcbiAgICB9XG5cbiAgICB2YXIgYnJlYWtwb2ludHMgPSB7XG4gICAgICBzZXRCcmVha3BvaW50LFxuICAgICAgZ2V0QnJlYWtwb2ludFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ2xhc3NlcyhlbnRyaWVzLCBwcmVmaXgpIHtcbiAgICAgIGNvbnN0IHJlc3VsdENsYXNzZXMgPSBbXTtcbiAgICAgIGVudHJpZXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIE9iamVjdC5rZXlzKGl0ZW0pLmZvckVhY2goY2xhc3NOYW1lcyA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbVtjbGFzc05hbWVzXSkge1xuICAgICAgICAgICAgICByZXN1bHRDbGFzc2VzLnB1c2gocHJlZml4ICsgY2xhc3NOYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmVzdWx0Q2xhc3Nlcy5wdXNoKHByZWZpeCArIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHRDbGFzc2VzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc05hbWVzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHJ0bCxcbiAgICAgICAgJGVsLFxuICAgICAgICBkZXZpY2UsXG4gICAgICAgIHN1cHBvcnRcbiAgICAgIH0gPSBzd2lwZXI7IC8vIHByZXR0aWVyLWlnbm9yZVxuXG4gICAgICBjb25zdCBzdWZmaXhlcyA9IHByZXBhcmVDbGFzc2VzKFsnaW5pdGlhbGl6ZWQnLCBwYXJhbXMuZGlyZWN0aW9uLCB7XG4gICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICFzdXBwb3J0LnRvdWNoXG4gICAgICB9LCB7XG4gICAgICAgICdmcmVlLW1vZGUnOiBzd2lwZXIucGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkXG4gICAgICB9LCB7XG4gICAgICAgICdhdXRvaGVpZ2h0JzogcGFyYW1zLmF1dG9IZWlnaHRcbiAgICAgIH0sIHtcbiAgICAgICAgJ3J0bCc6IHJ0bFxuICAgICAgfSwge1xuICAgICAgICAnZ3JpZCc6IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxXG4gICAgICB9LCB7XG4gICAgICAgICdncmlkLWNvbHVtbic6IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxICYmIHBhcmFtcy5ncmlkLmZpbGwgPT09ICdjb2x1bW4nXG4gICAgICB9LCB7XG4gICAgICAgICdhbmRyb2lkJzogZGV2aWNlLmFuZHJvaWRcbiAgICAgIH0sIHtcbiAgICAgICAgJ2lvcyc6IGRldmljZS5pb3NcbiAgICAgIH0sIHtcbiAgICAgICAgJ2Nzcy1tb2RlJzogcGFyYW1zLmNzc01vZGVcbiAgICAgIH0sIHtcbiAgICAgICAgJ2NlbnRlcmVkJzogcGFyYW1zLmNzc01vZGUgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzXG4gICAgICB9LCB7XG4gICAgICAgICd3YXRjaC1wcm9ncmVzcyc6IHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzXG4gICAgICB9XSwgcGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MpO1xuICAgICAgY2xhc3NOYW1lcy5wdXNoKC4uLnN1ZmZpeGVzKTtcbiAgICAgICRlbC5hZGRDbGFzcyhbLi4uY2xhc3NOYW1lc10uam9pbignICcpKTtcbiAgICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICAkZWwsXG4gICAgICAgIGNsYXNzTmFtZXNcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAkZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lcy5qb2luKCcgJykpO1xuICAgICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzZXMgPSB7XG4gICAgICBhZGRDbGFzc2VzLFxuICAgICAgcmVtb3ZlQ2xhc3Nlc1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2FkSW1hZ2UoaW1hZ2VFbCwgc3JjLCBzcmNzZXQsIHNpemVzLCBjaGVja0ZvckNvbXBsZXRlLCBjYWxsYmFjaykge1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBsZXQgaW1hZ2U7XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVhZHkoKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNQaWN0dXJlID0gJChpbWFnZUVsKS5wYXJlbnQoJ3BpY3R1cmUnKVswXTtcblxuICAgICAgaWYgKCFpc1BpY3R1cmUgJiYgKCFpbWFnZUVsLmNvbXBsZXRlIHx8ICFjaGVja0ZvckNvbXBsZXRlKSkge1xuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKCk7XG4gICAgICAgICAgaW1hZ2Uub25sb2FkID0gb25SZWFkeTtcbiAgICAgICAgICBpbWFnZS5vbmVycm9yID0gb25SZWFkeTtcblxuICAgICAgICAgIGlmIChzaXplcykge1xuICAgICAgICAgICAgaW1hZ2Uuc2l6ZXMgPSBzaXplcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3Jjc2V0KSB7XG4gICAgICAgICAgICBpbWFnZS5zcmNzZXQgPSBzcmNzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvblJlYWR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGltYWdlIGFscmVhZHkgbG9hZGVkLi4uXG4gICAgICAgIG9uUmVhZHkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVsb2FkSW1hZ2VzKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5pbWFnZXNUb0xvYWQgPSBzd2lwZXIuJGVsLmZpbmQoJ2ltZycpO1xuXG4gICAgICBmdW5jdGlvbiBvblJlYWR5KCkge1xuICAgICAgICBpZiAodHlwZW9mIHN3aXBlciA9PT0gJ3VuZGVmaW5lZCcgfHwgc3dpcGVyID09PSBudWxsIHx8ICFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICBpZiAoc3dpcGVyLmltYWdlc0xvYWRlZCAhPT0gdW5kZWZpbmVkKSBzd2lwZXIuaW1hZ2VzTG9hZGVkICs9IDE7XG5cbiAgICAgICAgaWYgKHN3aXBlci5pbWFnZXNMb2FkZWQgPT09IHN3aXBlci5pbWFnZXNUb0xvYWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMudXBkYXRlT25JbWFnZXNSZWFkeSkgc3dpcGVyLnVwZGF0ZSgpO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdpbWFnZXNSZWFkeScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLmltYWdlc1RvTG9hZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBpbWFnZUVsID0gc3dpcGVyLmltYWdlc1RvTG9hZFtpXTtcbiAgICAgICAgc3dpcGVyLmxvYWRJbWFnZShpbWFnZUVsLCBpbWFnZUVsLmN1cnJlbnRTcmMgfHwgaW1hZ2VFbC5nZXRBdHRyaWJ1dGUoJ3NyYycpLCBpbWFnZUVsLnNyY3NldCB8fCBpbWFnZUVsLmdldEF0dHJpYnV0ZSgnc3Jjc2V0JyksIGltYWdlRWwuc2l6ZXMgfHwgaW1hZ2VFbC5nZXRBdHRyaWJ1dGUoJ3NpemVzJyksIHRydWUsIG9uUmVhZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbWFnZXMgPSB7XG4gICAgICBsb2FkSW1hZ2UsXG4gICAgICBwcmVsb2FkSW1hZ2VzXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3coKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc0xvY2tlZDogd2FzTG9ja2VkLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNsaWRlc09mZnNldEJlZm9yZVxuICAgICAgfSA9IHBhcmFtcztcblxuICAgICAgaWYgKHNsaWRlc09mZnNldEJlZm9yZSkge1xuICAgICAgICBjb25zdCBsYXN0U2xpZGVJbmRleCA9IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbGFzdFNsaWRlUmlnaHRFZGdlID0gc3dpcGVyLnNsaWRlc0dyaWRbbGFzdFNsaWRlSW5kZXhdICsgc3dpcGVyLnNsaWRlc1NpemVzR3JpZFtsYXN0U2xpZGVJbmRleF0gKyBzbGlkZXNPZmZzZXRCZWZvcmUgKiAyO1xuICAgICAgICBzd2lwZXIuaXNMb2NrZWQgPSBzd2lwZXIuc2l6ZSA+IGxhc3RTbGlkZVJpZ2h0RWRnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5pc0xvY2tlZCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGggPT09IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuYWxsb3dTbGlkZU5leHQgPT09IHRydWUpIHtcbiAgICAgICAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gIXN3aXBlci5pc0xvY2tlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5hbGxvd1NsaWRlUHJldiA9PT0gdHJ1ZSkge1xuICAgICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSAhc3dpcGVyLmlzTG9ja2VkO1xuICAgICAgfVxuXG4gICAgICBpZiAod2FzTG9ja2VkICYmIHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSB7XG4gICAgICAgIHN3aXBlci5pc0VuZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAod2FzTG9ja2VkICE9PSBzd2lwZXIuaXNMb2NrZWQpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoc3dpcGVyLmlzTG9ja2VkID8gJ2xvY2snIDogJ3VubG9jaycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGVja092ZXJmbG93JDEgPSB7XG4gICAgICBjaGVja092ZXJmbG93XG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGluaXQ6IHRydWUsXG4gICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgICAgIHRvdWNoRXZlbnRzVGFyZ2V0OiAnd3JhcHBlcicsXG4gICAgICBpbml0aWFsU2xpZGU6IDAsXG4gICAgICBzcGVlZDogMzAwLFxuICAgICAgY3NzTW9kZTogZmFsc2UsXG4gICAgICB1cGRhdGVPbldpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgIHJlc2l6ZU9ic2VydmVyOiB0cnVlLFxuICAgICAgbmVzdGVkOiBmYWxzZSxcbiAgICAgIGNyZWF0ZUVsZW1lbnRzOiBmYWxzZSxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb2N1c2FibGVFbGVtZW50czogJ2lucHV0LCBzZWxlY3QsIG9wdGlvbiwgdGV4dGFyZWEsIGJ1dHRvbiwgdmlkZW8sIGxhYmVsJyxcbiAgICAgIC8vIE92ZXJyaWRlc1xuICAgICAgd2lkdGg6IG51bGwsXG4gICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICAvL1xuICAgICAgcHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uOiBmYWxzZSxcbiAgICAgIC8vIHNzclxuICAgICAgdXNlckFnZW50OiBudWxsLFxuICAgICAgdXJsOiBudWxsLFxuICAgICAgLy8gVG8gc3VwcG9ydCBpT1MncyBzd2lwZS10by1nby1iYWNrIGdlc3R1cmUgKHdoZW4gYmVpbmcgdXNlZCBpbi1hcHApLlxuICAgICAgZWRnZVN3aXBlRGV0ZWN0aW9uOiBmYWxzZSxcbiAgICAgIGVkZ2VTd2lwZVRocmVzaG9sZDogMjAsXG4gICAgICAvLyBBdXRvaGVpZ2h0XG4gICAgICBhdXRvSGVpZ2h0OiBmYWxzZSxcbiAgICAgIC8vIFNldCB3cmFwcGVyIHdpZHRoXG4gICAgICBzZXRXcmFwcGVyU2l6ZTogZmFsc2UsXG4gICAgICAvLyBWaXJ0dWFsIFRyYW5zbGF0ZVxuICAgICAgdmlydHVhbFRyYW5zbGF0ZTogZmFsc2UsXG4gICAgICAvLyBFZmZlY3RzXG4gICAgICBlZmZlY3Q6ICdzbGlkZScsXG4gICAgICAvLyAnc2xpZGUnIG9yICdmYWRlJyBvciAnY3ViZScgb3IgJ2NvdmVyZmxvdycgb3IgJ2ZsaXAnXG4gICAgICAvLyBCcmVha3BvaW50c1xuICAgICAgYnJlYWtwb2ludHM6IHVuZGVmaW5lZCxcbiAgICAgIGJyZWFrcG9pbnRzQmFzZTogJ3dpbmRvdycsXG4gICAgICAvLyBTbGlkZXMgZ3JpZFxuICAgICAgc3BhY2VCZXR3ZWVuOiAwLFxuICAgICAgc2xpZGVzUGVyVmlldzogMSxcbiAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgc2xpZGVzUGVyR3JvdXBTa2lwOiAwLFxuICAgICAgc2xpZGVzUGVyR3JvdXBBdXRvOiBmYWxzZSxcbiAgICAgIGNlbnRlcmVkU2xpZGVzOiBmYWxzZSxcbiAgICAgIGNlbnRlcmVkU2xpZGVzQm91bmRzOiBmYWxzZSxcbiAgICAgIHNsaWRlc09mZnNldEJlZm9yZTogMCxcbiAgICAgIC8vIGluIHB4XG4gICAgICBzbGlkZXNPZmZzZXRBZnRlcjogMCxcbiAgICAgIC8vIGluIHB4XG4gICAgICBub3JtYWxpemVTbGlkZUluZGV4OiB0cnVlLFxuICAgICAgY2VudGVySW5zdWZmaWNpZW50U2xpZGVzOiBmYWxzZSxcbiAgICAgIC8vIERpc2FibGUgc3dpcGVyIGFuZCBoaWRlIG5hdmlnYXRpb24gd2hlbiBjb250YWluZXIgbm90IG92ZXJmbG93XG4gICAgICB3YXRjaE92ZXJmbG93OiB0cnVlLFxuICAgICAgLy8gUm91bmQgbGVuZ3RoXG4gICAgICByb3VuZExlbmd0aHM6IGZhbHNlLFxuICAgICAgLy8gVG91Y2hlc1xuICAgICAgdG91Y2hSYXRpbzogMSxcbiAgICAgIHRvdWNoQW5nbGU6IDQ1LFxuICAgICAgc2ltdWxhdGVUb3VjaDogdHJ1ZSxcbiAgICAgIHNob3J0U3dpcGVzOiB0cnVlLFxuICAgICAgbG9uZ1N3aXBlczogdHJ1ZSxcbiAgICAgIGxvbmdTd2lwZXNSYXRpbzogMC41LFxuICAgICAgbG9uZ1N3aXBlc01zOiAzMDAsXG4gICAgICBmb2xsb3dGaW5nZXI6IHRydWUsXG4gICAgICBhbGxvd1RvdWNoTW92ZTogdHJ1ZSxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXG4gICAgICB0b3VjaFN0YXJ0UHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICB0b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgICB0b3VjaFJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcbiAgICAgIC8vIFVuaXF1ZSBOYXZpZ2F0aW9uIEVsZW1lbnRzXG4gICAgICB1bmlxdWVOYXZFbGVtZW50czogdHJ1ZSxcbiAgICAgIC8vIFJlc2lzdGFuY2VcbiAgICAgIHJlc2lzdGFuY2U6IHRydWUsXG4gICAgICByZXNpc3RhbmNlUmF0aW86IDAuODUsXG4gICAgICAvLyBQcm9ncmVzc1xuICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogZmFsc2UsXG4gICAgICAvLyBDdXJzb3JcbiAgICAgIGdyYWJDdXJzb3I6IGZhbHNlLFxuICAgICAgLy8gQ2xpY2tzXG4gICAgICBwcmV2ZW50Q2xpY2tzOiB0cnVlLFxuICAgICAgcHJldmVudENsaWNrc1Byb3BhZ2F0aW9uOiB0cnVlLFxuICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogZmFsc2UsXG4gICAgICAvLyBJbWFnZXNcbiAgICAgIHByZWxvYWRJbWFnZXM6IHRydWUsXG4gICAgICB1cGRhdGVPbkltYWdlc1JlYWR5OiB0cnVlLFxuICAgICAgLy8gbG9vcFxuICAgICAgbG9vcDogZmFsc2UsXG4gICAgICBsb29wQWRkaXRpb25hbFNsaWRlczogMCxcbiAgICAgIGxvb3BlZFNsaWRlczogbnVsbCxcbiAgICAgIGxvb3BlZFNsaWRlc0xpbWl0OiB0cnVlLFxuICAgICAgbG9vcEZpbGxHcm91cFdpdGhCbGFuazogZmFsc2UsXG4gICAgICBsb29wUHJldmVudHNTbGlkZTogdHJ1ZSxcbiAgICAgIC8vIHJld2luZFxuICAgICAgcmV3aW5kOiBmYWxzZSxcbiAgICAgIC8vIFN3aXBpbmcvbm8gc3dpcGluZ1xuICAgICAgYWxsb3dTbGlkZVByZXY6IHRydWUsXG4gICAgICBhbGxvd1NsaWRlTmV4dDogdHJ1ZSxcbiAgICAgIHN3aXBlSGFuZGxlcjogbnVsbCxcbiAgICAgIC8vICcuc3dpcGUtaGFuZGxlcicsXG4gICAgICBub1N3aXBpbmc6IHRydWUsXG4gICAgICBub1N3aXBpbmdDbGFzczogJ3N3aXBlci1uby1zd2lwaW5nJyxcbiAgICAgIG5vU3dpcGluZ1NlbGVjdG9yOiBudWxsLFxuICAgICAgLy8gUGFzc2l2ZSBMaXN0ZW5lcnNcbiAgICAgIHBhc3NpdmVMaXN0ZW5lcnM6IHRydWUsXG4gICAgICBtYXhCYWNrZmFjZUhpZGRlblNsaWRlczogMTAsXG4gICAgICAvLyBOU1xuICAgICAgY29udGFpbmVyTW9kaWZpZXJDbGFzczogJ3N3aXBlci0nLFxuICAgICAgLy8gTkVXXG4gICAgICBzbGlkZUNsYXNzOiAnc3dpcGVyLXNsaWRlJyxcbiAgICAgIHNsaWRlQmxhbmtDbGFzczogJ3N3aXBlci1zbGlkZS1pbnZpc2libGUtYmxhbmsnLFxuICAgICAgc2xpZGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1hY3RpdmUnLFxuICAgICAgc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUtYWN0aXZlJyxcbiAgICAgIHNsaWRlVmlzaWJsZUNsYXNzOiAnc3dpcGVyLXNsaWRlLXZpc2libGUnLFxuICAgICAgc2xpZGVEdXBsaWNhdGVDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUnLFxuICAgICAgc2xpZGVOZXh0Q2xhc3M6ICdzd2lwZXItc2xpZGUtbmV4dCcsXG4gICAgICBzbGlkZUR1cGxpY2F0ZU5leHRDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUtbmV4dCcsXG4gICAgICBzbGlkZVByZXZDbGFzczogJ3N3aXBlci1zbGlkZS1wcmV2JyxcbiAgICAgIHNsaWRlRHVwbGljYXRlUHJldkNsYXNzOiAnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1wcmV2JyxcbiAgICAgIHdyYXBwZXJDbGFzczogJ3N3aXBlci13cmFwcGVyJyxcbiAgICAgIC8vIENhbGxiYWNrc1xuICAgICAgcnVuQ2FsbGJhY2tzT25Jbml0OiB0cnVlLFxuICAgICAgLy8gSW50ZXJuYWxzXG4gICAgICBfZW1pdENsYXNzZXM6IGZhbHNlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1vZHVsZUV4dGVuZFBhcmFtcyhwYXJhbXMsIGFsbE1vZHVsZXNQYXJhbXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBleHRlbmRQYXJhbXMob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT09IHZvaWQgMCkge1xuICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kdWxlUGFyYW1OYW1lID0gT2JqZWN0LmtleXMob2JqKVswXTtcbiAgICAgICAgY29uc3QgbW9kdWxlUGFyYW1zID0gb2JqW21vZHVsZVBhcmFtTmFtZV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVQYXJhbXMgIT09ICdvYmplY3QnIHx8IG1vZHVsZVBhcmFtcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGV4dGVuZCQxKGFsbE1vZHVsZXNQYXJhbXMsIG9iaik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFsnbmF2aWdhdGlvbicsICdwYWdpbmF0aW9uJywgJ3Njcm9sbGJhciddLmluZGV4T2YobW9kdWxlUGFyYW1OYW1lKSA+PSAwICYmIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSB0cnVlKSB7XG4gICAgICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7XG4gICAgICAgICAgICBhdXRvOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKG1vZHVsZVBhcmFtTmFtZSBpbiBwYXJhbXMgJiYgJ2VuYWJsZWQnIGluIG1vZHVsZVBhcmFtcykpIHtcbiAgICAgICAgICBleHRlbmQkMShhbGxNb2R1bGVzUGFyYW1zLCBvYmopO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID0ge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSAnb2JqZWN0JyAmJiAhKCdlbmFibGVkJyBpbiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSkpIHtcbiAgICAgICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0pIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID0ge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGV4dGVuZCQxKGFsbE1vZHVsZXNQYXJhbXMsIG9iaik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogXCJvZmZcIiAqL1xuICAgIGNvbnN0IHByb3RvdHlwZXMgPSB7XG4gICAgICBldmVudHNFbWl0dGVyLFxuICAgICAgdXBkYXRlLFxuICAgICAgdHJhbnNsYXRlLFxuICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiQxLFxuICAgICAgc2xpZGUsXG4gICAgICBsb29wLFxuICAgICAgZ3JhYkN1cnNvcixcbiAgICAgIGV2ZW50czogZXZlbnRzJDEsXG4gICAgICBicmVha3BvaW50cyxcbiAgICAgIGNoZWNrT3ZlcmZsb3c6IGNoZWNrT3ZlcmZsb3ckMSxcbiAgICAgIGNsYXNzZXMsXG4gICAgICBpbWFnZXNcbiAgICB9O1xuICAgIGNvbnN0IGV4dGVuZGVkRGVmYXVsdHMgPSB7fTtcblxuICAgIGNsYXNzIFN3aXBlciB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IGVsO1xuICAgICAgICBsZXQgcGFyYW1zO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgYXJnc1swXS5jb25zdHJ1Y3RvciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnc1swXSkuc2xpY2UoOCwgLTEpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgW2VsLCBwYXJhbXNdID0gYXJncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICAgICAgcGFyYW1zID0gZXh0ZW5kJDEoe30sIHBhcmFtcyk7XG4gICAgICAgIGlmIChlbCAmJiAhcGFyYW1zLmVsKSBwYXJhbXMuZWwgPSBlbDtcblxuICAgICAgICBpZiAocGFyYW1zLmVsICYmICQocGFyYW1zLmVsKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29uc3Qgc3dpcGVycyA9IFtdO1xuICAgICAgICAgICQocGFyYW1zLmVsKS5lYWNoKGNvbnRhaW5lckVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IGV4dGVuZCQxKHt9LCBwYXJhbXMsIHtcbiAgICAgICAgICAgICAgZWw6IGNvbnRhaW5lckVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN3aXBlcnMucHVzaChuZXcgU3dpcGVyKG5ld1BhcmFtcykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBzd2lwZXJzO1xuICAgICAgICB9IC8vIFN3aXBlciBJbnN0YW5jZVxuXG5cbiAgICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgICAgc3dpcGVyLl9fc3dpcGVyX18gPSB0cnVlO1xuICAgICAgICBzd2lwZXIuc3VwcG9ydCA9IGdldFN1cHBvcnQoKTtcbiAgICAgICAgc3dpcGVyLmRldmljZSA9IGdldERldmljZSh7XG4gICAgICAgICAgdXNlckFnZW50OiBwYXJhbXMudXNlckFnZW50XG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXIuYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICAgICAgc3dpcGVyLmV2ZW50c0xpc3RlbmVycyA9IHt9O1xuICAgICAgICBzd2lwZXIuZXZlbnRzQW55TGlzdGVuZXJzID0gW107XG4gICAgICAgIHN3aXBlci5tb2R1bGVzID0gWy4uLnN3aXBlci5fX21vZHVsZXNfX107XG5cbiAgICAgICAgaWYgKHBhcmFtcy5tb2R1bGVzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLm1vZHVsZXMpKSB7XG4gICAgICAgICAgc3dpcGVyLm1vZHVsZXMucHVzaCguLi5wYXJhbXMubW9kdWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbGxNb2R1bGVzUGFyYW1zID0ge307XG4gICAgICAgIHN3aXBlci5tb2R1bGVzLmZvckVhY2gobW9kID0+IHtcbiAgICAgICAgICBtb2Qoe1xuICAgICAgICAgICAgc3dpcGVyLFxuICAgICAgICAgICAgZXh0ZW5kUGFyYW1zOiBtb2R1bGVFeHRlbmRQYXJhbXMocGFyYW1zLCBhbGxNb2R1bGVzUGFyYW1zKSxcbiAgICAgICAgICAgIG9uOiBzd2lwZXIub24uYmluZChzd2lwZXIpLFxuICAgICAgICAgICAgb25jZTogc3dpcGVyLm9uY2UuYmluZChzd2lwZXIpLFxuICAgICAgICAgICAgb2ZmOiBzd2lwZXIub2ZmLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgICAgIGVtaXQ6IHN3aXBlci5lbWl0LmJpbmQoc3dpcGVyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggbW9kdWxlcyBwYXJhbXNcblxuICAgICAgICBjb25zdCBzd2lwZXJQYXJhbXMgPSBleHRlbmQkMSh7fSwgZGVmYXVsdHMsIGFsbE1vZHVsZXNQYXJhbXMpOyAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBwYXNzZWQgcGFyYW1zXG5cbiAgICAgICAgc3dpcGVyLnBhcmFtcyA9IGV4dGVuZCQxKHt9LCBzd2lwZXJQYXJhbXMsIGV4dGVuZGVkRGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcyA9IGV4dGVuZCQxKHt9LCBzd2lwZXIucGFyYW1zKTtcbiAgICAgICAgc3dpcGVyLnBhc3NlZFBhcmFtcyA9IGV4dGVuZCQxKHt9LCBwYXJhbXMpOyAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzXG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMgJiYgc3dpcGVyLnBhcmFtcy5vbikge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHN3aXBlci5wYXJhbXMub24pLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgICAgICAgIHN3aXBlci5vbihldmVudE5hbWUsIHN3aXBlci5wYXJhbXMub25bZXZlbnROYW1lXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcyAmJiBzd2lwZXIucGFyYW1zLm9uQW55KSB7XG4gICAgICAgICAgc3dpcGVyLm9uQW55KHN3aXBlci5wYXJhbXMub25BbnkpO1xuICAgICAgICB9IC8vIFNhdmUgRG9tIGxpYlxuXG5cbiAgICAgICAgc3dpcGVyLiQgPSAkOyAvLyBFeHRlbmQgU3dpcGVyXG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgICBlbmFibGVkOiBzd2lwZXIucGFyYW1zLmVuYWJsZWQsXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgLy8gQ2xhc3Nlc1xuICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgIC8vIFNsaWRlc1xuICAgICAgICAgIHNsaWRlczogJCgpLFxuICAgICAgICAgIHNsaWRlc0dyaWQ6IFtdLFxuICAgICAgICAgIHNuYXBHcmlkOiBbXSxcbiAgICAgICAgICBzbGlkZXNTaXplc0dyaWQ6IFtdLFxuXG4gICAgICAgICAgLy8gaXNEaXJlY3Rpb25cbiAgICAgICAgICBpc0hvcml6b250YWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaXNWZXJ0aWNhbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gSW5kZXhlc1xuICAgICAgICAgIGFjdGl2ZUluZGV4OiAwLFxuICAgICAgICAgIHJlYWxJbmRleDogMCxcbiAgICAgICAgICAvL1xuICAgICAgICAgIGlzQmVnaW5uaW5nOiB0cnVlLFxuICAgICAgICAgIGlzRW5kOiBmYWxzZSxcbiAgICAgICAgICAvLyBQcm9wc1xuICAgICAgICAgIHRyYW5zbGF0ZTogMCxcbiAgICAgICAgICBwcmV2aW91c1RyYW5zbGF0ZTogMCxcbiAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICB2ZWxvY2l0eTogMCxcbiAgICAgICAgICBhbmltYXRpbmc6IGZhbHNlLFxuICAgICAgICAgIC8vIExvY2tzXG4gICAgICAgICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXG4gICAgICAgICAgYWxsb3dTbGlkZVByZXY6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZVByZXYsXG4gICAgICAgICAgLy8gVG91Y2ggRXZlbnRzXG4gICAgICAgICAgdG91Y2hFdmVudHM6IGZ1bmN0aW9uIHRvdWNoRXZlbnRzKCkge1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJ107XG4gICAgICAgICAgICBjb25zdCBkZXNrdG9wID0gWydwb2ludGVyZG93bicsICdwb2ludGVybW92ZScsICdwb2ludGVydXAnXTtcbiAgICAgICAgICAgIHN3aXBlci50b3VjaEV2ZW50c1RvdWNoID0ge1xuICAgICAgICAgICAgICBzdGFydDogdG91Y2hbMF0sXG4gICAgICAgICAgICAgIG1vdmU6IHRvdWNoWzFdLFxuICAgICAgICAgICAgICBlbmQ6IHRvdWNoWzJdLFxuICAgICAgICAgICAgICBjYW5jZWw6IHRvdWNoWzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGVza3RvcCA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRlc2t0b3BbMF0sXG4gICAgICAgICAgICAgIG1vdmU6IGRlc2t0b3BbMV0sXG4gICAgICAgICAgICAgIGVuZDogZGVza3RvcFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzd2lwZXIuc3VwcG9ydC50b3VjaCB8fCAhc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoID8gc3dpcGVyLnRvdWNoRXZlbnRzVG91Y2ggOiBzd2lwZXIudG91Y2hFdmVudHNEZXNrdG9wO1xuICAgICAgICAgIH0oKSxcbiAgICAgICAgICB0b3VjaEV2ZW50c0RhdGE6IHtcbiAgICAgICAgICAgIGlzVG91Y2hlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNNb3ZlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG91Y2hTdGFydFRpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGFydFRyYW5zbGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3dUaHJlc2hvbGRNb3ZlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBGb3JtIGVsZW1lbnRzIHRvIG1hdGNoXG4gICAgICAgICAgICBmb2N1c2FibGVFbGVtZW50czogc3dpcGVyLnBhcmFtcy5mb2N1c2FibGVFbGVtZW50cyxcbiAgICAgICAgICAgIC8vIExhc3QgY2xpY2sgdGltZVxuICAgICAgICAgICAgbGFzdENsaWNrVGltZTogbm93KCksXG4gICAgICAgICAgICBjbGlja1RpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFZlbG9jaXRpZXNcbiAgICAgICAgICAgIHZlbG9jaXRpZXM6IFtdLFxuICAgICAgICAgICAgYWxsb3dNb21lbnR1bUJvdW5jZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGFydE1vdmluZzogdW5kZWZpbmVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBDbGlja3NcbiAgICAgICAgICBhbGxvd0NsaWNrOiB0cnVlLFxuICAgICAgICAgIC8vIFRvdWNoZXNcbiAgICAgICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcbiAgICAgICAgICB0b3VjaGVzOiB7XG4gICAgICAgICAgICBzdGFydFg6IDAsXG4gICAgICAgICAgICBzdGFydFk6IDAsXG4gICAgICAgICAgICBjdXJyZW50WDogMCxcbiAgICAgICAgICAgIGN1cnJlbnRZOiAwLFxuICAgICAgICAgICAgZGlmZjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gSW1hZ2VzXG4gICAgICAgICAgaW1hZ2VzVG9Mb2FkOiBbXSxcbiAgICAgICAgICBpbWFnZXNMb2FkZWQ6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlci5lbWl0KCdfc3dpcGVyJyk7IC8vIEluaXRcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5pbml0KSB7XG4gICAgICAgICAgc3dpcGVyLmluaXQoKTtcbiAgICAgICAgfSAvLyBSZXR1cm4gYXBwIGluc3RhbmNlXG5cblxuICAgICAgICByZXR1cm4gc3dpcGVyO1xuICAgICAgfVxuXG4gICAgICBlbmFibGUoKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBzd2lwZXIuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnZW5hYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGRpc2FibGUoKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yKSB7XG4gICAgICAgICAgc3dpcGVyLnVuc2V0R3JhYkN1cnNvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmVtaXQoJ2Rpc2FibGUnKTtcbiAgICAgIH1cblxuICAgICAgc2V0UHJvZ3Jlc3MocHJvZ3Jlc3MsIHNwZWVkKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIHByb2dyZXNzID0gTWF0aC5taW4oTWF0aC5tYXgocHJvZ3Jlc3MsIDApLCAxKTtcbiAgICAgICAgY29uc3QgbWluID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICBjb25zdCBtYXggPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSAobWF4IC0gbWluKSAqIHByb2dyZXNzICsgbWluO1xuICAgICAgICBzd2lwZXIudHJhbnNsYXRlVG8oY3VycmVudCwgdHlwZW9mIHNwZWVkID09PSAndW5kZWZpbmVkJyA/IDAgOiBzcGVlZCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgICAgfVxuXG4gICAgICBlbWl0Q29udGFpbmVyQ2xhc3NlcygpIHtcbiAgICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLl9lbWl0Q2xhc3NlcyB8fCAhc3dpcGVyLmVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGNscyA9IHN3aXBlci5lbC5jbGFzc05hbWUuc3BsaXQoJyAnKS5maWx0ZXIoY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3N3aXBlcicpID09PSAwIHx8IGNsYXNzTmFtZS5pbmRleE9mKHN3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcykgPT09IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXIuZW1pdCgnX2NvbnRhaW5lckNsYXNzZXMnLCBjbHMuam9pbignICcpKTtcbiAgICAgIH1cblxuICAgICAgZ2V0U2xpZGVDbGFzc2VzKHNsaWRlRWwpIHtcbiAgICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgICAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybiAnJztcbiAgICAgICAgcmV0dXJuIHNsaWRlRWwuY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKCdzd2lwZXItc2xpZGUnKSA9PT0gMCB8fCBjbGFzc05hbWUuaW5kZXhPZihzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3MpID09PSAwO1xuICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICB9XG5cbiAgICAgIGVtaXRTbGlkZXNDbGFzc2VzKCkge1xuICAgICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuX2VtaXRDbGFzc2VzIHx8ICFzd2lwZXIuZWwpIHJldHVybjtcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgICAgICBzd2lwZXIuc2xpZGVzLmVhY2goc2xpZGVFbCA9PiB7XG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IHN3aXBlci5nZXRTbGlkZUNsYXNzZXMoc2xpZGVFbCk7XG4gICAgICAgICAgdXBkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNsaWRlRWwsXG4gICAgICAgICAgICBjbGFzc05hbWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ19zbGlkZUNsYXNzJywgc2xpZGVFbCwgY2xhc3NOYW1lcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXIuZW1pdCgnX3NsaWRlQ2xhc3NlcycsIHVwZGF0ZXMpO1xuICAgICAgfVxuXG4gICAgICBzbGlkZXNQZXJWaWV3RHluYW1pYyh2aWV3LCBleGFjdCkge1xuICAgICAgICBpZiAodmlldyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmlldyA9ICdjdXJyZW50JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGFjdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZXhhY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgIHNsaWRlc0dyaWQsXG4gICAgICAgICAgc2xpZGVzU2l6ZXNHcmlkLFxuICAgICAgICAgIHNpemU6IHN3aXBlclNpemUsXG4gICAgICAgICAgYWN0aXZlSW5kZXhcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgbGV0IHNwdiA9IDE7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgIGxldCBzbGlkZVNpemUgPSBzbGlkZXNbYWN0aXZlSW5kZXhdLnN3aXBlclNsaWRlU2l6ZTtcbiAgICAgICAgICBsZXQgYnJlYWtMb29wO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHNsaWRlc1tpXSAmJiAhYnJlYWtMb29wKSB7XG4gICAgICAgICAgICAgIHNsaWRlU2l6ZSArPSBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplO1xuICAgICAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKHNsaWRlU2l6ZSA+IHN3aXBlclNpemUpIGJyZWFrTG9vcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgIGlmIChzbGlkZXNbaV0gJiYgIWJyZWFrTG9vcCkge1xuICAgICAgICAgICAgICBzbGlkZVNpemUgKz0gc2xpZGVzW2ldLnN3aXBlclNsaWRlU2l6ZTtcbiAgICAgICAgICAgICAgc3B2ICs9IDE7XG4gICAgICAgICAgICAgIGlmIChzbGlkZVNpemUgPiBzd2lwZXJTaXplKSBicmVha0xvb3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICBpZiAodmlldyA9PT0gJ2N1cnJlbnQnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggKyAxOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlSW5WaWV3ID0gZXhhY3QgPyBzbGlkZXNHcmlkW2ldICsgc2xpZGVzU2l6ZXNHcmlkW2ldIC0gc2xpZGVzR3JpZFthY3RpdmVJbmRleF0gPCBzd2lwZXJTaXplIDogc2xpZGVzR3JpZFtpXSAtIHNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdIDwgc3dpcGVyU2l6ZTtcblxuICAgICAgICAgICAgICBpZiAoc2xpZGVJblZpZXcpIHtcbiAgICAgICAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2xpZGVJblZpZXcgPSBzbGlkZXNHcmlkW2FjdGl2ZUluZGV4XSAtIHNsaWRlc0dyaWRbaV0gPCBzd2lwZXJTaXplO1xuXG4gICAgICAgICAgICAgIGlmIChzbGlkZUluVmlldykge1xuICAgICAgICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNwdjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKCkge1xuICAgICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICBwYXJhbXNcbiAgICAgICAgfSA9IHN3aXBlcjsgLy8gQnJlYWtwb2ludHNcblxuICAgICAgICBpZiAocGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgICAgICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci51cGRhdGVTaXplKCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlKCkge1xuICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgKiAtMSA6IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICAgICAgY29uc3QgbmV3VHJhbnNsYXRlID0gTWF0aC5taW4oTWF0aC5tYXgodHJhbnNsYXRlVmFsdWUsIHN3aXBlci5tYXhUcmFuc2xhdGUoKSksIHN3aXBlci5taW5UcmFuc2xhdGUoKSk7XG4gICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdUcmFuc2xhdGUpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdHJhbnNsYXRlZDtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBzd2lwZXIucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQpIHtcbiAgICAgICAgICBzZXRUcmFuc2xhdGUoKTtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgfHwgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZWQgPSBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRyYW5zbGF0ZWQpIHtcbiAgICAgICAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzbmFwR3JpZCAhPT0gc3dpcGVyLnNuYXBHcmlkKSB7XG4gICAgICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci5lbWl0KCd1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlRGlyZWN0aW9uKG5ld0RpcmVjdGlvbiwgbmVlZFVwZGF0ZSkge1xuICAgICAgICBpZiAobmVlZFVwZGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgICBjb25zdCBjdXJyZW50RGlyZWN0aW9uID0gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb247XG5cbiAgICAgICAgaWYgKCFuZXdEaXJlY3Rpb24pIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICBuZXdEaXJlY3Rpb24gPSBjdXJyZW50RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0RpcmVjdGlvbiA9PT0gY3VycmVudERpcmVjdGlvbiB8fCBuZXdEaXJlY3Rpb24gIT09ICdob3Jpem9udGFsJyAmJiBuZXdEaXJlY3Rpb24gIT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICByZXR1cm4gc3dpcGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLiRlbC5yZW1vdmVDbGFzcyhgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHtjdXJyZW50RGlyZWN0aW9ufWApLmFkZENsYXNzKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30ke25ld0RpcmVjdGlvbn1gKTtcbiAgICAgICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgICAgIHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID0gbmV3RGlyZWN0aW9uO1xuICAgICAgICBzd2lwZXIuc2xpZGVzLmVhY2goc2xpZGVFbCA9PiB7XG4gICAgICAgICAgaWYgKG5ld0RpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgc2xpZGVFbC5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGlkZUVsLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlci5lbWl0KCdjaGFuZ2VEaXJlY3Rpb24nKTtcbiAgICAgICAgaWYgKG5lZWRVcGRhdGUpIHN3aXBlci51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHN3aXBlcjtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlTGFuZ3VhZ2VEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChzd2lwZXIucnRsICYmIGRpcmVjdGlvbiA9PT0gJ3J0bCcgfHwgIXN3aXBlci5ydGwgJiYgZGlyZWN0aW9uID09PSAnbHRyJykgcmV0dXJuO1xuICAgICAgICBzd2lwZXIucnRsID0gZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgc3dpcGVyLnJ0bFRyYW5zbGF0ZSA9IHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgc3dpcGVyLnJ0bDtcblxuICAgICAgICBpZiAoc3dpcGVyLnJ0bCkge1xuICAgICAgICAgIHN3aXBlci4kZWwuYWRkQ2xhc3MoYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXJ0bGApO1xuICAgICAgICAgIHN3aXBlci5lbC5kaXIgPSAncnRsJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuJGVsLnJlbW92ZUNsYXNzKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ydGxgKTtcbiAgICAgICAgICBzd2lwZXIuZWwuZGlyID0gJ2x0cic7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIG1vdW50KGVsKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChzd2lwZXIubW91bnRlZCkgcmV0dXJuIHRydWU7IC8vIEZpbmQgZWxcblxuICAgICAgICBjb25zdCAkZWwgPSAkKGVsIHx8IHN3aXBlci5wYXJhbXMuZWwpO1xuICAgICAgICBlbCA9ICRlbFswXTtcblxuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuc3dpcGVyID0gc3dpcGVyO1xuXG4gICAgICAgIGNvbnN0IGdldFdyYXBwZXJTZWxlY3RvciA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gYC4keyhzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzcyB8fCAnJykudHJpbSgpLnNwbGl0KCcgJykuam9pbignLicpfWA7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZ2V0V3JhcHBlciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoZWwgJiYgZWwuc2hhZG93Um9vdCAmJiBlbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9ICQoZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGdldFdyYXBwZXJTZWxlY3RvcigpKSk7IC8vIENoaWxkcmVuIG5lZWRzIHRvIHJldHVybiBzbG90IGl0ZW1zXG5cbiAgICAgICAgICAgIHJlcy5jaGlsZHJlbiA9IG9wdGlvbnMgPT4gJGVsLmNoaWxkcmVuKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghJGVsLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm4gJCgkZWwpLmNoaWxkcmVuKGdldFdyYXBwZXJTZWxlY3RvcigpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJGVsLmNoaWxkcmVuKGdldFdyYXBwZXJTZWxlY3RvcigpKTtcbiAgICAgICAgfTsgLy8gRmluZCBXcmFwcGVyXG5cblxuICAgICAgICBsZXQgJHdyYXBwZXJFbCA9IGdldFdyYXBwZXIoKTtcblxuICAgICAgICBpZiAoJHdyYXBwZXJFbC5sZW5ndGggPT09IDAgJiYgc3dpcGVyLnBhcmFtcy5jcmVhdGVFbGVtZW50cykge1xuICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgJHdyYXBwZXJFbCA9ICQod3JhcHBlcik7XG4gICAgICAgICAgd3JhcHBlci5jbGFzc05hbWUgPSBzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzcztcbiAgICAgICAgICAkZWwuYXBwZW5kKHdyYXBwZXIpO1xuICAgICAgICAgICRlbC5jaGlsZHJlbihgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWApLmVhY2goc2xpZGVFbCA9PiB7XG4gICAgICAgICAgICAkd3JhcHBlckVsLmFwcGVuZChzbGlkZUVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgICAgICAgJGVsLFxuICAgICAgICAgIGVsLFxuICAgICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgICAgd3JhcHBlckVsOiAkd3JhcHBlckVsWzBdLFxuICAgICAgICAgIG1vdW50ZWQ6IHRydWUsXG4gICAgICAgICAgLy8gUlRMXG4gICAgICAgICAgcnRsOiBlbC5kaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCcgfHwgJGVsLmNzcygnZGlyZWN0aW9uJykgPT09ICdydGwnLFxuICAgICAgICAgIHJ0bFRyYW5zbGF0ZTogc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiAoZWwuZGlyLnRvTG93ZXJDYXNlKCkgPT09ICdydGwnIHx8ICRlbC5jc3MoJ2RpcmVjdGlvbicpID09PSAncnRsJyksXG4gICAgICAgICAgd3JvbmdSVEw6ICR3cmFwcGVyRWwuY3NzKCdkaXNwbGF5JykgPT09ICctd2Via2l0LWJveCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpbml0KGVsKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybiBzd2lwZXI7XG4gICAgICAgIGNvbnN0IG1vdW50ZWQgPSBzd2lwZXIubW91bnQoZWwpO1xuICAgICAgICBpZiAobW91bnRlZCA9PT0gZmFsc2UpIHJldHVybiBzd2lwZXI7XG4gICAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVJbml0Jyk7IC8vIFNldCBicmVha3BvaW50XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYnJlYWtwb2ludHMpIHtcbiAgICAgICAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xuICAgICAgICB9IC8vIEFkZCBDbGFzc2VzXG5cblxuICAgICAgICBzd2lwZXIuYWRkQ2xhc3NlcygpOyAvLyBDcmVhdGUgbG9vcFxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xuICAgICAgICB9IC8vIFVwZGF0ZSBzaXplXG5cblxuICAgICAgICBzd2lwZXIudXBkYXRlU2l6ZSgpOyAvLyBVcGRhdGUgc2xpZGVzXG5cbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cpIHtcbiAgICAgICAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICAgICAgICB9IC8vIFNldCBHcmFiIEN1cnNvclxuXG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvciAmJiBzd2lwZXIuZW5hYmxlZCkge1xuICAgICAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5wcmVsb2FkSW1hZ2VzKSB7XG4gICAgICAgICAgc3dpcGVyLnByZWxvYWRJbWFnZXMoKTtcbiAgICAgICAgfSAvLyBTbGlkZSBUbyBJbml0aWFsIFNsaWRlXG5cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnBhcmFtcy5pbml0aWFsU2xpZGUgKyBzd2lwZXIubG9vcGVkU2xpZGVzLCAwLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlLCAwLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IC8vIEF0dGFjaCBldmVudHNcblxuXG4gICAgICAgIHN3aXBlci5hdHRhY2hFdmVudHMoKTsgLy8gSW5pdCBGbGFnXG5cbiAgICAgICAgc3dpcGVyLmluaXRpYWxpemVkID0gdHJ1ZTsgLy8gRW1pdFxuXG4gICAgICAgIHN3aXBlci5lbWl0KCdpbml0Jyk7XG4gICAgICAgIHN3aXBlci5lbWl0KCdhZnRlckluaXQnKTtcbiAgICAgICAgcmV0dXJuIHN3aXBlcjtcbiAgICAgIH1cblxuICAgICAgZGVzdHJveShkZWxldGVJbnN0YW5jZSwgY2xlYW5TdHlsZXMpIHtcbiAgICAgICAgaWYgKGRlbGV0ZUluc3RhbmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkZWxldGVJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xlYW5TdHlsZXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNsZWFuU3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgJGVsLFxuICAgICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgICAgc2xpZGVzXG4gICAgICAgIH0gPSBzd2lwZXI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zID09PSAndW5kZWZpbmVkJyB8fCBzd2lwZXIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlRGVzdHJveScpOyAvLyBJbml0IEZsYWdcblxuICAgICAgICBzd2lwZXIuaW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy8gRGV0YWNoIGV2ZW50c1xuXG4gICAgICAgIHN3aXBlci5kZXRhY2hFdmVudHMoKTsgLy8gRGVzdHJveSBsb29wXG5cbiAgICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gICAgICAgIH0gLy8gQ2xlYW51cCBzdHlsZXNcblxuXG4gICAgICAgIGlmIChjbGVhblN0eWxlcykge1xuICAgICAgICAgIHN3aXBlci5yZW1vdmVDbGFzc2VzKCk7XG4gICAgICAgICAgJGVsLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgICAgICAgJHdyYXBwZXJFbC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXG4gICAgICAgICAgaWYgKHNsaWRlcyAmJiBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzbGlkZXMucmVtb3ZlQ2xhc3MoW3BhcmFtcy5zbGlkZVZpc2libGVDbGFzcywgcGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MsIHBhcmFtcy5zbGlkZU5leHRDbGFzcywgcGFyYW1zLnNsaWRlUHJldkNsYXNzXS5qb2luKCcgJykpLnJlbW92ZUF0dHIoJ3N0eWxlJykucmVtb3ZlQXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnZGVzdHJveScpOyAvLyBEZXRhY2ggZW1pdHRlciBldmVudHNcblxuICAgICAgICBPYmplY3Qua2V5cyhzd2lwZXIuZXZlbnRzTGlzdGVuZXJzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgICAgc3dpcGVyLm9mZihldmVudE5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGVsZXRlSW5zdGFuY2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgc3dpcGVyLiRlbFswXS5zd2lwZXIgPSBudWxsO1xuICAgICAgICAgIGRlbGV0ZVByb3BzKHN3aXBlcik7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBleHRlbmREZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICAgICAgICBleHRlbmQkMShleHRlbmRlZERlZmF1bHRzLCBuZXdEZWZhdWx0cyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBnZXQgZXh0ZW5kZWREZWZhdWx0cygpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZGVkRGVmYXVsdHM7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGluc3RhbGxNb2R1bGUobW9kKSB7XG4gICAgICAgIGlmICghU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXykgU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXyA9IFtdO1xuICAgICAgICBjb25zdCBtb2R1bGVzID0gU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXztcblxuICAgICAgICBpZiAodHlwZW9mIG1vZCA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGVzLmluZGV4T2YobW9kKSA8IDApIHtcbiAgICAgICAgICBtb2R1bGVzLnB1c2gobW9kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0aWMgdXNlKG1vZHVsZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtb2R1bGUpKSB7XG4gICAgICAgICAgbW9kdWxlLmZvckVhY2gobSA9PiBTd2lwZXIuaW5zdGFsbE1vZHVsZShtKSk7XG4gICAgICAgICAgcmV0dXJuIFN3aXBlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIFN3aXBlci5pbnN0YWxsTW9kdWxlKG1vZHVsZSk7XG4gICAgICAgIHJldHVybiBTd2lwZXI7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhwcm90b3R5cGVzKS5mb3JFYWNoKHByb3RvdHlwZUdyb3VwID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHByb3RvdHlwZXNbcHJvdG90eXBlR3JvdXBdKS5mb3JFYWNoKHByb3RvTWV0aG9kID0+IHtcbiAgICAgICAgU3dpcGVyLnByb3RvdHlwZVtwcm90b01ldGhvZF0gPSBwcm90b3R5cGVzW3Byb3RvdHlwZUdyb3VwXVtwcm90b01ldGhvZF07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBTd2lwZXIudXNlKFtSZXNpemUsIE9ic2VydmVyXSk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuICAgIGZ1bmN0aW9uIE1vdXNld2hlZWwoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgc3dpcGVyLFxuICAgICAgICBleHRlbmRQYXJhbXMsXG4gICAgICAgIG9uLFxuICAgICAgICBlbWl0XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgZXh0ZW5kUGFyYW1zKHtcbiAgICAgICAgbW91c2V3aGVlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcbiAgICAgICAgICBpbnZlcnQ6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlVG9BeGlzOiBmYWxzZSxcbiAgICAgICAgICBzZW5zaXRpdml0eTogMSxcbiAgICAgICAgICBldmVudHNUYXJnZXQ6ICdjb250YWluZXInLFxuICAgICAgICAgIHRocmVzaG9sZERlbHRhOiBudWxsLFxuICAgICAgICAgIHRocmVzaG9sZFRpbWU6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzd2lwZXIubW91c2V3aGVlbCA9IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgdGltZW91dDtcbiAgICAgIGxldCBsYXN0U2Nyb2xsVGltZSA9IG5vdygpO1xuICAgICAgbGV0IGxhc3RFdmVudEJlZm9yZVNuYXA7XG4gICAgICBjb25zdCByZWNlbnRXaGVlbEV2ZW50cyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBub3JtYWxpemUoZSkge1xuICAgICAgICAvLyBSZWFzb25hYmxlIGRlZmF1bHRzXG4gICAgICAgIGNvbnN0IFBJWEVMX1NURVAgPSAxMDtcbiAgICAgICAgY29uc3QgTElORV9IRUlHSFQgPSA0MDtcbiAgICAgICAgY29uc3QgUEFHRV9IRUlHSFQgPSA4MDA7XG4gICAgICAgIGxldCBzWCA9IDA7XG4gICAgICAgIGxldCBzWSA9IDA7IC8vIHNwaW5YLCBzcGluWVxuXG4gICAgICAgIGxldCBwWCA9IDA7XG4gICAgICAgIGxldCBwWSA9IDA7IC8vIHBpeGVsWCwgcGl4ZWxZXG4gICAgICAgIC8vIExlZ2FjeVxuXG4gICAgICAgIGlmICgnZGV0YWlsJyBpbiBlKSB7XG4gICAgICAgICAgc1kgPSBlLmRldGFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnd2hlZWxEZWx0YScgaW4gZSkge1xuICAgICAgICAgIHNZID0gLWUud2hlZWxEZWx0YSAvIDEyMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnd2hlZWxEZWx0YVknIGluIGUpIHtcbiAgICAgICAgICBzWSA9IC1lLndoZWVsRGVsdGFZIC8gMTIwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCd3aGVlbERlbHRhWCcgaW4gZSkge1xuICAgICAgICAgIHNYID0gLWUud2hlZWxEZWx0YVggLyAxMjA7XG4gICAgICAgIH0gLy8gc2lkZSBzY3JvbGxpbmcgb24gRkYgd2l0aCBET01Nb3VzZVNjcm9sbFxuXG5cbiAgICAgICAgaWYgKCdheGlzJyBpbiBlICYmIGUuYXhpcyA9PT0gZS5IT1JJWk9OVEFMX0FYSVMpIHtcbiAgICAgICAgICBzWCA9IHNZO1xuICAgICAgICAgIHNZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBYID0gc1ggKiBQSVhFTF9TVEVQO1xuICAgICAgICBwWSA9IHNZICogUElYRUxfU1RFUDtcblxuICAgICAgICBpZiAoJ2RlbHRhWScgaW4gZSkge1xuICAgICAgICAgIHBZID0gZS5kZWx0YVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2RlbHRhWCcgaW4gZSkge1xuICAgICAgICAgIHBYID0gZS5kZWx0YVg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiAhcFgpIHtcbiAgICAgICAgICAvLyBpZiB1c2VyIHNjcm9sbHMgd2l0aCBzaGlmdCBoZSB3YW50cyBob3Jpem9udGFsIHNjcm9sbFxuICAgICAgICAgIHBYID0gcFk7XG4gICAgICAgICAgcFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwWCB8fCBwWSkgJiYgZS5kZWx0YU1vZGUpIHtcbiAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGRlbHRhIGluIExJTkUgdW5pdHNcbiAgICAgICAgICAgIHBYICo9IExJTkVfSEVJR0hUO1xuICAgICAgICAgICAgcFkgKj0gTElORV9IRUlHSFQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlbHRhIGluIFBBR0UgdW5pdHNcbiAgICAgICAgICAgIHBYICo9IFBBR0VfSEVJR0hUO1xuICAgICAgICAgICAgcFkgKj0gUEFHRV9IRUlHSFQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEZhbGwtYmFjayBpZiBzcGluIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG5cblxuICAgICAgICBpZiAocFggJiYgIXNYKSB7XG4gICAgICAgICAgc1ggPSBwWCA8IDEgPyAtMSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocFkgJiYgIXNZKSB7XG4gICAgICAgICAgc1kgPSBwWSA8IDEgPyAtMSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwaW5YOiBzWCxcbiAgICAgICAgICBzcGluWTogc1ksXG4gICAgICAgICAgcGl4ZWxYOiBwWCxcbiAgICAgICAgICBwaXhlbFk6IHBZXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRW50ZXIoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLm1vdXNlRW50ZXJlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLm1vdXNlRW50ZXJlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhbmltYXRlU2xpZGVyKG5ld0V2ZW50KSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkRGVsdGEgJiYgbmV3RXZlbnQuZGVsdGEgPCBzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkRGVsdGEpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGlmIGRlbHRhIG9mIHdoZWVsIHNjcm9sbCBkZWx0YSBpcyBiZWxvdyBjb25maWd1cmVkIHRocmVzaG9sZFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkVGltZSAmJiBub3coKSAtIGxhc3RTY3JvbGxUaW1lIDwgc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLnRocmVzaG9sZFRpbWUpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGlmIHRpbWUgYmV0d2VlbiBzY3JvbGxzIGlzIGJlbG93IGNvbmZpZ3VyZWQgdGhyZXNob2xkXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIElmIHRoZSBtb3ZlbWVudCBpcyBOT1QgYmlnIGVub3VnaCBhbmRcbiAgICAgICAgLy8gaWYgdGhlIGxhc3QgdGltZSB0aGUgdXNlciBzY3JvbGxlZCB3YXMgdG9vIGNsb3NlIHRvIHRoZSBjdXJyZW50IG9uZSAoYXZvaWQgY29udGludW91c2x5IHRyaWdnZXJpbmcgdGhlIHNsaWRlcik6XG4gICAgICAgIC8vICAgRG9uJ3QgZ28gYW55IGZ1cnRoZXIgKGF2b2lkIGluc2lnbmlmaWNhbnQgc2Nyb2xsIG1vdmVtZW50KS5cblxuXG4gICAgICAgIGlmIChuZXdFdmVudC5kZWx0YSA+PSA2ICYmIG5vdygpIC0gbGFzdFNjcm9sbFRpbWUgPCA2MCkge1xuICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBhcyBhIGRlZmF1bHRcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBJZiB1c2VyIGlzIHNjcm9sbGluZyB0b3dhcmRzIHRoZSBlbmQ6XG4gICAgICAgIC8vICAgSWYgdGhlIHNsaWRlciBoYXNuJ3QgaGl0IHRoZSBsYXRlc3Qgc2xpZGUgb3JcbiAgICAgICAgLy8gICBpZiB0aGUgc2xpZGVyIGlzIGEgbG9vcCBhbmRcbiAgICAgICAgLy8gICBpZiB0aGUgc2xpZGVyIGlzbid0IG1vdmluZyByaWdodCBub3c6XG4gICAgICAgIC8vICAgICBHbyB0byBuZXh0IHNsaWRlIGFuZFxuICAgICAgICAvLyAgICAgZW1pdCBhIHNjcm9sbCBldmVudC5cbiAgICAgICAgLy8gRWxzZSAodGhlIHVzZXIgaXMgc2Nyb2xsaW5nIHRvd2FyZHMgdGhlIGJlZ2lubmluZykgYW5kXG4gICAgICAgIC8vIGlmIHRoZSBzbGlkZXIgaGFzbid0IGhpdCB0aGUgZmlyc3Qgc2xpZGUgb3JcbiAgICAgICAgLy8gaWYgdGhlIHNsaWRlciBpcyBhIGxvb3AgYW5kXG4gICAgICAgIC8vIGlmIHRoZSBzbGlkZXIgaXNuJ3QgbW92aW5nIHJpZ2h0IG5vdzpcbiAgICAgICAgLy8gICBHbyB0byBwcmV2IHNsaWRlIGFuZFxuICAgICAgICAvLyAgIGVtaXQgYSBzY3JvbGwgZXZlbnQuXG5cblxuICAgICAgICBpZiAobmV3RXZlbnQuZGlyZWN0aW9uIDwgMCkge1xuICAgICAgICAgIGlmICgoIXN3aXBlci5pc0VuZCB8fCBzd2lwZXIucGFyYW1zLmxvb3ApICYmICFzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVOZXh0KCk7XG4gICAgICAgICAgICBlbWl0KCdzY3JvbGwnLCBuZXdFdmVudC5yYXcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgoIXN3aXBlci5pc0JlZ2lubmluZyB8fCBzd2lwZXIucGFyYW1zLmxvb3ApICYmICFzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlUHJldigpO1xuICAgICAgICAgIGVtaXQoJ3Njcm9sbCcsIG5ld0V2ZW50LnJhdyk7XG4gICAgICAgIH0gLy8gSWYgeW91IGdvdCBoZXJlIGlzIGJlY2F1c2UgYW4gYW5pbWF0aW9uIGhhcyBiZWVuIHRyaWdnZXJlZCBzbyBzdG9yZSB0aGUgY3VycmVudCB0aW1lXG5cblxuICAgICAgICBsYXN0U2Nyb2xsVGltZSA9IG5ldyB3aW5kb3cuRGF0ZSgpLmdldFRpbWUoKTsgLy8gUmV0dXJuIGZhbHNlIGFzIGEgZGVmYXVsdFxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVsZWFzZVNjcm9sbChuZXdFdmVudCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm1vdXNld2hlZWw7XG5cbiAgICAgICAgaWYgKG5ld0V2ZW50LmRpcmVjdGlvbiA8IDApIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgcGFyYW1zLnJlbGVhc2VPbkVkZ2VzKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdHJ1ZSB0byBhbmltYXRlIHNjcm9sbCBvbiBlZGdlc1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0JlZ2lubmluZyAmJiAhc3dpcGVyLnBhcmFtcy5sb29wICYmIHBhcmFtcy5yZWxlYXNlT25FZGdlcykge1xuICAgICAgICAgIC8vIFJldHVybiB0cnVlIHRvIGFuaW1hdGUgc2Nyb2xsIG9uIGVkZ2VzXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShldmVudCkge1xuICAgICAgICBsZXQgZSA9IGV2ZW50O1xuICAgICAgICBsZXQgZGlzYWJsZVBhcmVudFN3aXBlciA9IHRydWU7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGFyZ2V0ID0gc3dpcGVyLiRlbDtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCAhPT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgICB0YXJnZXQgPSAkKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzd2lwZXIubW91c2VFbnRlcmVkICYmICF0YXJnZXRbMF0uY29udGFpbnMoZS50YXJnZXQpICYmICFwYXJhbXMucmVsZWFzZU9uRWRnZXMpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50OyAvLyBqcXVlcnkgZml4XG5cbiAgICAgICAgbGV0IGRlbHRhID0gMDtcbiAgICAgICAgY29uc3QgcnRsRmFjdG9yID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5vcm1hbGl6ZShlKTtcblxuICAgICAgICBpZiAocGFyYW1zLmZvcmNlVG9BeGlzKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRhdGEucGl4ZWxYKSA+IE1hdGguYWJzKGRhdGEucGl4ZWxZKSkgZGVsdGEgPSAtZGF0YS5waXhlbFggKiBydGxGYWN0b3I7ZWxzZSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRhdGEucGl4ZWxZKSA+IE1hdGguYWJzKGRhdGEucGl4ZWxYKSkgZGVsdGEgPSAtZGF0YS5waXhlbFk7ZWxzZSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YSA9IE1hdGguYWJzKGRhdGEucGl4ZWxYKSA+IE1hdGguYWJzKGRhdGEucGl4ZWxZKSA/IC1kYXRhLnBpeGVsWCAqIHJ0bEZhY3RvciA6IC1kYXRhLnBpeGVsWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChwYXJhbXMuaW52ZXJ0KSBkZWx0YSA9IC1kZWx0YTsgLy8gR2V0IHRoZSBzY3JvbGwgcG9zaXRpb25zXG5cbiAgICAgICAgbGV0IHBvc2l0aW9ucyA9IHN3aXBlci5nZXRUcmFuc2xhdGUoKSArIGRlbHRhICogcGFyYW1zLnNlbnNpdGl2aXR5O1xuICAgICAgICBpZiAocG9zaXRpb25zID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkgcG9zaXRpb25zID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICBpZiAocG9zaXRpb25zIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkgcG9zaXRpb25zID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpOyAvLyBXaGVuIGxvb3AgaXMgdHJ1ZTpcbiAgICAgICAgLy8gICAgIHRoZSBkaXNhYmxlUGFyZW50U3dpcGVyIHdpbGwgYmUgdHJ1ZS5cbiAgICAgICAgLy8gV2hlbiBsb29wIGlzIGZhbHNlOlxuICAgICAgICAvLyAgICAgaWYgdGhlIHNjcm9sbCBwb3NpdGlvbnMgaXMgbm90IG9uIGVkZ2UsXG4gICAgICAgIC8vICAgICB0aGVuIHRoZSBkaXNhYmxlUGFyZW50U3dpcGVyIHdpbGwgYmUgdHJ1ZS5cbiAgICAgICAgLy8gICAgIGlmIHRoZSBzY3JvbGwgb24gZWRnZSBwb3NpdGlvbnMsXG4gICAgICAgIC8vICAgICB0aGVuIHRoZSBkaXNhYmxlUGFyZW50U3dpcGVyIHdpbGwgYmUgZmFsc2UuXG5cbiAgICAgICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IHN3aXBlci5wYXJhbXMubG9vcCA/IHRydWUgOiAhKHBvc2l0aW9ucyA9PT0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIHx8IHBvc2l0aW9ucyA9PT0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKTtcbiAgICAgICAgaWYgKGRpc2FibGVQYXJlbnRTd2lwZXIgJiYgc3dpcGVyLnBhcmFtcy5uZXN0ZWQpIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmZyZWVNb2RlIHx8ICFzd2lwZXIucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQpIHtcbiAgICAgICAgICAvLyBSZWdpc3RlciB0aGUgbmV3IGV2ZW50IGluIGEgdmFyaWFibGUgd2hpY2ggc3RvcmVzIHRoZSByZWxldmFudCBkYXRhXG4gICAgICAgICAgY29uc3QgbmV3RXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgIGRlbHRhOiBNYXRoLmFicyhkZWx0YSksXG4gICAgICAgICAgICBkaXJlY3Rpb246IE1hdGguc2lnbihkZWx0YSksXG4gICAgICAgICAgICByYXc6IGV2ZW50XG4gICAgICAgICAgfTsgLy8gS2VlcCB0aGUgbW9zdCByZWNlbnQgZXZlbnRzXG5cbiAgICAgICAgICBpZiAocmVjZW50V2hlZWxFdmVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHJlY2VudFdoZWVsRXZlbnRzLnNoaWZ0KCk7IC8vIG9ubHkgc3RvcmUgdGhlIGxhc3QgTiBldmVudHNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwcmV2RXZlbnQgPSByZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggPyByZWNlbnRXaGVlbEV2ZW50c1tyZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5wdXNoKG5ld0V2ZW50KTsgLy8gSWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByZXZpb3VzIHJlY29yZGVkIGV2ZW50OlxuICAgICAgICAgIC8vICAgSWYgZGlyZWN0aW9uIGhhcyBjaGFuZ2VkIG9yXG4gICAgICAgICAgLy8gICBpZiB0aGUgc2Nyb2xsIGlzIHF1aWNrZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lOlxuICAgICAgICAgIC8vICAgICBBbmltYXRlIHRoZSBzbGlkZXIuXG4gICAgICAgICAgLy8gRWxzZSAodGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgd2hlZWwgaXMgbW92ZWQpOlxuICAgICAgICAgIC8vICAgICBBbmltYXRlIHRoZSBzbGlkZXIuXG5cbiAgICAgICAgICBpZiAocHJldkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAobmV3RXZlbnQuZGlyZWN0aW9uICE9PSBwcmV2RXZlbnQuZGlyZWN0aW9uIHx8IG5ld0V2ZW50LmRlbHRhID4gcHJldkV2ZW50LmRlbHRhIHx8IG5ld0V2ZW50LnRpbWUgPiBwcmV2RXZlbnQudGltZSArIDE1MCkge1xuICAgICAgICAgICAgICBhbmltYXRlU2xpZGVyKG5ld0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5pbWF0ZVNsaWRlcihuZXdFdmVudCk7XG4gICAgICAgICAgfSAvLyBJZiBpdCdzIHRpbWUgdG8gcmVsZWFzZSB0aGUgc2Nyb2xsOlxuICAgICAgICAgIC8vICAgUmV0dXJuIG5vdyBzbyB5b3UgZG9uJ3QgaGl0IHRoZSBwcmV2ZW50RGVmYXVsdC5cblxuXG4gICAgICAgICAgaWYgKHJlbGVhc2VTY3JvbGwobmV3RXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRnJlZW1vZGUgb3Igc2Nyb2xsQ29udGFpbmVyOlxuICAgICAgICAgIC8vIElmIHdlIHJlY2VudGx5IHNuYXBwZWQgYWZ0ZXIgYSBtb21lbnR1bSBzY3JvbGwsIHRoZW4gaWdub3JlIHdoZWVsIGV2ZW50c1xuICAgICAgICAgIC8vIHRvIGdpdmUgdGltZSBmb3IgdGhlIGRlY2VsZXJhdGlvbiB0byBmaW5pc2guIFN0b3AgaWdub3JpbmcgYWZ0ZXIgNTAwIG1zZWNzXG4gICAgICAgICAgLy8gb3IgaWYgaXQncyBhIG5ldyBzY3JvbGwgKGxhcmdlciBkZWx0YSBvciBpbnZlcnNlIHNpZ24gYXMgbGFzdCBldmVudCBiZWZvcmVcbiAgICAgICAgICAvLyBhbiBlbmQtb2YtbW9tZW50dW0gc25hcCkuXG4gICAgICAgICAgY29uc3QgbmV3RXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgIGRlbHRhOiBNYXRoLmFicyhkZWx0YSksXG4gICAgICAgICAgICBkaXJlY3Rpb246IE1hdGguc2lnbihkZWx0YSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGlnbm9yZVdoZWVsRXZlbnRzID0gbGFzdEV2ZW50QmVmb3JlU25hcCAmJiBuZXdFdmVudC50aW1lIDwgbGFzdEV2ZW50QmVmb3JlU25hcC50aW1lICsgNTAwICYmIG5ld0V2ZW50LmRlbHRhIDw9IGxhc3RFdmVudEJlZm9yZVNuYXAuZGVsdGEgJiYgbmV3RXZlbnQuZGlyZWN0aW9uID09PSBsYXN0RXZlbnRCZWZvcmVTbmFwLmRpcmVjdGlvbjtcblxuICAgICAgICAgIGlmICghaWdub3JlV2hlZWxFdmVudHMpIHtcbiAgICAgICAgICAgIGxhc3RFdmVudEJlZm9yZVNuYXAgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpICsgZGVsdGEgKiBwYXJhbXMuc2Vuc2l0aXZpdHk7XG4gICAgICAgICAgICBjb25zdCB3YXNCZWdpbm5pbmcgPSBzd2lwZXIuaXNCZWdpbm5pbmc7XG4gICAgICAgICAgICBjb25zdCB3YXNFbmQgPSBzd2lwZXIuaXNFbmQ7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSBwb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHBvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuXG4gICAgICAgICAgICBpZiAoIXdhc0JlZ2lubmluZyAmJiBzd2lwZXIuaXNCZWdpbm5pbmcgfHwgIXdhc0VuZCAmJiBzd2lwZXIuaXNFbmQpIHtcbiAgICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUuc3RpY2t5KSB7XG4gICAgICAgICAgICAgIC8vIFdoZW4gd2hlZWwgc2Nyb2xsaW5nIHN0YXJ0cyB3aXRoIHN0aWNreSAoYWthIHNuYXApIGVuYWJsZWQsIHRoZW4gZGV0ZWN0XG4gICAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgYSBtb21lbnR1bSBzY3JvbGwgYnkgc3RvcmluZyByZWNlbnQgKE49MTU/KSB3aGVlbCBldmVudHMuXG4gICAgICAgICAgICAgIC8vIDEuIGRvIGFsbCBOIGV2ZW50cyBoYXZlIGRlY3JlYXNpbmcgb3Igc2FtZSAoYWJzb2x1dGUgdmFsdWUpIGRlbHRhP1xuICAgICAgICAgICAgICAvLyAyLiBkaWQgYWxsIE4gZXZlbnRzIGFycml2ZSBpbiB0aGUgbGFzdCBNIChNPTUwMD8pIG1zZWNzP1xuICAgICAgICAgICAgICAvLyAzLiBkb2VzIHRoZSBlYXJsaWVzdCBldmVudCBoYXZlIGFuIChhYnNvbHV0ZSB2YWx1ZSkgZGVsdGEgdGhhdCdzXG4gICAgICAgICAgICAgIC8vICAgIGF0IGxlYXN0IFAgKFA9MT8pIGxhcmdlciB0aGFuIHRoZSBtb3N0IHJlY2VudCBldmVudCdzIGRlbHRhP1xuICAgICAgICAgICAgICAvLyA0LiBkb2VzIHRoZSBsYXRlc3QgZXZlbnQgaGF2ZSBhIGRlbHRhIHRoYXQncyBzbWFsbGVyIHRoYW4gUSAoUT02PykgcGl4ZWxzP1xuICAgICAgICAgICAgICAvLyBJZiAxLTQgYXJlIFwieWVzXCIgdGhlbiB3ZSdyZSBuZWFyIHRoZSBlbmQgb2YgYSBtb21lbnR1bSBzY3JvbGwgZGVjZWxlcmF0aW9uLlxuICAgICAgICAgICAgICAvLyBTbmFwIGltbWVkaWF0ZWx5IGFuZCBpZ25vcmUgcmVtYWluaW5nIHdoZWVsIGV2ZW50cyBpbiB0aGlzIHNjcm9sbC5cbiAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgZm9yIFwicmVtYWluaW5nIHdoZWVsIGV2ZW50cyBpbiB0aGlzIHNjcm9sbFwiIGRldGVybWluYXRpb24uXG4gICAgICAgICAgICAgIC8vIElmIDEtNCBhcmVuJ3Qgc2F0aXNmaWVkLCB0aGVuIHdhaXQgdG8gc25hcCB1bnRpbCA1MDBtcyBhZnRlciB0aGUgbGFzdCBldmVudC5cbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIGlmIChyZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggPj0gMTUpIHtcbiAgICAgICAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5zaGlmdCgpOyAvLyBvbmx5IHN0b3JlIHRoZSBsYXN0IE4gZXZlbnRzXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBwcmV2RXZlbnQgPSByZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggPyByZWNlbnRXaGVlbEV2ZW50c1tyZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RFdmVudCA9IHJlY2VudFdoZWVsRXZlbnRzWzBdO1xuICAgICAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5wdXNoKG5ld0V2ZW50KTtcblxuICAgICAgICAgICAgICBpZiAocHJldkV2ZW50ICYmIChuZXdFdmVudC5kZWx0YSA+IHByZXZFdmVudC5kZWx0YSB8fCBuZXdFdmVudC5kaXJlY3Rpb24gIT09IHByZXZFdmVudC5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5jcmVhc2luZyBvciByZXZlcnNlLXNpZ24gZGVsdGEgbWVhbnMgdGhlIHVzZXIgc3RhcnRlZCBzY3JvbGxpbmcgYWdhaW4uIENsZWFyIHRoZSB3aGVlbCBldmVudCBsb2cuXG4gICAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlY2VudFdoZWVsRXZlbnRzLmxlbmd0aCA+PSAxNSAmJiBuZXdFdmVudC50aW1lIC0gZmlyc3RFdmVudC50aW1lIDwgNTAwICYmIGZpcnN0RXZlbnQuZGVsdGEgLSBuZXdFdmVudC5kZWx0YSA+PSAxICYmIG5ld0V2ZW50LmRlbHRhIDw9IDYpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBkZWNlbGVyYXRpb24gb2YgYSBtb21lbnR1bSBzY3JvbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAgICAgICAgICAgICAgIC8vIHRvIHdhaXQgZm9yIG1vcmUgZXZlbnRzLiBTbmFwIEFTQVAgb24gdGhlIG5leHQgdGljay5cbiAgICAgICAgICAgICAgICAvLyBBbHNvLCBiZWNhdXNlIHRoZXJlJ3Mgc29tZSByZW1haW5pbmcgbW9tZW50dW0gd2UnbGwgYmlhcyB0aGUgc25hcCBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBkaXJlY3Rpb24gb2YgdGhlIG9uZ29pbmcgc2Nyb2xsIGJlY2F1c2UgaXQncyBiZXR0ZXIgVVggZm9yIHRoZSBzY3JvbGwgdG8gc25hcFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGUgc2Nyb2xsIGluc3RlYWQgb2YgcmV2ZXJzaW5nIHRvIHNuYXAuICBUaGVyZWZvcmUsXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbHJlYWR5IHNjcm9sbGVkIG1vcmUgdGhhbiAyMCUgaW4gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBrZWVwIGdvaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IHNuYXBUb1RocmVzaG9sZCA9IGRlbHRhID4gMCA/IDAuOCA6IDAuMjtcbiAgICAgICAgICAgICAgICBsYXN0RXZlbnRCZWZvcmVTbmFwID0gbmV3RXZlbnQ7XG4gICAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3Qoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdW5kZWZpbmVkLCBzbmFwVG9UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgIH0sIDApOyAvLyBubyBkZWxheTsgbW92ZSBvbiBuZXh0IHRpY2tcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGdldCBoZXJlLCB0aGVuIHdlIGhhdmVuJ3QgZGV0ZWN0ZWQgdGhlIGVuZCBvZiBhIG1vbWVudHVtIHNjcm9sbCwgc29cbiAgICAgICAgICAgICAgICAvLyB3ZSdsbCBjb25zaWRlciBhIHNjcm9sbCBcImNvbXBsZXRlXCIgd2hlbiB0aGVyZSBoYXZlbid0IGJlZW4gYW55IHdoZWVsIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIGZvciA1MDBtcy5cbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc25hcFRvVGhyZXNob2xkID0gMC41O1xuICAgICAgICAgICAgICAgICAgbGFzdEV2ZW50QmVmb3JlU25hcCA9IG5ld0V2ZW50O1xuICAgICAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHVuZGVmaW5lZCwgc25hcFRvVGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIEVtaXQgZXZlbnRcblxuXG4gICAgICAgICAgICBpZiAoIWlnbm9yZVdoZWVsRXZlbnRzKSBlbWl0KCdzY3JvbGwnLCBlKTsgLy8gU3RvcCBhdXRvcGxheVxuXG4gICAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheSAmJiBzd2lwZXIucGFyYW1zLmF1dG9wbGF5RGlzYWJsZU9uSW50ZXJhY3Rpb24pIHN3aXBlci5hdXRvcGxheS5zdG9wKCk7IC8vIFJldHVybiBwYWdlIHNjcm9sbCBvbiBlZGdlIHBvc2l0aW9uc1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IHN3aXBlci5taW5UcmFuc2xhdGUoKSB8fCBwb3NpdGlvbiA9PT0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGV2ZW50cyhtZXRob2QpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHN3aXBlci4kZWw7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQgIT09ICdjb250YWluZXInKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gJChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFttZXRob2RdKCdtb3VzZWVudGVyJywgaGFuZGxlTW91c2VFbnRlcik7XG4gICAgICAgIHRhcmdldFttZXRob2RdKCdtb3VzZWxlYXZlJywgaGFuZGxlTW91c2VMZWF2ZSk7XG4gICAgICAgIHRhcmdldFttZXRob2RdKCd3aGVlbCcsIGhhbmRsZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBoYW5kbGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZXZlbnRzKCdvbicpO1xuICAgICAgICBzd2lwZXIubW91c2V3aGVlbC5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZXZlbnRzKCdvZmYnKTtcbiAgICAgICAgc3dpcGVyLm1vdXNld2hlZWwuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgICAgZGlzYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5lbmFibGVkKSBlbmFibGUoKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBlbmFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIubW91c2V3aGVlbC5lbmFibGVkKSBkaXNhYmxlKCk7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLm1vdXNld2hlZWwsIHtcbiAgICAgICAgZW5hYmxlLFxuICAgICAgICBkaXNhYmxlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkKHN3aXBlciwgb3JpZ2luYWxQYXJhbXMsIHBhcmFtcywgY2hlY2tQcm9wcykge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jcmVhdGVFbGVtZW50cykge1xuICAgICAgICBPYmplY3Qua2V5cyhjaGVja1Byb3BzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgaWYgKCFwYXJhbXNba2V5XSAmJiBwYXJhbXMuYXV0byA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBzd2lwZXIuJGVsLmNoaWxkcmVuKGAuJHtjaGVja1Byb3BzW2tleV19YClbMF07XG5cbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2hlY2tQcm9wc1trZXldO1xuICAgICAgICAgICAgICBzd2lwZXIuJGVsLmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyYW1zW2tleV0gPSBlbGVtZW50O1xuICAgICAgICAgICAgb3JpZ2luYWxQYXJhbXNba2V5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgICBvbixcbiAgICAgICAgZW1pdFxuICAgICAgfSA9IF9yZWY7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBuYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgbmV4dEVsOiBudWxsLFxuICAgICAgICAgIHByZXZFbDogbnVsbCxcbiAgICAgICAgICBoaWRlT25DbGljazogZmFsc2UsXG4gICAgICAgICAgZGlzYWJsZWRDbGFzczogJ3N3aXBlci1idXR0b24tZGlzYWJsZWQnLFxuICAgICAgICAgIGhpZGRlbkNsYXNzOiAnc3dpcGVyLWJ1dHRvbi1oaWRkZW4nLFxuICAgICAgICAgIGxvY2tDbGFzczogJ3N3aXBlci1idXR0b24tbG9jaycsXG4gICAgICAgICAgbmF2aWdhdGlvbkRpc2FibGVkQ2xhc3M6ICdzd2lwZXItbmF2aWdhdGlvbi1kaXNhYmxlZCdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzd2lwZXIubmF2aWdhdGlvbiA9IHtcbiAgICAgICAgbmV4dEVsOiBudWxsLFxuICAgICAgICAkbmV4dEVsOiBudWxsLFxuICAgICAgICBwcmV2RWw6IG51bGwsXG4gICAgICAgICRwcmV2RWw6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGdldEVsKGVsKSB7XG4gICAgICAgIGxldCAkZWw7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgJGVsID0gJChlbCk7XG5cbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnICYmICRlbC5sZW5ndGggPiAxICYmIHN3aXBlci4kZWwuZmluZChlbCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAkZWwgPSBzd2lwZXIuJGVsLmZpbmQoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkZWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRvZ2dsZUVsKCRlbCwgZGlzYWJsZWQpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uO1xuXG4gICAgICAgIGlmICgkZWwgJiYgJGVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAkZWxbZGlzYWJsZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10ocGFyYW1zLmRpc2FibGVkQ2xhc3MpO1xuICAgICAgICAgIGlmICgkZWxbMF0gJiYgJGVsWzBdLnRhZ05hbWUgPT09ICdCVVRUT04nKSAkZWxbMF0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICRlbFtzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10ocGFyYW1zLmxvY2tDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gVXBkYXRlIE5hdmlnYXRpb24gQnV0dG9uc1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkbmV4dEVsLFxuICAgICAgICAgICRwcmV2RWxcbiAgICAgICAgfSA9IHN3aXBlci5uYXZpZ2F0aW9uO1xuICAgICAgICB0b2dnbGVFbCgkcHJldkVsLCBzd2lwZXIuaXNCZWdpbm5pbmcgJiYgIXN3aXBlci5wYXJhbXMucmV3aW5kKTtcbiAgICAgICAgdG9nZ2xlRWwoJG5leHRFbCwgc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLnJld2luZCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUHJldkNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgIXN3aXBlci5wYXJhbXMucmV3aW5kKSByZXR1cm47XG4gICAgICAgIHN3aXBlci5zbGlkZVByZXYoKTtcbiAgICAgICAgZW1pdCgnbmF2aWdhdGlvblByZXYnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25OZXh0Q2xpY2soZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5wYXJhbXMubG9vcCAmJiAhc3dpcGVyLnBhcmFtcy5yZXdpbmQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLnNsaWRlTmV4dCgpO1xuICAgICAgICBlbWl0KCduYXZpZ2F0aW9uTmV4dCcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb247XG4gICAgICAgIHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbiA9IGNyZWF0ZUVsZW1lbnRJZk5vdERlZmluZWQoc3dpcGVyLCBzd2lwZXIub3JpZ2luYWxQYXJhbXMubmF2aWdhdGlvbiwgc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLCB7XG4gICAgICAgICAgbmV4dEVsOiAnc3dpcGVyLWJ1dHRvbi1uZXh0JyxcbiAgICAgICAgICBwcmV2RWw6ICdzd2lwZXItYnV0dG9uLXByZXYnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIShwYXJhbXMubmV4dEVsIHx8IHBhcmFtcy5wcmV2RWwpKSByZXR1cm47XG4gICAgICAgIGNvbnN0ICRuZXh0RWwgPSBnZXRFbChwYXJhbXMubmV4dEVsKTtcbiAgICAgICAgY29uc3QgJHByZXZFbCA9IGdldEVsKHBhcmFtcy5wcmV2RWwpO1xuXG4gICAgICAgIGlmICgkbmV4dEVsICYmICRuZXh0RWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICRuZXh0RWwub24oJ2NsaWNrJywgb25OZXh0Q2xpY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRwcmV2RWwgJiYgJHByZXZFbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgJHByZXZFbC5vbignY2xpY2snLCBvblByZXZDbGljayk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKHN3aXBlci5uYXZpZ2F0aW9uLCB7XG4gICAgICAgICAgJG5leHRFbCxcbiAgICAgICAgICBuZXh0RWw6ICRuZXh0RWwgJiYgJG5leHRFbFswXSxcbiAgICAgICAgICAkcHJldkVsLFxuICAgICAgICAgIHByZXZFbDogJHByZXZFbCAmJiAkcHJldkVsWzBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoJG5leHRFbCkgJG5leHRFbC5hZGRDbGFzcyhwYXJhbXMubG9ja0NsYXNzKTtcbiAgICAgICAgICBpZiAoJHByZXZFbCkgJHByZXZFbC5hZGRDbGFzcyhwYXJhbXMubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJG5leHRFbCxcbiAgICAgICAgICAkcHJldkVsXG4gICAgICAgIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcblxuICAgICAgICBpZiAoJG5leHRFbCAmJiAkbmV4dEVsLmxlbmd0aCkge1xuICAgICAgICAgICRuZXh0RWwub2ZmKCdjbGljaycsIG9uTmV4dENsaWNrKTtcbiAgICAgICAgICAkbmV4dEVsLnJlbW92ZUNsYXNzKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5kaXNhYmxlZENsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcHJldkVsICYmICRwcmV2RWwubGVuZ3RoKSB7XG4gICAgICAgICAgJHByZXZFbC5vZmYoJ2NsaWNrJywgb25QcmV2Q2xpY2spO1xuICAgICAgICAgICRwcmV2RWwucmVtb3ZlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgZGlzYWJsZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbigndG9FZGdlIGZyb21FZGdlIGxvY2sgdW5sb2NrJywgKCkgPT4ge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2VuYWJsZSBkaXNhYmxlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJG5leHRFbCxcbiAgICAgICAgICAkcHJldkVsXG4gICAgICAgIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcblxuICAgICAgICBpZiAoJG5leHRFbCkge1xuICAgICAgICAgICRuZXh0RWxbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmxvY2tDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJHByZXZFbCkge1xuICAgICAgICAgICRwcmV2RWxbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmxvY2tDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2NsaWNrJywgKF9zLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkbmV4dEVsLFxuICAgICAgICAgICRwcmV2RWxcbiAgICAgICAgfSA9IHN3aXBlci5uYXZpZ2F0aW9uO1xuICAgICAgICBjb25zdCB0YXJnZXRFbCA9IGUudGFyZ2V0O1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZU9uQ2xpY2sgJiYgISQodGFyZ2V0RWwpLmlzKCRwcmV2RWwpICYmICEkKHRhcmdldEVsKS5pcygkbmV4dEVsKSkge1xuICAgICAgICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbiAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24gJiYgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmNsaWNrYWJsZSAmJiAoc3dpcGVyLnBhZ2luYXRpb24uZWwgPT09IHRhcmdldEVsIHx8IHN3aXBlci5wYWdpbmF0aW9uLmVsLmNvbnRhaW5zKHRhcmdldEVsKSkpIHJldHVybjtcbiAgICAgICAgICBsZXQgaXNIaWRkZW47XG5cbiAgICAgICAgICBpZiAoJG5leHRFbCkge1xuICAgICAgICAgICAgaXNIaWRkZW4gPSAkbmV4dEVsLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICgkcHJldkVsKSB7XG4gICAgICAgICAgICBpc0hpZGRlbiA9ICRwcmV2RWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGVtaXQoJ25hdmlnYXRpb25TaG93Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVtaXQoJ25hdmlnYXRpb25IaWRlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCRuZXh0RWwpIHtcbiAgICAgICAgICAgICRuZXh0RWwudG9nZ2xlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHByZXZFbCkge1xuICAgICAgICAgICAgJHByZXZFbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVuYWJsZSA9ICgpID0+IHtcbiAgICAgICAgc3dpcGVyLiRlbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24ubmF2aWdhdGlvbkRpc2FibGVkQ2xhc3MpO1xuICAgICAgICBpbml0KCk7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZGlzYWJsZSA9ICgpID0+IHtcbiAgICAgICAgc3dpcGVyLiRlbC5hZGRDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24ubmF2aWdhdGlvbkRpc2FibGVkQ2xhc3MpO1xuICAgICAgICBkZXN0cm95KCk7XG4gICAgICB9O1xuXG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlci5uYXZpZ2F0aW9uLCB7XG4gICAgICAgIGVuYWJsZSxcbiAgICAgICAgZGlzYWJsZSxcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBpbml0LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFzc2VzVG9TZWxlY3RvcihjbGFzc2VzKSB7XG4gICAgICBpZiAoY2xhc3NlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNsYXNzZXMgPSAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGAuJHtjbGFzc2VzLnRyaW0oKS5yZXBsYWNlKC8oW1xcLjohXFwvXSkvZywgJ1xcXFwkMScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgLnJlcGxhY2UoLyAvZywgJy4nKX1gO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBhZ2luYXRpb24oX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgc3dpcGVyLFxuICAgICAgICBleHRlbmRQYXJhbXMsXG4gICAgICAgIG9uLFxuICAgICAgICBlbWl0XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IHBmeCA9ICdzd2lwZXItcGFnaW5hdGlvbic7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgICAgZWw6IG51bGwsXG4gICAgICAgICAgYnVsbGV0RWxlbWVudDogJ3NwYW4nLFxuICAgICAgICAgIGNsaWNrYWJsZTogZmFsc2UsXG4gICAgICAgICAgaGlkZU9uQ2xpY2s6IGZhbHNlLFxuICAgICAgICAgIHJlbmRlckJ1bGxldDogbnVsbCxcbiAgICAgICAgICByZW5kZXJQcm9ncmVzc2JhcjogbnVsbCxcbiAgICAgICAgICByZW5kZXJGcmFjdGlvbjogbnVsbCxcbiAgICAgICAgICByZW5kZXJDdXN0b206IG51bGwsXG4gICAgICAgICAgcHJvZ3Jlc3NiYXJPcHBvc2l0ZTogZmFsc2UsXG4gICAgICAgICAgdHlwZTogJ2J1bGxldHMnLFxuICAgICAgICAgIC8vICdidWxsZXRzJyBvciAncHJvZ3Jlc3NiYXInIG9yICdmcmFjdGlvbicgb3IgJ2N1c3RvbSdcbiAgICAgICAgICBkeW5hbWljQnVsbGV0czogZmFsc2UsXG4gICAgICAgICAgZHluYW1pY01haW5CdWxsZXRzOiAxLFxuICAgICAgICAgIGZvcm1hdEZyYWN0aW9uQ3VycmVudDogbnVtYmVyID0+IG51bWJlcixcbiAgICAgICAgICBmb3JtYXRGcmFjdGlvblRvdGFsOiBudW1iZXIgPT4gbnVtYmVyLFxuICAgICAgICAgIGJ1bGxldENsYXNzOiBgJHtwZnh9LWJ1bGxldGAsXG4gICAgICAgICAgYnVsbGV0QWN0aXZlQ2xhc3M6IGAke3BmeH0tYnVsbGV0LWFjdGl2ZWAsXG4gICAgICAgICAgbW9kaWZpZXJDbGFzczogYCR7cGZ4fS1gLFxuICAgICAgICAgIGN1cnJlbnRDbGFzczogYCR7cGZ4fS1jdXJyZW50YCxcbiAgICAgICAgICB0b3RhbENsYXNzOiBgJHtwZnh9LXRvdGFsYCxcbiAgICAgICAgICBoaWRkZW5DbGFzczogYCR7cGZ4fS1oaWRkZW5gLFxuICAgICAgICAgIHByb2dyZXNzYmFyRmlsbENsYXNzOiBgJHtwZnh9LXByb2dyZXNzYmFyLWZpbGxgLFxuICAgICAgICAgIHByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzczogYCR7cGZ4fS1wcm9ncmVzc2Jhci1vcHBvc2l0ZWAsXG4gICAgICAgICAgY2xpY2thYmxlQ2xhc3M6IGAke3BmeH0tY2xpY2thYmxlYCxcbiAgICAgICAgICBsb2NrQ2xhc3M6IGAke3BmeH0tbG9ja2AsXG4gICAgICAgICAgaG9yaXpvbnRhbENsYXNzOiBgJHtwZnh9LWhvcml6b250YWxgLFxuICAgICAgICAgIHZlcnRpY2FsQ2xhc3M6IGAke3BmeH0tdmVydGljYWxgLFxuICAgICAgICAgIHBhZ2luYXRpb25EaXNhYmxlZENsYXNzOiBgJHtwZnh9LWRpc2FibGVkYFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uID0ge1xuICAgICAgICBlbDogbnVsbCxcbiAgICAgICAgJGVsOiBudWxsLFxuICAgICAgICBidWxsZXRzOiBbXVxuICAgICAgfTtcbiAgICAgIGxldCBidWxsZXRTaXplO1xuICAgICAgbGV0IGR5bmFtaWNCdWxsZXRJbmRleCA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIGlzUGFnaW5hdGlvbkRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gIXN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uZWwgfHwgIXN3aXBlci5wYWdpbmF0aW9uLiRlbCB8fCBzd2lwZXIucGFnaW5hdGlvbi4kZWwubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRTaWRlQnVsbGV0cygkYnVsbGV0RWwsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBidWxsZXRBY3RpdmVDbGFzc1xuICAgICAgICB9ID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgICAgICAkYnVsbGV0RWxbcG9zaXRpb25dKCkuYWRkQ2xhc3MoYCR7YnVsbGV0QWN0aXZlQ2xhc3N9LSR7cG9zaXRpb259YClbcG9zaXRpb25dKCkuYWRkQ2xhc3MoYCR7YnVsbGV0QWN0aXZlQ2xhc3N9LSR7cG9zaXRpb259LSR7cG9zaXRpb259YCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gUmVuZGVyIHx8IFVwZGF0ZSBQYWdpbmF0aW9uIGJ1bGxldHMvaXRlbXNcbiAgICAgICAgY29uc3QgcnRsID0gc3dpcGVyLnJ0bDtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgICAgICBpZiAoaXNQYWdpbmF0aW9uRGlzYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgJGVsID0gc3dpcGVyLnBhZ2luYXRpb24uJGVsOyAvLyBDdXJyZW50L1RvdGFsXG5cbiAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gc3dpcGVyLnBhcmFtcy5sb29wID8gTWF0aC5jZWlsKChzbGlkZXNMZW5ndGggLSBzd2lwZXIubG9vcGVkU2xpZGVzICogMikgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKSA6IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBNYXRoLmNlaWwoKHN3aXBlci5hY3RpdmVJbmRleCAtIHN3aXBlci5sb29wZWRTbGlkZXMpIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCA+IHNsaWRlc0xlbmd0aCAtIDEgLSBzd2lwZXIubG9vcGVkU2xpZGVzICogMikge1xuICAgICAgICAgICAgY3VycmVudCAtPSBzbGlkZXNMZW5ndGggLSBzd2lwZXIubG9vcGVkU2xpZGVzICogMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudCA+IHRvdGFsIC0gMSkgY3VycmVudCAtPSB0b3RhbDtcbiAgICAgICAgICBpZiAoY3VycmVudCA8IDAgJiYgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uVHlwZSAhPT0gJ2J1bGxldHMnKSBjdXJyZW50ID0gdG90YWwgKyBjdXJyZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzd2lwZXIuc25hcEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGN1cnJlbnQgPSBzd2lwZXIuc25hcEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnQgPSBzd2lwZXIuYWN0aXZlSW5kZXggfHwgMDtcbiAgICAgICAgfSAvLyBUeXBlc1xuXG5cbiAgICAgICAgaWYgKHBhcmFtcy50eXBlID09PSAnYnVsbGV0cycgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBidWxsZXRzID0gc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cztcbiAgICAgICAgICBsZXQgZmlyc3RJbmRleDtcbiAgICAgICAgICBsZXQgbGFzdEluZGV4O1xuICAgICAgICAgIGxldCBtaWRJbmRleDtcblxuICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgICAgIGJ1bGxldFNpemUgPSBidWxsZXRzLmVxKDApW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdvdXRlcldpZHRoJyA6ICdvdXRlckhlaWdodCddKHRydWUpO1xuICAgICAgICAgICAgJGVsLmNzcyhzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnd2lkdGgnIDogJ2hlaWdodCcsIGAke2J1bGxldFNpemUgKiAocGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyArIDQpfXB4YCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzID4gMSAmJiBzd2lwZXIucHJldmlvdXNJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGR5bmFtaWNCdWxsZXRJbmRleCArPSBjdXJyZW50IC0gKHN3aXBlci5wcmV2aW91c0luZGV4IC0gc3dpcGVyLmxvb3BlZFNsaWRlcyB8fCAwKTtcblxuICAgICAgICAgICAgICBpZiAoZHluYW1pY0J1bGxldEluZGV4ID4gcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyAtIDEpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljQnVsbGV0SW5kZXggPSBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIC0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkeW5hbWljQnVsbGV0SW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0J1bGxldEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gTWF0aC5tYXgoY3VycmVudCAtIGR5bmFtaWNCdWxsZXRJbmRleCwgMCk7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBmaXJzdEluZGV4ICsgKE1hdGgubWluKGJ1bGxldHMubGVuZ3RoLCBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzKSAtIDEpO1xuICAgICAgICAgICAgbWlkSW5kZXggPSAobGFzdEluZGV4ICsgZmlyc3RJbmRleCkgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJ1bGxldHMucmVtb3ZlQ2xhc3MoWycnLCAnLW5leHQnLCAnLW5leHQtbmV4dCcsICctcHJldicsICctcHJldi1wcmV2JywgJy1tYWluJ10ubWFwKHN1ZmZpeCA9PiBgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9JHtzdWZmaXh9YCkuam9pbignICcpKTtcblxuICAgICAgICAgIGlmICgkZWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYnVsbGV0cy5lYWNoKGJ1bGxldCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0ICRidWxsZXQgPSAkKGJ1bGxldCk7XG4gICAgICAgICAgICAgIGNvbnN0IGJ1bGxldEluZGV4ID0gJGJ1bGxldC5pbmRleCgpO1xuXG4gICAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICRidWxsZXQuYWRkQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPj0gZmlyc3RJbmRleCAmJiBidWxsZXRJbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICRidWxsZXQuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1tYWluYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJ1bGxldEluZGV4ID09PSBmaXJzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBzZXRTaWRlQnVsbGV0cygkYnVsbGV0LCAncHJldicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBzZXRTaWRlQnVsbGV0cygkYnVsbGV0LCAnbmV4dCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0ICRidWxsZXQgPSBidWxsZXRzLmVxKGN1cnJlbnQpO1xuICAgICAgICAgICAgY29uc3QgYnVsbGV0SW5kZXggPSAkYnVsbGV0LmluZGV4KCk7XG4gICAgICAgICAgICAkYnVsbGV0LmFkZENsYXNzKHBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcyk7XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgJGZpcnN0RGlzcGxheWVkQnVsbGV0ID0gYnVsbGV0cy5lcShmaXJzdEluZGV4KTtcbiAgICAgICAgICAgICAgY29uc3QgJGxhc3REaXNwbGF5ZWRCdWxsZXQgPSBidWxsZXRzLmVxKGxhc3RJbmRleCk7XG5cbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0SW5kZXg7IGkgPD0gbGFzdEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBidWxsZXRzLmVxKGkpLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbWFpbmApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA+PSBidWxsZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHM7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1bGxldHMuZXEoYnVsbGV0cy5sZW5ndGggLSBpKS5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnVsbGV0cy5lcShidWxsZXRzLmxlbmd0aCAtIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxKS5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LXByZXZgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2V0U2lkZUJ1bGxldHMoJGZpcnN0RGlzcGxheWVkQnVsbGV0LCAncHJldicpO1xuICAgICAgICAgICAgICAgICAgc2V0U2lkZUJ1bGxldHMoJGxhc3REaXNwbGF5ZWRCdWxsZXQsICduZXh0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFNpZGVCdWxsZXRzKCRmaXJzdERpc3BsYXllZEJ1bGxldCwgJ3ByZXYnKTtcbiAgICAgICAgICAgICAgICBzZXRTaWRlQnVsbGV0cygkbGFzdERpc3BsYXllZEJ1bGxldCwgJ25leHQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNCdWxsZXRzTGVuZ3RoID0gTWF0aC5taW4oYnVsbGV0cy5sZW5ndGgsIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgKyA0KTtcbiAgICAgICAgICAgIGNvbnN0IGJ1bGxldHNPZmZzZXQgPSAoYnVsbGV0U2l6ZSAqIGR5bmFtaWNCdWxsZXRzTGVuZ3RoIC0gYnVsbGV0U2l6ZSkgLyAyIC0gbWlkSW5kZXggKiBidWxsZXRTaXplO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0UHJvcCA9IHJ0bCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICBidWxsZXRzLmNzcyhzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBvZmZzZXRQcm9wIDogJ3RvcCcsIGAke2J1bGxldHNPZmZzZXR9cHhgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICAkZWwuZmluZChjbGFzc2VzVG9TZWxlY3RvcihwYXJhbXMuY3VycmVudENsYXNzKSkudGV4dChwYXJhbXMuZm9ybWF0RnJhY3Rpb25DdXJyZW50KGN1cnJlbnQgKyAxKSk7XG4gICAgICAgICAgJGVsLmZpbmQoY2xhc3Nlc1RvU2VsZWN0b3IocGFyYW1zLnRvdGFsQ2xhc3MpKS50ZXh0KHBhcmFtcy5mb3JtYXRGcmFjdGlvblRvdGFsKHRvdGFsKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdwcm9ncmVzc2JhcicpIHtcbiAgICAgICAgICBsZXQgcHJvZ3Jlc3NiYXJEaXJlY3Rpb247XG5cbiAgICAgICAgICBpZiAocGFyYW1zLnByb2dyZXNzYmFyT3Bwb3NpdGUpIHtcbiAgICAgICAgICAgIHByb2dyZXNzYmFyRGlyZWN0aW9uID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvZ3Jlc3NiYXJEaXJlY3Rpb24gPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnaG9yaXpvbnRhbCcgOiAndmVydGljYWwnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHNjYWxlID0gKGN1cnJlbnQgKyAxKSAvIHRvdGFsO1xuICAgICAgICAgIGxldCBzY2FsZVggPSAxO1xuICAgICAgICAgIGxldCBzY2FsZVkgPSAxO1xuXG4gICAgICAgICAgaWYgKHByb2dyZXNzYmFyRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZVkgPSBzY2FsZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkZWwuZmluZChjbGFzc2VzVG9TZWxlY3RvcihwYXJhbXMucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MpKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZVgoJHtzY2FsZVh9KSBzY2FsZVkoJHtzY2FsZVl9KWApLnRyYW5zaXRpb24oc3dpcGVyLnBhcmFtcy5zcGVlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdjdXN0b20nICYmIHBhcmFtcy5yZW5kZXJDdXN0b20pIHtcbiAgICAgICAgICAkZWwuaHRtbChwYXJhbXMucmVuZGVyQ3VzdG9tKHN3aXBlciwgY3VycmVudCArIDEsIHRvdGFsKSk7XG4gICAgICAgICAgZW1pdCgncGFnaW5hdGlvblJlbmRlcicsICRlbFswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW1pdCgncGFnaW5hdGlvblVwZGF0ZScsICRlbFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5lbmFibGVkKSB7XG4gICAgICAgICAgJGVsW3N3aXBlci5pc0xvY2tlZCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShwYXJhbXMubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIC8vIFJlbmRlciBDb250YWluZXJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgICAgICBpZiAoaXNQYWdpbmF0aW9uRGlzYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgJGVsID0gc3dpcGVyLnBhZ2luYXRpb24uJGVsO1xuICAgICAgICBsZXQgcGFnaW5hdGlvbkhUTUwgPSAnJztcblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJykge1xuICAgICAgICAgIGxldCBudW1iZXJPZkJ1bGxldHMgPSBzd2lwZXIucGFyYW1zLmxvb3AgPyBNYXRoLmNlaWwoKHNsaWRlc0xlbmd0aCAtIHN3aXBlci5sb29wZWRTbGlkZXMgKiAyKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogc3dpcGVyLnNuYXBHcmlkLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZyZWVNb2RlICYmIHN3aXBlci5wYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCAmJiAhc3dpcGVyLnBhcmFtcy5sb29wICYmIG51bWJlck9mQnVsbGV0cyA+IHNsaWRlc0xlbmd0aCkge1xuICAgICAgICAgICAgbnVtYmVyT2ZCdWxsZXRzID0gc2xpZGVzTGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZCdWxsZXRzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucmVuZGVyQnVsbGV0KSB7XG4gICAgICAgICAgICAgIHBhZ2luYXRpb25IVE1MICs9IHBhcmFtcy5yZW5kZXJCdWxsZXQuY2FsbChzd2lwZXIsIGksIHBhcmFtcy5idWxsZXRDbGFzcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYWdpbmF0aW9uSFRNTCArPSBgPCR7cGFyYW1zLmJ1bGxldEVsZW1lbnR9IGNsYXNzPVwiJHtwYXJhbXMuYnVsbGV0Q2xhc3N9XCI+PC8ke3BhcmFtcy5idWxsZXRFbGVtZW50fT5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbC5odG1sKHBhZ2luYXRpb25IVE1MKTtcbiAgICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzID0gJGVsLmZpbmQoY2xhc3Nlc1RvU2VsZWN0b3IocGFyYW1zLmJ1bGxldENsYXNzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLnJlbmRlckZyYWN0aW9uKSB7XG4gICAgICAgICAgICBwYWdpbmF0aW9uSFRNTCA9IHBhcmFtcy5yZW5kZXJGcmFjdGlvbi5jYWxsKHN3aXBlciwgcGFyYW1zLmN1cnJlbnRDbGFzcywgcGFyYW1zLnRvdGFsQ2xhc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWdpbmF0aW9uSFRNTCA9IGA8c3BhbiBjbGFzcz1cIiR7cGFyYW1zLmN1cnJlbnRDbGFzc31cIj48L3NwYW4+YCArICcgLyAnICsgYDxzcGFuIGNsYXNzPVwiJHtwYXJhbXMudG90YWxDbGFzc31cIj48L3NwYW4+YDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdwcm9ncmVzc2JhcicpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLnJlbmRlclByb2dyZXNzYmFyKSB7XG4gICAgICAgICAgICBwYWdpbmF0aW9uSFRNTCA9IHBhcmFtcy5yZW5kZXJQcm9ncmVzc2Jhci5jYWxsKHN3aXBlciwgcGFyYW1zLnByb2dyZXNzYmFyRmlsbENsYXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFnaW5hdGlvbkhUTUwgPSBgPHNwYW4gY2xhc3M9XCIke3BhcmFtcy5wcm9ncmVzc2JhckZpbGxDbGFzc31cIj48L3NwYW4+YDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdjdXN0b20nKSB7XG4gICAgICAgICAgZW1pdCgncGFnaW5hdGlvblJlbmRlcicsIHN3aXBlci5wYWdpbmF0aW9uLiRlbFswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uID0gY3JlYXRlRWxlbWVudElmTm90RGVmaW5lZChzd2lwZXIsIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5wYWdpbmF0aW9uLCBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24sIHtcbiAgICAgICAgICBlbDogJ3N3aXBlci1wYWdpbmF0aW9uJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgICAgICBpZiAoIXBhcmFtcy5lbCkgcmV0dXJuO1xuICAgICAgICBsZXQgJGVsID0gJChwYXJhbXMuZWwpO1xuICAgICAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmIHR5cGVvZiBwYXJhbXMuZWwgPT09ICdzdHJpbmcnICYmICRlbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgJGVsID0gc3dpcGVyLiRlbC5maW5kKHBhcmFtcy5lbCk7IC8vIGNoZWNrIGlmIGl0IGJlbG9uZ3MgdG8gYW5vdGhlciBuZXN0ZWQgU3dpcGVyXG5cbiAgICAgICAgICBpZiAoJGVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICRlbCA9ICRlbC5maWx0ZXIoZWwgPT4ge1xuICAgICAgICAgICAgICBpZiAoJChlbCkucGFyZW50cygnLnN3aXBlcicpWzBdICE9PSBzd2lwZXIuZWwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJyAmJiBwYXJhbXMuY2xpY2thYmxlKSB7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5jbGlja2FibGVDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICAkZWwuYWRkQ2xhc3MocGFyYW1zLm1vZGlmaWVyQ2xhc3MgKyBwYXJhbXMudHlwZSk7XG4gICAgICAgICRlbC5hZGRDbGFzcyhzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBwYXJhbXMuaG9yaXpvbnRhbENsYXNzIDogcGFyYW1zLnZlcnRpY2FsQ2xhc3MpO1xuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xuICAgICAgICAgICRlbC5hZGRDbGFzcyhgJHtwYXJhbXMubW9kaWZpZXJDbGFzc30ke3BhcmFtcy50eXBlfS1keW5hbWljYCk7XG4gICAgICAgICAgZHluYW1pY0J1bGxldEluZGV4ID0gMDtcblxuICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIDwgMSkge1xuICAgICAgICAgICAgcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy50eXBlID09PSAncHJvZ3Jlc3NiYXInICYmIHBhcmFtcy5wcm9ncmVzc2Jhck9wcG9zaXRlKSB7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5wcm9ncmVzc2Jhck9wcG9zaXRlQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5jbGlja2FibGUpIHtcbiAgICAgICAgICAkZWwub24oJ2NsaWNrJywgY2xhc3Nlc1RvU2VsZWN0b3IocGFyYW1zLmJ1bGxldENsYXNzKSwgZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkKHRoaXMpLmluZGV4KCkgKiBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkgaW5kZXggKz0gc3dpcGVyLmxvb3BlZFNsaWRlcztcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLnBhZ2luYXRpb24sIHtcbiAgICAgICAgICAkZWwsXG4gICAgICAgICAgZWw6ICRlbFswXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXN3aXBlci5lbmFibGVkKSB7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5sb2NrQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcbiAgICAgICAgaWYgKGlzUGFnaW5hdGlvbkRpc2FibGVkKCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgJGVsID0gc3dpcGVyLnBhZ2luYXRpb24uJGVsO1xuICAgICAgICAkZWwucmVtb3ZlQ2xhc3MocGFyYW1zLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKHBhcmFtcy5tb2RpZmllckNsYXNzICsgcGFyYW1zLnR5cGUpO1xuICAgICAgICAkZWwucmVtb3ZlQ2xhc3Moc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gcGFyYW1zLmhvcml6b250YWxDbGFzcyA6IHBhcmFtcy52ZXJ0aWNhbENsYXNzKTtcbiAgICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5yZW1vdmVDbGFzcykgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5yZW1vdmVDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xuXG4gICAgICAgIGlmIChwYXJhbXMuY2xpY2thYmxlKSB7XG4gICAgICAgICAgJGVsLm9mZignY2xpY2snLCBjbGFzc2VzVG9TZWxlY3RvcihwYXJhbXMuYnVsbGV0Q2xhc3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgIGRpc2FibGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0KCk7XG4gICAgICAgICAgcmVuZGVyKCk7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2FjdGl2ZUluZGV4Q2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN3aXBlci5zbmFwSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ3NuYXBJbmRleENoYW5nZScsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignc2xpZGVzTGVuZ3RoQ2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgcmVuZGVyKCk7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ3NuYXBHcmlkTGVuZ3RoQ2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICAgIHJlbmRlcigpO1xuICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICBkZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdlbmFibGUgZGlzYWJsZScsICgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbFxuICAgICAgICB9ID0gc3dpcGVyLnBhZ2luYXRpb247XG5cbiAgICAgICAgaWYgKCRlbCkge1xuICAgICAgICAgICRlbFtzd2lwZXIuZW5hYmxlZCA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnXShzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24ubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignbG9jayB1bmxvY2snLCAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBvbignY2xpY2snLCAoX3MsIGUpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSBlLnRhcmdldDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbFxuICAgICAgICB9ID0gc3dpcGVyLnBhZ2luYXRpb247XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5lbCAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZU9uQ2xpY2sgJiYgJGVsICYmICRlbC5sZW5ndGggPiAwICYmICEkKHRhcmdldEVsKS5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5uYXZpZ2F0aW9uICYmIChzd2lwZXIubmF2aWdhdGlvbi5uZXh0RWwgJiYgdGFyZ2V0RWwgPT09IHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCB8fCBzd2lwZXIubmF2aWdhdGlvbi5wcmV2RWwgJiYgdGFyZ2V0RWwgPT09IHN3aXBlci5uYXZpZ2F0aW9uLnByZXZFbCkpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBpc0hpZGRlbiA9ICRlbC5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICBlbWl0KCdwYWdpbmF0aW9uU2hvdycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbWl0KCdwYWdpbmF0aW9uSGlkZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZW5hYmxlID0gKCkgPT4ge1xuICAgICAgICBzd2lwZXIuJGVsLnJlbW92ZUNsYXNzKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5wYWdpbmF0aW9uRGlzYWJsZWRDbGFzcyk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uLiRlbCkge1xuICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLiRlbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24ucGFnaW5hdGlvbkRpc2FibGVkQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdCgpO1xuICAgICAgICByZW5kZXIoKTtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBkaXNhYmxlID0gKCkgPT4ge1xuICAgICAgICBzd2lwZXIuJGVsLmFkZENsYXNzKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5wYWdpbmF0aW9uRGlzYWJsZWRDbGFzcyk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uLiRlbCkge1xuICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLiRlbC5hZGRDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24ucGFnaW5hdGlvbkRpc2FibGVkQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdHJveSgpO1xuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIucGFnaW5hdGlvbiwge1xuICAgICAgICBlbmFibGUsXG4gICAgICAgIGRpc2FibGUsXG4gICAgICAgIHJlbmRlcixcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBpbml0LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTY3JvbGxiYXIoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgc3dpcGVyLFxuICAgICAgICBleHRlbmRQYXJhbXMsXG4gICAgICAgIG9uLFxuICAgICAgICBlbWl0XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgIGxldCBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGxldCBkcmFnVGltZW91dCA9IG51bGw7XG4gICAgICBsZXQgZHJhZ1N0YXJ0UG9zO1xuICAgICAgbGV0IGRyYWdTaXplO1xuICAgICAgbGV0IHRyYWNrU2l6ZTtcbiAgICAgIGxldCBkaXZpZGVyO1xuICAgICAgZXh0ZW5kUGFyYW1zKHtcbiAgICAgICAgc2Nyb2xsYmFyOiB7XG4gICAgICAgICAgZWw6IG51bGwsXG4gICAgICAgICAgZHJhZ1NpemU6ICdhdXRvJyxcbiAgICAgICAgICBoaWRlOiBmYWxzZSxcbiAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgIHNuYXBPblJlbGVhc2U6IHRydWUsXG4gICAgICAgICAgbG9ja0NsYXNzOiAnc3dpcGVyLXNjcm9sbGJhci1sb2NrJyxcbiAgICAgICAgICBkcmFnQ2xhc3M6ICdzd2lwZXItc2Nyb2xsYmFyLWRyYWcnLFxuICAgICAgICAgIHNjcm9sbGJhckRpc2FibGVkQ2xhc3M6ICdzd2lwZXItc2Nyb2xsYmFyLWRpc2FibGVkJyxcbiAgICAgICAgICBob3Jpem9udGFsQ2xhc3M6IGBzd2lwZXItc2Nyb2xsYmFyLWhvcml6b250YWxgLFxuICAgICAgICAgIHZlcnRpY2FsQ2xhc3M6IGBzd2lwZXItc2Nyb2xsYmFyLXZlcnRpY2FsYFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIgPSB7XG4gICAgICAgIGVsOiBudWxsLFxuICAgICAgICBkcmFnRWw6IG51bGwsXG4gICAgICAgICRlbDogbnVsbCxcbiAgICAgICAgJGRyYWdFbDogbnVsbFxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlKCkge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsIHx8ICFzd2lwZXIuc2Nyb2xsYmFyLmVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzY3JvbGxiYXIsXG4gICAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgICAgcHJvZ3Jlc3NcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRkcmFnRWwsXG4gICAgICAgICAgJGVsXG4gICAgICAgIH0gPSBzY3JvbGxiYXI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyO1xuICAgICAgICBsZXQgbmV3U2l6ZSA9IGRyYWdTaXplO1xuICAgICAgICBsZXQgbmV3UG9zID0gKHRyYWNrU2l6ZSAtIGRyYWdTaXplKSAqIHByb2dyZXNzO1xuXG4gICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICBuZXdQb3MgPSAtbmV3UG9zO1xuXG4gICAgICAgICAgaWYgKG5ld1BvcyA+IDApIHtcbiAgICAgICAgICAgIG5ld1NpemUgPSBkcmFnU2l6ZSAtIG5ld1BvcztcbiAgICAgICAgICAgIG5ld1BvcyA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmICgtbmV3UG9zICsgZHJhZ1NpemUgPiB0cmFja1NpemUpIHtcbiAgICAgICAgICAgIG5ld1NpemUgPSB0cmFja1NpemUgKyBuZXdQb3M7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld1BvcyA8IDApIHtcbiAgICAgICAgICBuZXdTaXplID0gZHJhZ1NpemUgKyBuZXdQb3M7XG4gICAgICAgICAgbmV3UG9zID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChuZXdQb3MgKyBkcmFnU2l6ZSA+IHRyYWNrU2l6ZSkge1xuICAgICAgICAgIG5ld1NpemUgPSB0cmFja1NpemUgLSBuZXdQb3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgJGRyYWdFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7bmV3UG9zfXB4LCAwLCAwKWApO1xuICAgICAgICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSBgJHtuZXdTaXplfXB4YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZHJhZ0VsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMHB4LCAke25ld1Bvc31weCwgMClgKTtcbiAgICAgICAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9IGAke25ld1NpemV9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5oaWRlKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAkZWxbMF0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICAkZWwudHJhbnNpdGlvbig0MDApO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCB8fCAhc3dpcGVyLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgICAgICBzd2lwZXIuc2Nyb2xsYmFyLiRkcmFnRWwudHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNjcm9sbGJhclxuICAgICAgICB9ID0gc3dpcGVyO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJGRyYWdFbCxcbiAgICAgICAgICAkZWxcbiAgICAgICAgfSA9IHNjcm9sbGJhcjtcbiAgICAgICAgJGRyYWdFbFswXS5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICB0cmFja1NpemUgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAkZWxbMF0ub2Zmc2V0V2lkdGggOiAkZWxbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBkaXZpZGVyID0gc3dpcGVyLnNpemUgLyAoc3dpcGVyLnZpcnR1YWxTaXplICsgc3dpcGVyLnBhcmFtcy5zbGlkZXNPZmZzZXRCZWZvcmUgLSAoc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5zbmFwR3JpZFswXSA6IDApKTtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ1NpemUgPT09ICdhdXRvJykge1xuICAgICAgICAgIGRyYWdTaXplID0gdHJhY2tTaXplICogZGl2aWRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmFnU2l6ZSA9IHBhcnNlSW50KHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdTaXplLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgJGRyYWdFbFswXS5zdHlsZS53aWR0aCA9IGAke2RyYWdTaXplfXB4YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9IGAke2RyYWdTaXplfXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXZpZGVyID49IDEpIHtcbiAgICAgICAgICAkZWxbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZWxbMF0uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmhpZGUpIHtcbiAgICAgICAgICAkZWxbMF0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5lbmFibGVkKSB7XG4gICAgICAgICAgc2Nyb2xsYmFyLiRlbFtzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQb2ludGVyUG9zaXRpb24oZSkge1xuICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkgOiBlLmNsaWVudFk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldERyYWdQb3NpdGlvbihlKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzY3JvbGxiYXIsXG4gICAgICAgICAgcnRsVHJhbnNsYXRlOiBydGxcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbFxuICAgICAgICB9ID0gc2Nyb2xsYmFyO1xuICAgICAgICBsZXQgcG9zaXRpb25SYXRpbztcbiAgICAgICAgcG9zaXRpb25SYXRpbyA9IChnZXRQb2ludGVyUG9zaXRpb24oZSkgLSAkZWwub2Zmc2V0KClbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ2xlZnQnIDogJ3RvcCddIC0gKGRyYWdTdGFydFBvcyAhPT0gbnVsbCA/IGRyYWdTdGFydFBvcyA6IGRyYWdTaXplIC8gMikpIC8gKHRyYWNrU2l6ZSAtIGRyYWdTaXplKTtcbiAgICAgICAgcG9zaXRpb25SYXRpbyA9IE1hdGgubWF4KE1hdGgubWluKHBvc2l0aW9uUmF0aW8sIDEpLCAwKTtcblxuICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgcG9zaXRpb25SYXRpbyA9IDEgLSBwb3NpdGlvblJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCkgKyAoc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAqIHBvc2l0aW9uUmF0aW87XG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhwb3NpdGlvbik7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUocG9zaXRpb24pO1xuICAgICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25EcmFnU3RhcnQoZSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNjcm9sbGJhcixcbiAgICAgICAgICAkd3JhcHBlckVsXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkZWwsXG4gICAgICAgICAgJGRyYWdFbFxuICAgICAgICB9ID0gc2Nyb2xsYmFyO1xuICAgICAgICBpc1RvdWNoZWQgPSB0cnVlO1xuICAgICAgICBkcmFnU3RhcnRQb3MgPSBlLnRhcmdldCA9PT0gJGRyYWdFbFswXSB8fCBlLnRhcmdldCA9PT0gJGRyYWdFbCA/IGdldFBvaW50ZXJQb3NpdGlvbihlKSAtIGUudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdsZWZ0JyA6ICd0b3AnXSA6IG51bGw7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uKDEwMCk7XG4gICAgICAgICRkcmFnRWwudHJhbnNpdGlvbigxMDApO1xuICAgICAgICBzZXREcmFnUG9zaXRpb24oZSk7XG4gICAgICAgIGNsZWFyVGltZW91dChkcmFnVGltZW91dCk7XG4gICAgICAgICRlbC50cmFuc2l0aW9uKDApO1xuXG4gICAgICAgIGlmIChwYXJhbXMuaGlkZSkge1xuICAgICAgICAgICRlbC5jc3MoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC5jc3MoJ3Njcm9sbC1zbmFwLXR5cGUnLCAnbm9uZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdCgnc2Nyb2xsYmFyRHJhZ1N0YXJ0JywgZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRHJhZ01vdmUoZSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2Nyb2xsYmFyLFxuICAgICAgICAgICR3cmFwcGVyRWxcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbCxcbiAgICAgICAgICAkZHJhZ0VsXG4gICAgICAgIH0gPSBzY3JvbGxiYXI7XG4gICAgICAgIGlmICghaXNUb3VjaGVkKSByZXR1cm47XG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7ZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIHNldERyYWdQb3NpdGlvbihlKTtcbiAgICAgICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uKDApO1xuICAgICAgICAkZWwudHJhbnNpdGlvbigwKTtcbiAgICAgICAgJGRyYWdFbC50cmFuc2l0aW9uKDApO1xuICAgICAgICBlbWl0KCdzY3JvbGxiYXJEcmFnTW92ZScsIGUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkRyYWdFbmQoZSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNjcm9sbGJhcixcbiAgICAgICAgICAkd3JhcHBlckVsXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkZWxcbiAgICAgICAgfSA9IHNjcm9sbGJhcjtcbiAgICAgICAgaWYgKCFpc1RvdWNoZWQpIHJldHVybjtcbiAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsLmNzcygnc2Nyb2xsLXNuYXAtdHlwZScsICcnKTtcbiAgICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb24oJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5oaWRlKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGRyYWdUaW1lb3V0KTtcbiAgICAgICAgICBkcmFnVGltZW91dCA9IG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICRlbC5jc3MoJ29wYWNpdHknLCAwKTtcbiAgICAgICAgICAgICRlbC50cmFuc2l0aW9uKDQwMCk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KCdzY3JvbGxiYXJEcmFnRW5kJywgZSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5zbmFwT25SZWxlYXNlKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXZlbnRzKG1ldGhvZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2Nyb2xsYmFyLFxuICAgICAgICAgIHRvdWNoRXZlbnRzVG91Y2gsXG4gICAgICAgICAgdG91Y2hFdmVudHNEZXNrdG9wLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICBzdXBwb3J0XG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0ICRlbCA9IHNjcm9sbGJhci4kZWw7XG4gICAgICAgIGlmICghJGVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRhcmdldCA9ICRlbFswXTtcbiAgICAgICAgY29uc3QgYWN0aXZlTGlzdGVuZXIgPSBzdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBmYWxzZVxuICAgICAgICB9IDogZmFsc2U7XG4gICAgICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IHN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzID8ge1xuICAgICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICAgICAgfSA6IGZhbHNlO1xuICAgICAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBldmVudE1ldGhvZCA9IG1ldGhvZCA9PT0gJ29uJyA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcblxuICAgICAgICBpZiAoIXN1cHBvcnQudG91Y2gpIHtcbiAgICAgICAgICB0YXJnZXRbZXZlbnRNZXRob2RdKHRvdWNoRXZlbnRzRGVza3RvcC5zdGFydCwgb25EcmFnU3RhcnQsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgICAgICBkb2N1bWVudFtldmVudE1ldGhvZF0odG91Y2hFdmVudHNEZXNrdG9wLm1vdmUsIG9uRHJhZ01vdmUsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgICAgICBkb2N1bWVudFtldmVudE1ldGhvZF0odG91Y2hFdmVudHNEZXNrdG9wLmVuZCwgb25EcmFnRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtldmVudE1ldGhvZF0odG91Y2hFdmVudHNUb3VjaC5zdGFydCwgb25EcmFnU3RhcnQsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgICAgICB0YXJnZXRbZXZlbnRNZXRob2RdKHRvdWNoRXZlbnRzVG91Y2gubW92ZSwgb25EcmFnTW92ZSwgYWN0aXZlTGlzdGVuZXIpO1xuICAgICAgICAgIHRhcmdldFtldmVudE1ldGhvZF0odG91Y2hFdmVudHNUb3VjaC5lbmQsIG9uRHJhZ0VuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbmFibGVEcmFnZ2FibGUoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcbiAgICAgICAgZXZlbnRzKCdvbicpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkaXNhYmxlRHJhZ2dhYmxlKCkge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsIHx8ICFzd2lwZXIuc2Nyb2xsYmFyLmVsKSByZXR1cm47XG4gICAgICAgIGV2ZW50cygnb2ZmJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzY3JvbGxiYXIsXG4gICAgICAgICAgJGVsOiAkc3dpcGVyRWxcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIgPSBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkKHN3aXBlciwgc3dpcGVyLm9yaWdpbmFsUGFyYW1zLnNjcm9sbGJhciwgc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIsIHtcbiAgICAgICAgICBlbDogJ3N3aXBlci1zY3JvbGxiYXInXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICAgICAgaWYgKCFwYXJhbXMuZWwpIHJldHVybjtcbiAgICAgICAgbGV0ICRlbCA9ICQocGFyYW1zLmVsKTtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiB0eXBlb2YgcGFyYW1zLmVsID09PSAnc3RyaW5nJyAmJiAkZWwubGVuZ3RoID4gMSAmJiAkc3dpcGVyRWwuZmluZChwYXJhbXMuZWwpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICRlbCA9ICRzd2lwZXJFbC5maW5kKHBhcmFtcy5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICAkZWwuYWRkQ2xhc3Moc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gcGFyYW1zLmhvcml6b250YWxDbGFzcyA6IHBhcmFtcy52ZXJ0aWNhbENsYXNzKTtcbiAgICAgICAgbGV0ICRkcmFnRWwgPSAkZWwuZmluZChgLiR7c3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ0NsYXNzfWApO1xuXG4gICAgICAgIGlmICgkZHJhZ0VsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICRkcmFnRWwgPSAkKGA8ZGl2IGNsYXNzPVwiJHtzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5kcmFnQ2xhc3N9XCI+PC9kaXY+YCk7XG4gICAgICAgICAgJGVsLmFwcGVuZCgkZHJhZ0VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2Nyb2xsYmFyLCB7XG4gICAgICAgICAgJGVsLFxuICAgICAgICAgIGVsOiAkZWxbMF0sXG4gICAgICAgICAgJGRyYWdFbCxcbiAgICAgICAgICBkcmFnRWw6ICRkcmFnRWxbMF1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICBlbmFibGVEcmFnZ2FibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkZWwpIHtcbiAgICAgICAgICAkZWxbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICAgICAgY29uc3QgJGVsID0gc3dpcGVyLnNjcm9sbGJhci4kZWw7XG5cbiAgICAgICAgaWYgKCRlbCkge1xuICAgICAgICAgICRlbC5yZW1vdmVDbGFzcyhzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBwYXJhbXMuaG9yaXpvbnRhbENsYXNzIDogcGFyYW1zLnZlcnRpY2FsQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzYWJsZURyYWdnYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICBvbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgZGlzYWJsZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgICB1cGRhdGVTaXplKCk7XG4gICAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ3VwZGF0ZSByZXNpemUgb2JzZXJ2ZXJVcGRhdGUgbG9jayB1bmxvY2snLCAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVNpemUoKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ3NldFRyYW5zbGF0ZScsICgpID0+IHtcbiAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdzZXRUcmFuc2l0aW9uJywgKF9zLCBkdXJhdGlvbikgPT4ge1xuICAgICAgICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2VuYWJsZSBkaXNhYmxlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJGVsXG4gICAgICAgIH0gPSBzd2lwZXIuc2Nyb2xsYmFyO1xuXG4gICAgICAgIGlmICgkZWwpIHtcbiAgICAgICAgICAkZWxbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgZGVzdHJveSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVuYWJsZSA9ICgpID0+IHtcbiAgICAgICAgc3dpcGVyLiRlbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5zY3JvbGxiYXJEaXNhYmxlZENsYXNzKTtcblxuICAgICAgICBpZiAoc3dpcGVyLnNjcm9sbGJhci4kZWwpIHtcbiAgICAgICAgICBzd2lwZXIuc2Nyb2xsYmFyLiRlbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5zY3JvbGxiYXJEaXNhYmxlZENsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgdXBkYXRlU2l6ZSgpO1xuICAgICAgICBzZXRUcmFuc2xhdGUoKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGRpc2FibGUgPSAoKSA9PiB7XG4gICAgICAgIHN3aXBlci4kZWwuYWRkQ2xhc3Moc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuc2Nyb2xsYmFyRGlzYWJsZWRDbGFzcyk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5zY3JvbGxiYXIuJGVsKSB7XG4gICAgICAgICAgc3dpcGVyLnNjcm9sbGJhci4kZWwuYWRkQ2xhc3Moc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuc2Nyb2xsYmFyRGlzYWJsZWRDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0cm95KCk7XG4gICAgICB9O1xuXG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlci5zY3JvbGxiYXIsIHtcbiAgICAgICAgZW5hYmxlLFxuICAgICAgICBkaXNhYmxlLFxuICAgICAgICB1cGRhdGVTaXplLFxuICAgICAgICBzZXRUcmFuc2xhdGUsXG4gICAgICAgIGluaXQsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBhcmFsbGF4KF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgICBvblxuICAgICAgfSA9IF9yZWY7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBwYXJhbGxheDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2Zvcm0gPSAoZWwsIHByb2dyZXNzKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBydGxcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgICAgIGNvbnN0IHJ0bEZhY3RvciA9IHJ0bCA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgcCA9ICRlbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheCcpIHx8ICcwJztcbiAgICAgICAgbGV0IHggPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgteCcpO1xuICAgICAgICBsZXQgeSA9ICRlbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheC15Jyk7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gJGVsLmF0dHIoJ2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlJyk7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eScpO1xuXG4gICAgICAgIGlmICh4IHx8IHkpIHtcbiAgICAgICAgICB4ID0geCB8fCAnMCc7XG4gICAgICAgICAgeSA9IHkgfHwgJzAnO1xuICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgIHggPSBwO1xuICAgICAgICAgIHkgPSAnMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeSA9IHA7XG4gICAgICAgICAgeCA9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4LmluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICAgICAgeCA9IGAke3BhcnNlSW50KHgsIDEwKSAqIHByb2dyZXNzICogcnRsRmFjdG9yfSVgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBgJHt4ICogcHJvZ3Jlc3MgKiBydGxGYWN0b3J9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkuaW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICB5ID0gYCR7cGFyc2VJbnQoeSwgMTApICogcHJvZ3Jlc3N9JWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeSA9IGAke3kgKiBwcm9ncmVzc31weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnICYmIG9wYWNpdHkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50T3BhY2l0eSA9IG9wYWNpdHkgLSAob3BhY2l0eSAtIDEpICogKDEgLSBNYXRoLmFicyhwcm9ncmVzcykpO1xuICAgICAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gY3VycmVudE9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNjYWxlID09PSAndW5kZWZpbmVkJyB8fCBzY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICRlbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7eH0sICR7eX0sIDBweClgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U2NhbGUgPSBzY2FsZSAtIChzY2FsZSAtIDEpICogKDEgLSBNYXRoLmFicyhwcm9ncmVzcykpO1xuICAgICAgICAgICRlbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7eH0sICR7eX0sIDBweCkgc2NhbGUoJHtjdXJyZW50U2NhbGV9KWApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2xhdGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkZWwsXG4gICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgIHNuYXBHcmlkXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgICRlbC5jaGlsZHJlbignW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpLmVhY2goZWwgPT4ge1xuICAgICAgICAgIHNldFRyYW5zZm9ybShlbCwgcHJvZ3Jlc3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2xpZGVzLmVhY2goKHNsaWRlRWwsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgICAgICBsZXQgc2xpZGVQcm9ncmVzcyA9IHNsaWRlRWwucHJvZ3Jlc3M7XG5cbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA+IDEgJiYgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHNsaWRlUHJvZ3Jlc3MgKz0gTWF0aC5jZWlsKHNsaWRlSW5kZXggLyAyKSAtIHByb2dyZXNzICogKHNuYXBHcmlkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNsaWRlUHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heChzbGlkZVByb2dyZXNzLCAtMSksIDEpO1xuICAgICAgICAgICQoc2xpZGVFbCkuZmluZCgnW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpLmVhY2goZWwgPT4ge1xuICAgICAgICAgICAgc2V0VHJhbnNmb3JtKGVsLCBzbGlkZVByb2dyZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZHVyYXRpb24gPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbFxuICAgICAgICB9ID0gc3dpcGVyO1xuICAgICAgICAkZWwuZmluZCgnW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpLmVhY2gocGFyYWxsYXhFbCA9PiB7XG4gICAgICAgICAgY29uc3QgJHBhcmFsbGF4RWwgPSAkKHBhcmFsbGF4RWwpO1xuICAgICAgICAgIGxldCBwYXJhbGxheER1cmF0aW9uID0gcGFyc2VJbnQoJHBhcmFsbGF4RWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgtZHVyYXRpb24nKSwgMTApIHx8IGR1cmF0aW9uO1xuICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCkgcGFyYWxsYXhEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgJHBhcmFsbGF4RWwudHJhbnNpdGlvbihwYXJhbGxheER1cmF0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBvbignYmVmb3JlSW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgc3dpcGVyLm9yaWdpbmFsUGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBvbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdzZXRUcmFuc2xhdGUnLCAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkKSByZXR1cm47XG4gICAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBvbignc2V0VHJhbnNpdGlvbicsIChfc3dpcGVyLCBkdXJhdGlvbikgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIGVzbGludCBuby11bmRlcnNjb3JlLWRhbmdsZTogXCJvZmZcIiAqL1xuICAgIGZ1bmN0aW9uIEF1dG9wbGF5KF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgICBvbixcbiAgICAgICAgZW1pdFxuICAgICAgfSA9IF9yZWY7XG4gICAgICBsZXQgdGltZW91dDtcbiAgICAgIHN3aXBlci5hdXRvcGxheSA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIHBhdXNlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBhdXRvcGxheToge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIGRlbGF5OiAzMDAwLFxuICAgICAgICAgIHdhaXRGb3JUcmFuc2l0aW9uOiB0cnVlLFxuICAgICAgICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiB0cnVlLFxuICAgICAgICAgIHN0b3BPbkxhc3RTbGlkZTogZmFsc2UsXG4gICAgICAgICAgcmV2ZXJzZURpcmVjdGlvbjogZmFsc2UsXG4gICAgICAgICAgcGF1c2VPbk1vdXNlRW50ZXI6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBydW4oKSB7XG4gICAgICAgIGlmICghc3dpcGVyLnNpemUpIHtcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCAkYWN0aXZlU2xpZGVFbCA9IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgbGV0IGRlbGF5ID0gc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kZWxheTtcblxuICAgICAgICBpZiAoJGFjdGl2ZVNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItYXV0b3BsYXknKSkge1xuICAgICAgICAgIGRlbGF5ID0gJGFjdGl2ZVNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItYXV0b3BsYXknKSB8fCBzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRlbGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIGxldCBhdXRvcGxheVJlc3VsdDtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnJldmVyc2VEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICAgICAgYXV0b3BsYXlSZXN1bHQgPSBzd2lwZXIuc2xpZGVQcmV2KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICBlbWl0KCdhdXRvcGxheScpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3dpcGVyLmlzQmVnaW5uaW5nKSB7XG4gICAgICAgICAgICAgIGF1dG9wbGF5UmVzdWx0ID0gc3dpcGVyLnNsaWRlUHJldihzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlKSB7XG4gICAgICAgICAgICAgIGF1dG9wbGF5UmVzdWx0ID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCBzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICAgIGF1dG9wbGF5UmVzdWx0ID0gc3dpcGVyLnNsaWRlTmV4dChzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghc3dpcGVyLmlzRW5kKSB7XG4gICAgICAgICAgICBhdXRvcGxheVJlc3VsdCA9IHN3aXBlci5zbGlkZU5leHQoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBlbWl0KCdhdXRvcGxheScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlKSB7XG4gICAgICAgICAgICBhdXRvcGxheVJlc3VsdCA9IHN3aXBlci5zbGlkZVRvKDAsIHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUgJiYgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHJ1bigpO2Vsc2UgaWYgKGF1dG9wbGF5UmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcnVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkucnVubmluZyA9IHRydWU7XG4gICAgICAgIGVtaXQoJ2F1dG9wbGF5U3RhcnQnKTtcbiAgICAgICAgcnVuKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBpZiAoIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgZW1pdCgnYXV0b3BsYXlTdG9wJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXVzZShzcGVlZCkge1xuICAgICAgICBpZiAoIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm47XG4gICAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucGF1c2VkKSByZXR1cm47XG4gICAgICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzcGVlZCA9PT0gMCB8fCAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS53YWl0Rm9yVHJhbnNpdGlvbikge1xuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICBydW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcblxuICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJyAmJiBzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZSkge1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuJHdyYXBwZXJFbCkgcmV0dXJuO1xuICAgICAgICBpZiAoZS50YXJnZXQgIT09IHN3aXBlci4kd3JhcHBlckVsWzBdKSByZXR1cm47XG4gICAgICAgIFsndHJhbnNpdGlvbmVuZCcsICd3ZWJraXRUcmFuc2l0aW9uRW5kJ10uZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSB7XG4gICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VFbnRlcigpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW1pdCgnYXV0b3BsYXlQYXVzZScpO1xuICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICBlbWl0KCdhdXRvcGxheVJlc3VtZScpO1xuICAgICAgICBydW4oKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXR0YWNoTW91c2VFdmVudHMoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnBhdXNlT25Nb3VzZUVudGVyKSB7XG4gICAgICAgICAgc3dpcGVyLiRlbC5vbignbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgICAgICAgc3dpcGVyLiRlbC5vbignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0YWNoTW91c2VFdmVudHMoKSB7XG4gICAgICAgIHN3aXBlci4kZWwub2ZmKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgc3dpcGVyLiRlbC5vZmYoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgfVxuXG4gICAgICBvbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZCkge1xuICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICAgIGF0dGFjaE1vdXNlRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIChfcywgc3BlZWQsIGludGVybmFsKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbCB8fCAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlKHNwZWVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignc2xpZGVyRmlyc3RNb3ZlJywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbigndG91Y2hFbmQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCAmJiAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICBkZXRhY2hNb3VzZUV2ZW50cygpO1xuXG4gICAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLmF1dG9wbGF5LCB7XG4gICAgICAgIHBhdXNlLFxuICAgICAgICBydW4sXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBzdG9wXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcmVlTW9kZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICBzd2lwZXIsXG4gICAgICAgIGV4dGVuZFBhcmFtcyxcbiAgICAgICAgZW1pdCxcbiAgICAgICAgb25jZVxuICAgICAgfSA9IF9yZWY7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBmcmVlTW9kZToge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIG1vbWVudHVtOiB0cnVlLFxuICAgICAgICAgIG1vbWVudHVtUmF0aW86IDEsXG4gICAgICAgICAgbW9tZW50dW1Cb3VuY2U6IHRydWUsXG4gICAgICAgICAgbW9tZW50dW1Cb3VuY2VSYXRpbzogMSxcbiAgICAgICAgICBtb21lbnR1bVZlbG9jaXR5UmF0aW86IDEsXG4gICAgICAgICAgc3RpY2t5OiBmYWxzZSxcbiAgICAgICAgICBtaW5pbXVtVmVsb2NpdHk6IDAuMDJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uVG91Y2hTdGFydCgpIHtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSk7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNEYXRhLnZlbG9jaXRpZXMubGVuZ3RoID0gMDtcbiAgICAgICAgc3dpcGVyLmZyZWVNb2RlLm9uVG91Y2hFbmQoe1xuICAgICAgICAgIGN1cnJlbnRQb3M6IHN3aXBlci5ydGwgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdG91Y2hFdmVudHNEYXRhOiBkYXRhLFxuICAgICAgICAgIHRvdWNoZXNcbiAgICAgICAgfSA9IHN3aXBlcjsgLy8gVmVsb2NpdHlcblxuICAgICAgICBpZiAoZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRhdGEudmVsb2NpdGllcy5wdXNoKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdzdGFydFgnIDogJ3N0YXJ0WSddLFxuICAgICAgICAgICAgdGltZTogZGF0YS50b3VjaFN0YXJ0VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS52ZWxvY2l0aWVzLnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdjdXJyZW50WCcgOiAnY3VycmVudFknXSxcbiAgICAgICAgICB0aW1lOiBub3coKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Ub3VjaEVuZChfcmVmMikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRQb3NcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgdG91Y2hFdmVudHNEYXRhOiBkYXRhXG4gICAgICAgIH0gPSBzd2lwZXI7IC8vIFRpbWUgZGlmZlxuXG4gICAgICAgIGNvbnN0IHRvdWNoRW5kVGltZSA9IG5vdygpO1xuICAgICAgICBjb25zdCB0aW1lRGlmZiA9IHRvdWNoRW5kVGltZSAtIGRhdGEudG91Y2hTdGFydFRpbWU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQb3MgPCAtc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudFBvcyA+IC1zd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLnNsaWRlcy5sZW5ndGggPCBzbmFwR3JpZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNuYXBHcmlkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuZnJlZU1vZGUubW9tZW50dW0pIHtcbiAgICAgICAgICBpZiAoZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RNb3ZlRXZlbnQgPSBkYXRhLnZlbG9jaXRpZXMucG9wKCk7XG4gICAgICAgICAgICBjb25zdCB2ZWxvY2l0eUV2ZW50ID0gZGF0YS52ZWxvY2l0aWVzLnBvcCgpO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBsYXN0TW92ZUV2ZW50LnBvc2l0aW9uIC0gdmVsb2NpdHlFdmVudC5wb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBsYXN0TW92ZUV2ZW50LnRpbWUgLSB2ZWxvY2l0eUV2ZW50LnRpbWU7XG4gICAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSBkaXN0YW5jZSAvIHRpbWU7XG4gICAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgLz0gMjtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHN3aXBlci52ZWxvY2l0eSkgPCBwYXJhbXMuZnJlZU1vZGUubWluaW11bVZlbG9jaXR5KSB7XG4gICAgICAgICAgICAgIHN3aXBlci52ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICB9IC8vIHRoaXMgaW1wbGllcyB0aGF0IHRoZSB1c2VyIHN0b3BwZWQgbW92aW5nIGEgZmluZ2VyIHRoZW4gcmVsZWFzZWQuXG4gICAgICAgICAgICAvLyBUaGVyZSB3b3VsZCBiZSBubyBldmVudHMgd2l0aCBkaXN0YW5jZSB6ZXJvLCBzbyB0aGUgbGFzdCBldmVudCBpcyBzdGFsZS5cblxuXG4gICAgICAgICAgICBpZiAodGltZSA+IDE1MCB8fCBub3coKSAtIGxhc3RNb3ZlRXZlbnQudGltZSA+IDMwMCkge1xuICAgICAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXBlci52ZWxvY2l0eSAqPSBwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1WZWxvY2l0eVJhdGlvO1xuICAgICAgICAgIGRhdGEudmVsb2NpdGllcy5sZW5ndGggPSAwO1xuICAgICAgICAgIGxldCBtb21lbnR1bUR1cmF0aW9uID0gMTAwMCAqIHBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bVJhdGlvO1xuICAgICAgICAgIGNvbnN0IG1vbWVudHVtRGlzdGFuY2UgPSBzd2lwZXIudmVsb2NpdHkgKiBtb21lbnR1bUR1cmF0aW9uO1xuICAgICAgICAgIGxldCBuZXdQb3NpdGlvbiA9IHN3aXBlci50cmFuc2xhdGUgKyBtb21lbnR1bURpc3RhbmNlO1xuICAgICAgICAgIGlmIChydGwpIG5ld1Bvc2l0aW9uID0gLW5ld1Bvc2l0aW9uO1xuICAgICAgICAgIGxldCBkb0JvdW5jZSA9IGZhbHNlO1xuICAgICAgICAgIGxldCBhZnRlckJvdW5jZVBvc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IGJvdW5jZUFtb3VudCA9IE1hdGguYWJzKHN3aXBlci52ZWxvY2l0eSkgKiAyMCAqIHBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bUJvdW5jZVJhdGlvO1xuICAgICAgICAgIGxldCBuZWVkc0xvb3BGaXg7XG5cbiAgICAgICAgICBpZiAobmV3UG9zaXRpb24gPCBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2UpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uICsgc3dpcGVyLm1heFRyYW5zbGF0ZSgpIDwgLWJvdW5jZUFtb3VudCkge1xuICAgICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gYm91bmNlQW1vdW50O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYWZ0ZXJCb3VuY2VQb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcbiAgICAgICAgICAgICAgZG9Cb3VuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMubG9vcCAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIG5lZWRzTG9vcEZpeCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXdQb3NpdGlvbiA+IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bUJvdW5jZSkge1xuICAgICAgICAgICAgICBpZiAobmV3UG9zaXRpb24gLSBzd2lwZXIubWluVHJhbnNsYXRlKCkgPiBib3VuY2VBbW91bnQpIHtcbiAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKSArIGJvdW5jZUFtb3VudDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFmdGVyQm91bmNlUG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gICAgICAgICAgICAgIGRvQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZGF0YS5hbGxvd01vbWVudHVtQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmxvb3AgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSBuZWVkc0xvb3BGaXggPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlLnN0aWNreSkge1xuICAgICAgICAgICAgbGV0IG5leHRTbGlkZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbmFwR3JpZC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoc25hcEdyaWRbal0gPiAtbmV3UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBuZXh0U2xpZGUgPSBqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzbmFwR3JpZFtuZXh0U2xpZGVdIC0gbmV3UG9zaXRpb24pIDwgTWF0aC5hYnMoc25hcEdyaWRbbmV4dFNsaWRlIC0gMV0gLSBuZXdQb3NpdGlvbikgfHwgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAnbmV4dCcpIHtcbiAgICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBzbmFwR3JpZFtuZXh0U2xpZGVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBzbmFwR3JpZFtuZXh0U2xpZGUgLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSAtbmV3UG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lZWRzTG9vcEZpeCkge1xuICAgICAgICAgICAgb25jZSgndHJhbnNpdGlvbkVuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gRml4IGR1cmF0aW9uXG5cblxuICAgICAgICAgIGlmIChzd2lwZXIudmVsb2NpdHkgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGguYWJzKCgtbmV3UG9zaXRpb24gLSBzd2lwZXIudHJhbnNsYXRlKSAvIHN3aXBlci52ZWxvY2l0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtb21lbnR1bUR1cmF0aW9uID0gTWF0aC5hYnMoKG5ld1Bvc2l0aW9uIC0gc3dpcGVyLnRyYW5zbGF0ZSkgLyBzd2lwZXIudmVsb2NpdHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlLnN0aWNreSkge1xuICAgICAgICAgICAgICAvLyBJZiBmcmVlTW9kZS5zdGlja3kgaXMgYWN0aXZlIGFuZCB0aGUgdXNlciBlbmRzIGEgc3dpcGUgd2l0aCBhIHNsb3ctdmVsb2NpdHlcbiAgICAgICAgICAgICAgLy8gZXZlbnQsIHRoZW4gZHVyYXRpb25zIGNhbiBiZSAyMCsgc2Vjb25kcyB0byBzbGlkZSBvbmUgKG9yIHplcm8hKSBzbGlkZXMuXG4gICAgICAgICAgICAgIC8vIEl0J3MgZWFzeSB0byBzZWUgdGhpcyB3aGVuIHNpbXVsYXRpbmcgdG91Y2ggd2l0aCBtb3VzZSBldmVudHMuIFRvIGZpeCB0aGlzLFxuICAgICAgICAgICAgICAvLyBsaW1pdCBzaW5nbGUtc2xpZGUgc3dpcGVzIHRvIHRoZSBkZWZhdWx0IHNsaWRlIGR1cmF0aW9uLiBUaGlzIGFsc28gaGFzIHRoZVxuICAgICAgICAgICAgICAvLyBuaWNlIHNpZGUgZWZmZWN0IG9mIG1hdGNoaW5nIHNsaWRlIHNwZWVkIGlmIHRoZSB1c2VyIHN0b3BwZWQgbW92aW5nIGJlZm9yZVxuICAgICAgICAgICAgICAvLyBsaWZ0aW5nIGZpbmdlciBvciBtb3VzZSB2cy4gbW92aW5nIHNsb3dseSBiZWZvcmUgbGlmdGluZyB0aGUgZmluZ2VyL21vdXNlLlxuICAgICAgICAgICAgICAvLyBGb3IgZmFzdGVyIHN3aXBlcywgYWxzbyBhcHBseSBsaW1pdHMgKGFsYmVpdCBoaWdoZXIgb25lcykuXG4gICAgICAgICAgICAgIGNvbnN0IG1vdmVEaXN0YW5jZSA9IE1hdGguYWJzKChydGwgPyAtbmV3UG9zaXRpb24gOiBuZXdQb3NpdGlvbikgLSBzd2lwZXIudHJhbnNsYXRlKTtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNsaWRlU2l6ZSA9IHN3aXBlci5zbGlkZXNTaXplc0dyaWRbc3dpcGVyLmFjdGl2ZUluZGV4XTtcblxuICAgICAgICAgICAgICBpZiAobW92ZURpc3RhbmNlIDwgY3VycmVudFNsaWRlU2l6ZSkge1xuICAgICAgICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBwYXJhbXMuc3BlZWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobW92ZURpc3RhbmNlIDwgMiAqIGN1cnJlbnRTbGlkZVNpemUpIHtcbiAgICAgICAgICAgICAgICBtb21lbnR1bUR1cmF0aW9uID0gcGFyYW1zLnNwZWVkICogMS41O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBwYXJhbXMuc3BlZWQgKiAyLjU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5mcmVlTW9kZS5zdGlja3kpIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvQ2xvc2VzdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2UgJiYgZG9Cb3VuY2UpIHtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhhZnRlckJvdW5jZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKG1vbWVudHVtRHVyYXRpb24pO1xuICAgICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvblN0YXJ0KHRydWUsIHN3aXBlci5zd2lwZURpcmVjdGlvbik7XG4gICAgICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIWRhdGEuYWxsb3dNb21lbnR1bUJvdW5jZSkgcmV0dXJuO1xuICAgICAgICAgICAgICBlbWl0KCdtb21lbnR1bUJvdW5jZScpO1xuICAgICAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihwYXJhbXMuc3BlZWQpO1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKGFmdGVyQm91bmNlUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLnZlbG9jaXR5KSB7XG4gICAgICAgICAgICBlbWl0KCdfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZScpO1xuICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKG1vbWVudHVtRHVyYXRpb24pO1xuICAgICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvblN0YXJ0KHRydWUsIHN3aXBlci5zd2lwZURpcmVjdGlvbik7XG5cbiAgICAgICAgICAgIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uRW5kKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhuZXdQb3NpdGlvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuZnJlZU1vZGUuc3RpY2t5KSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5mcmVlTW9kZSkge1xuICAgICAgICAgIGVtaXQoJ19mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bSB8fCB0aW1lRGlmZiA+PSBwYXJhbXMubG9uZ1N3aXBlc01zKSB7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgICAgICBmcmVlTW9kZToge1xuICAgICAgICAgIG9uVG91Y2hTdGFydCxcbiAgICAgICAgICBvblRvdWNoTW92ZSxcbiAgICAgICAgICBvblRvdWNoRW5kXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZhc2hpb25TbGlkZXIoZWwpIHtcbiAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc3dpcGVyLWZhc2hpb24nKSkge1xuICAgICAgICBjb25zdCBzd2lwZXJFbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItZmFzaGlvbicpO1xuICAgICAgICBsZXQgbmF2aWdhdGlvbkxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgdHJhbnNpdGlvbkRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBmcmFtZUlkO1xuXG4gICAgICAgIGNvbnN0IGRpc2FibGVUcmFuc2l0aW9ucyA9ICRlbCA9PiB7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKCdmYXNoaW9uLXNsaWRlci1uby10cmFuc2l0aW9uJyk7XG4gICAgICAgICAgdHJhbnNpdGlvbkRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgICAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICRlbC5yZW1vdmVDbGFzcygnZmFzaGlvbi1zbGlkZXItbm8tdHJhbnNpdGlvbicpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbkRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICBuYXZpZ2F0aW9uTG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaW5pdE5hdmlnYXRpb24gPSBzd2lwZXIgPT4ge1xuICAgICAgICAgIC8vIFVzZSBsb2NrIHRvIGNvbnRyb2wgdGhlIGJ1dHRvbiBsb2NraW5nIHRpbWUgd2l0aG91dCB1c2luZyB0aGUgYnV0dG9uIGNvbXBvbmVudCB0aGF0IGNvbWVzIHdpdGggaXRcbiAgICAgICAgICBzd2lwZXIuJGVsLmZpbmQoJy5mYXNoaW9uLXNsaWRlci1idXR0b24tbmV4dCcpLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghbmF2aWdhdGlvbkxvY2tlZCkge1xuICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVOZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3dpcGVyLiRlbC5maW5kKCcuZmFzaGlvbi1zbGlkZXItYnV0dG9uLXByZXYnKS5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5hdmlnYXRpb25Mb2NrZWQpIHtcbiAgICAgICAgICAgICAgc3dpcGVyLnNsaWRlUHJldigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGRlc3Ryb3lOYXZpZ2F0aW9uID0gc3dpcGVyID0+IHtcbiAgICAgICAgICBzd2lwZXIuJGVsLmZpbmQoJy5mYXNoaW9uLXNsaWRlci1idXR0b24tbmV4dCwgLmZhc2hpb24tc2xpZGVyLWJ1dHRvbi1wcmV2Jykub2ZmKCdjbGljaycpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZhc2hpb25TbGlkZXIgPSBuZXcgU3dpcGVyKHN3aXBlckVsLCB7XG4gICAgICAgICAgbW9kdWxlczogW1BhcmFsbGF4LCBQYWdpbmF0aW9uLCBBdXRvcGxheV0sXG4gICAgICAgICAgc3BlZWQ6IDEzMDAsXG4gICAgICAgICAgYWxsb3dUb3VjaE1vdmU6IGZhbHNlLFxuICAgICAgICAgIC8vIG5vIHRvdWNoIHN3aXBpbmdcbiAgICAgICAgICBwYXJhbGxheDogdHJ1ZSxcbiAgICAgICAgICAvLyB0ZXh0IHBhcmFsbGF4XG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25TdGFydChzd2lwZXIpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHNsaWRlcyxcbiAgICAgICAgICAgICAgICBwcmV2aW91c0luZGV4LFxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICAgICAgICAgICRlbFxuICAgICAgICAgICAgICB9ID0gc3dpcGVyO1xuICAgICAgICAgICAgICBpZiAoIXRyYW5zaXRpb25EaXNhYmxlZCkgbmF2aWdhdGlvbkxvY2tlZCA9IHRydWU7IC8vIGxvY2sgbmF2aWdhdGlvbiBidXR0b25zXG5cbiAgICAgICAgICAgICAgY29uc3QgJGFjdGl2ZVNsaWRlID0gc2xpZGVzLmVxKGFjdGl2ZUluZGV4KTtcbiAgICAgICAgICAgICAgY29uc3QgJHByZXZpb3VzU2xpZGUgPSBzbGlkZXMuZXEocHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICAgIGNvbnN0ICRwcmV2aW91c0ltYWdlU2NhbGUgPSAkcHJldmlvdXNTbGlkZS5maW5kKCcuZmFzaGlvbi1zbGlkZXItc2NhbGUnKTsgLy8gaW1hZ2Ugd3JhcHBlclxuXG4gICAgICAgICAgICAgIGNvbnN0ICRwcmV2aW91c0ltYWdlID0gJHByZXZpb3VzU2xpZGUuZmluZCgnaW1nJyk7IC8vIGN1cnJlbnQgaW1hZ2VcblxuICAgICAgICAgICAgICBjb25zdCAkYWN0aXZlSW1hZ2UgPSAkYWN0aXZlU2xpZGUuZmluZCgnaW1nJyk7IC8vIG5leHQgaW1hZ2VcblxuICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBhY3RpdmVJbmRleCAtIHByZXZpb3VzSW5kZXg7XG4gICAgICAgICAgICAgIGNvbnN0IGJnQ29sb3IgPSAkYWN0aXZlU2xpZGUuYXR0cignZGF0YS1zbGlkZS1iZy1jb2xvcicpO1xuICAgICAgICAgICAgICAkZWwuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgYmdDb2xvcik7IC8vIGJhY2tncm91bmQgY29sb3IgYW5pbWF0aW9uXG5cbiAgICAgICAgICAgICAgJHByZXZpb3VzSW1hZ2VTY2FsZS50cmFuc2Zvcm0oJ3NjYWxlKDAuNiknKTtcbiAgICAgICAgICAgICAgJHByZXZpb3VzSW1hZ2UudHJhbnNpdGlvbigxMDAwKS50cmFuc2Zvcm0oJ3NjYWxlKDEuMiknKTsgLy8gaW1hZ2Ugc2NhbGluZyBwYXJhbGxheFxuXG4gICAgICAgICAgICAgICRwcmV2aW91c1NsaWRlLmZpbmQoJy5mYXNoaW9uLXNsaWRlci10aXRsZS10ZXh0JykudHJhbnNpdGlvbigxMDAwKS5jc3MoJ2NvbG9yJywgJ3JnYmEoMjU1LDI1NSwyNTUsMCknKSAvLyB0ZXh0IHRyYW5zcGFyZW5jeSBhbmltYXRpb25cbiAgICAgICAgICAgICAgLmNzcygnb3BhY2l0eScsICcwJyk7IC8vIHRleHQgdHJhbnNwYXJlbmN5IGFuaW1hdGlvblxuXG4gICAgICAgICAgICAgICRwcmV2aW91c0ltYWdlLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICRhY3RpdmVJbWFnZS50cmFuc2l0aW9uKDEzMDApLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMCwgMCwgMCkgc2NhbGUoMS4yKScpOyAvLyBpbWFnZSBzaGlmdCBwYXJhbGxheFxuXG4gICAgICAgICAgICAgICAgJHByZXZpb3VzSW1hZ2UudHJhbnNpdGlvbigxMzAwKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7NjAgKiBkaXJlY3Rpb259JSwgMCwgMCkgIHNjYWxlKDEuMilgKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0cmFuc2l0aW9uRW5kKHN3aXBlcikge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICAgICAgICAgICRlbFxuICAgICAgICAgICAgICB9ID0gc3dpcGVyO1xuICAgICAgICAgICAgICBjb25zdCAkYWN0aXZlU2xpZGUgPSBzbGlkZXMuZXEoYWN0aXZlSW5kZXgpO1xuICAgICAgICAgICAgICBjb25zdCAkYWN0aXZlSW1hZ2UgPSAkYWN0aXZlU2xpZGUuZmluZCgnaW1nJyk7XG4gICAgICAgICAgICAgICRhY3RpdmVTbGlkZS5maW5kKCcuZmFzaGlvbi1zbGlkZXItc2NhbGUnKS50cmFuc2Zvcm0oJ3NjYWxlKDEpJyk7XG4gICAgICAgICAgICAgICRhY3RpdmVJbWFnZS50cmFuc2l0aW9uKDEwMDApLnRyYW5zZm9ybSgnc2NhbGUoMSknKTtcbiAgICAgICAgICAgICAgJGFjdGl2ZVNsaWRlLmZpbmQoJy5mYXNoaW9uLXNsaWRlci10aXRsZS10ZXh0JykudHJhbnNpdGlvbigxMDAwKS5jc3MoJ2NvbG9yJywgJ3JnYmEoMjU1LDI1NSwyNTUsMSknKS5jc3MoJ29wYWNpdHknLCAnMScpOyAvLyB0ZXh0IHRyYW5zcGFyZW5jeSBhbmltYXRpb25cblxuICAgICAgICAgICAgICAkYWN0aXZlSW1hZ2UudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9KTsgLy8gRmlyc3QgYW5kIGxhc3QsIGRpc2FibGUgYnV0dG9uXG5cbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgJGVsLmZpbmQoJy5mYXNoaW9uLXNsaWRlci1idXR0b24tcHJldicpLmFkZENsYXNzKCdmYXNoaW9uLXNsaWRlci1idXR0b24tZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkZWwuZmluZCgnLmZhc2hpb24tc2xpZGVyLWJ1dHRvbi1wcmV2JykucmVtb3ZlQ2xhc3MoJ2Zhc2hpb24tc2xpZGVyLWJ1dHRvbi1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZUluZGV4ID09PSBzbGlkZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICRlbC5maW5kKCcuZmFzaGlvbi1zbGlkZXItYnV0dG9uLW5leHQnKS5hZGRDbGFzcygnZmFzaGlvbi1zbGlkZXItYnV0dG9uLWRpc2FibGVkJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJGVsLmZpbmQoJy5mYXNoaW9uLXNsaWRlci1idXR0b24tbmV4dCcpLnJlbW92ZUNsYXNzKCdmYXNoaW9uLXNsaWRlci1idXR0b24tZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW5pdChzd2lwZXIpIHtcbiAgICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgc2xpZGUgYmcgY29sb3JcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHNsaWRlcyxcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgICAgICAgICAkZWxcbiAgICAgICAgICAgICAgfSA9IHN3aXBlcjsgLy8gZGlzYWJsZSBpbml0aWFsIHRyYW5zaXRpb25cblxuICAgICAgICAgICAgICBkaXNhYmxlVHJhbnNpdGlvbnMoJGVsKTsgLy8gc2V0IGN1cnJlbnQgYmcgY29sb3JcblxuICAgICAgICAgICAgICBjb25zdCBiZ0NvbG9yID0gc2xpZGVzLmVxKGFjdGl2ZUluZGV4KS5hdHRyKCdkYXRhLXNsaWRlLWJnLWNvbG9yJyk7XG4gICAgICAgICAgICAgICRlbC5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBiZ0NvbG9yKTsgLy8gYmFja2dyb3VuZCBjb2xvciBhbmltYXRpb25cbiAgICAgICAgICAgICAgLy8gdHJpZ2dlciB0aGUgdHJhbnNpdGlvbkVuZCBldmVudCBvbmNlIGR1cmluZyBpbml0aWFsaXphdGlvblxuXG4gICAgICAgICAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uRW5kJyk7IC8vIGluaXQgbmF2aWdhdGlvblxuXG4gICAgICAgICAgICAgIGluaXROYXZpZ2F0aW9uKHN3aXBlcik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZXNpemUoc3dpcGVyKSB7XG4gICAgICAgICAgICAgIGRpc2FibGVUcmFuc2l0aW9ucyhzd2lwZXIuJGVsKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRlc3Ryb3koc3dpcGVyKSB7XG4gICAgICAgICAgICAgIGRlc3Ryb3lOYXZpZ2F0aW9uKHN3aXBlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICAgIGVsOiBcIi5mYXNoaW9uLXBhZ2luYXRpb25cIixcbiAgICAgICAgICAgIHR5cGU6ICdidWxsZXRzJyxcbiAgICAgICAgICAgIGNsaWNrYWJsZTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXV0b3BsYXk6IHtcbiAgICAgICAgICAgIGRlbGF5OiAyNTAwLFxuICAgICAgICAgICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhc2hpb25TbGlkZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQGZhbmN5YXBwcy91aS9GYW5jeWJveCB2NC4wLjMxXG4gICAgY29uc3QgdCA9IHQgPT4gXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiBudWxsICE9PSB0ICYmIHQuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBcIltvYmplY3QgT2JqZWN0XVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXG4gICAgICAgICAgZSA9ICguLi5pKSA9PiB7XG4gICAgICBsZXQgcyA9ICExO1xuICAgICAgXCJib29sZWFuXCIgPT0gdHlwZW9mIGlbMF0gJiYgKHMgPSBpLnNoaWZ0KCkpO1xuICAgICAgbGV0IG8gPSBpWzBdO1xuICAgICAgaWYgKCFvIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIG8pIHRocm93IG5ldyBFcnJvcihcImV4dGVuZGVlIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgY29uc3QgbiA9IGkuc2xpY2UoMSksXG4gICAgICAgICAgICBhID0gbi5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBuW2ldO1xuXG4gICAgICAgIGZvciAobGV0IGkgaW4gYSkgaWYgKGEuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBjb25zdCBuID0gYVtpXTtcblxuICAgICAgICAgIGlmIChzICYmIChBcnJheS5pc0FycmF5KG4pIHx8IHQobikpKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gQXJyYXkuaXNBcnJheShuKSA/IFtdIDoge307XG4gICAgICAgICAgICBvW2ldID0gZSghMCwgby5oYXNPd25Qcm9wZXJ0eShpKSA/IG9baV0gOiB0LCBuKTtcbiAgICAgICAgICB9IGVsc2Ugb1tpXSA9IG47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG87XG4gICAgfSxcbiAgICAgICAgICBpID0gKHQsIGUgPSAxZTQpID0+ICh0ID0gcGFyc2VGbG9hdCh0KSB8fCAwLCBNYXRoLnJvdW5kKCh0ICsgTnVtYmVyLkVQU0lMT04pICogZSkgLyBlKSxcbiAgICAgICAgICBzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAhISh0ICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgdCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgdCAhPT0gZG9jdW1lbnQuYm9keSkgJiYgIXQuX19QYW56b29tICYmIChmdW5jdGlvbiAodCkge1xuICAgICAgICBjb25zdCBlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0KVtcIm92ZXJmbG93LXlcIl0sXG4gICAgICAgICAgICAgIGkgPSBnZXRDb21wdXRlZFN0eWxlKHQpW1wib3ZlcmZsb3cteFwiXSxcbiAgICAgICAgICAgICAgcyA9IChcInNjcm9sbFwiID09PSBlIHx8IFwiYXV0b1wiID09PSBlKSAmJiBNYXRoLmFicyh0LnNjcm9sbEhlaWdodCAtIHQuY2xpZW50SGVpZ2h0KSA+IDEsXG4gICAgICAgICAgICAgIG8gPSAoXCJzY3JvbGxcIiA9PT0gaSB8fCBcImF1dG9cIiA9PT0gaSkgJiYgTWF0aC5hYnModC5zY3JvbGxXaWR0aCAtIHQuY2xpZW50V2lkdGgpID4gMTtcbiAgICAgICAgcmV0dXJuIHMgfHwgbztcbiAgICAgIH0odCkgPyB0IDogcyh0LnBhcmVudE5vZGUpKTtcbiAgICB9LFxuICAgICAgICAgIG8gPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgd2luZG93LlJlc2l6ZU9ic2VydmVyIHx8IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IFtdLCB0aGlzLmJvdW5kQ2hlY2sgPSB0aGlzLmNoZWNrLmJpbmQodGhpcyksIHRoaXMuYm91bmRDaGVjaygpLCB0aGlzLmNhbGxiYWNrID0gdDtcbiAgICAgIH1cblxuICAgICAgb2JzZXJ2ZSh0KSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmFibGVzLnNvbWUoZSA9PiBlLmVsID09PSB0KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlID0ge1xuICAgICAgICAgIGVsOiB0LFxuICAgICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIGhlaWdodDogdC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogdC5jbGllbnRXaWR0aFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcy5wdXNoKGUpO1xuICAgICAgfVxuXG4gICAgICB1bm9ic2VydmUodCkge1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gdGhpcy5vYnNlcnZhYmxlcy5maWx0ZXIoZSA9PiBlLmVsICE9PSB0KTtcbiAgICAgIH1cblxuICAgICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBjaGVjaygpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMub2JzZXJ2YWJsZXMuZmlsdGVyKHQgPT4ge1xuICAgICAgICAgIGNvbnN0IGUgPSB0LmVsLmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgICAgICBpID0gdC5lbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICBpZiAodC5zaXplLmhlaWdodCAhPT0gZSB8fCB0LnNpemUud2lkdGggIT09IGkpIHJldHVybiB0LnNpemUuaGVpZ2h0ID0gZSwgdC5zaXplLndpZHRoID0gaSwgITA7XG4gICAgICAgIH0pLm1hcCh0ID0+IHQuZWwpO1xuICAgICAgICB0Lmxlbmd0aCA+IDAgJiYgdGhpcy5jYWxsYmFjayh0KSwgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmJvdW5kQ2hlY2spO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGNsYXNzIG4ge1xuICAgICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLmlkID0gc2VsZi5Ub3VjaCAmJiB0IGluc3RhbmNlb2YgVG91Y2ggPyB0LmlkZW50aWZpZXIgOiAtMSwgdGhpcy5wYWdlWCA9IHQucGFnZVgsIHRoaXMucGFnZVkgPSB0LnBhZ2VZLCB0aGlzLmNsaWVudFggPSB0LmNsaWVudFgsIHRoaXMuY2xpZW50WSA9IHQuY2xpZW50WTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGNvbnN0IGEgPSAodCwgZSkgPT4gZSA/IE1hdGguc3FydCgoZS5jbGllbnRYIC0gdC5jbGllbnRYKSAqKiAyICsgKGUuY2xpZW50WSAtIHQuY2xpZW50WSkgKiogMikgOiAwLFxuICAgICAgICAgIHIgPSAodCwgZSkgPT4gZSA/IHtcbiAgICAgIGNsaWVudFg6ICh0LmNsaWVudFggKyBlLmNsaWVudFgpIC8gMixcbiAgICAgIGNsaWVudFk6ICh0LmNsaWVudFkgKyBlLmNsaWVudFkpIC8gMlxuICAgIH0gOiB0O1xuXG4gICAgY2xhc3MgaCB7XG4gICAgICBjb25zdHJ1Y3Rvcih0LCB7XG4gICAgICAgIHN0YXJ0OiBlID0gKCkgPT4gITAsXG4gICAgICAgIG1vdmU6IGkgPSAoKSA9PiB7fSxcbiAgICAgICAgZW5kOiBzID0gKCkgPT4ge31cbiAgICAgIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5zdGFydFBvaW50ZXJzID0gW10sIHRoaXMuY3VycmVudFBvaW50ZXJzID0gW10sIHRoaXMuX3BvaW50ZXJTdGFydCA9IHQgPT4ge1xuICAgICAgICAgIGlmICh0LmJ1dHRvbnMgPiAwICYmIDAgIT09IHQuYnV0dG9uKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgZSA9IG5ldyBuKHQpO1xuICAgICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXJzLnNvbWUodCA9PiB0LmlkID09PSBlLmlkKSB8fCB0aGlzLl90cmlnZ2VyUG9pbnRlclN0YXJ0KGUsIHQpICYmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3ZlKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX3BvaW50ZXJFbmQpKTtcbiAgICAgICAgfSwgdGhpcy5fdG91Y2hTdGFydCA9IHQgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBBcnJheS5mcm9tKHQuY2hhbmdlZFRvdWNoZXMgfHwgW10pKSB0aGlzLl90cmlnZ2VyUG9pbnRlclN0YXJ0KG5ldyBuKGUpLCB0KTtcbiAgICAgICAgfSwgdGhpcy5fbW92ZSA9IHQgPT4ge1xuICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLmN1cnJlbnRQb2ludGVycy5zbGljZSgpLFxuICAgICAgICAgICAgICAgIGkgPSAodCA9PiBcImNoYW5nZWRUb3VjaGVzXCIgaW4gdCkodCkgPyBBcnJheS5mcm9tKHQuY2hhbmdlZFRvdWNoZXMpLm1hcCh0ID0+IG5ldyBuKHQpKSA6IFtuZXcgbih0KV07XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgaSkge1xuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMuY3VycmVudFBvaW50ZXJzLmZpbmRJbmRleChlID0+IGUuaWQgPT09IHQuaWQpO1xuICAgICAgICAgICAgZSA8IDAgfHwgKHRoaXMuY3VycmVudFBvaW50ZXJzW2VdID0gdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbW92ZUNhbGxiYWNrKGUsIHRoaXMuY3VycmVudFBvaW50ZXJzLnNsaWNlKCksIHQpO1xuICAgICAgICB9LCB0aGlzLl90cmlnZ2VyUG9pbnRlckVuZCA9ICh0LCBlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IHRoaXMuY3VycmVudFBvaW50ZXJzLmZpbmRJbmRleChlID0+IGUuaWQgPT09IHQuaWQpO1xuICAgICAgICAgIHJldHVybiAhKGkgPCAwKSAmJiAodGhpcy5jdXJyZW50UG9pbnRlcnMuc3BsaWNlKGksIDEpLCB0aGlzLnN0YXJ0UG9pbnRlcnMuc3BsaWNlKGksIDEpLCB0aGlzLl9lbmRDYWxsYmFjayh0LCBlKSwgITApO1xuICAgICAgICB9LCB0aGlzLl9wb2ludGVyRW5kID0gdCA9PiB7XG4gICAgICAgICAgdC5idXR0b25zID4gMCAmJiAwICE9PSB0LmJ1dHRvbiB8fCB0aGlzLl90cmlnZ2VyUG9pbnRlckVuZChuZXcgbih0KSwgdCkgJiYgKHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdmUsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgICAgfSksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9wb2ludGVyRW5kLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwgdGhpcy5fdG91Y2hFbmQgPSB0ID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgQXJyYXkuZnJvbSh0LmNoYW5nZWRUb3VjaGVzIHx8IFtdKSkgdGhpcy5fdHJpZ2dlclBvaW50ZXJFbmQobmV3IG4oZSksIHQpO1xuICAgICAgICB9LCB0aGlzLl9zdGFydENhbGxiYWNrID0gZSwgdGhpcy5fbW92ZUNhbGxiYWNrID0gaSwgdGhpcy5fZW5kQ2FsbGJhY2sgPSBzLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fcG9pbnRlclN0YXJ0LCB7XG4gICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgfSksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hTdGFydCwge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fbW92ZSwge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaEVuZCksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIHRoaXMuX3RvdWNoRW5kKTtcbiAgICAgIH1cblxuICAgICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX3BvaW50ZXJTdGFydCwge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX3RvdWNoU3RhcnQsIHtcbiAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICB9KSwgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX21vdmUsIHtcbiAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICB9KSwgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fdG91Y2hFbmQpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLl90b3VjaEVuZCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdmUpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fcG9pbnRlckVuZCk7XG4gICAgICB9XG5cbiAgICAgIF90cmlnZ2VyUG9pbnRlclN0YXJ0KHQsIGUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fc3RhcnRDYWxsYmFjayh0LCBlKSAmJiAodGhpcy5jdXJyZW50UG9pbnRlcnMucHVzaCh0KSwgdGhpcy5zdGFydFBvaW50ZXJzLnB1c2godCksICEwKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGNsYXNzIGwge1xuICAgICAgY29uc3RydWN0b3IodCA9IHt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGUoITAsIHt9LCB0KSwgdGhpcy5wbHVnaW5zID0gW10sIHRoaXMuZXZlbnRzID0ge307XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIFtcIm9uXCIsIFwib25jZVwiXSkgZm9yIChjb25zdCBlIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMub3B0aW9uc1t0XSB8fCB7fSkpIHRoaXNbdF0oLi4uZSk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbih0LCBlLCAuLi5pKSB7XG4gICAgICAgIHQgPSBTdHJpbmcodCk7XG4gICAgICAgIGxldCBzID0gKG8gPSB0LCBuID0gdGhpcy5vcHRpb25zLCBvLnNwbGl0KFwiLlwiKS5yZWR1Y2UoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdCAmJiB0W2VdO1xuICAgICAgICB9LCBuKSk7XG4gICAgICAgIHZhciBvLCBuO1xuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBzICYmIChzID0gcy5jYWxsKHRoaXMsIHRoaXMsIC4uLmkpKSwgdm9pZCAwID09PSBzID8gZSA6IHM7XG4gICAgICB9XG5cbiAgICAgIGxvY2FsaXplKHQsIGUgPSBbXSkge1xuICAgICAgICByZXR1cm4gdCA9ICh0ID0gU3RyaW5nKHQpLnJlcGxhY2UoL1xce1xceyhcXHcrKS4/KFxcdyspP1xcfVxcfS9nLCAodCwgaSwgcykgPT4ge1xuICAgICAgICAgIGxldCBvID0gXCJcIjtcbiAgICAgICAgICBzID8gbyA9IHRoaXMub3B0aW9uKGAke2lbMF0gKyBpLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDEpfS5sMTBuLiR7c31gKSA6IGkgJiYgKG8gPSB0aGlzLm9wdGlvbihgbDEwbi4ke2l9YCkpLCBvIHx8IChvID0gdCk7XG5cbiAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIG8gPSBvLnNwbGl0KGVbdF1bMF0pLmpvaW4oZVt0XVsxXSk7XG5cbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSkpLnJlcGxhY2UoL1xce1xceyguKilcXH1cXH0vLCAodCwgZSkgPT4gZSk7XG4gICAgICB9XG5cbiAgICAgIG9uKGUsIGkpIHtcbiAgICAgICAgaWYgKHQoZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgT2JqZWN0LmVudHJpZXMoZSkpIHRoaXMub24oLi4udCk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTdHJpbmcoZSkuc3BsaXQoXCIgXCIpLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgY29uc3QgZSA9IHRoaXMuZXZlbnRzW3RdID0gdGhpcy5ldmVudHNbdF0gfHwgW107XG4gICAgICAgICAgLTEgPT0gZS5pbmRleE9mKGkpICYmIGUucHVzaChpKTtcbiAgICAgICAgfSksIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG9uY2UoZSwgaSkge1xuICAgICAgICBpZiAodChlKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBPYmplY3QuZW50cmllcyhlKSkgdGhpcy5vbmNlKC4uLnQpO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RyaW5nKGUpLnNwbGl0KFwiIFwiKS5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIGNvbnN0IGUgPSAoLi4ucykgPT4ge1xuICAgICAgICAgICAgdGhpcy5vZmYodCwgZSksIGkuY2FsbCh0aGlzLCB0aGlzLCAuLi5zKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZS5fID0gaSwgdGhpcy5vbih0LCBlKTtcbiAgICAgICAgfSksIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG9mZihlLCBpKSB7XG4gICAgICAgIGlmICghdChlKSkgcmV0dXJuIGUuc3BsaXQoXCIgXCIpLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgY29uc3QgZSA9IHRoaXMuZXZlbnRzW3RdO1xuICAgICAgICAgIGlmICghZSB8fCAhZS5sZW5ndGgpIHJldHVybiB0aGlzO1xuICAgICAgICAgIGxldCBzID0gLTE7XG5cbiAgICAgICAgICBmb3IgKGxldCB0ID0gMCwgbyA9IGUubGVuZ3RoOyB0IDwgbzsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBvID0gZVt0XTtcblxuICAgICAgICAgICAgaWYgKG8gJiYgKG8gPT09IGkgfHwgby5fID09PSBpKSkge1xuICAgICAgICAgICAgICBzID0gdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLTEgIT0gcyAmJiBlLnNwbGljZShzLCAxKTtcbiAgICAgICAgfSksIHRoaXM7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIE9iamVjdC5lbnRyaWVzKGUpKSB0aGlzLm9mZiguLi50KTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlcih0LCAuLi5lKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBbLi4uKHRoaXMuZXZlbnRzW3RdIHx8IFtdKV0uc2xpY2UoKSkgaWYgKGkgJiYgITEgPT09IGkuY2FsbCh0aGlzLCB0aGlzLCAuLi5lKSkgcmV0dXJuICExO1xuXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBbLi4uKHRoaXMuZXZlbnRzW1wiKlwiXSB8fCBbXSldLnNsaWNlKCkpIGlmIChpICYmICExID09PSBpLmNhbGwodGhpcywgdCwgdGhpcywgLi4uZSkpIHJldHVybiAhMTtcblxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG5cbiAgICAgIGF0dGFjaFBsdWdpbnModCkge1xuICAgICAgICBjb25zdCBpID0ge307XG5cbiAgICAgICAgZm9yIChjb25zdCBbcywgb10gb2YgT2JqZWN0LmVudHJpZXModCB8fCB7fSkpICExID09PSB0aGlzLm9wdGlvbnNbc10gfHwgdGhpcy5wbHVnaW5zW3NdIHx8ICh0aGlzLm9wdGlvbnNbc10gPSBlKHt9LCBvLmRlZmF1bHRzIHx8IHt9LCB0aGlzLm9wdGlvbnNbc10pLCBpW3NdID0gbmV3IG8odGhpcykpO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3QsIGVdIG9mIE9iamVjdC5lbnRyaWVzKGkpKSBlLmF0dGFjaCh0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wbHVnaW5zLCBpKSwgdGhpcztcbiAgICAgIH1cblxuICAgICAgZGV0YWNoUGx1Z2lucygpIHtcbiAgICAgICAgZm9yIChjb25zdCB0IGluIHRoaXMucGx1Z2lucykge1xuICAgICAgICAgIGxldCBlO1xuICAgICAgICAgIChlID0gdGhpcy5wbHVnaW5zW3RdKSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUuZGV0YWNoICYmIGUuZGV0YWNoKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2lucyA9IHt9LCB0aGlzO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29uc3QgYyA9IHtcbiAgICAgIHRvdWNoOiAhMCxcbiAgICAgIHpvb206ICEwLFxuICAgICAgcGluY2hUb1pvb206ICEwLFxuICAgICAgcGFuT25seVpvb21lZDogITEsXG4gICAgICBsb2NrQXhpczogITEsXG4gICAgICBmcmljdGlvbjogLjY0LFxuICAgICAgZGVjZWxGcmljdGlvbjogLjg4LFxuICAgICAgem9vbUZyaWN0aW9uOiAuNzQsXG4gICAgICBib3VuY2VGb3JjZTogLjIsXG4gICAgICBiYXNlU2NhbGU6IDEsXG4gICAgICBtaW5TY2FsZTogMSxcbiAgICAgIG1heFNjYWxlOiAyLFxuICAgICAgc3RlcDogLjUsXG4gICAgICB0ZXh0U2VsZWN0aW9uOiAhMSxcbiAgICAgIGNsaWNrOiBcInRvZ2dsZVpvb21cIixcbiAgICAgIHdoZWVsOiBcInpvb21cIixcbiAgICAgIHdoZWVsRmFjdG9yOiA0MixcbiAgICAgIHdoZWVsTGltaXQ6IDUsXG4gICAgICBkcmFnZ2FibGVDbGFzczogXCJpcy1kcmFnZ2FibGVcIixcbiAgICAgIGRyYWdnaW5nQ2xhc3M6IFwiaXMtZHJhZ2dpbmdcIixcbiAgICAgIHJhdGlvOiAxXG4gICAgfTtcblxuICAgIGNsYXNzIGQgZXh0ZW5kcyBsIHtcbiAgICAgIGNvbnN0cnVjdG9yKHQsIGkgPSB7fSkge1xuICAgICAgICBzdXBlcihlKCEwLCB7fSwgYywgaSkpLCB0aGlzLnN0YXRlID0gXCJpbml0XCIsIHRoaXMuJGNvbnRhaW5lciA9IHQ7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIFtcIm9uTG9hZFwiLCBcIm9uV2hlZWxcIiwgXCJvbkNsaWNrXCJdKSB0aGlzW3RdID0gdGhpc1t0XS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuaW5pdExheW91dCgpLCB0aGlzLnJlc2V0VmFsdWVzKCksIHRoaXMuYXR0YWNoUGx1Z2lucyhkLlBsdWdpbnMpLCB0aGlzLnRyaWdnZXIoXCJpbml0XCIpLCB0aGlzLnVwZGF0ZU1ldHJpY3MoKSwgdGhpcy5hdHRhY2hFdmVudHMoKSwgdGhpcy50cmlnZ2VyKFwicmVhZHlcIiksICExID09PSB0aGlzLm9wdGlvbihcImNlbnRlck9uU3RhcnRcIikgPyB0aGlzLnN0YXRlID0gXCJyZWFkeVwiIDogdGhpcy5wYW5Ubyh7XG4gICAgICAgICAgZnJpY3Rpb246IDBcbiAgICAgICAgfSksIHQuX19QYW56b29tID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaW5pdExheW91dCgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuJGNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCEodCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgdGhyb3cgbmV3IEVycm9yKFwiUGFuem9vbTogQ29udGFpbmVyIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMub3B0aW9uKFwiY29udGVudFwiKSB8fCB0LnF1ZXJ5U2VsZWN0b3IoXCIucGFuem9vbV9fY29udGVudFwiKTtcbiAgICAgICAgaWYgKCFlKSB0aHJvdyBuZXcgRXJyb3IoXCJQYW56b29tOiBDb250ZW50IG5vdCBmb3VuZFwiKTtcbiAgICAgICAgdGhpcy4kY29udGVudCA9IGU7XG4gICAgICAgIGxldCBpID0gdGhpcy5vcHRpb24oXCJ2aWV3cG9ydFwiKSB8fCB0LnF1ZXJ5U2VsZWN0b3IoXCIucGFuem9vbV9fdmlld3BvcnRcIik7XG4gICAgICAgIGkgfHwgITEgPT09IHRoaXMub3B0aW9uKFwid3JhcElubmVyXCIpIHx8IChpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgaS5jbGFzc0xpc3QuYWRkKFwicGFuem9vbV9fdmlld3BvcnRcIiksIGkuYXBwZW5kKC4uLnQuY2hpbGROb2RlcyksIHQuYXBwZW5kQ2hpbGQoaSkpLCB0aGlzLiR2aWV3cG9ydCA9IGkgfHwgZS5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICByZXNldFZhbHVlcygpIHtcbiAgICAgICAgdGhpcy51cGRhdGVSYXRlID0gdGhpcy5vcHRpb24oXCJ1cGRhdGVSYXRlXCIsIC9pUGhvbmV8aVBhZHxpUG9kfEFuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpID8gMjUwIDogMjQpLCB0aGlzLmNvbnRhaW5lciA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSwgdGhpcy52aWV3cG9ydCA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSwgdGhpcy5jb250ZW50ID0ge1xuICAgICAgICAgIG9yaWdXaWR0aDogMCxcbiAgICAgICAgICBvcmlnSGVpZ2h0OiAwLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICB4OiB0aGlzLm9wdGlvbihcInhcIiwgMCksXG4gICAgICAgICAgeTogdGhpcy5vcHRpb24oXCJ5XCIsIDApLFxuICAgICAgICAgIHNjYWxlOiB0aGlzLm9wdGlvbihcImJhc2VTY2FsZVwiKVxuICAgICAgICB9LCB0aGlzLnRyYW5zZm9ybSA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgc2NhbGU6IDFcbiAgICAgICAgfSwgdGhpcy5yZXNldERyYWdQb3NpdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBvbkxvYWQodCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1ldHJpY3MoKSwgdGhpcy5wYW5Ubyh7XG4gICAgICAgICAgc2NhbGU6IHRoaXMub3B0aW9uKFwiYmFzZVNjYWxlXCIpLFxuICAgICAgICAgIGZyaWN0aW9uOiAwXG4gICAgICAgIH0pLCB0aGlzLnRyaWdnZXIoXCJsb2FkXCIsIHQpO1xuICAgICAgfVxuXG4gICAgICBvbkNsaWNrKHQpIHtcbiAgICAgICAgaWYgKHQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsb3Nlc3QoXCJbY29udGVudGVkaXRhYmxlXVwiKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5vcHRpb24oXCJ0ZXh0U2VsZWN0aW9uXCIpICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpLmxlbmd0aCAmJiAoIXQudGFyZ2V0IHx8ICF0LnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWZhbmN5Ym94LWNsb3NlXCIpKSkgcmV0dXJuIHZvaWQgdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuJGNvbnRlbnQuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgICAgaWYgKFwicmVhZHlcIiAhPT0gdGhpcy5zdGF0ZSAmJiAodGhpcy5kcmFnUG9zaXRpb24ubWlkUG9pbnQgfHwgTWF0aC5hYnMoZS50b3AgLSB0aGlzLmRyYWdTdGFydC5yZWN0LnRvcCkgPiAxIHx8IE1hdGguYWJzKGUubGVmdCAtIHRoaXMuZHJhZ1N0YXJ0LnJlY3QubGVmdCkgPiAxKSkgcmV0dXJuIHQucHJldmVudERlZmF1bHQoKSwgdm9pZCB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAhMSAhPT0gdGhpcy50cmlnZ2VyKFwiY2xpY2tcIiwgdCkgJiYgdGhpcy5vcHRpb24oXCJ6b29tXCIpICYmIFwidG9nZ2xlWm9vbVwiID09PSB0aGlzLm9wdGlvbihcImNsaWNrXCIpICYmICh0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCksIHRoaXMuem9vbVdpdGhDbGljayh0KSk7XG4gICAgICB9XG5cbiAgICAgIG9uV2hlZWwodCkge1xuICAgICAgICAhMSAhPT0gdGhpcy50cmlnZ2VyKFwid2hlZWxcIiwgdCkgJiYgdGhpcy5vcHRpb24oXCJ6b29tXCIpICYmIHRoaXMub3B0aW9uKFwid2hlZWxcIikgJiYgdGhpcy56b29tV2l0aFdoZWVsKHQpO1xuICAgICAgfVxuXG4gICAgICB6b29tV2l0aFdoZWVsKHQpIHtcbiAgICAgICAgdm9pZCAwID09PSB0aGlzLmNoYW5nZWREZWx0YSAmJiAodGhpcy5jaGFuZ2VkRGVsdGEgPSAwKTtcbiAgICAgICAgY29uc3QgZSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCAtdC5kZWx0YVkgfHwgLXQuZGVsdGFYIHx8IHQud2hlZWxEZWx0YSB8fCAtdC5kZXRhaWwpKSxcbiAgICAgICAgICAgICAgaSA9IHRoaXMuY29udGVudC5zY2FsZTtcbiAgICAgICAgbGV0IHMgPSBpICogKDEwMCArIGUgKiB0aGlzLm9wdGlvbihcIndoZWVsRmFjdG9yXCIpKSAvIDEwMDtcbiAgICAgICAgaWYgKGUgPCAwICYmIE1hdGguYWJzKGkgLSB0aGlzLm9wdGlvbihcIm1pblNjYWxlXCIpKSA8IC4wMSB8fCBlID4gMCAmJiBNYXRoLmFicyhpIC0gdGhpcy5vcHRpb24oXCJtYXhTY2FsZVwiKSkgPCAuMDEgPyAodGhpcy5jaGFuZ2VkRGVsdGEgKz0gTWF0aC5hYnMoZSksIHMgPSBpKSA6ICh0aGlzLmNoYW5nZWREZWx0YSA9IDAsIHMgPSBNYXRoLm1heChNYXRoLm1pbihzLCB0aGlzLm9wdGlvbihcIm1heFNjYWxlXCIpKSwgdGhpcy5vcHRpb24oXCJtaW5TY2FsZVwiKSkpLCB0aGlzLmNoYW5nZWREZWx0YSA+IHRoaXMub3B0aW9uKFwid2hlZWxMaW1pdFwiKSkgcmV0dXJuO1xuICAgICAgICBpZiAodC5wcmV2ZW50RGVmYXVsdCgpLCBzID09PSBpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLiRjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICBuID0gdC5jbGllbnRYIC0gby5sZWZ0LFxuICAgICAgICAgICAgICBhID0gdC5jbGllbnRZIC0gby50b3A7XG4gICAgICAgIHRoaXMuem9vbVRvKHMsIHtcbiAgICAgICAgICB4OiBuLFxuICAgICAgICAgIHk6IGFcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHpvb21XaXRoQ2xpY2sodCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy4kY29udGVudC5nZXRDbGllbnRSZWN0cygpWzBdLFxuICAgICAgICAgICAgICBpID0gdC5jbGllbnRYIC0gZS5sZWZ0LFxuICAgICAgICAgICAgICBzID0gdC5jbGllbnRZIC0gZS50b3A7XG4gICAgICAgIHRoaXMudG9nZ2xlWm9vbSh7XG4gICAgICAgICAgeDogaSxcbiAgICAgICAgICB5OiBzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuJGNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5vbkxvYWQpLCB0aGlzLiRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0aGlzLiRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25DbGljaywge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0aGlzLmluaXRPYnNlcnZlcigpO1xuICAgICAgICBjb25zdCB0ID0gbmV3IGgodGhpcy4kY29udGFpbmVyLCB7XG4gICAgICAgICAgc3RhcnQ6IChlLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uKFwidG91Y2hcIikpIHJldHVybiAhMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZlbG9jaXR5LnNjYWxlIDwgMCkgcmV0dXJuICExO1xuICAgICAgICAgICAgY29uc3QgbyA9IGkuY29tcG9zZWRQYXRoKClbMF07XG5cbiAgICAgICAgICAgIGlmICghdC5jdXJyZW50UG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmICgtMSAhPT0gW1wiQlVUVE9OXCIsIFwiVEVYVEFSRUFcIiwgXCJPUFRJT05cIiwgXCJJTlBVVFwiLCBcIlNFTEVDVFwiLCBcIlZJREVPXCJdLmluZGV4T2Yoby5ub2RlTmFtZSkpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uKFwidGV4dFNlbGVjdGlvblwiKSAmJiAoKHQsIGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gdC5jaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgIG8gPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuID0gc1t0XTtcbiAgICAgICAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBvLnNlbGVjdE5vZGVDb250ZW50cyhuKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGUgPj0gYS5sZWZ0ICYmIGkgPj0gYS50b3AgJiYgZSA8PSBhLnJpZ2h0ICYmIGkgPD0gYS5ib3R0b20pIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgfSkobywgZS5jbGllbnRYLCBlLmNsaWVudFkpKSByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAhcyhvKSAmJiAhMSAhPT0gdGhpcy50cmlnZ2VyKFwidG91Y2hTdGFydFwiLCBpKSAmJiAoXCJtb3VzZWRvd25cIiA9PT0gaS50eXBlICYmIGkucHJldmVudERlZmF1bHQoKSwgdGhpcy5zdGF0ZSA9IFwicG9pbnRlcmRvd25cIiwgdGhpcy5yZXNldERyYWdQb3NpdGlvbigpLCB0aGlzLmRyYWdQb3NpdGlvbi5taWRQb2ludCA9IG51bGwsIHRoaXMuZHJhZ1Bvc2l0aW9uLnRpbWUgPSBEYXRlLm5vdygpLCAhMCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb3ZlOiAoZSwgaSwgcykgPT4ge1xuICAgICAgICAgICAgaWYgKFwicG9pbnRlcmRvd25cIiAhPT0gdGhpcy5zdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCExID09PSB0aGlzLnRyaWdnZXIoXCJ0b3VjaE1vdmVcIiwgcykpIHJldHVybiB2b2lkIHMucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChpLmxlbmd0aCA8IDIgJiYgITAgPT09IHRoaXMub3B0aW9uKFwicGFuT25seVpvb21lZFwiKSAmJiB0aGlzLmNvbnRlbnQud2lkdGggPD0gdGhpcy52aWV3cG9ydC53aWR0aCAmJiB0aGlzLmNvbnRlbnQuaGVpZ2h0IDw9IHRoaXMudmlld3BvcnQuaGVpZ2h0ICYmIHRoaXMudHJhbnNmb3JtLnNjYWxlIDw9IHRoaXMub3B0aW9uKFwiYmFzZVNjYWxlXCIpKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoaS5sZW5ndGggPiAxICYmICghdGhpcy5vcHRpb24oXCJ6b29tXCIpIHx8ICExID09PSB0aGlzLm9wdGlvbihcInBpbmNoVG9ab29tXCIpKSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgbyA9IHIoZVswXSwgZVsxXSksXG4gICAgICAgICAgICAgICAgICBuID0gcihpWzBdLCBpWzFdKSxcbiAgICAgICAgICAgICAgICAgIGggPSBuLmNsaWVudFggLSBvLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICBsID0gbi5jbGllbnRZIC0gby5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgYyA9IGEoZVswXSwgZVsxXSksXG4gICAgICAgICAgICAgICAgICBkID0gYShpWzBdLCBpWzFdKSxcbiAgICAgICAgICAgICAgICAgIHUgPSBjICYmIGQgPyBkIC8gYyA6IDE7XG4gICAgICAgICAgICB0aGlzLmRyYWdPZmZzZXQueCArPSBoLCB0aGlzLmRyYWdPZmZzZXQueSArPSBsLCB0aGlzLmRyYWdPZmZzZXQuc2NhbGUgKj0gdSwgdGhpcy5kcmFnT2Zmc2V0LnRpbWUgPSBEYXRlLm5vdygpIC0gdGhpcy5kcmFnUG9zaXRpb24udGltZTtcbiAgICAgICAgICAgIGNvbnN0IGYgPSAxID09PSB0aGlzLmRyYWdTdGFydC5zY2FsZSAmJiB0aGlzLm9wdGlvbihcImxvY2tBeGlzXCIpO1xuXG4gICAgICAgICAgICBpZiAoZiAmJiAhdGhpcy5sb2NrQXhpcykge1xuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5kcmFnT2Zmc2V0LngpIDwgNiAmJiBNYXRoLmFicyh0aGlzLmRyYWdPZmZzZXQueSkgPCA2KSByZXR1cm4gdm9pZCBzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygxODAgKiBNYXRoLmF0YW4yKHRoaXMuZHJhZ09mZnNldC55LCB0aGlzLmRyYWdPZmZzZXQueCkgLyBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgdGhpcy5sb2NrQXhpcyA9IHQgPiA0NSAmJiB0IDwgMTM1ID8gXCJ5XCIgOiBcInhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFwieHlcIiA9PT0gZiB8fCBcInlcIiAhPT0gdGhpcy5sb2NrQXhpcykge1xuICAgICAgICAgICAgICBpZiAocy5wcmV2ZW50RGVmYXVsdCgpLCBzLnN0b3BQcm9wYWdhdGlvbigpLCBzLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCB0aGlzLmxvY2tBeGlzICYmICh0aGlzLmRyYWdPZmZzZXRbXCJ4XCIgPT09IHRoaXMubG9ja0F4aXMgPyBcInlcIiA6IFwieFwiXSA9IDApLCB0aGlzLiRjb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbihcImRyYWdnaW5nQ2xhc3NcIikpLCB0aGlzLnRyYW5zZm9ybS5zY2FsZSA9PT0gdGhpcy5vcHRpb24oXCJiYXNlU2NhbGVcIikgJiYgXCJ5XCIgPT09IHRoaXMubG9ja0F4aXMgfHwgKHRoaXMuZHJhZ1Bvc2l0aW9uLnggPSB0aGlzLmRyYWdTdGFydC54ICsgdGhpcy5kcmFnT2Zmc2V0LngpLCB0aGlzLnRyYW5zZm9ybS5zY2FsZSA9PT0gdGhpcy5vcHRpb24oXCJiYXNlU2NhbGVcIikgJiYgXCJ4XCIgPT09IHRoaXMubG9ja0F4aXMgfHwgKHRoaXMuZHJhZ1Bvc2l0aW9uLnkgPSB0aGlzLmRyYWdTdGFydC55ICsgdGhpcy5kcmFnT2Zmc2V0LnkpLCB0aGlzLmRyYWdQb3NpdGlvbi5zY2FsZSA9IHRoaXMuZHJhZ1N0YXJ0LnNjYWxlICogdGhpcy5kcmFnT2Zmc2V0LnNjYWxlLCBpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gcih0LnN0YXJ0UG9pbnRlcnNbMF0sIHQuc3RhcnRQb2ludGVyc1sxXSksXG4gICAgICAgICAgICAgICAgICAgICAgaSA9IGUuY2xpZW50WCAtIHRoaXMuZHJhZ1N0YXJ0LnJlY3QueCxcbiAgICAgICAgICAgICAgICAgICAgICBzID0gZS5jbGllbnRZIC0gdGhpcy5kcmFnU3RhcnQucmVjdC55LFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGRlbHRhWDogbyxcbiAgICAgICAgICAgICAgICAgIGRlbHRhWTogYVxuICAgICAgICAgICAgICAgIH0gPSB0aGlzLmdldFpvb21EZWx0YSh0aGlzLmNvbnRlbnQuc2NhbGUgKiB0aGlzLmRyYWdPZmZzZXQuc2NhbGUsIGksIHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uLnggLT0gbywgdGhpcy5kcmFnUG9zaXRpb24ueSAtPSBhLCB0aGlzLmRyYWdQb3NpdGlvbi5taWRQb2ludCA9IG47XG4gICAgICAgICAgICAgIH0gZWxzZSB0aGlzLnNldERyYWdSZXNpc3RhbmNlKCk7XG5cbiAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5kcmFnUG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmRyYWdQb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgIHNjYWxlOiB0aGlzLmRyYWdQb3NpdGlvbi5zY2FsZVxuICAgICAgICAgICAgICB9LCB0aGlzLnN0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IChlLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJwb2ludGVyZG93blwiICE9PSB0aGlzLnN0YXRlKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ09mZnNldCA9IHsgLi4udGhpcy5kcmFnT2Zmc2V0XG4gICAgICAgICAgICB9LCB0LmN1cnJlbnRQb2ludGVycy5sZW5ndGgpIHJldHVybiB2b2lkIHRoaXMucmVzZXREcmFnUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID0gXCJkZWNlbFwiLCB0aGlzLmZyaWN0aW9uID0gdGhpcy5vcHRpb24oXCJkZWNlbEZyaWN0aW9uXCIpLCB0aGlzLnJlY2FsY3VsYXRlVHJhbnNmb3JtKCksIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9uKFwiZHJhZ2dpbmdDbGFzc1wiKSksICExID09PSB0aGlzLnRyaWdnZXIoXCJ0b3VjaEVuZFwiLCBpKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKFwiZGVjZWxcIiAhPT0gdGhpcy5zdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMub3B0aW9uKFwibWluU2NhbGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0uc2NhbGUgPCBzKSByZXR1cm4gdm9pZCB0aGlzLnpvb21UbyhzLCB7XG4gICAgICAgICAgICAgIGZyaWN0aW9uOiAuNjRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbyA9IHRoaXMub3B0aW9uKFwibWF4U2NhbGVcIik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS5zY2FsZSAtIG8gPiAuMDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuZHJhZ1Bvc2l0aW9uLm1pZFBvaW50IHx8IGUsXG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLiRjb250ZW50LmdldENsaWVudFJlY3RzKClbMF07XG4gICAgICAgICAgICAgIHRoaXMuem9vbVRvKG8sIHtcbiAgICAgICAgICAgICAgICBmcmljdGlvbjogLjY0LFxuICAgICAgICAgICAgICAgIHg6IHQuY2xpZW50WCAtIGkubGVmdCxcbiAgICAgICAgICAgICAgICB5OiB0LmNsaWVudFkgLSBpLnRvcFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvaW50ZXJUcmFja2VyID0gdDtcbiAgICAgIH1cblxuICAgICAgaW5pdE9ic2VydmVyKCkge1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyIHx8ICh0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IG8oKCkgPT4ge1xuICAgICAgICAgIHRoaXMudXBkYXRlVGltZXIgfHwgKHRoaXMudXBkYXRlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLiRjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0LndpZHRoICYmIHQuaGVpZ2h0ID8gKChNYXRoLmFicyh0LndpZHRoIC0gdGhpcy5jb250YWluZXIud2lkdGgpID4gMSB8fCBNYXRoLmFicyh0LmhlaWdodCAtIHRoaXMuY29udGFpbmVyLmhlaWdodCkgPiAxKSAmJiAodGhpcy5pc0FuaW1hdGluZygpICYmIHRoaXMuZW5kQW5pbWF0aW9uKCEwKSwgdGhpcy51cGRhdGVNZXRyaWNzKCksIHRoaXMucGFuVG8oe1xuICAgICAgICAgICAgICB4OiB0aGlzLmNvbnRlbnQueCxcbiAgICAgICAgICAgICAgeTogdGhpcy5jb250ZW50LnksXG4gICAgICAgICAgICAgIHNjYWxlOiB0aGlzLm9wdGlvbihcImJhc2VTY2FsZVwiKSxcbiAgICAgICAgICAgICAgZnJpY3Rpb246IDBcbiAgICAgICAgICAgIH0pKSwgdGhpcy51cGRhdGVUaW1lciA9IG51bGwpIDogdGhpcy51cGRhdGVUaW1lciA9IG51bGw7XG4gICAgICAgICAgfSwgdGhpcy51cGRhdGVSYXRlKSk7XG4gICAgICAgIH0pLCB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy4kY29udGFpbmVyKSk7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0RHJhZ1Bvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLmxvY2tBeGlzID0gbnVsbCwgdGhpcy5mcmljdGlvbiA9IHRoaXMub3B0aW9uKFwiZnJpY3Rpb25cIiksIHRoaXMudmVsb2NpdHkgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHNjYWxlOiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB4OiB0LFxuICAgICAgICAgIHk6IGUsXG4gICAgICAgICAgc2NhbGU6IGlcbiAgICAgICAgfSA9IHRoaXMuY29udGVudDtcbiAgICAgICAgdGhpcy5kcmFnU3RhcnQgPSB7XG4gICAgICAgICAgcmVjdDogdGhpcy4kY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICB4OiB0LFxuICAgICAgICAgIHk6IGUsXG4gICAgICAgICAgc2NhbGU6IGlcbiAgICAgICAgfSwgdGhpcy5kcmFnUG9zaXRpb24gPSB7IC4uLnRoaXMuZHJhZ1Bvc2l0aW9uLFxuICAgICAgICAgIHg6IHQsXG4gICAgICAgICAgeTogZSxcbiAgICAgICAgICBzY2FsZTogaVxuICAgICAgICB9LCB0aGlzLmRyYWdPZmZzZXQgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHNjYWxlOiAxLFxuICAgICAgICAgIHRpbWU6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlTWV0cmljcyh0KSB7XG4gICAgICAgICEwICE9PSB0ICYmIHRoaXMudHJpZ2dlcihcImJlZm9yZVVwZGF0ZVwiKTtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuJGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgcyA9IHRoaXMuJGNvbnRlbnQsXG4gICAgICAgICAgICAgIG8gPSB0aGlzLiR2aWV3cG9ydCxcbiAgICAgICAgICAgICAgbiA9IHMgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50LFxuICAgICAgICAgICAgICBhID0gdGhpcy5vcHRpb24oXCJ6b29tXCIpLFxuICAgICAgICAgICAgICByID0gdGhpcy5vcHRpb24oXCJyZXNpemVQYXJlbnRcIiwgYSk7XG4gICAgICAgIGxldCBoID0gdGhpcy5vcHRpb24oXCJ3aWR0aFwiKSxcbiAgICAgICAgICAgIGwgPSB0aGlzLm9wdGlvbihcImhlaWdodFwiKSxcbiAgICAgICAgICAgIGMgPSBoIHx8IChkID0gcywgTWF0aC5tYXgocGFyc2VGbG9hdChkLm5hdHVyYWxXaWR0aCB8fCAwKSwgcGFyc2VGbG9hdChkLndpZHRoICYmIGQud2lkdGguYmFzZVZhbCAmJiBkLndpZHRoLmJhc2VWYWwudmFsdWUgfHwgMCksIHBhcnNlRmxvYXQoZC5vZmZzZXRXaWR0aCB8fCAwKSwgcGFyc2VGbG9hdChkLnNjcm9sbFdpZHRoIHx8IDApKSk7XG4gICAgICAgIHZhciBkO1xuXG4gICAgICAgIGxldCB1ID0gbCB8fCAodCA9PiBNYXRoLm1heChwYXJzZUZsb2F0KHQubmF0dXJhbEhlaWdodCB8fCAwKSwgcGFyc2VGbG9hdCh0LmhlaWdodCAmJiB0LmhlaWdodC5iYXNlVmFsICYmIHQuaGVpZ2h0LmJhc2VWYWwudmFsdWUgfHwgMCksIHBhcnNlRmxvYXQodC5vZmZzZXRIZWlnaHQgfHwgMCksIHBhcnNlRmxvYXQodC5zY3JvbGxIZWlnaHQgfHwgMCkpKShzKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHMuc3R5bGUsIHtcbiAgICAgICAgICB3aWR0aDogaCA/IGAke2h9cHhgIDogXCJcIixcbiAgICAgICAgICBoZWlnaHQ6IGwgPyBgJHtsfXB4YCA6IFwiXCIsXG4gICAgICAgICAgbWF4V2lkdGg6IFwiXCIsXG4gICAgICAgICAgbWF4SGVpZ2h0OiBcIlwiXG4gICAgICAgIH0pLCByICYmIE9iamVjdC5hc3NpZ24oby5zdHlsZSwge1xuICAgICAgICAgIHdpZHRoOiBcIlwiLFxuICAgICAgICAgIGhlaWdodDogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZiA9IHRoaXMub3B0aW9uKFwicmF0aW9cIik7XG4gICAgICAgIGMgPSBpKGMgKiBmKSwgdSA9IGkodSAqIGYpLCBoID0gYywgbCA9IHU7XG4gICAgICAgIGNvbnN0IGcgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICBwID0gby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgbSA9IG8gPT0gZSA/IHAgOiBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgeSA9IE1hdGgubWF4KG8ub2Zmc2V0V2lkdGgsIGkocC53aWR0aCkpLFxuICAgICAgICAgICAgdiA9IE1hdGgubWF4KG8ub2Zmc2V0SGVpZ2h0LCBpKHAuaGVpZ2h0KSksXG4gICAgICAgICAgICBiID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobyk7XG5cbiAgICAgICAgaWYgKHkgLT0gcGFyc2VGbG9hdChiLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoYi5wYWRkaW5nUmlnaHQpLCB2IC09IHBhcnNlRmxvYXQoYi5wYWRkaW5nVG9wKSArIHBhcnNlRmxvYXQoYi5wYWRkaW5nQm90dG9tKSwgdGhpcy52aWV3cG9ydC53aWR0aCA9IHksIHRoaXMudmlld3BvcnQuaGVpZ2h0ID0gdiwgYSkge1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjIC0gZy53aWR0aCkgPiAuMSB8fCBNYXRoLmFicyh1IC0gZy5oZWlnaHQpID4gLjEpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAoKHQsIGUsIGksIHMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbyA9IE1hdGgubWluKGkgLyB0IHx8IDAsIHMgLyBlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdCAqIG8gfHwgMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGUgKiBvIHx8IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKGMsIHUsIE1hdGgubWluKGMsIGcud2lkdGgpLCBNYXRoLm1pbih1LCBnLmhlaWdodCkpO1xuXG4gICAgICAgICAgICBoID0gaSh0LndpZHRoKSwgbCA9IGkodC5oZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocy5zdHlsZSwge1xuICAgICAgICAgICAgd2lkdGg6IGAke2h9cHhgLFxuICAgICAgICAgICAgaGVpZ2h0OiBgJHtsfXB4YCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIgJiYgKE9iamVjdC5hc3NpZ24oby5zdHlsZSwge1xuICAgICAgICAgIHdpZHRoOiBgJHtofXB4YCxcbiAgICAgICAgICBoZWlnaHQ6IGAke2x9cHhgXG4gICAgICAgIH0pLCB0aGlzLnZpZXdwb3J0ID0geyAuLi50aGlzLnZpZXdwb3J0LFxuICAgICAgICAgIHdpZHRoOiBoLFxuICAgICAgICAgIGhlaWdodDogbFxuICAgICAgICB9KSwgbiAmJiBhICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdGhpcy5vcHRpb25zLm1heFNjYWxlKSB7XG4gICAgICAgICAgY29uc3QgdCA9IHRoaXMub3B0aW9uKFwibWF4U2NhbGVcIik7XG5cbiAgICAgICAgICB0aGlzLm9wdGlvbnMubWF4U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lm9yaWdXaWR0aCA+IDAgJiYgdGhpcy5jb250ZW50LmZpdFdpZHRoID4gMCA/IHRoaXMuY29udGVudC5vcmlnV2lkdGggLyB0aGlzLmNvbnRlbnQuZml0V2lkdGggOiB0O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnRlbnQgPSB7IC4uLnRoaXMuY29udGVudCxcbiAgICAgICAgICBvcmlnV2lkdGg6IGMsXG4gICAgICAgICAgb3JpZ0hlaWdodDogdSxcbiAgICAgICAgICBmaXRXaWR0aDogaCxcbiAgICAgICAgICBmaXRIZWlnaHQ6IGwsXG4gICAgICAgICAgd2lkdGg6IGgsXG4gICAgICAgICAgaGVpZ2h0OiBsLFxuICAgICAgICAgIHNjYWxlOiAxLFxuICAgICAgICAgIGlzWm9vbWFibGU6IGFcbiAgICAgICAgfSwgdGhpcy5jb250YWluZXIgPSB7XG4gICAgICAgICAgd2lkdGg6IG0ud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBtLmhlaWdodFxuICAgICAgICB9LCAhMCAhPT0gdCAmJiB0aGlzLnRyaWdnZXIoXCJhZnRlclVwZGF0ZVwiKTtcbiAgICAgIH1cblxuICAgICAgem9vbUluKHQpIHtcbiAgICAgICAgdGhpcy56b29tVG8odGhpcy5jb250ZW50LnNjYWxlICsgKHQgfHwgdGhpcy5vcHRpb24oXCJzdGVwXCIpKSk7XG4gICAgICB9XG5cbiAgICAgIHpvb21PdXQodCkge1xuICAgICAgICB0aGlzLnpvb21Ubyh0aGlzLmNvbnRlbnQuc2NhbGUgLSAodCB8fCB0aGlzLm9wdGlvbihcInN0ZXBcIikpKTtcbiAgICAgIH1cblxuICAgICAgdG9nZ2xlWm9vbSh0ID0ge30pIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMub3B0aW9uKFwibWF4U2NhbGVcIiksXG4gICAgICAgICAgICAgIGkgPSB0aGlzLm9wdGlvbihcImJhc2VTY2FsZVwiKSxcbiAgICAgICAgICAgICAgcyA9IHRoaXMuY29udGVudC5zY2FsZSA+IGkgKyAuNSAqIChlIC0gaSkgPyBpIDogZTtcbiAgICAgICAgdGhpcy56b29tVG8ocywgdCk7XG4gICAgICB9XG5cbiAgICAgIHpvb21Ubyh0ID0gdGhpcy5vcHRpb24oXCJiYXNlU2NhbGVcIiksIHtcbiAgICAgICAgeDogZSA9IG51bGwsXG4gICAgICAgIHk6IHMgPSBudWxsXG4gICAgICB9ID0ge30pIHtcbiAgICAgICAgdCA9IE1hdGgubWF4KE1hdGgubWluKHQsIHRoaXMub3B0aW9uKFwibWF4U2NhbGVcIikpLCB0aGlzLm9wdGlvbihcIm1pblNjYWxlXCIpKTtcbiAgICAgICAgY29uc3QgbyA9IGkodGhpcy5jb250ZW50LnNjYWxlIC8gKHRoaXMuY29udGVudC53aWR0aCAvIHRoaXMuY29udGVudC5maXRXaWR0aCksIDFlNyk7XG4gICAgICAgIG51bGwgPT09IGUgJiYgKGUgPSB0aGlzLmNvbnRlbnQud2lkdGggKiBvICogLjUpLCBudWxsID09PSBzICYmIChzID0gdGhpcy5jb250ZW50LmhlaWdodCAqIG8gKiAuNSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkZWx0YVg6IG4sXG4gICAgICAgICAgZGVsdGFZOiBhXG4gICAgICAgIH0gPSB0aGlzLmdldFpvb21EZWx0YSh0LCBlLCBzKTtcbiAgICAgICAgZSA9IHRoaXMuY29udGVudC54IC0gbiwgcyA9IHRoaXMuY29udGVudC55IC0gYSwgdGhpcy5wYW5Ubyh7XG4gICAgICAgICAgeDogZSxcbiAgICAgICAgICB5OiBzLFxuICAgICAgICAgIHNjYWxlOiB0LFxuICAgICAgICAgIGZyaWN0aW9uOiB0aGlzLm9wdGlvbihcInpvb21GcmljdGlvblwiKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0Wm9vbURlbHRhKHQsIGUgPSAwLCBpID0gMCkge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5jb250ZW50LmZpdFdpZHRoICogdGhpcy5jb250ZW50LnNjYWxlLFxuICAgICAgICAgICAgICBvID0gdGhpcy5jb250ZW50LmZpdEhlaWdodCAqIHRoaXMuY29udGVudC5zY2FsZSxcbiAgICAgICAgICAgICAgbiA9IGUgPiAwICYmIHMgPyBlIC8gcyA6IDAsXG4gICAgICAgICAgICAgIGEgPSBpID4gMCAmJiBvID8gaSAvIG8gOiAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlbHRhWDogKHRoaXMuY29udGVudC5maXRXaWR0aCAqIHQgLSBzKSAqIG4sXG4gICAgICAgICAgZGVsdGFZOiAodGhpcy5jb250ZW50LmZpdEhlaWdodCAqIHQgLSBvKSAqIGFcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcGFuVG8oe1xuICAgICAgICB4OiB0ID0gdGhpcy5jb250ZW50LngsXG4gICAgICAgIHk6IGUgPSB0aGlzLmNvbnRlbnQueSxcbiAgICAgICAgc2NhbGU6IGksXG4gICAgICAgIGZyaWN0aW9uOiBzID0gdGhpcy5vcHRpb24oXCJmcmljdGlvblwiKSxcbiAgICAgICAgaWdub3JlQm91bmRzOiBvID0gITFcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICBpZiAoaSA9IGkgfHwgdGhpcy5jb250ZW50LnNjYWxlIHx8IDEsICFvKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYm91bmRYOiBzLFxuICAgICAgICAgICAgYm91bmRZOiBvXG4gICAgICAgICAgfSA9IHRoaXMuZ2V0Qm91bmRzKGkpO1xuICAgICAgICAgIHMgJiYgKHQgPSBNYXRoLm1heChNYXRoLm1pbih0LCBzLnRvKSwgcy5mcm9tKSksIG8gJiYgKGUgPSBNYXRoLm1heChNYXRoLm1pbihlLCBvLnRvKSwgby5mcm9tKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyaWN0aW9uID0gcywgdGhpcy50cmFuc2Zvcm0gPSB7IC4uLnRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgIHg6IHQsXG4gICAgICAgICAgeTogZSxcbiAgICAgICAgICBzY2FsZTogaVxuICAgICAgICB9LCBzID8gKHRoaXMuc3RhdGUgPSBcInBhbm5pbmdcIiwgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgICAgICB4OiAoMSAvIHRoaXMuZnJpY3Rpb24gLSAxKSAqICh0IC0gdGhpcy5jb250ZW50LngpLFxuICAgICAgICAgIHk6ICgxIC8gdGhpcy5mcmljdGlvbiAtIDEpICogKGUgLSB0aGlzLmNvbnRlbnQueSksXG4gICAgICAgICAgc2NhbGU6ICgxIC8gdGhpcy5mcmljdGlvbiAtIDEpICogKGkgLSB0aGlzLmNvbnRlbnQuc2NhbGUpXG4gICAgICAgIH0sIHRoaXMuc3RhcnRBbmltYXRpb24oKSkgOiB0aGlzLmVuZEFuaW1hdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBzdGFydEFuaW1hdGlvbigpIHtcbiAgICAgICAgdGhpcy5yQUYgPyBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJBRikgOiB0aGlzLnRyaWdnZXIoXCJzdGFydEFuaW1hdGlvblwiKSwgdGhpcy5yQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hbmltYXRlKCkpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5zZXRFZGdlRm9yY2UoKSwgdGhpcy5zZXREcmFnRm9yY2UoKSwgdGhpcy52ZWxvY2l0eS54ICo9IHRoaXMuZnJpY3Rpb24sIHRoaXMudmVsb2NpdHkueSAqPSB0aGlzLmZyaWN0aW9uLCB0aGlzLnZlbG9jaXR5LnNjYWxlICo9IHRoaXMuZnJpY3Rpb24sIHRoaXMuY29udGVudC54ICs9IHRoaXMudmVsb2NpdHkueCwgdGhpcy5jb250ZW50LnkgKz0gdGhpcy52ZWxvY2l0eS55LCB0aGlzLmNvbnRlbnQuc2NhbGUgKz0gdGhpcy52ZWxvY2l0eS5zY2FsZSwgdGhpcy5pc0FuaW1hdGluZygpKSB0aGlzLnNldFRyYW5zZm9ybSgpO2Vsc2UgaWYgKFwicG9pbnRlcmRvd25cIiAhPT0gdGhpcy5zdGF0ZSkgcmV0dXJuIHZvaWQgdGhpcy5lbmRBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5yQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hbmltYXRlKCkpO1xuICAgICAgfVxuXG4gICAgICBnZXRCb3VuZHModCkge1xuICAgICAgICBsZXQgZSA9IHRoaXMuYm91bmRYLFxuICAgICAgICAgICAgcyA9IHRoaXMuYm91bmRZO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBlICYmIHZvaWQgMCAhPT0gcykgcmV0dXJuIHtcbiAgICAgICAgICBib3VuZFg6IGUsXG4gICAgICAgICAgYm91bmRZOiBzXG4gICAgICAgIH07XG4gICAgICAgIGUgPSB7XG4gICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICB0bzogMFxuICAgICAgICB9LCBzID0ge1xuICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgdG86IDBcbiAgICAgICAgfSwgdCA9IHQgfHwgdGhpcy50cmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmNvbnRlbnQuZml0V2lkdGggKiB0LFxuICAgICAgICAgICAgICBuID0gdGhpcy5jb250ZW50LmZpdEhlaWdodCAqIHQsXG4gICAgICAgICAgICAgIGEgPSB0aGlzLnZpZXdwb3J0LndpZHRoLFxuICAgICAgICAgICAgICByID0gdGhpcy52aWV3cG9ydC5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKG8gPCBhKSB7XG4gICAgICAgICAgY29uc3QgdCA9IGkoLjUgKiAoYSAtIG8pKTtcbiAgICAgICAgICBlLmZyb20gPSB0LCBlLnRvID0gdDtcbiAgICAgICAgfSBlbHNlIGUuZnJvbSA9IGkoYSAtIG8pO1xuXG4gICAgICAgIGlmIChuIDwgcikge1xuICAgICAgICAgIGNvbnN0IHQgPSAuNSAqIChyIC0gbik7XG4gICAgICAgICAgcy5mcm9tID0gdCwgcy50byA9IHQ7XG4gICAgICAgIH0gZWxzZSBzLmZyb20gPSBpKHIgLSBuKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvdW5kWDogZSxcbiAgICAgICAgICBib3VuZFk6IHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2V0RWRnZUZvcmNlKCkge1xuICAgICAgICBpZiAoXCJkZWNlbFwiICE9PSB0aGlzLnN0YXRlKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbihcImJvdW5jZUZvcmNlXCIpLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgYm91bmRYOiBlLFxuICAgICAgICAgIGJvdW5kWTogaVxuICAgICAgICB9ID0gdGhpcy5nZXRCb3VuZHMoTWF0aC5tYXgodGhpcy50cmFuc2Zvcm0uc2NhbGUsIHRoaXMuY29udGVudC5zY2FsZSkpO1xuICAgICAgICBsZXQgcywgbywgbiwgYTtcblxuICAgICAgICBpZiAoZSAmJiAocyA9IHRoaXMuY29udGVudC54IDwgZS5mcm9tLCBvID0gdGhpcy5jb250ZW50LnggPiBlLnRvKSwgaSAmJiAobiA9IHRoaXMuY29udGVudC55IDwgaS5mcm9tLCBhID0gdGhpcy5jb250ZW50LnkgPiBpLnRvKSwgcyB8fCBvKSB7XG4gICAgICAgICAgbGV0IGkgPSAoKHMgPyBlLmZyb20gOiBlLnRvKSAtIHRoaXMuY29udGVudC54KSAqIHQ7XG4gICAgICAgICAgY29uc3QgbyA9IHRoaXMuY29udGVudC54ICsgKHRoaXMudmVsb2NpdHkueCArIGkpIC8gdGhpcy5mcmljdGlvbjtcbiAgICAgICAgICBvID49IGUuZnJvbSAmJiBvIDw9IGUudG8gJiYgKGkgKz0gdGhpcy52ZWxvY2l0eS54KSwgdGhpcy52ZWxvY2l0eS54ID0gaSwgdGhpcy5yZWNhbGN1bGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gfHwgYSkge1xuICAgICAgICAgIGxldCBlID0gKChuID8gaS5mcm9tIDogaS50bykgLSB0aGlzLmNvbnRlbnQueSkgKiB0O1xuICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLmNvbnRlbnQueSArIChlICsgdGhpcy52ZWxvY2l0eS55KSAvIHRoaXMuZnJpY3Rpb247XG4gICAgICAgICAgcyA+PSBpLmZyb20gJiYgcyA8PSBpLnRvICYmIChlICs9IHRoaXMudmVsb2NpdHkueSksIHRoaXMudmVsb2NpdHkueSA9IGUsIHRoaXMucmVjYWxjdWxhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXREcmFnUmVzaXN0YW5jZSgpIHtcbiAgICAgICAgaWYgKFwicG9pbnRlcmRvd25cIiAhPT0gdGhpcy5zdGF0ZSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYm91bmRYOiB0LFxuICAgICAgICAgIGJvdW5kWTogZVxuICAgICAgICB9ID0gdGhpcy5nZXRCb3VuZHModGhpcy5kcmFnUG9zaXRpb24uc2NhbGUpO1xuICAgICAgICBsZXQgaSwgcywgbywgbjtcblxuICAgICAgICBpZiAodCAmJiAoaSA9IHRoaXMuZHJhZ1Bvc2l0aW9uLnggPCB0LmZyb20sIHMgPSB0aGlzLmRyYWdQb3NpdGlvbi54ID4gdC50byksIGUgJiYgKG8gPSB0aGlzLmRyYWdQb3NpdGlvbi55IDwgZS5mcm9tLCBuID0gdGhpcy5kcmFnUG9zaXRpb24ueSA+IGUudG8pLCAoaSB8fCBzKSAmJiAoIWkgfHwgIXMpKSB7XG4gICAgICAgICAgY29uc3QgZSA9IGkgPyB0LmZyb20gOiB0LnRvLFxuICAgICAgICAgICAgICAgIHMgPSBlIC0gdGhpcy5kcmFnUG9zaXRpb24ueDtcbiAgICAgICAgICB0aGlzLmRyYWdQb3NpdGlvbi54ID0gZSAtIC4zICogcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobyB8fCBuKSAmJiAoIW8gfHwgIW4pKSB7XG4gICAgICAgICAgY29uc3QgdCA9IG8gPyBlLmZyb20gOiBlLnRvLFxuICAgICAgICAgICAgICAgIGkgPSB0IC0gdGhpcy5kcmFnUG9zaXRpb24ueTtcbiAgICAgICAgICB0aGlzLmRyYWdQb3NpdGlvbi55ID0gdCAtIC4zICogaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXREcmFnRm9yY2UoKSB7XG4gICAgICAgIFwicG9pbnRlcmRvd25cIiA9PT0gdGhpcy5zdGF0ZSAmJiAodGhpcy52ZWxvY2l0eS54ID0gdGhpcy5kcmFnUG9zaXRpb24ueCAtIHRoaXMuY29udGVudC54LCB0aGlzLnZlbG9jaXR5LnkgPSB0aGlzLmRyYWdQb3NpdGlvbi55IC0gdGhpcy5jb250ZW50LnksIHRoaXMudmVsb2NpdHkuc2NhbGUgPSB0aGlzLmRyYWdQb3NpdGlvbi5zY2FsZSAtIHRoaXMuY29udGVudC5zY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIHJlY2FsY3VsYXRlVHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS54ID0gdGhpcy5jb250ZW50LnggKyB0aGlzLnZlbG9jaXR5LnggLyAoMSAvIHRoaXMuZnJpY3Rpb24gLSAxKSwgdGhpcy50cmFuc2Zvcm0ueSA9IHRoaXMuY29udGVudC55ICsgdGhpcy52ZWxvY2l0eS55IC8gKDEgLyB0aGlzLmZyaWN0aW9uIC0gMSksIHRoaXMudHJhbnNmb3JtLnNjYWxlID0gdGhpcy5jb250ZW50LnNjYWxlICsgdGhpcy52ZWxvY2l0eS5zY2FsZSAvICgxIC8gdGhpcy5mcmljdGlvbiAtIDEpO1xuICAgICAgfVxuXG4gICAgICBpc0FuaW1hdGluZygpIHtcbiAgICAgICAgcmV0dXJuICEoIXRoaXMuZnJpY3Rpb24gfHwgIShNYXRoLmFicyh0aGlzLnZlbG9jaXR5LngpID4gLjA1IHx8IE1hdGguYWJzKHRoaXMudmVsb2NpdHkueSkgPiAuMDUgfHwgTWF0aC5hYnModGhpcy52ZWxvY2l0eS5zY2FsZSkgPiAuMDUpKTtcbiAgICAgIH1cblxuICAgICAgc2V0VHJhbnNmb3JtKHQpIHtcbiAgICAgICAgbGV0IGUsIHMsIG87XG5cbiAgICAgICAgaWYgKHQgPyAoZSA9IGkodGhpcy50cmFuc2Zvcm0ueCksIHMgPSBpKHRoaXMudHJhbnNmb3JtLnkpLCBvID0gdGhpcy50cmFuc2Zvcm0uc2NhbGUsIHRoaXMuY29udGVudCA9IHsgLi4udGhpcy5jb250ZW50LFxuICAgICAgICAgIHg6IGUsXG4gICAgICAgICAgeTogcyxcbiAgICAgICAgICBzY2FsZTogb1xuICAgICAgICB9KSA6IChlID0gaSh0aGlzLmNvbnRlbnQueCksIHMgPSBpKHRoaXMuY29udGVudC55KSwgbyA9IHRoaXMuY29udGVudC5zY2FsZSAvICh0aGlzLmNvbnRlbnQud2lkdGggLyB0aGlzLmNvbnRlbnQuZml0V2lkdGgpLCB0aGlzLmNvbnRlbnQgPSB7IC4uLnRoaXMuY29udGVudCxcbiAgICAgICAgICB4OiBlLFxuICAgICAgICAgIHk6IHNcbiAgICAgICAgfSksIHRoaXMudHJpZ2dlcihcImJlZm9yZVRyYW5zZm9ybVwiKSwgZSA9IGkodGhpcy5jb250ZW50LngpLCBzID0gaSh0aGlzLmNvbnRlbnQueSksIHQgJiYgdGhpcy5vcHRpb24oXCJ6b29tXCIpKSB7XG4gICAgICAgICAgbGV0IHQsIG47XG4gICAgICAgICAgdCA9IGkodGhpcy5jb250ZW50LmZpdFdpZHRoICogbyksIG4gPSBpKHRoaXMuY29udGVudC5maXRIZWlnaHQgKiBvKSwgdGhpcy5jb250ZW50LndpZHRoID0gdCwgdGhpcy5jb250ZW50LmhlaWdodCA9IG4sIHRoaXMudHJhbnNmb3JtID0geyAuLi50aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHdpZHRoOiB0LFxuICAgICAgICAgICAgaGVpZ2h0OiBuLFxuICAgICAgICAgICAgc2NhbGU6IG9cbiAgICAgICAgICB9LCBPYmplY3QuYXNzaWduKHRoaXMuJGNvbnRlbnQuc3R5bGUsIHtcbiAgICAgICAgICAgIHdpZHRoOiBgJHt0fXB4YCxcbiAgICAgICAgICAgIGhlaWdodDogYCR7bn1weGAsXG4gICAgICAgICAgICBtYXhXaWR0aDogXCJub25lXCIsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwibm9uZVwiLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtlfXB4LCAke3N9cHgsIDApIHNjYWxlKDEpYFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgdGhpcy4kY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtlfXB4LCAke3N9cHgsIDApIHNjYWxlKCR7b30pYDtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJhZnRlclRyYW5zZm9ybVwiKTtcbiAgICAgIH1cblxuICAgICAgZW5kQW5pbWF0aW9uKHQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yQUYpLCB0aGlzLnJBRiA9IG51bGwsIHRoaXMudmVsb2NpdHkgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHNjYWxlOiAwXG4gICAgICAgIH0sIHRoaXMuc2V0VHJhbnNmb3JtKCEwKSwgdGhpcy5zdGF0ZSA9IFwicmVhZHlcIiwgdGhpcy5oYW5kbGVDdXJzb3IoKSwgITAgIT09IHQgJiYgdGhpcy50cmlnZ2VyKFwiZW5kQW5pbWF0aW9uXCIpO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVDdXJzb3IoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbihcImRyYWdnYWJsZUNsYXNzXCIpO1xuICAgICAgICB0ICYmIHRoaXMub3B0aW9uKFwidG91Y2hcIikgJiYgKDEgPT0gdGhpcy5vcHRpb24oXCJwYW5Pbmx5Wm9vbWVkXCIpICYmIHRoaXMuY29udGVudC53aWR0aCA8PSB0aGlzLnZpZXdwb3J0LndpZHRoICYmIHRoaXMuY29udGVudC5oZWlnaHQgPD0gdGhpcy52aWV3cG9ydC5oZWlnaHQgJiYgdGhpcy50cmFuc2Zvcm0uc2NhbGUgPD0gdGhpcy5vcHRpb24oXCJiYXNlU2NhbGVcIikgPyB0aGlzLiRjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSh0KSA6IHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHQpKTtcbiAgICAgIH1cblxuICAgICAgZGV0YWNoRXZlbnRzKCkge1xuICAgICAgICB0aGlzLiRjb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMub25Mb2FkKSwgdGhpcy4kY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwsIHtcbiAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICB9KSwgdGhpcy4kY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm9uQ2xpY2ssIHtcbiAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICB9KSwgdGhpcy5wb2ludGVyVHJhY2tlciAmJiAodGhpcy5wb2ludGVyVHJhY2tlci5zdG9wKCksIHRoaXMucG9pbnRlclRyYWNrZXIgPSBudWxsKSwgdGhpcy5yZXNpemVPYnNlcnZlciAmJiAodGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCksIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBudWxsKTtcbiAgICAgIH1cblxuICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgXCJkZXN0cm95XCIgIT09IHRoaXMuc3RhdGUgJiYgKHRoaXMuc3RhdGUgPSBcImRlc3Ryb3lcIiwgY2xlYXJUaW1lb3V0KHRoaXMudXBkYXRlVGltZXIpLCB0aGlzLnVwZGF0ZVRpbWVyID0gbnVsbCwgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yQUYpLCB0aGlzLnJBRiA9IG51bGwsIHRoaXMuZGV0YWNoRXZlbnRzKCksIHRoaXMuZGV0YWNoUGx1Z2lucygpLCB0aGlzLnJlc2V0RHJhZ1Bvc2l0aW9uKCkpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZC52ZXJzaW9uID0gXCI0LjAuMzFcIiwgZC5QbHVnaW5zID0ge307XG5cbiAgICBjb25zdCB1ID0gKHQsIGUpID0+IHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4ucykge1xuICAgICAgICBjb25zdCBvID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGlmICghKG8gLSBpIDwgZSkpIHJldHVybiBpID0gbywgdCguLi5zKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNsYXNzIGYge1xuICAgICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLiRjb250YWluZXIgPSBudWxsLCB0aGlzLiRwcmV2ID0gbnVsbCwgdGhpcy4kbmV4dCA9IG51bGwsIHRoaXMuY2Fyb3VzZWwgPSB0LCB0aGlzLm9uUmVmcmVzaCA9IHRoaXMub25SZWZyZXNoLmJpbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhcm91c2VsLm9wdGlvbihgTmF2aWdhdGlvbi4ke3R9YCk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZUJ1dHRvbih0KSB7XG4gICAgICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICBlLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRoaXMuY2Fyb3VzZWwubG9jYWxpemUoYHt7JHt0LnRvVXBwZXJDYXNlKCl9fX1gKSk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLm9wdGlvbihcImNsYXNzTmFtZXMuYnV0dG9uXCIpICsgXCIgXCIgKyB0aGlzLm9wdGlvbihgY2xhc3NOYW1lcy4ke3R9YCk7XG4gICAgICAgIHJldHVybiBlLmNsYXNzTGlzdC5hZGQoLi4uaS5zcGxpdChcIiBcIikpLCBlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKSwgZS5pbm5lckhUTUwgPSB0aGlzLmNhcm91c2VsLmxvY2FsaXplKHRoaXMub3B0aW9uKGAke3R9VHBsYCkpLCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKCksIHRoaXMuY2Fyb3VzZWxbXCJzbGlkZVwiICsgKFwibmV4dFwiID09PSB0ID8gXCJOZXh0XCIgOiBcIlByZXZcIildKCk7XG4gICAgICAgIH0pLCBlO1xuICAgICAgfVxuXG4gICAgICBidWlsZCgpIHtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyIHx8ICh0aGlzLiRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB0aGlzLiRjb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLm9wdGlvbihcImNsYXNzTmFtZXMubWFpblwiKS5zcGxpdChcIiBcIikpLCB0aGlzLmNhcm91c2VsLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy4kY29udGFpbmVyKSksIHRoaXMuJG5leHQgfHwgKHRoaXMuJG5leHQgPSB0aGlzLmNyZWF0ZUJ1dHRvbihcIm5leHRcIiksIHRoaXMuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLiRuZXh0KSksIHRoaXMuJHByZXYgfHwgKHRoaXMuJHByZXYgPSB0aGlzLmNyZWF0ZUJ1dHRvbihcInByZXZcIiksIHRoaXMuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLiRwcmV2KSk7XG4gICAgICB9XG5cbiAgICAgIG9uUmVmcmVzaCgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuY2Fyb3VzZWwucGFnZXMubGVuZ3RoO1xuICAgICAgICB0IDw9IDEgfHwgdCA+IDEgJiYgdGhpcy5jYXJvdXNlbC5lbGVtRGltV2lkdGggPCB0aGlzLmNhcm91c2VsLndyYXBEaW1XaWR0aCAmJiAhTnVtYmVyLmlzSW50ZWdlcih0aGlzLmNhcm91c2VsLm9wdGlvbihcInNsaWRlc1BlclBhZ2VcIikpID8gdGhpcy5jbGVhbnVwKCkgOiAodGhpcy5idWlsZCgpLCB0aGlzLiRwcmV2LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpLCB0aGlzLiRuZXh0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpLCB0aGlzLmNhcm91c2VsLm9wdGlvbihcImluZmluaXRlWFwiLCB0aGlzLmNhcm91c2VsLm9wdGlvbihcImluZmluaXRlXCIpKSB8fCAodGhpcy5jYXJvdXNlbC5wYWdlIDw9IDAgJiYgdGhpcy4kcHJldi5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSwgdGhpcy5jYXJvdXNlbC5wYWdlID49IHQgLSAxICYmIHRoaXMuJG5leHQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIikpKTtcbiAgICAgIH1cblxuICAgICAgY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy4kcHJldiAmJiB0aGlzLiRwcmV2LnJlbW92ZSgpLCB0aGlzLiRwcmV2ID0gbnVsbCwgdGhpcy4kbmV4dCAmJiB0aGlzLiRuZXh0LnJlbW92ZSgpLCB0aGlzLiRuZXh0ID0gbnVsbCwgdGhpcy4kY29udGFpbmVyICYmIHRoaXMuJGNvbnRhaW5lci5yZW1vdmUoKSwgdGhpcy4kY29udGFpbmVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgYXR0YWNoKCkge1xuICAgICAgICB0aGlzLmNhcm91c2VsLm9uKFwicmVmcmVzaCBjaGFuZ2VcIiwgdGhpcy5vblJlZnJlc2gpO1xuICAgICAgfVxuXG4gICAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuY2Fyb3VzZWwub2ZmKFwicmVmcmVzaCBjaGFuZ2VcIiwgdGhpcy5vblJlZnJlc2gpLCB0aGlzLmNsZWFudXAoKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGYuZGVmYXVsdHMgPSB7XG4gICAgICBwcmV2VHBsOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHRhYmluZGV4PVwiLTFcIj48cGF0aCBkPVwiTTE1IDNsLTkgOSA5IDlcIi8+PC9zdmc+JyxcbiAgICAgIG5leHRUcGw6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgdGFiaW5kZXg9XCItMVwiPjxwYXRoIGQ9XCJNOSAzbDkgOS05IDlcIi8+PC9zdmc+JyxcbiAgICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgbWFpbjogXCJjYXJvdXNlbF9fbmF2XCIsXG4gICAgICAgIGJ1dHRvbjogXCJjYXJvdXNlbF9fYnV0dG9uXCIsXG4gICAgICAgIG5leHQ6IFwiaXMtbmV4dFwiLFxuICAgICAgICBwcmV2OiBcImlzLXByZXZcIlxuICAgICAgfVxuICAgIH07XG5cbiAgICBjbGFzcyBnIHtcbiAgICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5jYXJvdXNlbCA9IHQsIHRoaXMuc2VsZWN0ZWRJbmRleCA9IG51bGwsIHRoaXMuZnJpY3Rpb24gPSAwLCB0aGlzLm9uTmF2UmVhZHkgPSB0aGlzLm9uTmF2UmVhZHkuYmluZCh0aGlzKSwgdGhpcy5vbk5hdkNsaWNrID0gdGhpcy5vbk5hdkNsaWNrLmJpbmQodGhpcyksIHRoaXMub25OYXZDcmVhdGVTbGlkZSA9IHRoaXMub25OYXZDcmVhdGVTbGlkZS5iaW5kKHRoaXMpLCB0aGlzLm9uVGFyZ2V0Q2hhbmdlID0gdGhpcy5vblRhcmdldENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBhZGRBc1RhcmdldEZvcih0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5jYXJvdXNlbCwgdGhpcy5uYXYgPSB0LCB0aGlzLmF0dGFjaEV2ZW50cygpO1xuICAgICAgfVxuXG4gICAgICBhZGRBc05hdkZvcih0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdCwgdGhpcy5uYXYgPSB0aGlzLmNhcm91c2VsLCB0aGlzLmF0dGFjaEV2ZW50cygpO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMubmF2Lm9wdGlvbnMuaW5pdGlhbFNsaWRlID0gdGhpcy50YXJnZXQub3B0aW9ucy5pbml0aWFsUGFnZSwgdGhpcy5uYXYub24oXCJyZWFkeVwiLCB0aGlzLm9uTmF2UmVhZHkpLCB0aGlzLm5hdi5vbihcImNyZWF0ZVNsaWRlXCIsIHRoaXMub25OYXZDcmVhdGVTbGlkZSksIHRoaXMubmF2Lm9uKFwiUGFuem9vbS5jbGlja1wiLCB0aGlzLm9uTmF2Q2xpY2spLCB0aGlzLnRhcmdldC5vbihcImNoYW5nZVwiLCB0aGlzLm9uVGFyZ2V0Q2hhbmdlKSwgdGhpcy50YXJnZXQub24oXCJQYW56b29tLmFmdGVyVXBkYXRlXCIsIHRoaXMub25UYXJnZXRDaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBvbk5hdlJlYWR5KCkge1xuICAgICAgICB0aGlzLm9uVGFyZ2V0Q2hhbmdlKCEwKTtcbiAgICAgIH1cblxuICAgICAgb25OYXZDbGljayh0LCBlLCBpKSB7XG4gICAgICAgIGNvbnN0IHMgPSBpLnRhcmdldC5jbG9zZXN0KFwiLmNhcm91c2VsX19zbGlkZVwiKTtcbiAgICAgICAgaWYgKCFzKSByZXR1cm47XG4gICAgICAgIGkuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IG8gPSBwYXJzZUludChzLmRhdGFzZXQuaW5kZXgsIDEwKSxcbiAgICAgICAgICAgICAgbiA9IHRoaXMudGFyZ2V0LmZpbmRQYWdlRm9yU2xpZGUobyk7XG4gICAgICAgIHRoaXMudGFyZ2V0LnBhZ2UgIT09IG4gJiYgdGhpcy50YXJnZXQuc2xpZGVUbyhuLCB7XG4gICAgICAgICAgZnJpY3Rpb246IHRoaXMuZnJpY3Rpb25cbiAgICAgICAgfSksIHRoaXMubWFya1NlbGVjdGVkU2xpZGUobyk7XG4gICAgICB9XG5cbiAgICAgIG9uTmF2Q3JlYXRlU2xpZGUodCwgZSkge1xuICAgICAgICBlLmluZGV4ID09PSB0aGlzLnNlbGVjdGVkSW5kZXggJiYgdGhpcy5tYXJrU2VsZWN0ZWRTbGlkZShlLmluZGV4KTtcbiAgICAgIH1cblxuICAgICAgb25UYXJnZXRDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnRhcmdldC5wYWdlc1t0aGlzLnRhcmdldC5wYWdlXS5pbmRleGVzWzBdLFxuICAgICAgICAgICAgICBlID0gdGhpcy5uYXYuZmluZFBhZ2VGb3JTbGlkZSh0KTtcbiAgICAgICAgdGhpcy5uYXYuc2xpZGVUbyhlKSwgdGhpcy5tYXJrU2VsZWN0ZWRTbGlkZSh0KTtcbiAgICAgIH1cblxuICAgICAgbWFya1NlbGVjdGVkU2xpZGUodCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0LCBbLi4udGhpcy5uYXYuc2xpZGVzXS5maWx0ZXIodCA9PiB0LiRlbCAmJiB0LiRlbC5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtbmF2LXNlbGVjdGVkXCIpKTtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMubmF2LnNsaWRlc1t0XTtcbiAgICAgICAgZSAmJiBlLiRlbCAmJiBlLiRlbC5jbGFzc0xpc3QuYWRkKFwiaXMtbmF2LXNlbGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2godCkge1xuICAgICAgICBjb25zdCBlID0gdC5vcHRpb25zLlN5bmM7XG4gICAgICAgIChlLnRhcmdldCB8fCBlLm5hdikgJiYgKGUudGFyZ2V0ID8gdGhpcy5hZGRBc05hdkZvcihlLnRhcmdldCkgOiBlLm5hdiAmJiB0aGlzLmFkZEFzVGFyZ2V0Rm9yKGUubmF2KSwgdGhpcy5mcmljdGlvbiA9IGUuZnJpY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMubmF2ICYmICh0aGlzLm5hdi5vZmYoXCJyZWFkeVwiLCB0aGlzLm9uTmF2UmVhZHkpLCB0aGlzLm5hdi5vZmYoXCJQYW56b29tLmNsaWNrXCIsIHRoaXMub25OYXZDbGljayksIHRoaXMubmF2Lm9mZihcImNyZWF0ZVNsaWRlXCIsIHRoaXMub25OYXZDcmVhdGVTbGlkZSkpLCB0aGlzLnRhcmdldCAmJiAodGhpcy50YXJnZXQub2ZmKFwiUGFuem9vbS5hZnRlclVwZGF0ZVwiLCB0aGlzLm9uVGFyZ2V0Q2hhbmdlKSwgdGhpcy50YXJnZXQub2ZmKFwiY2hhbmdlXCIsIHRoaXMub25UYXJnZXRDaGFuZ2UpKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGcuZGVmYXVsdHMgPSB7XG4gICAgICBmcmljdGlvbjogLjkyXG4gICAgfTtcbiAgICBjb25zdCBwID0ge1xuICAgICAgTmF2aWdhdGlvbjogZixcbiAgICAgIERvdHM6IGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICAgIHRoaXMuY2Fyb3VzZWwgPSB0LCB0aGlzLiRsaXN0ID0gbnVsbCwgdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICAgICBjaGFuZ2U6IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJlZnJlc2g6IHRoaXMub25SZWZyZXNoLmJpbmQodGhpcylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgYnVpbGRMaXN0KCkge1xuICAgICAgICAgIGlmICh0aGlzLmNhcm91c2VsLnBhZ2VzLmxlbmd0aCA8IHRoaXMuY2Fyb3VzZWwub3B0aW9uKFwiRG90cy5taW5TbGlkZUNvdW50XCIpKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvbFwiKTtcbiAgICAgICAgICByZXR1cm4gdC5jbGFzc0xpc3QuYWRkKFwiY2Fyb3VzZWxfX2RvdHNcIiksIHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHQgPT4ge1xuICAgICAgICAgICAgaWYgKCEoXCJwYWdlXCIgaW4gdC50YXJnZXQuZGF0YXNldCkpIHJldHVybjtcbiAgICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBwYXJzZUludCh0LnRhcmdldC5kYXRhc2V0LnBhZ2UsIDEwKSxcbiAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLmNhcm91c2VsO1xuICAgICAgICAgICAgZSAhPT0gaS5wYWdlICYmIChpLnBhZ2VzLmxlbmd0aCA8IDMgJiYgaS5vcHRpb24oXCJpbmZpbml0ZVwiKSA/IGlbMCA9PSBlID8gXCJzbGlkZVByZXZcIiA6IFwic2xpZGVOZXh0XCJdKCkgOiBpLnNsaWRlVG8oZSkpO1xuICAgICAgICAgIH0pLCB0aGlzLiRsaXN0ID0gdCwgdGhpcy5jYXJvdXNlbC4kY29udGFpbmVyLmFwcGVuZENoaWxkKHQpLCB0aGlzLmNhcm91c2VsLiRjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhcy1kb3RzXCIpLCB0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlTGlzdCgpIHtcbiAgICAgICAgICB0aGlzLiRsaXN0ICYmICh0aGlzLiRsaXN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kbGlzdCksIHRoaXMuJGxpc3QgPSBudWxsKSwgdGhpcy5jYXJvdXNlbC4kY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJoYXMtZG90c1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlYnVpbGREb3RzKCkge1xuICAgICAgICAgIGxldCB0ID0gdGhpcy4kbGlzdDtcbiAgICAgICAgICBjb25zdCBlID0gISF0LFxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLmNhcm91c2VsLnBhZ2VzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaSA8IDIpIHJldHVybiB2b2lkIChlICYmIHRoaXMucmVtb3ZlTGlzdCgpKTtcbiAgICAgICAgICBlIHx8ICh0ID0gdGhpcy5idWlsZExpc3QoKSk7XG4gICAgICAgICAgY29uc3QgcyA9IHRoaXMuJGxpc3QuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIGlmIChzID4gaSkgZm9yIChsZXQgdCA9IGk7IHQgPCBzOyB0KyspIHRoaXMuJGxpc3QucmVtb3ZlQ2hpbGQodGhpcy4kbGlzdC5sYXN0Q2hpbGQpO2Vsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgdCA9IHM7IHQgPCBpOyB0KyspIHtcbiAgICAgICAgICAgICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgICAgICAgICAgZS5jbGFzc0xpc3QuYWRkKFwiY2Fyb3VzZWxfX2RvdFwiKSwgZS5kYXRhc2V0LnBhZ2UgPSB0LCBlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIiksIGUuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpLCBlLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRoaXMuY2Fyb3VzZWwubG9jYWxpemUoXCJ7e0dPVE99fVwiLCBbW1wiJWRcIiwgdCArIDFdXSkpLCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB0LmNvZGU7XG4gICAgICAgICAgICAgICAgbGV0IHM7XG4gICAgICAgICAgICAgICAgXCJFbnRlclwiID09PSBpIHx8IFwiTnVtcGFkRW50ZXJcIiA9PT0gaSA/IHMgPSBlIDogXCJBcnJvd1JpZ2h0XCIgPT09IGkgPyBzID0gZS5uZXh0U2libGluZyA6IFwiQXJyb3dMZWZ0XCIgPT09IGkgJiYgKHMgPSBlLnByZXZpb3VzU2libGluZyksIHMgJiYgcy5jbGljaygpO1xuICAgICAgICAgICAgICB9KSwgdGhpcy4kbGlzdC5hcHBlbmRDaGlsZChlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVEb3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZXRBY3RpdmVEb3QoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiRsaXN0KSByZXR1cm47XG4gICAgICAgICAgdGhpcy4kbGlzdC5jaGlsZE5vZGVzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgICB0LmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1zZWxlY3RlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCB0ID0gdGhpcy4kbGlzdC5jaGlsZE5vZGVzW3RoaXMuY2Fyb3VzZWwucGFnZV07XG4gICAgICAgICAgdCAmJiB0LmNsYXNzTGlzdC5hZGQoXCJpcy1zZWxlY3RlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uQ2hhbmdlKCkge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlRG90KCk7XG4gICAgICAgIH1cblxuICAgICAgICBvblJlZnJlc2goKSB7XG4gICAgICAgICAgdGhpcy5yZWJ1aWxkRG90cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0YWNoKCkge1xuICAgICAgICAgIHRoaXMuY2Fyb3VzZWwub24odGhpcy5ldmVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0YWNoKCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdCgpLCB0aGlzLmNhcm91c2VsLm9mZih0aGlzLmV2ZW50cyksIHRoaXMuY2Fyb3VzZWwgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgIH0sXG4gICAgICBTeW5jOiBnXG4gICAgfTtcbiAgICBjb25zdCBtID0ge1xuICAgICAgc2xpZGVzOiBbXSxcbiAgICAgIHByZWxvYWQ6IDAsXG4gICAgICBzbGlkZXNQZXJQYWdlOiBcImF1dG9cIixcbiAgICAgIGluaXRpYWxQYWdlOiBudWxsLFxuICAgICAgaW5pdGlhbFNsaWRlOiBudWxsLFxuICAgICAgZnJpY3Rpb246IC45MixcbiAgICAgIGNlbnRlcjogITAsXG4gICAgICBpbmZpbml0ZTogITAsXG4gICAgICBmaWxsOiAhMCxcbiAgICAgIGRyYWdGcmVlOiAhMSxcbiAgICAgIHByZWZpeDogXCJcIixcbiAgICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgdmlld3BvcnQ6IFwiY2Fyb3VzZWxfX3ZpZXdwb3J0XCIsXG4gICAgICAgIHRyYWNrOiBcImNhcm91c2VsX190cmFja1wiLFxuICAgICAgICBzbGlkZTogXCJjYXJvdXNlbF9fc2xpZGVcIixcbiAgICAgICAgc2xpZGVTZWxlY3RlZDogXCJpcy1zZWxlY3RlZFwiXG4gICAgICB9LFxuICAgICAgbDEwbjoge1xuICAgICAgICBORVhUOiBcIk5leHQgc2xpZGVcIixcbiAgICAgICAgUFJFVjogXCJQcmV2aW91cyBzbGlkZVwiLFxuICAgICAgICBHT1RPOiBcIkdvIHRvIHNsaWRlICMlZFwiXG4gICAgICB9XG4gICAgfTtcblxuICAgIGNsYXNzIHkgZXh0ZW5kcyBsIHtcbiAgICAgIGNvbnN0cnVjdG9yKHQsIGkgPSB7fSkge1xuICAgICAgICBpZiAoc3VwZXIoaSA9IGUoITAsIHt9LCBtLCBpKSksIHRoaXMuc3RhdGUgPSBcImluaXRcIiwgdGhpcy4kY29udGFpbmVyID0gdCwgISh0aGlzLiRjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHRocm93IG5ldyBFcnJvcihcIk5vIHJvb3QgZWxlbWVudCBwcm92aWRlZFwiKTtcbiAgICAgICAgdGhpcy5zbGlkZU5leHQgPSB1KHRoaXMuc2xpZGVOZXh0LmJpbmQodGhpcyksIDI1MCksIHRoaXMuc2xpZGVQcmV2ID0gdSh0aGlzLnNsaWRlUHJldi5iaW5kKHRoaXMpLCAyNTApLCB0aGlzLmluaXQoKSwgdC5fX0Nhcm91c2VsID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5wYWdlcyA9IFtdLCB0aGlzLnBhZ2UgPSB0aGlzLnBhZ2VJbmRleCA9IG51bGwsIHRoaXMucHJldlBhZ2UgPSB0aGlzLnByZXZQYWdlSW5kZXggPSBudWxsLCB0aGlzLmF0dGFjaFBsdWdpbnMoeS5QbHVnaW5zKSwgdGhpcy50cmlnZ2VyKFwiaW5pdFwiKSwgdGhpcy5pbml0TGF5b3V0KCksIHRoaXMuaW5pdFNsaWRlcygpLCB0aGlzLnVwZGF0ZU1ldHJpY3MoKSwgdGhpcy4kdHJhY2sgJiYgdGhpcy5wYWdlcy5sZW5ndGggJiYgKHRoaXMuJHRyYWNrLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgkey0xICogdGhpcy5wYWdlc1t0aGlzLnBhZ2VdLmxlZnR9cHgsIDBweCwgMCkgc2NhbGUoMSlgKSwgdGhpcy5tYW5hZ2VTbGlkZVZpc2libGl0eSgpLCB0aGlzLmluaXRQYW56b29tKCksIHRoaXMuc3RhdGUgPSBcInJlYWR5XCIsIHRoaXMudHJpZ2dlcihcInJlYWR5XCIpO1xuICAgICAgfVxuXG4gICAgICBpbml0TGF5b3V0KCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5vcHRpb24oXCJwcmVmaXhcIiksXG4gICAgICAgICAgICAgIGUgPSB0aGlzLm9wdGlvbihcImNsYXNzTmFtZXNcIik7XG4gICAgICAgIHRoaXMuJHZpZXdwb3J0ID0gdGhpcy5vcHRpb24oXCJ2aWV3cG9ydFwiKSB8fCB0aGlzLiRjb250YWluZXIucXVlcnlTZWxlY3RvcihgLiR7dH0ke2Uudmlld3BvcnR9YCksIHRoaXMuJHZpZXdwb3J0IHx8ICh0aGlzLiR2aWV3cG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHRoaXMuJHZpZXdwb3J0LmNsYXNzTGlzdC5hZGQoLi4uKHQgKyBlLnZpZXdwb3J0KS5zcGxpdChcIiBcIikpLCB0aGlzLiR2aWV3cG9ydC5hcHBlbmQoLi4udGhpcy4kY29udGFpbmVyLmNoaWxkTm9kZXMpLCB0aGlzLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy4kdmlld3BvcnQpKSwgdGhpcy4kdHJhY2sgPSB0aGlzLm9wdGlvbihcInRyYWNrXCIpIHx8IHRoaXMuJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGAuJHt0fSR7ZS50cmFja31gKSwgdGhpcy4kdHJhY2sgfHwgKHRoaXMuJHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGhpcy4kdHJhY2suY2xhc3NMaXN0LmFkZCguLi4odCArIGUudHJhY2spLnNwbGl0KFwiIFwiKSksIHRoaXMuJHRyYWNrLmFwcGVuZCguLi50aGlzLiR2aWV3cG9ydC5jaGlsZE5vZGVzKSwgdGhpcy4kdmlld3BvcnQuYXBwZW5kQ2hpbGQodGhpcy4kdHJhY2spKTtcbiAgICAgIH1cblxuICAgICAgaW5pdFNsaWRlcygpIHtcbiAgICAgICAgdGhpcy5zbGlkZXMgPSBbXTtcbiAgICAgICAgdGhpcy4kdmlld3BvcnQucXVlcnlTZWxlY3RvckFsbChgLiR7dGhpcy5vcHRpb24oXCJwcmVmaXhcIil9JHt0aGlzLm9wdGlvbihcImNsYXNzTmFtZXMuc2xpZGVcIil9YCkuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBjb25zdCBlID0ge1xuICAgICAgICAgICAgJGVsOiB0LFxuICAgICAgICAgICAgaXNEb206ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnNsaWRlcy5wdXNoKGUpLCB0aGlzLnRyaWdnZXIoXCJjcmVhdGVTbGlkZVwiLCBlLCB0aGlzLnNsaWRlcy5sZW5ndGgpO1xuICAgICAgICB9KSwgQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuc2xpZGVzKSAmJiAodGhpcy5zbGlkZXMgPSBlKCEwLCBbLi4udGhpcy5zbGlkZXNdLCB0aGlzLm9wdGlvbnMuc2xpZGVzKSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZU1ldHJpY3MoKSB7XG4gICAgICAgIGxldCB0LFxuICAgICAgICAgICAgZSA9IDAsXG4gICAgICAgICAgICBzID0gW107XG4gICAgICAgIHRoaXMuc2xpZGVzLmZvckVhY2goKGksIG8pID0+IHtcbiAgICAgICAgICBjb25zdCBuID0gaS4kZWwsXG4gICAgICAgICAgICAgICAgYSA9IGkuaXNEb20gfHwgIXQgPyB0aGlzLmdldFNsaWRlTWV0cmljcyhuKSA6IHQ7XG4gICAgICAgICAgaS5pbmRleCA9IG8sIGkud2lkdGggPSBhLCBpLmxlZnQgPSBlLCB0ID0gYSwgZSArPSBhLCBzLnB1c2gobyk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbyA9IE1hdGgubWF4KHRoaXMuJHRyYWNrLm9mZnNldFdpZHRoLCBpKHRoaXMuJHRyYWNrLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKSksXG4gICAgICAgICAgICBuID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiR0cmFjayk7XG4gICAgICAgIG8gLT0gcGFyc2VGbG9hdChuLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQobi5wYWRkaW5nUmlnaHQpLCB0aGlzLmNvbnRlbnRXaWR0aCA9IGUsIHRoaXMudmlld3BvcnRXaWR0aCA9IG87XG4gICAgICAgIGNvbnN0IGEgPSBbXSxcbiAgICAgICAgICAgICAgciA9IHRoaXMub3B0aW9uKFwic2xpZGVzUGVyUGFnZVwiKTtcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIocikgJiYgZSA+IG8pIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5zbGlkZXMubGVuZ3RoOyB0ICs9IHIpIGEucHVzaCh7XG4gICAgICAgICAgaW5kZXhlczogcy5zbGljZSh0LCB0ICsgciksXG4gICAgICAgICAgc2xpZGVzOiB0aGlzLnNsaWRlcy5zbGljZSh0LCB0ICsgcilcbiAgICAgICAgfSk7ZWxzZSB7XG4gICAgICAgICAgbGV0IHQgPSAwLFxuICAgICAgICAgICAgICBlID0gMDtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBzID0gdGhpcy5zbGlkZXNbaV07XG4gICAgICAgICAgICAoIWEubGVuZ3RoIHx8IGUgKyBzLndpZHRoID4gbykgJiYgKGEucHVzaCh7XG4gICAgICAgICAgICAgIGluZGV4ZXM6IFtdLFxuICAgICAgICAgICAgICBzbGlkZXM6IFtdXG4gICAgICAgICAgICB9KSwgdCA9IGEubGVuZ3RoIC0gMSwgZSA9IDApLCBlICs9IHMud2lkdGgsIGFbdF0uaW5kZXhlcy5wdXNoKGkpLCBhW3RdLnNsaWRlcy5wdXNoKHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoID0gdGhpcy5vcHRpb24oXCJjZW50ZXJcIiksXG4gICAgICAgICAgICAgIGwgPSB0aGlzLm9wdGlvbihcImZpbGxcIik7XG4gICAgICAgIGEuZm9yRWFjaCgodCwgaSkgPT4ge1xuICAgICAgICAgIHQuaW5kZXggPSBpLCB0LndpZHRoID0gdC5zbGlkZXMucmVkdWNlKCh0LCBlKSA9PiB0ICsgZS53aWR0aCwgMCksIHQubGVmdCA9IHQuc2xpZGVzWzBdLmxlZnQsIGggJiYgKHQubGVmdCArPSAuNSAqIChvIC0gdC53aWR0aCkgKiAtMSksIGwgJiYgIXRoaXMub3B0aW9uKFwiaW5maW5pdGVYXCIsIHRoaXMub3B0aW9uKFwiaW5maW5pdGVcIikpICYmIGUgPiBvICYmICh0LmxlZnQgPSBNYXRoLm1heCh0LmxlZnQsIDApLCB0LmxlZnQgPSBNYXRoLm1pbih0LmxlZnQsIGUgLSBvKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjID0gW107XG4gICAgICAgIGxldCBkO1xuICAgICAgICBhLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgY29uc3QgZSA9IHsgLi4udFxuICAgICAgICAgIH07XG4gICAgICAgICAgZCAmJiBlLmxlZnQgPT09IGQubGVmdCA/IChkLndpZHRoICs9IGUud2lkdGgsIGQuc2xpZGVzID0gWy4uLmQuc2xpZGVzLCAuLi5lLnNsaWRlc10sIGQuaW5kZXhlcyA9IFsuLi5kLmluZGV4ZXMsIC4uLmUuaW5kZXhlc10pIDogKGUuaW5kZXggPSBjLmxlbmd0aCwgZCA9IGUsIGMucHVzaChlKSk7XG4gICAgICAgIH0pLCB0aGlzLnBhZ2VzID0gYztcbiAgICAgICAgbGV0IHUgPSB0aGlzLnBhZ2U7XG5cbiAgICAgICAgaWYgKG51bGwgPT09IHUpIHtcbiAgICAgICAgICBjb25zdCB0ID0gdGhpcy5vcHRpb24oXCJpbml0aWFsU2xpZGVcIik7XG4gICAgICAgICAgdSA9IG51bGwgIT09IHQgPyB0aGlzLmZpbmRQYWdlRm9yU2xpZGUodCkgOiBwYXJzZUludCh0aGlzLm9wdGlvbihcImluaXRpYWxQYWdlXCIsIDApLCAxMCkgfHwgMCwgY1t1XSB8fCAodSA9IGMubGVuZ3RoICYmIHUgPiBjLmxlbmd0aCA/IGNbYy5sZW5ndGggLSAxXS5pbmRleCA6IDApLCB0aGlzLnBhZ2UgPSB1LCB0aGlzLnBhZ2VJbmRleCA9IHU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVBhbnpvb20oKSwgdGhpcy50cmlnZ2VyKFwicmVmcmVzaFwiKTtcbiAgICAgIH1cblxuICAgICAgZ2V0U2xpZGVNZXRyaWNzKHQpIHtcbiAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgY29uc3QgZSA9IHRoaXMuc2xpZGVzWzBdO1xuICAgICAgICAgICh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuZGF0YXNldC5pc1Rlc3RFbCA9IDEsIHQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCIsIHQuY2xhc3NMaXN0LmFkZCguLi4odGhpcy5vcHRpb24oXCJwcmVmaXhcIikgKyB0aGlzLm9wdGlvbihcImNsYXNzTmFtZXMuc2xpZGVcIikpLnNwbGl0KFwiIFwiKSksIGUuY3VzdG9tQ2xhc3MgJiYgdC5jbGFzc0xpc3QuYWRkKC4uLmUuY3VzdG9tQ2xhc3Muc3BsaXQoXCIgXCIpKSwgdGhpcy4kdHJhY2sucHJlcGVuZCh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBlID0gTWF0aC5tYXgodC5vZmZzZXRXaWR0aCwgaSh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKSk7XG4gICAgICAgIGNvbnN0IHMgPSB0LmN1cnJlbnRTdHlsZSB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KTtcbiAgICAgICAgcmV0dXJuIGUgPSBlICsgKHBhcnNlRmxvYXQocy5tYXJnaW5MZWZ0KSB8fCAwKSArIChwYXJzZUZsb2F0KHMubWFyZ2luUmlnaHQpIHx8IDApLCB0LmRhdGFzZXQuaXNUZXN0RWwgJiYgdC5yZW1vdmUoKSwgZTtcbiAgICAgIH1cblxuICAgICAgZmluZFBhZ2VGb3JTbGlkZSh0KSB7XG4gICAgICAgIHQgPSBwYXJzZUludCh0LCAxMCkgfHwgMDtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMucGFnZXMuZmluZChlID0+IGUuaW5kZXhlcy5pbmRleE9mKHQpID4gLTEpO1xuICAgICAgICByZXR1cm4gZSA/IGUuaW5kZXggOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBzbGlkZU5leHQoKSB7XG4gICAgICAgIHRoaXMuc2xpZGVUbyh0aGlzLnBhZ2VJbmRleCArIDEpO1xuICAgICAgfVxuXG4gICAgICBzbGlkZVByZXYoKSB7XG4gICAgICAgIHRoaXMuc2xpZGVUbyh0aGlzLnBhZ2VJbmRleCAtIDEpO1xuICAgICAgfVxuXG4gICAgICBzbGlkZVRvKHQsIGUgPSB7fSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgeDogaSA9IC0xICogdGhpcy5zZXRQYWdlKHQsICEwKSxcbiAgICAgICAgICB5OiBzID0gMCxcbiAgICAgICAgICBmcmljdGlvbjogbyA9IHRoaXMub3B0aW9uKFwiZnJpY3Rpb25cIilcbiAgICAgICAgfSA9IGU7XG4gICAgICAgIHRoaXMuUGFuem9vbS5jb250ZW50LnggPT09IGkgJiYgIXRoaXMuUGFuem9vbS52ZWxvY2l0eS54ICYmIG8gfHwgKHRoaXMuUGFuem9vbS5wYW5Ubyh7XG4gICAgICAgICAgeDogaSxcbiAgICAgICAgICB5OiBzLFxuICAgICAgICAgIGZyaWN0aW9uOiBvLFxuICAgICAgICAgIGlnbm9yZUJvdW5kczogITBcbiAgICAgICAgfSksIFwicmVhZHlcIiA9PT0gdGhpcy5zdGF0ZSAmJiBcInJlYWR5XCIgPT09IHRoaXMuUGFuem9vbS5zdGF0ZSAmJiB0aGlzLnRyaWdnZXIoXCJzZXR0bGVcIikpO1xuICAgICAgfVxuXG4gICAgICBpbml0UGFuem9vbSgpIHtcbiAgICAgICAgdGhpcy5QYW56b29tICYmIHRoaXMuUGFuem9vbS5kZXN0cm95KCk7XG4gICAgICAgIGNvbnN0IHQgPSBlKCEwLCB7fSwge1xuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuJHRyYWNrLFxuICAgICAgICAgIHdyYXBJbm5lcjogITEsXG4gICAgICAgICAgcmVzaXplUGFyZW50OiAhMSxcbiAgICAgICAgICB6b29tOiAhMSxcbiAgICAgICAgICBjbGljazogITEsXG4gICAgICAgICAgbG9ja0F4aXM6IFwieFwiLFxuICAgICAgICAgIHg6IHRoaXMucGFnZXMubGVuZ3RoID8gLTEgKiB0aGlzLnBhZ2VzW3RoaXMucGFnZV0ubGVmdCA6IDAsXG4gICAgICAgICAgY2VudGVyT25TdGFydDogITEsXG4gICAgICAgICAgdGV4dFNlbGVjdGlvbjogKCkgPT4gdGhpcy5vcHRpb24oXCJ0ZXh0U2VsZWN0aW9uXCIsICExKSxcbiAgICAgICAgICBwYW5Pbmx5Wm9vbWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LndpZHRoIDw9IHRoaXMudmlld3BvcnQud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLm9wdGlvbihcIlBhbnpvb21cIikpO1xuICAgICAgICB0aGlzLlBhbnpvb20gPSBuZXcgZCh0aGlzLiRjb250YWluZXIsIHQpLCB0aGlzLlBhbnpvb20ub24oe1xuICAgICAgICAgIFwiKlwiOiAodCwgLi4uZSkgPT4gdGhpcy50cmlnZ2VyKGBQYW56b29tLiR7dH1gLCAuLi5lKSxcbiAgICAgICAgICBhZnRlclVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBiZWZvcmVUcmFuc2Zvcm06IHRoaXMub25CZWZvcmVUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICAgICAgICB0b3VjaEVuZDogdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyksXG4gICAgICAgICAgZW5kQW5pbWF0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJzZXR0bGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgdGhpcy51cGRhdGVNZXRyaWNzKCksIHRoaXMubWFuYWdlU2xpZGVWaXNpYmxpdHkoKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlUGFuem9vbSgpIHtcbiAgICAgICAgdGhpcy5QYW56b29tICYmICh0aGlzLlBhbnpvb20uY29udGVudCA9IHsgLi4udGhpcy5QYW56b29tLmNvbnRlbnQsXG4gICAgICAgICAgZml0V2lkdGg6IHRoaXMuY29udGVudFdpZHRoLFxuICAgICAgICAgIG9yaWdXaWR0aDogdGhpcy5jb250ZW50V2lkdGgsXG4gICAgICAgICAgd2lkdGg6IHRoaXMuY29udGVudFdpZHRoXG4gICAgICAgIH0sIHRoaXMucGFnZXMubGVuZ3RoID4gMSAmJiB0aGlzLm9wdGlvbihcImluZmluaXRlWFwiLCB0aGlzLm9wdGlvbihcImluZmluaXRlXCIpKSA/IHRoaXMuUGFuem9vbS5ib3VuZFggPSBudWxsIDogdGhpcy5wYWdlcy5sZW5ndGggJiYgKHRoaXMuUGFuem9vbS5ib3VuZFggPSB7XG4gICAgICAgICAgZnJvbTogLTEgKiB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0ubGVmdCxcbiAgICAgICAgICB0bzogLTEgKiB0aGlzLnBhZ2VzWzBdLmxlZnRcbiAgICAgICAgfSksIHRoaXMub3B0aW9uKFwiaW5maW5pdGVZXCIsIHRoaXMub3B0aW9uKFwiaW5maW5pdGVcIikpID8gdGhpcy5QYW56b29tLmJvdW5kWSA9IG51bGwgOiB0aGlzLlBhbnpvb20uYm91bmRZID0ge1xuICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgdG86IDBcbiAgICAgICAgfSwgdGhpcy5QYW56b29tLmhhbmRsZUN1cnNvcigpKTtcbiAgICAgIH1cblxuICAgICAgbWFuYWdlU2xpZGVWaXNpYmxpdHkoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbnRlbnRXaWR0aCxcbiAgICAgICAgICAgICAgZSA9IHRoaXMudmlld3BvcnRXaWR0aDtcbiAgICAgICAgbGV0IGkgPSB0aGlzLlBhbnpvb20gPyAtMSAqIHRoaXMuUGFuem9vbS5jb250ZW50LnggOiB0aGlzLnBhZ2VzLmxlbmd0aCA/IHRoaXMucGFnZXNbdGhpcy5wYWdlXS5sZWZ0IDogMDtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMub3B0aW9uKFwicHJlbG9hZFwiKSxcbiAgICAgICAgICAgICAgbyA9IHRoaXMub3B0aW9uKFwiaW5maW5pdGVYXCIsIHRoaXMub3B0aW9uKFwiaW5maW5pdGVcIikpLFxuICAgICAgICAgICAgICBuID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKHRoaXMuJHZpZXdwb3J0LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1sZWZ0XCIpKSxcbiAgICAgICAgICAgICAgYSA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiR2aWV3cG9ydCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctcmlnaHRcIikpO1xuICAgICAgICB0aGlzLnNsaWRlcy5mb3JFYWNoKHIgPT4ge1xuICAgICAgICAgIGxldCBoLFxuICAgICAgICAgICAgICBsLFxuICAgICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICBoID0gaSAtIG4sIGwgPSBpICsgZSArIGEsIGggLT0gcyAqIChlICsgbiArIGEpLCBsICs9IHMgKiAoZSArIG4gKyBhKTtcbiAgICAgICAgICBjb25zdCBkID0gci5sZWZ0ICsgci53aWR0aCA+IGggJiYgci5sZWZ0IDwgbDtcbiAgICAgICAgICBoID0gaSArIHQgLSBuLCBsID0gaSArIHQgKyBlICsgYSwgaCAtPSBzICogKGUgKyBuICsgYSk7XG4gICAgICAgICAgY29uc3QgdSA9IG8gJiYgci5sZWZ0ICsgci53aWR0aCA+IGggJiYgci5sZWZ0IDwgbDtcbiAgICAgICAgICBoID0gaSAtIHQgLSBuLCBsID0gaSAtIHQgKyBlICsgYSwgaCAtPSBzICogKGUgKyBuICsgYSk7XG4gICAgICAgICAgY29uc3QgZiA9IG8gJiYgci5sZWZ0ICsgci53aWR0aCA+IGggJiYgci5sZWZ0IDwgbDtcbiAgICAgICAgICB1IHx8IGQgfHwgZiA/ICh0aGlzLmNyZWF0ZVNsaWRlRWwociksIGQgJiYgKGMgPSAwKSwgdSAmJiAoYyA9IC0xKSwgZiAmJiAoYyA9IDEpLCByLmxlZnQgKyByLndpZHRoID4gaSAmJiByLmxlZnQgPD0gaSArIGUgKyBhICYmIChjID0gMCkpIDogdGhpcy5yZW1vdmVTbGlkZUVsKHIpLCByLmhhc0RpZmYgPSBjO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHIgPSAwLFxuICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgIHRoaXMuc2xpZGVzLmZvckVhY2goKGUsIGkpID0+IHtcbiAgICAgICAgICBsZXQgcyA9IDA7XG4gICAgICAgICAgZS4kZWwgPyAoaSAhPT0gciB8fCBlLmhhc0RpZmYgPyBzID0gaCArIGUuaGFzRGlmZiAqIHQgOiBoID0gMCwgZS4kZWwuc3R5bGUubGVmdCA9IE1hdGguYWJzKHMpID4gLjEgPyBgJHtoICsgZS5oYXNEaWZmICogdH1weGAgOiBcIlwiLCByKyspIDogaCArPSBlLndpZHRoO1xuICAgICAgICB9KSwgdGhpcy5tYXJrU2VsZWN0ZWRTbGlkZXMoKTtcbiAgICAgIH1cblxuICAgICAgY3JlYXRlU2xpZGVFbCh0KSB7XG4gICAgICAgIGlmICghdCkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0LiRlbCkge1xuICAgICAgICAgIGxldCBlID0gdC4kZWwuZGF0YXNldC5pbmRleDtcblxuICAgICAgICAgIGlmICghZSB8fCBwYXJzZUludChlLCAxMCkgIT09IHQuaW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBlO1xuICAgICAgICAgICAgdC4kZWwuZGF0YXNldC5pbmRleCA9IHQuaW5kZXgsIHQuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1sYXp5LXNyY3NldF1cIikuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgdC5zcmNzZXQgPSB0LmRhdGFzZXQubGF6eVNyY3NldDtcbiAgICAgICAgICAgIH0pLCB0LiRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtbGF6eS1zcmNdXCIpLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgICAgIGxldCBlID0gdC5kYXRhc2V0LmxhenlTcmM7XG4gICAgICAgICAgICAgIHQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ID8gdC5zcmMgPSBlIDogdC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke2V9JylgO1xuICAgICAgICAgICAgfSksIChlID0gdC4kZWwuZGF0YXNldC5sYXp5U3JjKSAmJiAodC4kZWwuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgnJHtlfScpYCksIHQuc3RhdGUgPSBcInJlYWR5XCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGUuZGF0YXNldC5pbmRleCA9IHQuaW5kZXgsIGUuY2xhc3NMaXN0LmFkZCguLi4odGhpcy5vcHRpb24oXCJwcmVmaXhcIikgKyB0aGlzLm9wdGlvbihcImNsYXNzTmFtZXMuc2xpZGVcIikpLnNwbGl0KFwiIFwiKSksIHQuY3VzdG9tQ2xhc3MgJiYgZS5jbGFzc0xpc3QuYWRkKC4uLnQuY3VzdG9tQ2xhc3Muc3BsaXQoXCIgXCIpKSwgdC5odG1sICYmIChlLmlubmVySFRNTCA9IHQuaHRtbCk7XG4gICAgICAgIGNvbnN0IGkgPSBbXTtcbiAgICAgICAgdGhpcy5zbGlkZXMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgICAgIHQuJGVsICYmIGkucHVzaChlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHMgPSB0LmluZGV4O1xuICAgICAgICBsZXQgbyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGkubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IHQgPSBpLnJlZHVjZSgodCwgZSkgPT4gTWF0aC5hYnMoZSAtIHMpIDwgTWF0aC5hYnModCAtIHMpID8gZSA6IHQpO1xuICAgICAgICAgIG8gPSB0aGlzLnNsaWRlc1t0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLiR0cmFjay5pbnNlcnRCZWZvcmUoZSwgbyAmJiBvLiRlbCA/IG8uaW5kZXggPCB0LmluZGV4ID8gby4kZWwubmV4dFNpYmxpbmcgOiBvLiRlbCA6IG51bGwpLCB0LiRlbCA9IGUsIHRoaXMudHJpZ2dlcihcImNyZWF0ZVNsaWRlXCIsIHQsIHMpLCB0O1xuICAgICAgfVxuXG4gICAgICByZW1vdmVTbGlkZUVsKHQpIHtcbiAgICAgICAgdC4kZWwgJiYgIXQuaXNEb20gJiYgKHRoaXMudHJpZ2dlcihcInJlbW92ZVNsaWRlXCIsIHQpLCB0LiRlbC5yZW1vdmUoKSwgdC4kZWwgPSBudWxsKTtcbiAgICAgIH1cblxuICAgICAgbWFya1NlbGVjdGVkU2xpZGVzKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5vcHRpb24oXCJjbGFzc05hbWVzLnNsaWRlU2VsZWN0ZWRcIiksXG4gICAgICAgICAgICAgIGUgPSBcImFyaWEtaGlkZGVuXCI7XG4gICAgICAgIHRoaXMuc2xpZGVzLmZvckVhY2goKGksIHMpID0+IHtcbiAgICAgICAgICBjb25zdCBvID0gaS4kZWw7XG4gICAgICAgICAgaWYgKCFvKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgbiA9IHRoaXMucGFnZXNbdGhpcy5wYWdlXTtcbiAgICAgICAgICBuICYmIG4uaW5kZXhlcyAmJiBuLmluZGV4ZXMuaW5kZXhPZihzKSA+IC0xID8gKHQgJiYgIW8uY2xhc3NMaXN0LmNvbnRhaW5zKHQpICYmIChvLmNsYXNzTGlzdC5hZGQodCksIHRoaXMudHJpZ2dlcihcInNlbGVjdFNsaWRlXCIsIGkpKSwgby5yZW1vdmVBdHRyaWJ1dGUoZSkpIDogKHQgJiYgby5jbGFzc0xpc3QuY29udGFpbnModCkgJiYgKG8uY2xhc3NMaXN0LnJlbW92ZSh0KSwgdGhpcy50cmlnZ2VyKFwidW5zZWxlY3RTbGlkZVwiLCBpKSksIG8uc2V0QXR0cmlidXRlKGUsICEwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVQYWdlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1ldHJpY3MoKSwgdGhpcy5zbGlkZVRvKHRoaXMucGFnZSwge1xuICAgICAgICAgIGZyaWN0aW9uOiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBvbkJlZm9yZVRyYW5zZm9ybSgpIHtcbiAgICAgICAgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVhcIiwgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVwiKSkgJiYgdGhpcy5tYW5hZ2VJbmZpbml0ZVRyYWNrKCksIHRoaXMubWFuYWdlU2xpZGVWaXNpYmxpdHkoKTtcbiAgICAgIH1cblxuICAgICAgbWFuYWdlSW5maW5pdGVUcmFjaygpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuY29udGVudFdpZHRoLFxuICAgICAgICAgICAgICBlID0gdGhpcy52aWV3cG9ydFdpZHRoO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uKFwiaW5maW5pdGVYXCIsIHRoaXMub3B0aW9uKFwiaW5maW5pdGVcIikpIHx8IHRoaXMucGFnZXMubGVuZ3RoIDwgMiB8fCB0IDwgZSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBpID0gdGhpcy5QYW56b29tO1xuICAgICAgICBsZXQgcyA9ICExO1xuICAgICAgICByZXR1cm4gaS5jb250ZW50LnggPCAtMSAqICh0IC0gZSkgJiYgKGkuY29udGVudC54ICs9IHQsIHRoaXMucGFnZUluZGV4ID0gdGhpcy5wYWdlSW5kZXggLSB0aGlzLnBhZ2VzLmxlbmd0aCwgcyA9ICEwKSwgaS5jb250ZW50LnggPiBlICYmIChpLmNvbnRlbnQueCAtPSB0LCB0aGlzLnBhZ2VJbmRleCA9IHRoaXMucGFnZUluZGV4ICsgdGhpcy5wYWdlcy5sZW5ndGgsIHMgPSAhMCksIHMgJiYgXCJwb2ludGVyZG93blwiID09PSBpLnN0YXRlICYmIGkucmVzZXREcmFnUG9zaXRpb24oKSwgcztcbiAgICAgIH1cblxuICAgICAgb25Ub3VjaEVuZCh0LCBlKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLm9wdGlvbihcImRyYWdGcmVlXCIpO1xuICAgICAgICBpZiAoIWkgJiYgdGhpcy5wYWdlcy5sZW5ndGggPiAxICYmIHQuZHJhZ09mZnNldC50aW1lIDwgMzUwICYmIE1hdGguYWJzKHQuZHJhZ09mZnNldC55KSA8IDEgJiYgTWF0aC5hYnModC5kcmFnT2Zmc2V0LngpID4gNSkgdGhpc1t0LmRyYWdPZmZzZXQueCA8IDAgPyBcInNsaWRlTmV4dFwiIDogXCJzbGlkZVByZXZcIl0oKTtlbHNlIGlmIChpKSB7XG4gICAgICAgICAgY29uc3QgWywgZV0gPSB0aGlzLmdldFBhZ2VGcm9tUG9zaXRpb24oLTEgKiB0LnRyYW5zZm9ybS54KTtcbiAgICAgICAgICB0aGlzLnNldFBhZ2UoZSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgICB9XG5cbiAgICAgIHNsaWRlVG9DbG9zZXN0KHQgPSB7fSkge1xuICAgICAgICBsZXQgWywgZV0gPSB0aGlzLmdldFBhZ2VGcm9tUG9zaXRpb24oLTEgKiB0aGlzLlBhbnpvb20uY29udGVudC54KTtcbiAgICAgICAgdGhpcy5zbGlkZVRvKGUsIHQpO1xuICAgICAgfVxuXG4gICAgICBnZXRQYWdlRnJvbVBvc2l0aW9uKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMucGFnZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLm9wdGlvbihcImNlbnRlclwiKSAmJiAodCArPSAuNSAqIHRoaXMudmlld3BvcnRXaWR0aCk7XG4gICAgICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKHQgLyB0aGlzLmNvbnRlbnRXaWR0aCk7XG4gICAgICAgIHQgLT0gaSAqIHRoaXMuY29udGVudFdpZHRoO1xuICAgICAgICBsZXQgcyA9IHRoaXMuc2xpZGVzLmZpbmQoZSA9PiBlLmxlZnQgPD0gdCAmJiBlLmxlZnQgKyBlLndpZHRoID4gdCk7XG5cbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICBsZXQgdCA9IHRoaXMuZmluZFBhZ2VGb3JTbGlkZShzLmluZGV4KTtcbiAgICAgICAgICByZXR1cm4gW3QsIHQgKyBpICogZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgfVxuXG4gICAgICBzZXRQYWdlKHQsIGUpIHtcbiAgICAgICAgbGV0IGkgPSAwLFxuICAgICAgICAgICAgcyA9IHBhcnNlSW50KHQsIDEwKSB8fCAwO1xuICAgICAgICBjb25zdCBvID0gdGhpcy5wYWdlLFxuICAgICAgICAgICAgICBuID0gdGhpcy5wYWdlSW5kZXgsXG4gICAgICAgICAgICAgIGEgPSB0aGlzLnBhZ2VzLmxlbmd0aCxcbiAgICAgICAgICAgICAgciA9IHRoaXMuY29udGVudFdpZHRoLFxuICAgICAgICAgICAgICBoID0gdGhpcy52aWV3cG9ydFdpZHRoO1xuXG4gICAgICAgIGlmICh0ID0gKHMgJSBhICsgYSkgJSBhLCB0aGlzLm9wdGlvbihcImluZmluaXRlWFwiLCB0aGlzLm9wdGlvbihcImluZmluaXRlXCIpKSAmJiByID4gaCkge1xuICAgICAgICAgIGNvbnN0IG8gPSBNYXRoLmZsb29yKHMgLyBhKSB8fCAwLFxuICAgICAgICAgICAgICAgIG4gPSByO1xuXG4gICAgICAgICAgaWYgKGkgPSB0aGlzLnBhZ2VzW3RdLmxlZnQgKyBvICogbiwgITAgPT09IGUgJiYgYSA+IDIpIHtcbiAgICAgICAgICAgIGxldCB0ID0gLTEgKiB0aGlzLlBhbnpvb20uY29udGVudC54O1xuICAgICAgICAgICAgY29uc3QgZSA9IGkgLSBuLFxuICAgICAgICAgICAgICAgICAgbyA9IGkgKyBuLFxuICAgICAgICAgICAgICAgICAgciA9IE1hdGguYWJzKHQgLSBpKSxcbiAgICAgICAgICAgICAgICAgIGggPSBNYXRoLmFicyh0IC0gZSksXG4gICAgICAgICAgICAgICAgICBsID0gTWF0aC5hYnModCAtIG8pO1xuICAgICAgICAgICAgbCA8IHIgJiYgbCA8PSBoID8gKGkgPSBvLCBzICs9IGEpIDogaCA8IHIgJiYgaCA8IGwgJiYgKGkgPSBlLCBzIC09IGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHQgPSBzID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocywgYSAtIDEpKSwgaSA9IHRoaXMucGFnZXMubGVuZ3RoID8gdGhpcy5wYWdlc1t0XS5sZWZ0IDogMDtcblxuICAgICAgICByZXR1cm4gdGhpcy5wYWdlID0gdCwgdGhpcy5wYWdlSW5kZXggPSBzLCBudWxsICE9PSBvICYmIHQgIT09IG8gJiYgKHRoaXMucHJldlBhZ2UgPSBvLCB0aGlzLnByZXZQYWdlSW5kZXggPSBuLCB0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIiwgdCwgbykpLCBpO1xuICAgICAgfVxuXG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJkZXN0cm95XCIsIHRoaXMuc2xpZGVzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTbGlkZUVsKHQpO1xuICAgICAgICB9KSwgdGhpcy5zbGlkZXMgPSBbXSwgdGhpcy5QYW56b29tLmRlc3Ryb3koKSwgdGhpcy5kZXRhY2hQbHVnaW5zKCk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB5LnZlcnNpb24gPSBcIjQuMC4zMVwiLCB5LlBsdWdpbnMgPSBwO1xuICAgIGNvbnN0IHYgPSAhKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIHdpbmRvdyB8fCAhd2luZG93LmRvY3VtZW50IHx8ICF3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG4gICAgbGV0IGIgPSBudWxsO1xuXG4gICAgY29uc3QgeCA9IFtcImFbaHJlZl1cIiwgXCJhcmVhW2hyZWZdXCIsICdpbnB1dDpub3QoW2Rpc2FibGVkXSk6bm90KFt0eXBlPVwiaGlkZGVuXCJdKTpub3QoW2FyaWEtaGlkZGVuXSknLCBcInNlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pXCIsIFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pOm5vdChbYXJpYS1oaWRkZW5dKVwiLCBcImJ1dHRvbjpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pXCIsIFwiaWZyYW1lXCIsIFwib2JqZWN0XCIsIFwiZW1iZWRcIiwgXCJ2aWRlb1wiLCBcImF1ZGlvXCIsIFwiW2NvbnRlbnRlZGl0YWJsZV1cIiwgJ1t0YWJpbmRleF06bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pJ10sXG4gICAgICAgICAgdyA9IHQgPT4ge1xuICAgICAgaWYgKHQgJiYgdikge1xuICAgICAgICBudWxsID09PSBiICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuZm9jdXMoe1xuICAgICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcmV0dXJuIGIgPSAhMCwgITE7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHQuc2V0QWN0aXZlKSB0LnNldEFjdGl2ZSgpO2Vsc2UgaWYgKGIpIHQuZm9jdXMoe1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbDogITBcbiAgICAgICAgICB9KTtlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICBpID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHQuZm9jdXMoKSwgZG9jdW1lbnQuYm9keS5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgIHRvcDogZSxcbiAgICAgICAgICAgICAgbGVmdDogaSxcbiAgICAgICAgICAgICAgYmVoYXZpb3I6IFwiYXV0b1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHQpIHt9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0ICQkMSA9IHtcbiAgICAgIG1pblNsaWRlQ291bnQ6IDIsXG4gICAgICBtaW5TY3JlZW5IZWlnaHQ6IDUwMCxcbiAgICAgIGF1dG9TdGFydDogITAsXG4gICAgICBrZXk6IFwidFwiLFxuICAgICAgQ2Fyb3VzZWw6IHt9LFxuICAgICAgdHBsOiAnPGRpdiBjbGFzcz1cImZhbmN5Ym94X190aHVtYlwiIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTp1cmwoXFwne3tzcmN9fVxcJylcIj48L2Rpdj4nXG4gICAgfTtcblxuICAgIGNsYXNzIEMge1xuICAgICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLmZhbmN5Ym94ID0gdCwgdGhpcy4kY29udGFpbmVyID0gbnVsbCwgdGhpcy5zdGF0ZSA9IFwiaW5pdFwiO1xuXG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBbXCJvblByZXBhcmVcIiwgXCJvbkNsb3NpbmdcIiwgXCJvbktleWRvd25cIl0pIHRoaXNbdF0gPSB0aGlzW3RdLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICAgcHJlcGFyZTogdGhpcy5vblByZXBhcmUsXG4gICAgICAgICAgY2xvc2luZzogdGhpcy5vbkNsb3NpbmcsXG4gICAgICAgICAga2V5ZG93bjogdGhpcy5vbktleWRvd25cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb25QcmVwYXJlKCkge1xuICAgICAgICB0aGlzLmdldFNsaWRlcygpLmxlbmd0aCA8IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiVGh1bWJzLm1pblNsaWRlQ291bnRcIikgPyB0aGlzLnN0YXRlID0gXCJkaXNhYmxlZFwiIDogITAgPT09IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiVGh1bWJzLmF1dG9TdGFydFwiKSAmJiB0aGlzLmZhbmN5Ym94LkNhcm91c2VsLlBhbnpvb20uY29udGVudC5oZWlnaHQgPj0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJUaHVtYnMubWluU2NyZWVuSGVpZ2h0XCIpICYmIHRoaXMuYnVpbGQoKTtcbiAgICAgIH1cblxuICAgICAgb25DbG9zaW5nKCkge1xuICAgICAgICB0aGlzLkNhcm91c2VsICYmIHRoaXMuQ2Fyb3VzZWwuUGFuem9vbS5kZXRhY2hFdmVudHMoKTtcbiAgICAgIH1cblxuICAgICAgb25LZXlkb3duKHQsIGUpIHtcbiAgICAgICAgZSA9PT0gdC5vcHRpb24oXCJUaHVtYnMua2V5XCIpICYmIHRoaXMudG9nZ2xlKCk7XG4gICAgICB9XG5cbiAgICAgIGJ1aWxkKCkge1xuICAgICAgICBpZiAodGhpcy4kY29udGFpbmVyKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0LmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveF9fdGh1bWJzXCIpLCB0aGlzLmZhbmN5Ym94LiRjYXJvdXNlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LCB0aGlzLmZhbmN5Ym94LiRjYXJvdXNlbC5uZXh0U2libGluZyksIHRoaXMuQ2Fyb3VzZWwgPSBuZXcgeSh0LCBlKCEwLCB7XG4gICAgICAgICAgRG90czogITEsXG4gICAgICAgICAgTmF2aWdhdGlvbjogITEsXG4gICAgICAgICAgU3luYzoge1xuICAgICAgICAgICAgZnJpY3Rpb246IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluZmluaXRlOiAhMSxcbiAgICAgICAgICBjZW50ZXI6ICEwLFxuICAgICAgICAgIGZpbGw6ICEwLFxuICAgICAgICAgIGRyYWdGcmVlOiAhMCxcbiAgICAgICAgICBzbGlkZXNQZXJQYWdlOiAxLFxuICAgICAgICAgIHByZWxvYWQ6IDFcbiAgICAgICAgfSwgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJUaHVtYnMuQ2Fyb3VzZWxcIiksIHtcbiAgICAgICAgICBTeW5jOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuZmFuY3lib3guQ2Fyb3VzZWxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNsaWRlczogdGhpcy5nZXRTbGlkZXMoKVxuICAgICAgICB9KSksIHRoaXMuQ2Fyb3VzZWwuUGFuem9vbS5vbihcIndoZWVsXCIsICh0LCBlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmZhbmN5Ym94W2UuZGVsdGFZIDwgMCA/IFwicHJldlwiIDogXCJuZXh0XCJdKCk7XG4gICAgICAgIH0pLCB0aGlzLiRjb250YWluZXIgPSB0LCB0aGlzLnN0YXRlID0gXCJ2aXNpYmxlXCI7XG4gICAgICB9XG5cbiAgICAgIGdldFNsaWRlcygpIHtcbiAgICAgICAgY29uc3QgdCA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmZhbmN5Ym94Lml0ZW1zKSB7XG4gICAgICAgICAgY29uc3QgaSA9IGUudGh1bWI7XG4gICAgICAgICAgaSAmJiB0LnB1c2goe1xuICAgICAgICAgICAgaHRtbDogdGhpcy5mYW5jeWJveC5vcHRpb24oXCJUaHVtYnMudHBsXCIpLnJlcGxhY2UoL1xce1xce3NyY1xcfVxcfS9naSwgaSksXG4gICAgICAgICAgICBjdXN0b21DbGFzczogYGhhcy10aHVtYiBoYXMtJHtlLnR5cGUgfHwgXCJpbWFnZVwifWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuXG4gICAgICB0b2dnbGUoKSB7XG4gICAgICAgIFwidmlzaWJsZVwiID09PSB0aGlzLnN0YXRlID8gdGhpcy5oaWRlKCkgOiBcImhpZGRlblwiID09PSB0aGlzLnN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmJ1aWxkKCk7XG4gICAgICB9XG5cbiAgICAgIHNob3coKSB7XG4gICAgICAgIFwiaGlkZGVuXCIgPT09IHRoaXMuc3RhdGUgJiYgKHRoaXMuJGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJcIiwgdGhpcy5DYXJvdXNlbC5QYW56b29tLmF0dGFjaEV2ZW50cygpLCB0aGlzLnN0YXRlID0gXCJ2aXNpYmxlXCIpO1xuICAgICAgfVxuXG4gICAgICBoaWRlKCkge1xuICAgICAgICBcInZpc2libGVcIiA9PT0gdGhpcy5zdGF0ZSAmJiAodGhpcy5DYXJvdXNlbC5QYW56b29tLmRldGFjaEV2ZW50cygpLCB0aGlzLiRjb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCB0aGlzLnN0YXRlID0gXCJoaWRkZW5cIik7XG4gICAgICB9XG5cbiAgICAgIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuQ2Fyb3VzZWwgJiYgKHRoaXMuQ2Fyb3VzZWwuZGVzdHJveSgpLCB0aGlzLkNhcm91c2VsID0gbnVsbCksIHRoaXMuJGNvbnRhaW5lciAmJiAodGhpcy4kY29udGFpbmVyLnJlbW92ZSgpLCB0aGlzLiRjb250YWluZXIgPSBudWxsKSwgdGhpcy5zdGF0ZSA9IFwiaW5pdFwiO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2goKSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3gub24odGhpcy5ldmVudHMpO1xuICAgICAgfVxuXG4gICAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3gub2ZmKHRoaXMuZXZlbnRzKSwgdGhpcy5jbGVhbnVwKCk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBDLmRlZmF1bHRzID0gJCQxO1xuXG4gICAgY29uc3QgUyA9ICh0LCBlKSA9PiB7XG4gICAgICBjb25zdCBpID0gbmV3IFVSTCh0KSxcbiAgICAgICAgICAgIHMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGkuc2VhcmNoKTtcbiAgICAgIGxldCBvID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gICAgICBmb3IgKGNvbnN0IFt0LCBpXSBvZiBbLi4ucywgLi4uT2JqZWN0LmVudHJpZXMoZSldKSBcInRcIiA9PT0gdCA/IG8uc2V0KFwic3RhcnRcIiwgcGFyc2VJbnQoaSkpIDogby5zZXQodCwgaSk7XG5cbiAgICAgIG8gPSBvLnRvU3RyaW5nKCk7XG4gICAgICBsZXQgbiA9IHQubWF0Y2goLyN0PSgoLiopP1xcZCtzKS8pO1xuICAgICAgcmV0dXJuIG4gJiYgKG8gKz0gYCN0PSR7blsxXX1gKSwgbztcbiAgICB9LFxuICAgICAgICAgIEUgPSB7XG4gICAgICB2aWRlbzoge1xuICAgICAgICBhdXRvcGxheTogITAsXG4gICAgICAgIHJhdGlvOiAxNiAvIDlcbiAgICAgIH0sXG4gICAgICB5b3V0dWJlOiB7XG4gICAgICAgIGF1dG9oaWRlOiAxLFxuICAgICAgICBmczogMSxcbiAgICAgICAgcmVsOiAwLFxuICAgICAgICBoZDogMSxcbiAgICAgICAgd21vZGU6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgZW5hYmxlanNhcGk6IDEsXG4gICAgICAgIGh0bWw1OiAxXG4gICAgICB9LFxuICAgICAgdmltZW86IHtcbiAgICAgICAgaGQ6IDEsXG4gICAgICAgIHNob3dfdGl0bGU6IDEsXG4gICAgICAgIHNob3dfYnlsaW5lOiAxLFxuICAgICAgICBzaG93X3BvcnRyYWl0OiAwLFxuICAgICAgICBmdWxsc2NyZWVuOiAxXG4gICAgICB9LFxuICAgICAgaHRtbDV2aWRlbzoge1xuICAgICAgICB0cGw6ICc8dmlkZW8gY2xhc3M9XCJmYW5jeWJveF9faHRtbDV2aWRlb1wiIHBsYXlzaW5saW5lIGNvbnRyb2xzIGNvbnRyb2xzTGlzdD1cIm5vZG93bmxvYWRcIiBwb3N0ZXI9XCJ7e3Bvc3Rlcn19XCI+XFxuICA8c291cmNlIHNyYz1cInt7c3JjfX1cIiB0eXBlPVwie3tmb3JtYXR9fVwiIC8+U29ycnksIHlvdXIgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCBlbWJlZGRlZCB2aWRlb3MuPC92aWRlbz4nLFxuICAgICAgICBmb3JtYXQ6IFwiXCJcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2xhc3MgUCB7XG4gICAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3ggPSB0O1xuXG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBbXCJvbkluaXRcIiwgXCJvblJlYWR5XCIsIFwib25DcmVhdGVTbGlkZVwiLCBcIm9uUmVtb3ZlU2xpZGVcIiwgXCJvblNlbGVjdFNsaWRlXCIsIFwib25VbnNlbGVjdFNsaWRlXCIsIFwib25SZWZyZXNoXCIsIFwib25NZXNzYWdlXCJdKSB0aGlzW3RdID0gdGhpc1t0XS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgICAgIGluaXQ6IHRoaXMub25Jbml0LFxuICAgICAgICAgIHJlYWR5OiB0aGlzLm9uUmVhZHksXG4gICAgICAgICAgXCJDYXJvdXNlbC5jcmVhdGVTbGlkZVwiOiB0aGlzLm9uQ3JlYXRlU2xpZGUsXG4gICAgICAgICAgXCJDYXJvdXNlbC5yZW1vdmVTbGlkZVwiOiB0aGlzLm9uUmVtb3ZlU2xpZGUsXG4gICAgICAgICAgXCJDYXJvdXNlbC5zZWxlY3RTbGlkZVwiOiB0aGlzLm9uU2VsZWN0U2xpZGUsXG4gICAgICAgICAgXCJDYXJvdXNlbC51bnNlbGVjdFNsaWRlXCI6IHRoaXMub25VbnNlbGVjdFNsaWRlLFxuICAgICAgICAgIFwiQ2Fyb3VzZWwucmVmcmVzaFwiOiB0aGlzLm9uUmVmcmVzaFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvbkluaXQoKSB7XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLmZhbmN5Ym94Lml0ZW1zKSB0aGlzLnByb2Nlc3NUeXBlKHQpO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzVHlwZSh0KSB7XG4gICAgICAgIGlmICh0Lmh0bWwpIHJldHVybiB0LnNyYyA9IHQuaHRtbCwgdC50eXBlID0gXCJodG1sXCIsIHZvaWQgZGVsZXRlIHQuaHRtbDtcbiAgICAgICAgY29uc3QgaSA9IHQuc3JjIHx8IFwiXCI7XG4gICAgICAgIGxldCBzID0gdC50eXBlIHx8IHRoaXMuZmFuY3lib3gub3B0aW9ucy50eXBlLFxuICAgICAgICAgICAgbyA9IG51bGw7XG5cbiAgICAgICAgaWYgKCFpIHx8IFwic3RyaW5nXCIgPT0gdHlwZW9mIGkpIHtcbiAgICAgICAgICBpZiAobyA9IGkubWF0Y2goLyg/OnlvdXR1YmVcXC5jb218eW91dHVcXC5iZXx5b3V0dWJlXFwtbm9jb29raWVcXC5jb20pXFwvKD86d2F0Y2hcXD8oPzouKiYpP3Y9fHZcXC98dVxcL3xlbWJlZFxcLz8pPyh2aWRlb3Nlcmllc1xcP2xpc3Q9KD86LiopfFtcXHctXXsxMX18XFw/bGlzdFR5cGU9KD86LiopJmxpc3Q9KD86LiopKSg/Oi4qKS9pKSkge1xuICAgICAgICAgICAgY29uc3QgZSA9IFMoaSwgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJIdG1sLnlvdXR1YmVcIikpLFxuICAgICAgICAgICAgICAgICAgbiA9IGVuY29kZVVSSUNvbXBvbmVudChvWzFdKTtcbiAgICAgICAgICAgIHQudmlkZW9JZCA9IG4sIHQuc3JjID0gYGh0dHBzOi8vd3d3LnlvdXR1YmUtbm9jb29raWUuY29tL2VtYmVkLyR7bn0/JHtlfWAsIHQudGh1bWIgPSB0LnRodW1iIHx8IGBodHRwczovL2kueXRpbWcuY29tL3ZpLyR7bn0vbXFkZWZhdWx0LmpwZ2AsIHQudmVuZG9yID0gXCJ5b3V0dWJlXCIsIHMgPSBcInZpZGVvXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChvID0gaS5tYXRjaCgvXi4rdmltZW8uY29tXFwvKD86XFwvKT8oW1xcZF0rKSguKik/LykpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBTKGksIHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSHRtbC52aW1lb1wiKSksXG4gICAgICAgICAgICAgICAgICBuID0gZW5jb2RlVVJJQ29tcG9uZW50KG9bMV0pO1xuICAgICAgICAgICAgdC52aWRlb0lkID0gbiwgdC5zcmMgPSBgaHR0cHM6Ly9wbGF5ZXIudmltZW8uY29tL3ZpZGVvLyR7bn0/JHtlfWAsIHQudmVuZG9yID0gXCJ2aW1lb1wiLCBzID0gXCJ2aWRlb1wiO1xuICAgICAgICAgIH0gZWxzZSAobyA9IGkubWF0Y2goLyg/Om1hcHNcXC4pP2dvb2dsZVxcLihbYS16XXsyLDN9KD86XFwuW2Etel17Mn0pPylcXC8oPzooPzooPzptYXBzXFwvKD86cGxhY2VcXC8oPzouKilcXC8pP1xcQCguKiksKFxcZCsuP1xcZCs/KXopKXwoPzpcXD9sbD0pKSguKik/L2kpKSA/ICh0LnNyYyA9IGAvL21hcHMuZ29vZ2xlLiR7b1sxXX0vP2xsPSR7KG9bMl0gPyBvWzJdICsgXCImej1cIiArIE1hdGguZmxvb3Iob1szXSkgKyAob1s0XSA/IG9bNF0ucmVwbGFjZSgvXlxcLy8sIFwiJlwiKSA6IFwiXCIpIDogb1s0XSArIFwiXCIpLnJlcGxhY2UoL1xcPy8sIFwiJlwiKX0mb3V0cHV0PSR7b1s0XSAmJiBvWzRdLmluZGV4T2YoXCJsYXllcj1jXCIpID4gMCA/IFwic3ZlbWJlZFwiIDogXCJlbWJlZFwifWAsIHMgPSBcIm1hcFwiKSA6IChvID0gaS5tYXRjaCgvKD86bWFwc1xcLik/Z29vZ2xlXFwuKFthLXpdezIsM30oPzpcXC5bYS16XXsyfSk/KVxcLyg/Om1hcHNcXC9zZWFyY2hcXC8pKC4qKS9pKSkgJiYgKHQuc3JjID0gYC8vbWFwcy5nb29nbGUuJHtvWzFdfS9tYXBzP3E9JHtvWzJdLnJlcGxhY2UoXCJxdWVyeT1cIiwgXCJxPVwiKS5yZXBsYWNlKFwiYXBpPTFcIiwgXCJcIil9Jm91dHB1dD1lbWJlZGAsIHMgPSBcIm1hcFwiKTtcblxuICAgICAgICAgIHMgfHwgKFwiI1wiID09PSBpLmNoYXJBdCgwKSA/IHMgPSBcImlubGluZVwiIDogKG8gPSBpLm1hdGNoKC9cXC4obXA0fG1vdnxvZ3Z8d2VibSkoKFxcP3wjKS4qKT8kL2kpKSA/IChzID0gXCJodG1sNXZpZGVvXCIsIHQuZm9ybWF0ID0gdC5mb3JtYXQgfHwgXCJ2aWRlby9cIiArIChcIm9ndlwiID09PSBvWzFdID8gXCJvZ2dcIiA6IG9bMV0pKSA6IGkubWF0Y2goLyheZGF0YTppbWFnZVxcL1thLXowLTkrXFwvPV0qLCl8KFxcLihqcChlfGd8ZWcpfGdpZnxwbmd8Ym1wfHdlYnB8c3ZnfGljbykoKFxcP3wjKS4qKT8kKS9pKSA/IHMgPSBcImltYWdlXCIgOiBpLm1hdGNoKC9cXC4ocGRmKSgoXFw/fCMpLiopPyQvaSkgJiYgKHMgPSBcInBkZlwiKSksIHQudHlwZSA9IHMgfHwgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJkZWZhdWx0VHlwZVwiLCBcImltYWdlXCIpLCBcImh0bWw1dmlkZW9cIiAhPT0gcyAmJiBcInZpZGVvXCIgIT09IHMgfHwgKHQudmlkZW8gPSBlKHt9LCB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkh0bWwudmlkZW9cIiksIHQudmlkZW8pLCB0Ll93aWR0aCAmJiB0Ll9oZWlnaHQgPyB0LnJhdGlvID0gcGFyc2VGbG9hdCh0Ll93aWR0aCkgLyBwYXJzZUZsb2F0KHQuX2hlaWdodCkgOiB0LnJhdGlvID0gdC5yYXRpbyB8fCB0LnZpZGVvLnJhdGlvIHx8IEUudmlkZW8ucmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uUmVhZHkoKSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3guQ2Fyb3VzZWwuc2xpZGVzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgdC4kZWwgJiYgKHRoaXMuc2V0Q29udGVudCh0KSwgdC5pbmRleCA9PT0gdGhpcy5mYW5jeWJveC5nZXRTbGlkZSgpLmluZGV4ICYmIHRoaXMucGxheVZpZGVvKHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG9uQ3JlYXRlU2xpZGUodCwgZSwgaSkge1xuICAgICAgICBcInJlYWR5XCIgPT09IHRoaXMuZmFuY3lib3guc3RhdGUgJiYgdGhpcy5zZXRDb250ZW50KGkpO1xuICAgICAgfVxuXG4gICAgICBsb2FkSW5saW5lQ29udGVudCh0KSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBpZiAodC5zcmMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgZSA9IHQuc3JjO2Vsc2UgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQuc3JjKSB7XG4gICAgICAgICAgY29uc3QgaSA9IHQuc3JjLnNwbGl0KFwiI1wiLCAyKSxcbiAgICAgICAgICAgICAgICBzID0gMiA9PT0gaS5sZW5ndGggJiYgXCJcIiA9PT0gaVswXSA/IGlbMV0gOiBpWzBdO1xuICAgICAgICAgIGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgaWYgKFwiY2xvbmVcIiA9PT0gdC50eXBlIHx8IGUuJHBsYWNlSG9sZGVyKSB7XG4gICAgICAgICAgICBlID0gZS5jbG9uZU5vZGUoITApO1xuICAgICAgICAgICAgbGV0IGkgPSBlLmdldEF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICAgICAgaSA9IGkgPyBgJHtpfS0tY2xvbmVgIDogYGNsb25lLSR7dGhpcy5mYW5jeWJveC5pZH0tJHt0LmluZGV4fWAsIGUuc2V0QXR0cmlidXRlKFwiaWRcIiwgaSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdC5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3gtcGxhY2Vob2xkZXJcIiksIGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodCwgZSksIGUuJHBsYWNlSG9sZGVyID0gdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZhbmN5Ym94LnNldENvbnRlbnQodCwgZSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLmZhbmN5Ym94LnNldEVycm9yKHQsIFwie3tFTEVNRU5UX05PVF9GT1VORH19XCIpO1xuICAgICAgfVxuXG4gICAgICBsb2FkQWpheENvbnRlbnQodCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5mYW5jeWJveCxcbiAgICAgICAgICAgICAgaSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICBlLnNob3dMb2FkaW5nKHQpLCBpLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgJiYgXCJyZWFkeVwiID09PSBlLnN0YXRlICYmIChlLmhpZGVMb2FkaW5nKHQpLCAyMDAgPT09IGkuc3RhdHVzID8gZS5zZXRDb250ZW50KHQsIGkucmVzcG9uc2VUZXh0KSA6IGUuc2V0RXJyb3IodCwgNDA0ID09PSBpLnN0YXR1cyA/IFwie3tBSkFYX05PVF9GT1VORH19XCIgOiBcInt7QUpBWF9GT1JCSURERU59fVwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSB0LmFqYXggfHwgbnVsbDtcbiAgICAgICAgaS5vcGVuKHMgPyBcIlBPU1RcIiA6IFwiR0VUXCIsIHQuc3JjKSwgaS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpLCBpLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIiksIGkuc2VuZChzKSwgdC54aHIgPSBpO1xuICAgICAgfVxuXG4gICAgICBsb2FkSWZyYW1lQ29udGVudCh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmZhbmN5Ym94LFxuICAgICAgICAgICAgICBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgaWYgKGkuY2xhc3NOYW1lID0gXCJmYW5jeWJveF9faWZyYW1lXCIsIGkuc2V0QXR0cmlidXRlKFwiaWRcIiwgYGZhbmN5Ym94X19pZnJhbWVfJHtlLmlkfV8ke3QuaW5kZXh9YCksIGkuc2V0QXR0cmlidXRlKFwiYWxsb3dcIiwgXCJhdXRvcGxheTsgZnVsbHNjcmVlblwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJzY3JvbGxpbmdcIiwgXCJhdXRvXCIpLCB0LiRpZnJhbWUgPSBpLCBcImlmcmFtZVwiICE9PSB0LnR5cGUgfHwgITEgPT09IHQucHJlbG9hZCkgcmV0dXJuIGkuc2V0QXR0cmlidXRlKFwic3JjXCIsIHQuc3JjKSwgdGhpcy5mYW5jeWJveC5zZXRDb250ZW50KHQsIGkpLCB2b2lkIHRoaXMucmVzaXplSWZyYW1lKHQpO1xuICAgICAgICBlLnNob3dMb2FkaW5nKHQpO1xuICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgcy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdGhpcy5mYW5jeWJveC5zZXRDb250ZW50KHQsIHMpLCBzLmFwcGVuZENoaWxkKGkpLCBpLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgZS5zZXRFcnJvcih0LCBcInt7SUZSQU1FX0VSUk9SfX1cIik7XG4gICAgICAgIH0sIGkub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIGUuaGlkZUxvYWRpbmcodCk7XG4gICAgICAgICAgbGV0IHMgPSAhMTtcbiAgICAgICAgICBpLmlzUmVhZHkgfHwgKGkuaXNSZWFkeSA9ICEwLCBzID0gITApLCBpLnNyYy5sZW5ndGggJiYgKGkucGFyZW50Tm9kZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIiwgdGhpcy5yZXNpemVJZnJhbWUodCksIHMgJiYgZS5yZXZlYWxDb250ZW50KHQpKTtcbiAgICAgICAgfSwgaS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdC5zcmMpO1xuICAgICAgfVxuXG4gICAgICBzZXRBc3BlY3RSYXRpbyh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0LiRjb250ZW50LFxuICAgICAgICAgICAgICBpID0gdC5yYXRpbztcbiAgICAgICAgaWYgKCFlKSByZXR1cm47XG4gICAgICAgIGxldCBzID0gdC5fd2lkdGgsXG4gICAgICAgICAgICBvID0gdC5faGVpZ2h0O1xuXG4gICAgICAgIGlmIChpIHx8IHMgJiYgbykge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZS5zdHlsZSwge1xuICAgICAgICAgICAgd2lkdGg6IHMgJiYgbyA/IFwiMTAwJVwiIDogXCJcIixcbiAgICAgICAgICAgIGhlaWdodDogcyAmJiBvID8gXCIxMDAlXCIgOiBcIlwiLFxuICAgICAgICAgICAgbWF4V2lkdGg6IFwiXCIsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgdCA9IGUub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgIG4gPSBlLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgIGlmIChzID0gcyB8fCB0LCBvID0gbyB8fCBuLCBzID4gdCB8fCBvID4gbikge1xuICAgICAgICAgICAgbGV0IGUgPSBNYXRoLm1pbih0IC8gcywgbiAvIG8pO1xuICAgICAgICAgICAgcyAqPSBlLCBvICo9IGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgTWF0aC5hYnMocyAvIG8gLSBpKSA+IC4wMSAmJiAoaSA8IHMgLyBvID8gcyA9IG8gKiBpIDogbyA9IHMgLyBpKSwgT2JqZWN0LmFzc2lnbihlLnN0eWxlLCB7XG4gICAgICAgICAgICB3aWR0aDogYCR7c31weGAsXG4gICAgICAgICAgICBoZWlnaHQ6IGAke299cHhgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzaXplSWZyYW1lKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHQuJGlmcmFtZTtcbiAgICAgICAgaWYgKCFlKSByZXR1cm47XG4gICAgICAgIGxldCBpID0gdC5fd2lkdGggfHwgMCxcbiAgICAgICAgICAgIHMgPSB0Ll9oZWlnaHQgfHwgMDtcbiAgICAgICAgaSAmJiBzICYmICh0LmF1dG9TaXplID0gITEpO1xuICAgICAgICBjb25zdCBvID0gZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICBuID0gbyAmJiBvLnN0eWxlO1xuICAgICAgICBpZiAoITEgIT09IHQucHJlbG9hZCAmJiAhMSAhPT0gdC5hdXRvU2l6ZSAmJiBuKSB0cnkge1xuICAgICAgICAgIGNvbnN0IHQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShvKSxcbiAgICAgICAgICAgICAgICBhID0gcGFyc2VGbG9hdCh0LnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQodC5wYWRkaW5nUmlnaHQpLFxuICAgICAgICAgICAgICAgIHIgPSBwYXJzZUZsb2F0KHQucGFkZGluZ1RvcCkgKyBwYXJzZUZsb2F0KHQucGFkZGluZ0JvdHRvbSksXG4gICAgICAgICAgICAgICAgaCA9IGUuY29udGVudFdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICBsID0gaC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImh0bWxcIilbMF0sXG4gICAgICAgICAgICAgICAgYyA9IGguYm9keTtcbiAgICAgICAgICBuLndpZHRoID0gXCJcIiwgYy5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIGkgPSBpIHx8IGwuc2Nyb2xsV2lkdGggKyBhLCBuLndpZHRoID0gYCR7aX1weGAsIGMuc3R5bGUub3ZlcmZsb3cgPSBcIlwiLCBuLmZsZXggPSBcIjAgMCBhdXRvXCIsIG4uaGVpZ2h0ID0gYCR7Yy5zY3JvbGxIZWlnaHR9cHhgLCBzID0gbC5zY3JvbGxIZWlnaHQgKyByO1xuICAgICAgICB9IGNhdGNoICh0KSB7fVxuXG4gICAgICAgIGlmIChpIHx8IHMpIHtcbiAgICAgICAgICBjb25zdCB0ID0ge1xuICAgICAgICAgICAgZmxleDogXCIwIDEgYXV0b1wiXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpICYmICh0LndpZHRoID0gYCR7aX1weGApLCBzICYmICh0LmhlaWdodCA9IGAke3N9cHhgKSwgT2JqZWN0LmFzc2lnbihuLCB0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvblJlZnJlc2godCwgZSkge1xuICAgICAgICBlLnNsaWRlcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIHQuJGVsICYmICh0LiRpZnJhbWUgJiYgdGhpcy5yZXNpemVJZnJhbWUodCksIHQucmF0aW8gJiYgdGhpcy5zZXRBc3BlY3RSYXRpbyh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzZXRDb250ZW50KHQpIHtcbiAgICAgICAgaWYgKHQgJiYgIXQuaXNEb20pIHtcbiAgICAgICAgICBzd2l0Y2ggKHQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICAgICAgdGhpcy5mYW5jeWJveC5zZXRDb250ZW50KHQsIHQuc3JjKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJodG1sNXZpZGVvXCI6XG4gICAgICAgICAgICAgIHRoaXMuZmFuY3lib3guc2V0Q29udGVudCh0LCB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkh0bWwuaHRtbDV2aWRlby50cGxcIikucmVwbGFjZSgvXFx7XFx7c3JjXFx9XFx9L2dpLCB0LnNyYykucmVwbGFjZShcInt7Zm9ybWF0fX1cIiwgdC5mb3JtYXQgfHwgdC5odG1sNXZpZGVvICYmIHQuaHRtbDV2aWRlby5mb3JtYXQgfHwgXCJcIikucmVwbGFjZShcInt7cG9zdGVyfX1cIiwgdC5wb3N0ZXIgfHwgdC50aHVtYiB8fCBcIlwiKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2xvbmVcIjpcbiAgICAgICAgICAgICAgdGhpcy5sb2FkSW5saW5lQ29udGVudCh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJhamF4XCI6XG4gICAgICAgICAgICAgIHRoaXMubG9hZEFqYXhDb250ZW50KHQpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInBkZlwiOlxuICAgICAgICAgICAgY2FzZSBcInZpZGVvXCI6XG4gICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgIHQucHJlbG9hZCA9ICExO1xuXG4gICAgICAgICAgICBjYXNlIFwiaWZyYW1lXCI6XG4gICAgICAgICAgICAgIHRoaXMubG9hZElmcmFtZUNvbnRlbnQodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdC5yYXRpbyAmJiB0aGlzLnNldEFzcGVjdFJhdGlvKHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uU2VsZWN0U2xpZGUodCwgZSwgaSkge1xuICAgICAgICBcInJlYWR5XCIgPT09IHQuc3RhdGUgJiYgdGhpcy5wbGF5VmlkZW8oaSk7XG4gICAgICB9XG5cbiAgICAgIHBsYXlWaWRlbyh0KSB7XG4gICAgICAgIGlmIChcImh0bWw1dmlkZW9cIiA9PT0gdC50eXBlICYmIHQudmlkZW8uYXV0b3BsYXkpIHRyeSB7XG4gICAgICAgICAgY29uc3QgZSA9IHQuJGVsLnF1ZXJ5U2VsZWN0b3IoXCJ2aWRlb1wiKTtcblxuICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gZS5wbGF5KCk7XG4gICAgICAgICAgICB2b2lkIDAgIT09IHQgJiYgdC50aGVuKCgpID0+IHt9KS5jYXRjaCh0ID0+IHtcbiAgICAgICAgICAgICAgZS5tdXRlZCA9ICEwLCBlLnBsYXkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAodCkge31cbiAgICAgICAgaWYgKFwidmlkZW9cIiAhPT0gdC50eXBlIHx8ICF0LiRpZnJhbWUgfHwgIXQuJGlmcmFtZS5jb250ZW50V2luZG93KSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoXCJkb25lXCIgPT09IHQuc3RhdGUgJiYgdC4kaWZyYW1lICYmIHQuJGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICBsZXQgZTtcbiAgICAgICAgICAgIGlmICh0LiRpZnJhbWUuaXNSZWFkeSkgcmV0dXJuIHQudmlkZW8gJiYgdC52aWRlby5hdXRvcGxheSAmJiAoZSA9IFwieW91dHViZVwiID09IHQudmVuZG9yID8ge1xuICAgICAgICAgICAgICBldmVudDogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgIGZ1bmM6IFwicGxheVZpZGVvXCJcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIG1ldGhvZDogXCJwbGF5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBcInRydWVcIlxuICAgICAgICAgICAgfSksIHZvaWQgKGUgJiYgdC4kaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoZSksIFwiKlwiKSk7XG4gICAgICAgICAgICBcInlvdXR1YmVcIiA9PT0gdC52ZW5kb3IgJiYgKGUgPSB7XG4gICAgICAgICAgICAgIGV2ZW50OiBcImxpc3RlbmluZ1wiLFxuICAgICAgICAgICAgICBpZDogdC4kaWZyYW1lLmdldEF0dHJpYnV0ZShcImlkXCIpXG4gICAgICAgICAgICB9LCB0LiRpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShlKSwgXCIqXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0LnBvbGxlciA9IHNldFRpbWVvdXQoZSwgMjUwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBlKCk7XG4gICAgICB9XG5cbiAgICAgIG9uVW5zZWxlY3RTbGlkZSh0LCBlLCBpKSB7XG4gICAgICAgIGlmIChcImh0bWw1dmlkZW9cIiA9PT0gaS50eXBlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGkuJGVsLnF1ZXJ5U2VsZWN0b3IoXCJ2aWRlb1wiKS5wYXVzZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKHQpIHt9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcyA9ICExO1xuICAgICAgICBcInZpbWVvXCIgPT0gaS52ZW5kb3IgPyBzID0ge1xuICAgICAgICAgIG1ldGhvZDogXCJwYXVzZVwiLFxuICAgICAgICAgIHZhbHVlOiBcInRydWVcIlxuICAgICAgICB9IDogXCJ5b3V0dWJlXCIgPT09IGkudmVuZG9yICYmIChzID0ge1xuICAgICAgICAgIGV2ZW50OiBcImNvbW1hbmRcIixcbiAgICAgICAgICBmdW5jOiBcInBhdXNlVmlkZW9cIlxuICAgICAgICB9KSwgcyAmJiBpLiRpZnJhbWUgJiYgaS4kaWZyYW1lLmNvbnRlbnRXaW5kb3cgJiYgaS4kaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkocyksIFwiKlwiKSwgY2xlYXJUaW1lb3V0KGkucG9sbGVyKTtcbiAgICAgIH1cblxuICAgICAgb25SZW1vdmVTbGlkZSh0LCBlLCBpKSB7XG4gICAgICAgIGkueGhyICYmIChpLnhoci5hYm9ydCgpLCBpLnhociA9IG51bGwpLCBpLiRpZnJhbWUgJiYgKGkuJGlmcmFtZS5vbmxvYWQgPSBpLiRpZnJhbWUub25lcnJvciA9IG51bGwsIGkuJGlmcmFtZS5zcmMgPSBcIi8vYWJvdXQ6YmxhbmtcIiwgaS4kaWZyYW1lID0gbnVsbCk7XG4gICAgICAgIGNvbnN0IHMgPSBpLiRjb250ZW50O1xuICAgICAgICBcImlubGluZVwiID09PSBpLnR5cGUgJiYgcyAmJiAocy5jbGFzc0xpc3QucmVtb3ZlKFwiZmFuY3lib3hfX2NvbnRlbnRcIiksIFwibm9uZVwiICE9PSBzLnN0eWxlLmRpc3BsYXkgJiYgKHMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKSksIGkuJGNsb3NlQnV0dG9uICYmIChpLiRjbG9zZUJ1dHRvbi5yZW1vdmUoKSwgaS4kY2xvc2VCdXR0b24gPSBudWxsKTtcbiAgICAgICAgY29uc3QgbyA9IHMgJiYgcy4kcGxhY2VIb2xkZXI7XG4gICAgICAgIG8gJiYgKG8ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocywgbyksIG8ucmVtb3ZlKCksIHMuJHBsYWNlSG9sZGVyID0gbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIG9uTWVzc2FnZSh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGUgPSBKU09OLnBhcnNlKHQuZGF0YSk7XG5cbiAgICAgICAgICBpZiAoXCJodHRwczovL3BsYXllci52aW1lby5jb21cIiA9PT0gdC5vcmlnaW4pIHtcbiAgICAgICAgICAgIGlmIChcInJlYWR5XCIgPT09IGUuZXZlbnQpIGZvciAobGV0IGUgb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImZhbmN5Ym94X19pZnJhbWVcIikpIGUuY29udGVudFdpbmRvdyA9PT0gdC5zb3VyY2UgJiYgKGUuaXNSZWFkeSA9IDEpO1xuICAgICAgICAgIH0gZWxzZSBcImh0dHBzOi8vd3d3LnlvdXR1YmUtbm9jb29raWUuY29tXCIgPT09IHQub3JpZ2luICYmIFwib25SZWFkeVwiID09PSBlLmV2ZW50ICYmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlLmlkKS5pc1JlYWR5ID0gMSk7XG4gICAgICAgIH0gY2F0Y2ggKHQpIHt9XG4gICAgICB9XG5cbiAgICAgIGF0dGFjaCgpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveC5vbih0aGlzLmV2ZW50cyksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLm9uTWVzc2FnZSwgITEpO1xuICAgICAgfVxuXG4gICAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3gub2ZmKHRoaXMuZXZlbnRzKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMub25NZXNzYWdlLCAhMSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBQLmRlZmF1bHRzID0gRTtcblxuICAgIGNsYXNzIFQge1xuICAgICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLmZhbmN5Ym94ID0gdDtcblxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgW1wib25SZWFkeVwiLCBcIm9uQ2xvc2luZ1wiLCBcIm9uRG9uZVwiLCBcIm9uUGFnZUNoYW5nZVwiLCBcIm9uQ3JlYXRlU2xpZGVcIiwgXCJvblJlbW92ZVNsaWRlXCIsIFwib25JbWFnZVN0YXR1c0NoYW5nZVwiXSkgdGhpc1t0XSA9IHRoaXNbdF0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICByZWFkeTogdGhpcy5vblJlYWR5LFxuICAgICAgICAgIGNsb3Npbmc6IHRoaXMub25DbG9zaW5nLFxuICAgICAgICAgIGRvbmU6IHRoaXMub25Eb25lLFxuICAgICAgICAgIFwiQ2Fyb3VzZWwuY2hhbmdlXCI6IHRoaXMub25QYWdlQ2hhbmdlLFxuICAgICAgICAgIFwiQ2Fyb3VzZWwuY3JlYXRlU2xpZGVcIjogdGhpcy5vbkNyZWF0ZVNsaWRlLFxuICAgICAgICAgIFwiQ2Fyb3VzZWwucmVtb3ZlU2xpZGVcIjogdGhpcy5vblJlbW92ZVNsaWRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9uUmVhZHkoKSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3guQ2Fyb3VzZWwuc2xpZGVzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgdC4kZWwgJiYgdGhpcy5zZXRDb250ZW50KHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgb25Eb25lKHQsIGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDdXJzb3IoZSk7XG4gICAgICB9XG5cbiAgICAgIG9uQ2xvc2luZyh0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsaWNrVGltZXIpLCB0aGlzLmNsaWNrVGltZXIgPSBudWxsLCB0LkNhcm91c2VsLnNsaWRlcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIHQuJGltYWdlICYmICh0LnN0YXRlID0gXCJkZXN0cm95XCIpLCB0LlBhbnpvb20gJiYgdC5QYW56b29tLmRldGFjaEV2ZW50cygpO1xuICAgICAgICB9KSwgXCJjbG9zaW5nXCIgPT09IHRoaXMuZmFuY3lib3guc3RhdGUgJiYgdGhpcy5jYW5ab29tKHQuZ2V0U2xpZGUoKSkgJiYgdGhpcy56b29tT3V0KCk7XG4gICAgICB9XG5cbiAgICAgIG9uQ3JlYXRlU2xpZGUodCwgZSwgaSkge1xuICAgICAgICBcInJlYWR5XCIgPT09IHRoaXMuZmFuY3lib3guc3RhdGUgJiYgdGhpcy5zZXRDb250ZW50KGkpO1xuICAgICAgfVxuXG4gICAgICBvblJlbW92ZVNsaWRlKHQsIGUsIGkpIHtcbiAgICAgICAgaS4kaW1hZ2UgJiYgKGkuJGVsLmNsYXNzTGlzdC5yZW1vdmUodC5vcHRpb24oXCJJbWFnZS5jYW5ab29tSW5DbGFzc1wiKSksIGkuJGltYWdlLnJlbW92ZSgpLCBpLiRpbWFnZSA9IG51bGwpLCBpLlBhbnpvb20gJiYgKGkuUGFuem9vbS5kZXN0cm95KCksIGkuUGFuem9vbSA9IG51bGwpLCBpLiRlbCAmJiBpLiRlbC5kYXRhc2V0ICYmIGRlbGV0ZSBpLiRlbC5kYXRhc2V0LmltYWdlRml0O1xuICAgICAgfVxuXG4gICAgICBzZXRDb250ZW50KHQpIHtcbiAgICAgICAgaWYgKHQuaXNEb20gfHwgdC5odG1sIHx8IHQudHlwZSAmJiBcImltYWdlXCIgIT09IHQudHlwZSkgcmV0dXJuO1xuICAgICAgICBpZiAodC4kaW1hZ2UpIHJldHVybjtcbiAgICAgICAgdC50eXBlID0gXCJpbWFnZVwiLCB0LnN0YXRlID0gXCJsb2FkaW5nXCI7XG4gICAgICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgaS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBlID0+IHtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCB0aGlzLm9uSW1hZ2VTdGF0dXNDaGFuZ2UodCk7XG4gICAgICAgIH0pLCBpLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbkltYWdlU3RhdHVzQ2hhbmdlKHQpO1xuICAgICAgICB9KSwgaS5zcmMgPSB0LnNyYywgaS5hbHQgPSBcIlwiLCBpLmRyYWdnYWJsZSA9ICExLCBpLmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveF9faW1hZ2VcIiksIHQuc3Jjc2V0ICYmIGkuc2V0QXR0cmlidXRlKFwic3Jjc2V0XCIsIHQuc3Jjc2V0KSwgdC5zaXplcyAmJiBpLnNldEF0dHJpYnV0ZShcInNpemVzXCIsIHQuc2l6ZXMpLCB0LiRpbWFnZSA9IGk7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLndyYXBcIik7XG5cbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICBvLmNsYXNzTGlzdC5hZGQoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcyA/IHMgOiBcImZhbmN5Ym94X19pbWFnZS13cmFwXCIpLCBvLmFwcGVuZENoaWxkKGkpLCBlLmFwcGVuZENoaWxkKG8pLCB0LiR3cmFwID0gbztcbiAgICAgICAgfSBlbHNlIGUuYXBwZW5kQ2hpbGQoaSk7XG5cbiAgICAgICAgdC4kZWwuZGF0YXNldC5pbWFnZUZpdCA9IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UuZml0XCIpLCB0aGlzLmZhbmN5Ym94LnNldENvbnRlbnQodCwgZSksIGkuY29tcGxldGUgfHwgaS5lcnJvciA/IHRoaXMub25JbWFnZVN0YXR1c0NoYW5nZSh0KSA6IHRoaXMuZmFuY3lib3guc2hvd0xvYWRpbmcodCk7XG4gICAgICB9XG5cbiAgICAgIG9uSW1hZ2VTdGF0dXNDaGFuZ2UodCkge1xuICAgICAgICBjb25zdCBlID0gdC4kaW1hZ2U7XG4gICAgICAgIGUgJiYgXCJsb2FkaW5nXCIgPT09IHQuc3RhdGUgJiYgKGUuY29tcGxldGUgJiYgZS5uYXR1cmFsV2lkdGggJiYgZS5uYXR1cmFsSGVpZ2h0ID8gKHRoaXMuZmFuY3lib3guaGlkZUxvYWRpbmcodCksIFwiY29udGFpblwiID09PSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLmZpdFwiKSAmJiB0aGlzLmluaXRTbGlkZVBhbnpvb20odCksIHQuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBlID0+IHRoaXMub25XaGVlbCh0LCBlKSwge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0LiRjb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlID0+IHRoaXMub25DbGljayh0LCBlKSwge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0aGlzLnJldmVhbENvbnRlbnQodCkpIDogdGhpcy5mYW5jeWJveC5zZXRFcnJvcih0LCBcInt7SU1BR0VfRVJST1J9fVwiKSk7XG4gICAgICB9XG5cbiAgICAgIGluaXRTbGlkZVBhbnpvb20odCkge1xuICAgICAgICB0LlBhbnpvb20gfHwgKHQuUGFuem9vbSA9IG5ldyBkKHQuJGVsLCBlKCEwLCB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLlBhbnpvb21cIiwge30pLCB7XG4gICAgICAgICAgdmlld3BvcnQ6IHQuJHdyYXAsXG4gICAgICAgICAgY29udGVudDogdC4kaW1hZ2UsXG4gICAgICAgICAgd2lkdGg6IHQuX3dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdC5faGVpZ2h0LFxuICAgICAgICAgIHdyYXBJbm5lcjogITEsXG4gICAgICAgICAgdGV4dFNlbGVjdGlvbjogITAsXG4gICAgICAgICAgdG91Y2g6IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UudG91Y2hcIiksXG4gICAgICAgICAgcGFuT25seVpvb21lZDogITAsXG4gICAgICAgICAgY2xpY2s6ICExLFxuICAgICAgICAgIHdoZWVsOiAhMVxuICAgICAgICB9KSksIHQuUGFuem9vbS5vbihcInN0YXJ0QW5pbWF0aW9uXCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmZhbmN5Ym94LnRyaWdnZXIoXCJJbWFnZS5zdGFydEFuaW1hdGlvblwiLCB0KTtcbiAgICAgICAgfSksIHQuUGFuem9vbS5vbihcImVuZEFuaW1hdGlvblwiLCAoKSA9PiB7XG4gICAgICAgICAgXCJ6b29tSW5cIiA9PT0gdC5zdGF0ZSAmJiB0aGlzLmZhbmN5Ym94LmRvbmUodCksIHRoaXMuaGFuZGxlQ3Vyc29yKHQpLCB0aGlzLmZhbmN5Ym94LnRyaWdnZXIoXCJJbWFnZS5lbmRBbmltYXRpb25cIiwgdCk7XG4gICAgICAgIH0pLCB0LlBhbnpvb20ub24oXCJhZnRlclVwZGF0ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVDdXJzb3IodCksIHRoaXMuZmFuY3lib3gudHJpZ2dlcihcIkltYWdlLmFmdGVyVXBkYXRlXCIsIHQpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldmVhbENvbnRlbnQodCkge1xuICAgICAgICBudWxsID09PSB0aGlzLmZhbmN5Ym94LkNhcm91c2VsLnByZXZQYWdlICYmIHQuaW5kZXggPT09IHRoaXMuZmFuY3lib3gub3B0aW9ucy5zdGFydEluZGV4ICYmIHRoaXMuY2FuWm9vbSh0KSA/IHRoaXMuem9vbUluKCkgOiB0aGlzLmZhbmN5Ym94LnJldmVhbENvbnRlbnQodCk7XG4gICAgICB9XG5cbiAgICAgIGdldFpvb21JbmZvKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHQuJHRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICBpID0gZS53aWR0aCxcbiAgICAgICAgICAgICAgcyA9IGUuaGVpZ2h0LFxuICAgICAgICAgICAgICBvID0gdC4kY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgbiA9IG8ud2lkdGgsXG4gICAgICAgICAgICAgIGEgPSBvLmhlaWdodCxcbiAgICAgICAgICAgICAgciA9IG8udG9wIC0gZS50b3AsXG4gICAgICAgICAgICAgIGggPSBvLmxlZnQgLSBlLmxlZnQ7XG4gICAgICAgIGxldCBsID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS56b29tT3BhY2l0eVwiKTtcbiAgICAgICAgcmV0dXJuIFwiYXV0b1wiID09PSBsICYmIChsID0gTWF0aC5hYnMoaSAvIHMgLSBuIC8gYSkgPiAuMSksIHtcbiAgICAgICAgICB0b3A6IHIsXG4gICAgICAgICAgbGVmdDogaCxcbiAgICAgICAgICBzY2FsZTogbiAmJiBpID8gaSAvIG4gOiAxLFxuICAgICAgICAgIG9wYWNpdHk6IGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY2FuWm9vbSh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmZhbmN5Ym94LFxuICAgICAgICAgICAgICBpID0gZS4kY29udGFpbmVyO1xuICAgICAgICBpZiAod2luZG93LnZpc3VhbFZpZXdwb3J0ICYmIDEgIT09IHdpbmRvdy52aXN1YWxWaWV3cG9ydC5zY2FsZSkgcmV0dXJuICExO1xuICAgICAgICBpZiAodC5QYW56b29tICYmICF0LlBhbnpvb20uY29udGVudC53aWR0aCkgcmV0dXJuICExO1xuICAgICAgICBpZiAoIWUub3B0aW9uKFwiSW1hZ2Uuem9vbVwiKSB8fCBcImNvbnRhaW5cIiAhPT0gZS5vcHRpb24oXCJJbWFnZS5maXRcIikpIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgcyA9IHQuJHRodW1iO1xuICAgICAgICBpZiAoIXMgfHwgXCJsb2FkaW5nXCIgPT09IHQuc3RhdGUpIHJldHVybiAhMTtcbiAgICAgICAgaS5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3hfX25vLWNsaWNrXCIpO1xuICAgICAgICBjb25zdCBvID0gcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IG47XG5cbiAgICAgICAgaWYgKHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UuaWdub3JlQ292ZXJlZFRodW1ibmFpbFwiKSkge1xuICAgICAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KG8ubGVmdCArIDEsIG8udG9wICsgMSkgPT09IHMsXG4gICAgICAgICAgICAgICAgZSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoby5yaWdodCAtIDEsIG8uYm90dG9tIC0gMSkgPT09IHM7XG4gICAgICAgICAgbiA9IHQgJiYgZTtcbiAgICAgICAgfSBlbHNlIG4gPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KG8ubGVmdCArIC41ICogby53aWR0aCwgby50b3AgKyAuNSAqIG8uaGVpZ2h0KSA9PT0gcztcblxuICAgICAgICByZXR1cm4gaS5jbGFzc0xpc3QucmVtb3ZlKFwiZmFuY3lib3hfX25vLWNsaWNrXCIpLCBuO1xuICAgICAgfVxuXG4gICAgICB6b29tSW4oKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmZhbmN5Ym94LFxuICAgICAgICAgICAgICBlID0gdC5nZXRTbGlkZSgpLFxuICAgICAgICAgICAgICBpID0gZS5QYW56b29tLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgdG9wOiBzLFxuICAgICAgICAgIGxlZnQ6IG8sXG4gICAgICAgICAgc2NhbGU6IG4sXG4gICAgICAgICAgb3BhY2l0eTogYVxuICAgICAgICB9ID0gdGhpcy5nZXRab29tSW5mbyhlKTtcbiAgICAgICAgdC50cmlnZ2VyKFwicmV2ZWFsXCIsIGUpLCBpLnBhblRvKHtcbiAgICAgICAgICB4OiAtMSAqIG8sXG4gICAgICAgICAgeTogLTEgKiBzLFxuICAgICAgICAgIHNjYWxlOiBuLFxuICAgICAgICAgIGZyaWN0aW9uOiAwLFxuICAgICAgICAgIGlnbm9yZUJvdW5kczogITBcbiAgICAgICAgfSksIGUuJGNvbnRlbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCIsIGUuc3RhdGUgPSBcInpvb21JblwiLCAhMCA9PT0gYSAmJiBpLm9uKFwiYWZ0ZXJUcmFuc2Zvcm1cIiwgdCA9PiB7XG4gICAgICAgICAgXCJ6b29tSW5cIiAhPT0gZS5zdGF0ZSAmJiBcInpvb21PdXRcIiAhPT0gZS5zdGF0ZSB8fCAodC4kY29udGVudC5zdHlsZS5vcGFjaXR5ID0gTWF0aC5taW4oMSwgMSAtICgxIC0gdC5jb250ZW50LnNjYWxlKSAvICgxIC0gbikpKTtcbiAgICAgICAgfSksIGkucGFuVG8oe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgICBmcmljdGlvbjogdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS56b29tRnJpY3Rpb25cIilcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHpvb21PdXQoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmZhbmN5Ym94LFxuICAgICAgICAgICAgICBlID0gdC5nZXRTbGlkZSgpLFxuICAgICAgICAgICAgICBpID0gZS5QYW56b29tO1xuICAgICAgICBpZiAoIWkpIHJldHVybjtcbiAgICAgICAgZS5zdGF0ZSA9IFwiem9vbU91dFwiLCB0LnN0YXRlID0gXCJjdXN0b21DbG9zaW5nXCIsIGUuJGNhcHRpb24gJiYgKGUuJGNhcHRpb24uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCIpO1xuICAgICAgICBsZXQgcyA9IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2Uuem9vbUZyaWN0aW9uXCIpO1xuXG4gICAgICAgIGNvbnN0IG8gPSB0ID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0b3A6IG8sXG4gICAgICAgICAgICBsZWZ0OiBuLFxuICAgICAgICAgICAgc2NhbGU6IGEsXG4gICAgICAgICAgICBvcGFjaXR5OiByXG4gICAgICAgICAgfSA9IHRoaXMuZ2V0Wm9vbUluZm8oZSk7XG4gICAgICAgICAgdCB8fCByIHx8IChzICo9IC44MiksIGkucGFuVG8oe1xuICAgICAgICAgICAgeDogLTEgKiBuLFxuICAgICAgICAgICAgeTogLTEgKiBvLFxuICAgICAgICAgICAgc2NhbGU6IGEsXG4gICAgICAgICAgICBmcmljdGlvbjogcyxcbiAgICAgICAgICAgIGlnbm9yZUJvdW5kczogITBcbiAgICAgICAgICB9KSwgcyAqPSAuOTg7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbyksIGkub25jZShcImVuZEFuaW1hdGlvblwiLCAoKSA9PiB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbyksIHQuZGVzdHJveSgpO1xuICAgICAgICB9KSwgbygpO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVDdXJzb3IodCkge1xuICAgICAgICBpZiAoXCJpbWFnZVwiICE9PSB0LnR5cGUgfHwgIXQuJGVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGUgPSB0LlBhbnpvb20sXG4gICAgICAgICAgICAgIGkgPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLmNsaWNrXCIsICExLCB0KSxcbiAgICAgICAgICAgICAgcyA9IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UudG91Y2hcIiksXG4gICAgICAgICAgICAgIG8gPSB0LiRlbC5jbGFzc0xpc3QsXG4gICAgICAgICAgICAgIG4gPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLmNhblpvb21JbkNsYXNzXCIpLFxuICAgICAgICAgICAgICBhID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS5jYW5ab29tT3V0Q2xhc3NcIik7XG5cbiAgICAgICAgaWYgKG8ucmVtb3ZlKGEpLCBvLnJlbW92ZShuKSwgZSAmJiBcInRvZ2dsZVpvb21cIiA9PT0gaSkge1xuICAgICAgICAgIGUgJiYgMSA9PT0gZS5jb250ZW50LnNjYWxlICYmIGUub3B0aW9uKFwibWF4U2NhbGVcIikgLSBlLmNvbnRlbnQuc2NhbGUgPiAuMDEgPyBvLmFkZChuKSA6IGUuY29udGVudC5zY2FsZSA+IDEgJiYgIXMgJiYgby5hZGQoYSk7XG4gICAgICAgIH0gZWxzZSBcImNsb3NlXCIgPT09IGkgJiYgby5hZGQoYSk7XG4gICAgICB9XG5cbiAgICAgIG9uV2hlZWwodCwgZSkge1xuICAgICAgICBpZiAoXCJyZWFkeVwiID09PSB0aGlzLmZhbmN5Ym94LnN0YXRlICYmICExICE9PSB0aGlzLmZhbmN5Ym94LnRyaWdnZXIoXCJJbWFnZS53aGVlbFwiLCBlKSkgc3dpdGNoICh0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLndoZWVsXCIpKSB7XG4gICAgICAgICAgY2FzZSBcInpvb21cIjpcbiAgICAgICAgICAgIFwiZG9uZVwiID09PSB0LnN0YXRlICYmIHQuUGFuem9vbSAmJiB0LlBhbnpvb20uem9vbVdpdGhXaGVlbChlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImNsb3NlXCI6XG4gICAgICAgICAgICB0aGlzLmZhbmN5Ym94LmNsb3NlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJzbGlkZVwiOlxuICAgICAgICAgICAgdGhpcy5mYW5jeWJveFtlLmRlbHRhWSA8IDAgPyBcInByZXZcIiA6IFwibmV4dFwiXSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uQ2xpY2sodCwgZSkge1xuICAgICAgICBpZiAoXCJyZWFkeVwiICE9PSB0aGlzLmZhbmN5Ym94LnN0YXRlKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGkgPSB0LlBhbnpvb207XG4gICAgICAgIGlmIChpICYmIChpLmRyYWdQb3NpdGlvbi5taWRQb2ludCB8fCAwICE9PSBpLmRyYWdPZmZzZXQueCB8fCAwICE9PSBpLmRyYWdPZmZzZXQueSB8fCAxICE9PSBpLmRyYWdPZmZzZXQuc2NhbGUpKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmZhbmN5Ym94LkNhcm91c2VsLlBhbnpvb20ubG9ja0F4aXMpIHJldHVybiAhMTtcblxuICAgICAgICBjb25zdCBzID0gaSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlIFwidG9nZ2xlWm9vbVwiOlxuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpLCB0LlBhbnpvb20gJiYgdC5QYW56b29tLnpvb21XaXRoQ2xpY2soZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgICAgdGhpcy5mYW5jeWJveC5jbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm5leHRcIjpcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy5mYW5jeWJveC5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAgICAgICBvID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS5jbGlja1wiKSxcbiAgICAgICAgICAgICAgbiA9IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UuZG91YmxlQ2xpY2tcIik7XG5cbiAgICAgICAgbiA/IHRoaXMuY2xpY2tUaW1lciA/IChjbGVhclRpbWVvdXQodGhpcy5jbGlja1RpbWVyKSwgdGhpcy5jbGlja1RpbWVyID0gbnVsbCwgcyhuKSkgOiB0aGlzLmNsaWNrVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsaWNrVGltZXIgPSBudWxsLCBzKG8pO1xuICAgICAgICB9LCAzMDApIDogcyhvKTtcbiAgICAgIH1cblxuICAgICAgb25QYWdlQ2hhbmdlKHQsIGUpIHtcbiAgICAgICAgY29uc3QgaSA9IHQuZ2V0U2xpZGUoKTtcbiAgICAgICAgZS5zbGlkZXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICB0LlBhbnpvb20gJiYgXCJkb25lXCIgPT09IHQuc3RhdGUgJiYgdC5pbmRleCAhPT0gaS5pbmRleCAmJiB0LlBhbnpvb20ucGFuVG8oe1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgICAgIGZyaWN0aW9uOiAuOFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYXR0YWNoKCkge1xuICAgICAgICB0aGlzLmZhbmN5Ym94Lm9uKHRoaXMuZXZlbnRzKTtcbiAgICAgIH1cblxuICAgICAgZGV0YWNoKCkge1xuICAgICAgICB0aGlzLmZhbmN5Ym94Lm9mZih0aGlzLmV2ZW50cyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBULmRlZmF1bHRzID0ge1xuICAgICAgY2FuWm9vbUluQ2xhc3M6IFwiY2FuLXpvb21faW5cIixcbiAgICAgIGNhblpvb21PdXRDbGFzczogXCJjYW4tem9vbV9vdXRcIixcbiAgICAgIHpvb206ICEwLFxuICAgICAgem9vbU9wYWNpdHk6IFwiYXV0b1wiLFxuICAgICAgem9vbUZyaWN0aW9uOiAuODIsXG4gICAgICBpZ25vcmVDb3ZlcmVkVGh1bWJuYWlsOiAhMSxcbiAgICAgIHRvdWNoOiAhMCxcbiAgICAgIGNsaWNrOiBcInRvZ2dsZVpvb21cIixcbiAgICAgIGRvdWJsZUNsaWNrOiBudWxsLFxuICAgICAgd2hlZWw6IFwiem9vbVwiLFxuICAgICAgZml0OiBcImNvbnRhaW5cIixcbiAgICAgIHdyYXA6ICExLFxuICAgICAgUGFuem9vbToge1xuICAgICAgICByYXRpbzogMVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjbGFzcyBMIHtcbiAgICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveCA9IHQ7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIFtcIm9uQ2hhbmdlXCIsIFwib25DbG9zaW5nXCJdKSB0aGlzW3RdID0gdGhpc1t0XS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgICAgIGluaXRDYXJvdXNlbDogdGhpcy5vbkNoYW5nZSxcbiAgICAgICAgICBcIkNhcm91c2VsLmNoYW5nZVwiOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgICAgIGNsb3Npbmc6IHRoaXMub25DbG9zaW5nXG4gICAgICAgIH0sIHRoaXMuaGFzQ3JlYXRlZEhpc3RvcnkgPSAhMSwgdGhpcy5vcmlnSGFzaCA9IFwiXCIsIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBvbkNoYW5nZSh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0LkNhcm91c2VsO1xuICAgICAgICB0aGlzLnRpbWVyICYmIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgY29uc3QgaSA9IG51bGwgPT09IGUucHJldlBhZ2UsXG4gICAgICAgICAgICAgIHMgPSB0LmdldFNsaWRlKCksXG4gICAgICAgICAgICAgIG8gPSBuZXcgVVJMKGRvY3VtZW50LlVSTCkuaGFzaDtcbiAgICAgICAgbGV0IG4gPSAhMTtcbiAgICAgICAgaWYgKHMuc2x1ZykgbiA9IFwiI1wiICsgcy5zbHVnO2Vsc2Uge1xuICAgICAgICAgIGNvbnN0IGkgPSBzLiR0cmlnZ2VyICYmIHMuJHRyaWdnZXIuZGF0YXNldCxcbiAgICAgICAgICAgICAgICBvID0gdC5vcHRpb24oXCJzbHVnXCIpIHx8IGkgJiYgaS5mYW5jeWJveDtcbiAgICAgICAgICBvICYmIG8ubGVuZ3RoICYmIFwidHJ1ZVwiICE9PSBvICYmIChuID0gXCIjXCIgKyBvICsgKGUuc2xpZGVzLmxlbmd0aCA+IDEgPyBcIi1cIiArIChzLmluZGV4ICsgMSkgOiBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaSAmJiAodGhpcy5vcmlnSGFzaCA9IG8gIT09IG4gPyBvIDogXCJcIiksIG4gJiYgbyAhPT0gbiAmJiAodGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVtpID8gXCJwdXNoU3RhdGVcIiA6IFwicmVwbGFjZVN0YXRlXCJdKHt9LCBkb2N1bWVudC50aXRsZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIG4pLCBpICYmICh0aGlzLmhhc0NyZWF0ZWRIaXN0b3J5ID0gITApO1xuICAgICAgICAgIH0gY2F0Y2ggKHQpIHt9XG4gICAgICAgIH0sIDMwMCkpO1xuICAgICAgfVxuXG4gICAgICBvbkNsb3NpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyICYmIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKSwgITAgIT09IHRoaXMuaGFzU2lsZW50Q2xvc2UpIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCBkb2N1bWVudC50aXRsZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArICh0aGlzLm9yaWdIYXNoIHx8IFwiXCIpKTtcbiAgICAgICAgfSBjYXRjaCAodCkge31cbiAgICAgIH1cblxuICAgICAgYXR0YWNoKHQpIHtcbiAgICAgICAgdC5vbih0aGlzLmV2ZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGRldGFjaCh0KSB7XG4gICAgICAgIHQub2ZmKHRoaXMuZXZlbnRzKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIHN0YXJ0RnJvbVVybCgpIHtcbiAgICAgICAgY29uc3QgdCA9IEwuRmFuY3lib3g7XG4gICAgICAgIGlmICghdCB8fCB0LmdldEluc3RhbmNlKCkgfHwgITEgPT09IHQuZGVmYXVsdHMuSGFzaCkgcmV0dXJuO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGFzaDogZSxcbiAgICAgICAgICBzbHVnOiBpLFxuICAgICAgICAgIGluZGV4OiBzXG4gICAgICAgIH0gPSBMLmdldFBhcnNlZFVSTCgpO1xuICAgICAgICBpZiAoIWkpIHJldHVybjtcbiAgICAgICAgbGV0IG8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1zbHVnPVwiJHtlfVwiXWApO1xuICAgICAgICBpZiAobyAmJiBvLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2xpY2tcIiwge1xuICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgICAgIH0pKSwgdC5nZXRJbnN0YW5jZSgpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1mYW5jeWJveD1cIiR7aX1cIl1gKTtcbiAgICAgICAgbi5sZW5ndGggJiYgKG51bGwgPT09IHMgJiYgMSA9PT0gbi5sZW5ndGggPyBvID0gblswXSA6IHMgJiYgKG8gPSBuW3MgLSAxXSksIG8gJiYgby5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNsaWNrXCIsIHtcbiAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICBjYW5jZWxhYmxlOiAhMFxuICAgICAgICB9KSkpO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgb25IYXNoQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2x1ZzogdCxcbiAgICAgICAgICBpbmRleDogZVxuICAgICAgICB9ID0gTC5nZXRQYXJzZWRVUkwoKSxcbiAgICAgICAgICAgICAgaSA9IEwuRmFuY3lib3gsXG4gICAgICAgICAgICAgIHMgPSBpICYmIGkuZ2V0SW5zdGFuY2UoKTtcblxuICAgICAgICBpZiAocyAmJiBzLnBsdWdpbnMuSGFzaCkge1xuICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICBjb25zdCBpID0gcy5DYXJvdXNlbDtcbiAgICAgICAgICAgIGlmICh0ID09PSBzLm9wdGlvbihcInNsdWdcIikpIHJldHVybiBpLnNsaWRlVG8oZSAtIDEpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBlIG9mIGkuc2xpZGVzKSBpZiAoZS5zbHVnICYmIGUuc2x1ZyA9PT0gdCkgcmV0dXJuIGkuc2xpZGVUbyhlLmluZGV4KTtcblxuICAgICAgICAgICAgY29uc3QgbyA9IHMuZ2V0U2xpZGUoKSxcbiAgICAgICAgICAgICAgICAgIG4gPSBvLiR0cmlnZ2VyICYmIG8uJHRyaWdnZXIuZGF0YXNldDtcbiAgICAgICAgICAgIGlmIChuICYmIG4uZmFuY3lib3ggPT09IHQpIHJldHVybiBpLnNsaWRlVG8oZSAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHMucGx1Z2lucy5IYXNoLmhhc1NpbGVudENsb3NlID0gITAsIHMuY2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEwuc3RhcnRGcm9tVXJsKCk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBjcmVhdGUodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLCBMLm9uSGFzaENoYW5nZSwgITEpLCBMLnN0YXJ0RnJvbVVybCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgTC5GYW5jeWJveCA9IHQsIHYgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgL2NvbXBsZXRlfGludGVyYWN0aXZlfGxvYWRlZC8udGVzdChkb2N1bWVudC5yZWFkeVN0YXRlKSA/IGUoKSA6IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLCBMLm9uSGFzaENoYW5nZSwgITEpO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgZ2V0UGFyc2VkVVJMKCkge1xuICAgICAgICBjb25zdCB0ID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpLFxuICAgICAgICAgICAgICBlID0gdC5zcGxpdChcIi1cIiksXG4gICAgICAgICAgICAgIGkgPSBlLmxlbmd0aCA+IDEgJiYgL15cXCs/XFxkKyQvLnRlc3QoZVtlLmxlbmd0aCAtIDFdKSAmJiBwYXJzZUludChlLnBvcCgtMSksIDEwKSB8fCBudWxsO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhhc2g6IHQsXG4gICAgICAgICAgc2x1ZzogZS5qb2luKFwiLVwiKSxcbiAgICAgICAgICBpbmRleDogaVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29uc3QgXyA9IHtcbiAgICAgIHBhZ2VYT2Zmc2V0OiAwLFxuICAgICAgcGFnZVlPZmZzZXQ6IDAsXG4gICAgICBlbGVtZW50OiAoKSA9PiBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCxcblxuICAgICAgYWN0aXZhdGUodCkge1xuICAgICAgICBfLnBhZ2VYT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0LCBfLnBhZ2VZT2Zmc2V0ID0gd2luZG93LnBhZ2VZT2Zmc2V0LCB0LnJlcXVlc3RGdWxsc2NyZWVuID8gdC5yZXF1ZXN0RnVsbHNjcmVlbigpIDogdC5tb3pSZXF1ZXN0RnVsbFNjcmVlbiA/IHQubW96UmVxdWVzdEZ1bGxTY3JlZW4oKSA6IHQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4gPyB0LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCkgOiB0Lm1zUmVxdWVzdEZ1bGxzY3JlZW4gJiYgdC5tc1JlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICB9LFxuXG4gICAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbiA/IGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCkgOiBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuID8gZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpIDogZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4gJiYgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBjbGFzcyBBIHtcbiAgICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveCA9IHQsIHRoaXMuYWN0aXZlID0gITEsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgICAgfVxuXG4gICAgICBzZXRUaW1lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSB8fCB0aGlzLnRpbWVyKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcInNsaWRlc2hvdy5kZWxheVwiLCAzZTMpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IG51bGwsIHRoaXMuZmFuY3lib3gub3B0aW9uKFwiaW5maW5pdGVcIikgfHwgdGhpcy5mYW5jeWJveC5nZXRTbGlkZSgpLmluZGV4ICE9PSB0aGlzLmZhbmN5Ym94LkNhcm91c2VsLnNsaWRlcy5sZW5ndGggLSAxID8gdGhpcy5mYW5jeWJveC5uZXh0KCkgOiB0aGlzLmZhbmN5Ym94Lmp1bXBUbygwLCB7XG4gICAgICAgICAgICBmcmljdGlvbjogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0KTtcbiAgICAgICAgbGV0IGUgPSB0aGlzLiRwcm9ncmVzcztcbiAgICAgICAgZSB8fCAoZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGUuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X19wcm9ncmVzc1wiKSwgdGhpcy5mYW5jeWJveC4kY2Fyb3VzZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSwgdGhpcy5mYW5jeWJveC4kY2Fyb3VzZWwpLCB0aGlzLiRwcm9ncmVzcyA9IGUsIGUub2Zmc2V0SGVpZ2h0KSwgZS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHt0fW1zYCwgZS5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlWCgxKVwiO1xuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lciksIHRoaXMudGltZXIgPSBudWxsLCB0aGlzLiRwcm9ncmVzcyAmJiAodGhpcy4kcHJvZ3Jlc3Muc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gXCJcIiwgdGhpcy4kcHJvZ3Jlc3Muc3R5bGUudHJhbnNmb3JtID0gXCJcIiwgdGhpcy4kcHJvZ3Jlc3Mub2Zmc2V0SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlIHx8ICh0aGlzLmFjdGl2ZSA9ICEwLCB0aGlzLmZhbmN5Ym94LiRjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhcy1zbGlkZXNob3dcIiksIFwiZG9uZVwiID09PSB0aGlzLmZhbmN5Ym94LmdldFNsaWRlKCkuc3RhdGUgJiYgdGhpcy5zZXRUaW1lcigpLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UsICExKSk7XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9ICExLCB0aGlzLmNsZWFyVGltZXIoKSwgdGhpcy5mYW5jeWJveC4kY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJoYXMtc2xpZGVzaG93XCIpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UsICExKTtcbiAgICAgIH1cblxuICAgICAgdG9nZ2xlKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA/IHRoaXMuZGVhY3RpdmF0ZSgpIDogdGhpcy5mYW5jeWJveC5DYXJvdXNlbC5zbGlkZXMubGVuZ3RoID4gMSAmJiB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBjb25zdCB6ID0ge1xuICAgICAgZGlzcGxheTogW1wiY291bnRlclwiLCBcInpvb21cIiwgXCJzbGlkZXNob3dcIiwgXCJmdWxsc2NyZWVuXCIsIFwidGh1bWJzXCIsIFwiY2xvc2VcIl0sXG4gICAgICBhdXRvRW5hYmxlOiAhMCxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIGNvdW50ZXI6IHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJsZWZ0XCIsXG4gICAgICAgICAgdHlwZTogXCJkaXZcIixcbiAgICAgICAgICBjbGFzczogXCJmYW5jeWJveF9fY291bnRlclwiLFxuICAgICAgICAgIGh0bWw6ICc8c3BhbiBkYXRhLWZhbmN5Ym94LWluZGV4PVwiXCI+PC9zcGFuPiZuYnNwOy8mbmJzcDs8c3BhbiBkYXRhLWZhbmN5Ym94LWNvdW50PVwiXCI+PC9zcGFuPicsXG4gICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgdGFiaW5kZXg6IC0xXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmV2OiB7XG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBjbGFzczogXCJmYW5jeWJveF9fYnV0dG9uLS1wcmV2XCIsXG4gICAgICAgICAgbGFiZWw6IFwiUFJFVlwiLFxuICAgICAgICAgIGh0bWw6ICc8c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTE1IDRsLTggOCA4IDhcIi8+PC9zdmc+JyxcbiAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICBcImRhdGEtZmFuY3lib3gtcHJldlwiOiBcIlwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBuZXh0OiB7XG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBjbGFzczogXCJmYW5jeWJveF9fYnV0dG9uLS1uZXh0XCIsXG4gICAgICAgICAgbGFiZWw6IFwiTkVYVFwiLFxuICAgICAgICAgIGh0bWw6ICc8c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTggNGw4IDgtOCA4XCIvPjwvc3ZnPicsXG4gICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgXCJkYXRhLWZhbmN5Ym94LW5leHRcIjogXCJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVsbHNjcmVlbjoge1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgY2xhc3M6IFwiZmFuY3lib3hfX2J1dHRvbi0tZnVsbHNjcmVlblwiLFxuICAgICAgICAgIGxhYmVsOiBcIlRPR0dMRV9GVUxMU0NSRUVOXCIsXG4gICAgICAgICAgaHRtbDogJzxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxcbiAgICAgICAgICAgICAgICA8Zz48cGF0aCBkPVwiTTMgOCBWM2g1XCI+PC9wYXRoPjxwYXRoIGQ9XCJNMjEgOFYzaC01XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOCAyMUgzdi01XCI+PC9wYXRoPjxwYXRoIGQ9XCJNMTYgMjFoNXYtNVwiPjwvcGF0aD48L2c+XFxuICAgICAgICAgICAgICAgIDxnPjxwYXRoIGQ9XCJNNyAydjVIMk0xNyAydjVoNU0yIDE3aDV2NU0yMiAxN2gtNXY1XCIvPjwvZz5cXG4gICAgICAgICAgICA8L3N2Zz4nLFxuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCBfLmVsZW1lbnQoKSA/IF8uZGVhY3RpdmF0ZSgpIDogXy5hY3RpdmF0ZSh0aGlzLmZhbmN5Ym94LiRjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2xpZGVzaG93OiB7XG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBjbGFzczogXCJmYW5jeWJveF9fYnV0dG9uLS1zbGlkZXNob3dcIixcbiAgICAgICAgICBsYWJlbDogXCJUT0dHTEVfU0xJREVTSE9XXCIsXG4gICAgICAgICAgaHRtbDogJzxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxcbiAgICAgICAgICAgICAgICA8Zz48cGF0aCBkPVwiTTYgNHYxNlwiLz48cGF0aCBkPVwiTTIwIDEyTDYgMjBcIi8+PHBhdGggZD1cIk0yMCAxMkw2IDRcIi8+PC9nPlxcbiAgICAgICAgICAgICAgICA8Zz48cGF0aCBkPVwiTTcgNHYxNU0xNyA0djE1XCIvPjwvZz5cXG4gICAgICAgICAgICA8L3N2Zz4nLFxuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLlNsaWRlc2hvdy50b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHpvb206IHtcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19idXR0b24tLXpvb21cIixcbiAgICAgICAgICBsYWJlbDogXCJUT0dHTEVfWk9PTVwiLFxuICAgICAgICAgIGh0bWw6ICc8c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48Y2lyY2xlIGN4PVwiMTBcIiBjeT1cIjEwXCIgcj1cIjdcIj48L2NpcmNsZT48cGF0aCBkPVwiTTE2IDE2IEwyMSAyMVwiPjwvc3ZnPicsXG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcy5mYW5jeWJveC5nZXRTbGlkZSgpLlBhbnpvb207XG4gICAgICAgICAgICBlICYmIGUudG9nZ2xlWm9vbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZG93bmxvYWQ6IHtcbiAgICAgICAgICB0eXBlOiBcImxpbmtcIixcbiAgICAgICAgICBsYWJlbDogXCJET1dOTE9BRFwiLFxuICAgICAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19idXR0b24tLWRvd25sb2FkXCIsXG4gICAgICAgICAgaHRtbDogJzxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMTIgMTVWM20wIDEybC00LTRtNCA0bDQtNE0yIDE3bC42MiAyLjQ4QTIgMiAwIDAwNC41NiAyMWgxNC44OGEyIDIgMCAwMDEuOTQtMS41MUwyMiAxN1wiLz48L3N2Zz4nLFxuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRodW1iczoge1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgbGFiZWw6IFwiVE9HR0xFX1RIVU1CU1wiLFxuICAgICAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19idXR0b24tLXRodW1ic1wiLFxuICAgICAgICAgIGh0bWw6ICc8c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48Y2lyY2xlIGN4PVwiNFwiIGN5PVwiNFwiIHI9XCIxXCIgLz48Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjRcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAxMiA0KVwiLz48Y2lyY2xlIGN4PVwiMjBcIiBjeT1cIjRcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAyMCA0KVwiLz48Y2lyY2xlIGN4PVwiNFwiIGN5PVwiMTJcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCA0IDEyKVwiLz48Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjFcIiB0cmFuc2Zvcm09XCJyb3RhdGUoOTAgMTIgMTIpXCIvPjxjaXJjbGUgY3g9XCIyMFwiIGN5PVwiMTJcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAyMCAxMilcIi8+PGNpcmNsZSBjeD1cIjRcIiBjeT1cIjIwXCIgcj1cIjFcIiB0cmFuc2Zvcm09XCJyb3RhdGUoOTAgNCAyMClcIi8+PGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIyMFwiIHI9XCIxXCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDEyIDIwKVwiLz48Y2lyY2xlIGN4PVwiMjBcIiBjeT1cIjIwXCIgcj1cIjFcIiB0cmFuc2Zvcm09XCJyb3RhdGUoOTAgMjAgMjApXCIvPjwvc3ZnPicsXG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMuZmFuY3lib3gucGx1Z2lucy5UaHVtYnM7XG4gICAgICAgICAgICBlICYmIGUudG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbG9zZToge1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgbGFiZWw6IFwiQ0xPU0VcIixcbiAgICAgICAgICBjbGFzczogXCJmYW5jeWJveF9fYnV0dG9uLS1jbG9zZVwiLFxuICAgICAgICAgIGh0bWw6ICc8c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTIwIDIwTDQgNG0xNiAwTDQgMjBcIj48L3BhdGg+PC9zdmc+JyxcbiAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICBcImRhdGEtZmFuY3lib3gtY2xvc2VcIjogXCJcIixcbiAgICAgICAgICAgIHRhYmluZGV4OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNsYXNzIGsge1xuICAgICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLmZhbmN5Ym94ID0gdCwgdGhpcy4kY29udGFpbmVyID0gbnVsbCwgdGhpcy5zdGF0ZSA9IFwiaW5pdFwiO1xuXG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBbXCJvbkluaXRcIiwgXCJvblByZXBhcmVcIiwgXCJvbkRvbmVcIiwgXCJvbktleWRvd25cIiwgXCJvbkNsb3NpbmdcIiwgXCJvbkNoYW5nZVwiLCBcIm9uU2V0dGxlXCIsIFwib25SZWZyZXNoXCJdKSB0aGlzW3RdID0gdGhpc1t0XS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgICAgIGluaXQ6IHRoaXMub25Jbml0LFxuICAgICAgICAgIHByZXBhcmU6IHRoaXMub25QcmVwYXJlLFxuICAgICAgICAgIGRvbmU6IHRoaXMub25Eb25lLFxuICAgICAgICAgIGtleWRvd246IHRoaXMub25LZXlkb3duLFxuICAgICAgICAgIGNsb3Npbmc6IHRoaXMub25DbG9zaW5nLFxuICAgICAgICAgIFwiQ2Fyb3VzZWwuY2hhbmdlXCI6IHRoaXMub25DaGFuZ2UsXG4gICAgICAgICAgXCJDYXJvdXNlbC5zZXR0bGVcIjogdGhpcy5vblNldHRsZSxcbiAgICAgICAgICBcIkNhcm91c2VsLlBhbnpvb20udG91Y2hTdGFydFwiOiAoKSA9PiB0aGlzLm9uUmVmcmVzaCgpLFxuICAgICAgICAgIFwiSW1hZ2Uuc3RhcnRBbmltYXRpb25cIjogKHQsIGUpID0+IHRoaXMub25SZWZyZXNoKGUpLFxuICAgICAgICAgIFwiSW1hZ2UuYWZ0ZXJVcGRhdGVcIjogKHQsIGUpID0+IHRoaXMub25SZWZyZXNoKGUpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmFuY3lib3gub3B0aW9uKFwiVG9vbGJhci5hdXRvRW5hYmxlXCIpKSB7XG4gICAgICAgICAgbGV0IHQgPSAhMTtcblxuICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmZhbmN5Ym94Lml0ZW1zKSBpZiAoXCJpbWFnZVwiID09PSBlLnR5cGUpIHtcbiAgICAgICAgICAgIHQgPSAhMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdCkgcmV0dXJuIHZvaWQgKHRoaXMuc3RhdGUgPSBcImRpc2FibGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuZmFuY3lib3gub3B0aW9uKFwiVG9vbGJhci5kaXNwbGF5XCIpKSB7XG4gICAgICAgICAgaWYgKFwiY2xvc2VcIiA9PT0gKHQoZSkgPyBlLmlkIDogZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZmFuY3lib3gub3B0aW9ucy5jbG9zZUJ1dHRvbiA9ICExO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uUHJlcGFyZSgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuZmFuY3lib3g7XG4gICAgICAgIGlmIChcImluaXRcIiA9PT0gdGhpcy5zdGF0ZSAmJiAodGhpcy5idWlsZCgpLCB0aGlzLnVwZGF0ZSgpLCB0aGlzLlNsaWRlc2hvdyA9IG5ldyBBKHQpLCAhdC5DYXJvdXNlbC5wcmV2UGFnZSAmJiAodC5vcHRpb24oXCJzbGlkZXNob3cuYXV0b1N0YXJ0XCIpICYmIHRoaXMuU2xpZGVzaG93LmFjdGl2YXRlKCksIHQub3B0aW9uKFwiZnVsbHNjcmVlbi5hdXRvU3RhcnRcIikgJiYgIV8uZWxlbWVudCgpKSkpIHRyeSB7XG4gICAgICAgICAgXy5hY3RpdmF0ZSh0LiRjb250YWluZXIpO1xuICAgICAgICB9IGNhdGNoICh0KSB7fVxuICAgICAgfVxuXG4gICAgICBvbkZzQ2hhbmdlKCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oXy5wYWdlWE9mZnNldCwgXy5wYWdlWU9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIG9uU2V0dGxlKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5mYW5jeWJveCxcbiAgICAgICAgICAgICAgZSA9IHRoaXMuU2xpZGVzaG93O1xuICAgICAgICBlICYmIGUuaXNBY3RpdmUoKSAmJiAodC5nZXRTbGlkZSgpLmluZGV4ICE9PSB0LkNhcm91c2VsLnNsaWRlcy5sZW5ndGggLSAxIHx8IHQub3B0aW9uKFwiaW5maW5pdGVcIikgPyBcImRvbmVcIiA9PT0gdC5nZXRTbGlkZSgpLnN0YXRlICYmIGUuc2V0VGltZXIoKSA6IGUuZGVhY3RpdmF0ZSgpKTtcbiAgICAgIH1cblxuICAgICAgb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCksIHRoaXMuU2xpZGVzaG93ICYmIHRoaXMuU2xpZGVzaG93LmlzQWN0aXZlKCkgJiYgdGhpcy5TbGlkZXNob3cuY2xlYXJUaW1lcigpO1xuICAgICAgfVxuXG4gICAgICBvbkRvbmUodCwgZSkge1xuICAgICAgICBjb25zdCBpID0gdGhpcy5TbGlkZXNob3c7XG4gICAgICAgIGUuaW5kZXggPT09IHQuZ2V0U2xpZGUoKS5pbmRleCAmJiAodGhpcy51cGRhdGUoKSwgaSAmJiBpLmlzQWN0aXZlKCkgJiYgKHQub3B0aW9uKFwiaW5maW5pdGVcIikgfHwgZS5pbmRleCAhPT0gdC5DYXJvdXNlbC5zbGlkZXMubGVuZ3RoIC0gMSA/IGkuc2V0VGltZXIoKSA6IGkuZGVhY3RpdmF0ZSgpKSk7XG4gICAgICB9XG5cbiAgICAgIG9uUmVmcmVzaCh0KSB7XG4gICAgICAgIHQgJiYgdC5pbmRleCAhPT0gdGhpcy5mYW5jeWJveC5nZXRTbGlkZSgpLmluZGV4IHx8ICh0aGlzLnVwZGF0ZSgpLCAhdGhpcy5TbGlkZXNob3cgfHwgIXRoaXMuU2xpZGVzaG93LmlzQWN0aXZlKCkgfHwgdCAmJiBcImRvbmVcIiAhPT0gdC5zdGF0ZSB8fCB0aGlzLlNsaWRlc2hvdy5kZWFjdGl2YXRlKCkpO1xuICAgICAgfVxuXG4gICAgICBvbktleWRvd24odCwgZSwgaSkge1xuICAgICAgICBcIiBcIiA9PT0gZSAmJiB0aGlzLlNsaWRlc2hvdyAmJiAodGhpcy5TbGlkZXNob3cudG9nZ2xlKCksIGkucHJldmVudERlZmF1bHQoKSk7XG4gICAgICB9XG5cbiAgICAgIG9uQ2xvc2luZygpIHtcbiAgICAgICAgdGhpcy5TbGlkZXNob3cgJiYgdGhpcy5TbGlkZXNob3cuZGVhY3RpdmF0ZSgpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZnVsbHNjcmVlbmNoYW5nZVwiLCB0aGlzLm9uRnNDaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVFbGVtZW50KHQpIHtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIFwiZGl2XCIgPT09IHQudHlwZSA/IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpIDogKGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiID09PSB0LnR5cGUgPyBcImFcIiA6IFwiYnV0dG9uXCIpLCBlLmNsYXNzTGlzdC5hZGQoXCJjYXJvdXNlbF9fYnV0dG9uXCIpKSwgZS5pbm5lckhUTUwgPSB0Lmh0bWwsIGUuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgdC50YWJpbmRleCB8fCAwKSwgdC5jbGFzcyAmJiBlLmNsYXNzTGlzdC5hZGQoLi4udC5jbGFzcy5zcGxpdChcIiBcIikpO1xuXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0LmF0dHIpIGUuc2V0QXR0cmlidXRlKGksIHQuYXR0cltpXSk7XG5cbiAgICAgICAgdC5sYWJlbCAmJiBlLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRoaXMuZmFuY3lib3gubG9jYWxpemUoYHt7JHt0LmxhYmVsfX19YCkpLCB0LmNsaWNrICYmIGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHQuY2xpY2suYmluZCh0aGlzKSksIFwicHJldlwiID09PSB0LmlkICYmIGUuc2V0QXR0cmlidXRlKFwiZGF0YS1mYW5jeWJveC1wcmV2XCIsIFwiXCIpLCBcIm5leHRcIiA9PT0gdC5pZCAmJiBlLnNldEF0dHJpYnV0ZShcImRhdGEtZmFuY3lib3gtbmV4dFwiLCBcIlwiKTtcbiAgICAgICAgY29uc3QgaSA9IGUucXVlcnlTZWxlY3RvcihcInN2Z1wiKTtcbiAgICAgICAgcmV0dXJuIGkgJiYgKGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKSwgaS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpLCBpLnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIikpLCBlO1xuICAgICAgfVxuXG4gICAgICBidWlsZCgpIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIlRvb2xiYXIuaXRlbXNcIiksXG4gICAgICAgICAgICAgIHMgPSBbe1xuICAgICAgICAgIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgfSwge1xuICAgICAgICAgIHBvc2l0aW9uOiBcImNlbnRlclwiLFxuICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcG9zaXRpb246IFwicmlnaHRcIixcbiAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgfV0sXG4gICAgICAgICAgICAgIG8gPSB0aGlzLmZhbmN5Ym94LnBsdWdpbnMuVGh1bWJzO1xuXG4gICAgICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIlRvb2xiYXIuZGlzcGxheVwiKSkge1xuICAgICAgICAgIGxldCBhLCByO1xuICAgICAgICAgIGlmICh0KG4pID8gKGEgPSBuLmlkLCByID0gZSh7fSwgaVthXSwgbikpIDogKGEgPSBuLCByID0gaVthXSksIFtcImNvdW50ZXJcIiwgXCJuZXh0XCIsIFwicHJldlwiLCBcInNsaWRlc2hvd1wiXS5pbmNsdWRlcyhhKSAmJiB0aGlzLmZhbmN5Ym94Lml0ZW1zLmxlbmd0aCA8IDIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKFwiZnVsbHNjcmVlblwiID09PSBhKSB7XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmZ1bGxzY3JlZW5FbmFibGVkIHx8IHdpbmRvdy5mdWxsU2NyZWVuKSBjb250aW51ZTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmdWxsc2NyZWVuY2hhbmdlXCIsIHRoaXMub25Gc0NoYW5nZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwidGh1bWJzXCIgPT09IGEgJiYgKCFvIHx8IFwiZGlzYWJsZWRcIiA9PT0gby5zdGF0ZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICghcikgY29udGludWU7XG4gICAgICAgICAgbGV0IGggPSByLnBvc2l0aW9uIHx8IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgbCA9IHMuZmluZCh0ID0+IHQucG9zaXRpb24gPT09IGgpO1xuICAgICAgICAgIGwgJiYgbC5pdGVtcy5wdXNoKHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIG4uY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X190b29sYmFyXCIpO1xuXG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBzKSBpZiAodC5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICBlLmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveF9fdG9vbGJhcl9faXRlbXNcIiksIGUuY2xhc3NMaXN0LmFkZChgZmFuY3lib3hfX3Rvb2xiYXJfX2l0ZW1zLS0ke3QucG9zaXRpb259YCk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdC5pdGVtcykgZS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUVsZW1lbnQoaSkpO1xuXG4gICAgICAgICAgbi5hcHBlbmRDaGlsZChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmFuY3lib3guJGNhcm91c2VsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG4sIHRoaXMuZmFuY3lib3guJGNhcm91c2VsKSwgdGhpcy4kY29udGFpbmVyID0gbjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5mYW5jeWJveC5nZXRTbGlkZSgpLFxuICAgICAgICAgICAgICBlID0gdC5pbmRleCxcbiAgICAgICAgICAgICAgaSA9IHRoaXMuZmFuY3lib3guaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICBzID0gdC5kb3dubG9hZFNyYyB8fCAoXCJpbWFnZVwiICE9PSB0LnR5cGUgfHwgdC5lcnJvciA/IG51bGwgOiB0LnNyYyk7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRoaXMuZmFuY3lib3guJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiYS5mYW5jeWJveF9fYnV0dG9uLS1kb3dubG9hZFwiKSkgcyA/ICh0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpLCB0LnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpLCB0LnNldEF0dHJpYnV0ZShcImhyZWZcIiwgcyksIHQuc2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIiwgcyksIHQuc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsIFwiX2JsYW5rXCIpKSA6ICh0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0LnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIC0xKSwgdC5yZW1vdmVBdHRyaWJ1dGUoXCJocmVmXCIpLCB0LnJlbW92ZUF0dHJpYnV0ZShcImRvd25sb2FkXCIpKTtcblxuICAgICAgICBjb25zdCBvID0gdC5QYW56b29tLFxuICAgICAgICAgICAgICBuID0gbyAmJiBvLm9wdGlvbihcIm1heFNjYWxlXCIpID4gby5vcHRpb24oXCJiYXNlU2NhbGVcIik7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRoaXMuZmFuY3lib3guJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLmZhbmN5Ym94X19idXR0b24tLXpvb21cIikpIG4gPyB0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpIDogdC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5mYW5jeWJveC4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1mYW5jeWJveC1pbmRleF1cIikpIGUuaW5uZXJIVE1MID0gdC5pbmRleCArIDE7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRoaXMuZmFuY3lib3guJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZmFuY3lib3gtY291bnRdXCIpKSB0LmlubmVySFRNTCA9IGk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmZhbmN5Ym94Lm9wdGlvbihcImluZmluaXRlXCIpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB0IG9mIHRoaXMuZmFuY3lib3guJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZmFuY3lib3gtcHJldl1cIikpIDAgPT09IGUgPyB0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpIDogdC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcblxuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLmZhbmN5Ym94LiRjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWZhbmN5Ym94LW5leHRdXCIpKSBlID09PSBpIC0gMSA/IHQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIikgOiB0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuU2xpZGVzaG93ICYmIHRoaXMuU2xpZGVzaG93LmlzQWN0aXZlKCkgJiYgdGhpcy5TbGlkZXNob3cuY2xlYXJUaW1lcigpLCB0aGlzLiRjb250YWluZXIgJiYgdGhpcy4kY29udGFpbmVyLnJlbW92ZSgpLCB0aGlzLiRjb250YWluZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2goKSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3gub24odGhpcy5ldmVudHMpO1xuICAgICAgfVxuXG4gICAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3gub2ZmKHRoaXMuZXZlbnRzKSwgdGhpcy5jbGVhbnVwKCk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBrLmRlZmF1bHRzID0gejtcbiAgICBjb25zdCBPID0ge1xuICAgICAgU2Nyb2xsTG9jazogY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgICAgdGhpcy5mYW5jeWJveCA9IHQsIHRoaXMudmlld3BvcnQgPSBudWxsLCB0aGlzLnBlbmRpbmdVcGRhdGUgPSBudWxsO1xuXG4gICAgICAgICAgZm9yIChjb25zdCB0IG9mIFtcIm9uUmVhZHlcIiwgXCJvblJlc2l6ZVwiLCBcIm9uVG91Y2hzdGFydFwiLCBcIm9uVG91Y2htb3ZlXCJdKSB0aGlzW3RdID0gdGhpc1t0XS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgb25SZWFkeSgpIHtcbiAgICAgICAgICBjb25zdCB0ID0gd2luZG93LnZpc3VhbFZpZXdwb3J0O1xuICAgICAgICAgIHQgJiYgKHRoaXMudmlld3BvcnQgPSB0LCB0aGlzLnN0YXJ0WSA9IDAsIHQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKSwgdGhpcy51cGRhdGVWaWV3cG9ydCgpKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMub25Ub3VjaHN0YXJ0LCB7XG4gICAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICAgIH0pLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uVG91Y2htb3ZlLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICAgIH0pLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uUmVzaXplKCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZVZpZXdwb3J0KCkge1xuICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmZhbmN5Ym94LFxuICAgICAgICAgICAgICAgIGUgPSB0aGlzLnZpZXdwb3J0LFxuICAgICAgICAgICAgICAgIGkgPSBlLnNjYWxlIHx8IDEsXG4gICAgICAgICAgICAgICAgcyA9IHQuJGNvbnRhaW5lcjtcbiAgICAgICAgICBpZiAoIXMpIHJldHVybjtcbiAgICAgICAgICBsZXQgbyA9IFwiXCIsXG4gICAgICAgICAgICAgIG4gPSBcIlwiLFxuICAgICAgICAgICAgICBhID0gXCJcIjtcbiAgICAgICAgICBpIC0gMSA+IC4xICYmIChvID0gZS53aWR0aCAqIGkgKyBcInB4XCIsIG4gPSBlLmhlaWdodCAqIGkgKyBcInB4XCIsIGEgPSBgdHJhbnNsYXRlM2QoJHtlLm9mZnNldExlZnR9cHgsICR7ZS5vZmZzZXRUb3B9cHgsIDApIHNjYWxlKCR7MSAvIGl9KWApLCBzLnN0eWxlLndpZHRoID0gbywgcy5zdHlsZS5oZWlnaHQgPSBuLCBzLnN0eWxlLnRyYW5zZm9ybSA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBvblRvdWNoc3RhcnQodCkge1xuICAgICAgICAgIHRoaXMuc3RhcnRZID0gdC50b3VjaGVzID8gdC50b3VjaGVzWzBdLnNjcmVlblkgOiB0LnNjcmVlblk7XG4gICAgICAgIH1cblxuICAgICAgICBvblRvdWNobW92ZSh0KSB7XG4gICAgICAgICAgY29uc3QgZSA9IHRoaXMuc3RhcnRZLFxuICAgICAgICAgICAgICAgIGkgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgaWYgKCF0LmNhbmNlbGFibGUpIHJldHVybjtcbiAgICAgICAgICBpZiAodC50b3VjaGVzLmxlbmd0aCA+IDEgfHwgMSAhPT0gaSkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IG8gPSBzKHQuY29tcG9zZWRQYXRoKClbMF0pO1xuICAgICAgICAgIGlmICghbykgcmV0dXJuIHZvaWQgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IG4gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShvKSxcbiAgICAgICAgICAgICAgICBhID0gcGFyc2VJbnQobi5nZXRQcm9wZXJ0eVZhbHVlKFwiaGVpZ2h0XCIpLCAxMCksXG4gICAgICAgICAgICAgICAgciA9IHQudG91Y2hlcyA/IHQudG91Y2hlc1swXS5zY3JlZW5ZIDogdC5zY3JlZW5ZLFxuICAgICAgICAgICAgICAgIGggPSBlIDw9IHIgJiYgMCA9PT0gby5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgbCA9IGUgPj0gciAmJiBvLnNjcm9sbEhlaWdodCAtIG8uc2Nyb2xsVG9wID09PSBhO1xuICAgICAgICAgIChoIHx8IGwpICYmIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uV2hlZWwodCkge1xuICAgICAgICAgIHModC5jb21wb3NlZFBhdGgoKVswXSkgfHwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYW51cCgpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdVcGRhdGUgJiYgKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucGVuZGluZ1VwZGF0ZSksIHRoaXMucGVuZGluZ1VwZGF0ZSA9IG51bGwpO1xuICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLnZpZXdwb3J0O1xuICAgICAgICAgIHQgJiYgKHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKSwgdGhpcy52aWV3cG9ydCA9IG51bGwpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblRvdWNoc3RhcnQsICExKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5vblRvdWNobW92ZSwgITEpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dGFjaCgpIHtcbiAgICAgICAgICB0aGlzLmZhbmN5Ym94Lm9uKFwiaW5pdExheW91dFwiLCB0aGlzLm9uUmVhZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0YWNoKCkge1xuICAgICAgICAgIHRoaXMuZmFuY3lib3gub2ZmKFwiaW5pdExheW91dFwiLCB0aGlzLm9uUmVhZHkpLCB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfVxuXG4gICAgICB9LFxuICAgICAgVGh1bWJzOiBDLFxuICAgICAgSHRtbDogUCxcbiAgICAgIFRvb2xiYXI6IGssXG4gICAgICBJbWFnZTogVCxcbiAgICAgIEhhc2g6IExcbiAgICB9O1xuICAgIGNvbnN0IE0gPSB7XG4gICAgICBzdGFydEluZGV4OiAwLFxuICAgICAgcHJlbG9hZDogMSxcbiAgICAgIGluZmluaXRlOiAhMCxcbiAgICAgIHNob3dDbGFzczogXCJmYW5jeWJveC16b29tSW5VcFwiLFxuICAgICAgaGlkZUNsYXNzOiBcImZhbmN5Ym94LWZhZGVPdXRcIixcbiAgICAgIGFuaW1hdGVkOiAhMCxcbiAgICAgIGhpZGVTY3JvbGxiYXI6ICEwLFxuICAgICAgcGFyZW50RWw6IG51bGwsXG4gICAgICBtYWluQ2xhc3M6IG51bGwsXG4gICAgICBhdXRvRm9jdXM6ICEwLFxuICAgICAgdHJhcEZvY3VzOiAhMCxcbiAgICAgIHBsYWNlRm9jdXNCYWNrOiAhMCxcbiAgICAgIGNsaWNrOiBcImNsb3NlXCIsXG4gICAgICBjbG9zZUJ1dHRvbjogXCJpbnNpZGVcIixcbiAgICAgIGRyYWdUb0Nsb3NlOiAhMCxcbiAgICAgIGtleWJvYXJkOiB7XG4gICAgICAgIEVzY2FwZTogXCJjbG9zZVwiLFxuICAgICAgICBEZWxldGU6IFwiY2xvc2VcIixcbiAgICAgICAgQmFja3NwYWNlOiBcImNsb3NlXCIsXG4gICAgICAgIFBhZ2VVcDogXCJuZXh0XCIsXG4gICAgICAgIFBhZ2VEb3duOiBcInByZXZcIixcbiAgICAgICAgQXJyb3dVcDogXCJuZXh0XCIsXG4gICAgICAgIEFycm93RG93bjogXCJwcmV2XCIsXG4gICAgICAgIEFycm93UmlnaHQ6IFwibmV4dFwiLFxuICAgICAgICBBcnJvd0xlZnQ6IFwicHJldlwiXG4gICAgICB9LFxuICAgICAgdGVtcGxhdGU6IHtcbiAgICAgICAgY2xvc2VCdXR0b246ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgdGFiaW5kZXg9XCItMVwiPjxwYXRoIGQ9XCJNMjAgMjBMNCA0bTE2IDBMNCAyMFwiLz48L3N2Zz4nLFxuICAgICAgICBzcGlubmVyOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgdmlld0JveD1cIjI1IDI1IDUwIDUwXCIgdGFiaW5kZXg9XCItMVwiPjxjaXJjbGUgY3g9XCI1MFwiIGN5PVwiNTBcIiByPVwiMjBcIi8+PC9zdmc+JyxcbiAgICAgICAgbWFpbjogbnVsbFxuICAgICAgfSxcbiAgICAgIGwxMG46IHtcbiAgICAgICAgQ0xPU0U6IFwiQ2xvc2VcIixcbiAgICAgICAgTkVYVDogXCJOZXh0XCIsXG4gICAgICAgIFBSRVY6IFwiUHJldmlvdXNcIixcbiAgICAgICAgTU9EQUw6IFwiWW91IGNhbiBjbG9zZSB0aGlzIG1vZGFsIGNvbnRlbnQgd2l0aCB0aGUgRVNDIGtleVwiLFxuICAgICAgICBFUlJPUjogXCJTb21ldGhpbmcgV2VudCBXcm9uZywgUGxlYXNlIFRyeSBBZ2FpbiBMYXRlclwiLFxuICAgICAgICBJTUFHRV9FUlJPUjogXCJJbWFnZSBOb3QgRm91bmRcIixcbiAgICAgICAgRUxFTUVOVF9OT1RfRk9VTkQ6IFwiSFRNTCBFbGVtZW50IE5vdCBGb3VuZFwiLFxuICAgICAgICBBSkFYX05PVF9GT1VORDogXCJFcnJvciBMb2FkaW5nIEFKQVggOiBOb3QgRm91bmRcIixcbiAgICAgICAgQUpBWF9GT1JCSURERU46IFwiRXJyb3IgTG9hZGluZyBBSkFYIDogRm9yYmlkZGVuXCIsXG4gICAgICAgIElGUkFNRV9FUlJPUjogXCJFcnJvciBMb2FkaW5nIFBhZ2VcIixcbiAgICAgICAgVE9HR0xFX1pPT006IFwiVG9nZ2xlIHpvb20gbGV2ZWxcIixcbiAgICAgICAgVE9HR0xFX1RIVU1CUzogXCJUb2dnbGUgdGh1bWJuYWlsc1wiLFxuICAgICAgICBUT0dHTEVfU0xJREVTSE9XOiBcIlRvZ2dsZSBzbGlkZXNob3dcIixcbiAgICAgICAgVE9HR0xFX0ZVTExTQ1JFRU46IFwiVG9nZ2xlIGZ1bGwtc2NyZWVuIG1vZGVcIixcbiAgICAgICAgRE9XTkxPQUQ6IFwiRG93bmxvYWRcIlxuICAgICAgfVxuICAgIH0sXG4gICAgICAgICAgSSA9IG5ldyBNYXAoKTtcbiAgICBsZXQgRiA9IDA7XG5cbiAgICBjbGFzcyBSIGV4dGVuZHMgbCB7XG4gICAgICBjb25zdHJ1Y3Rvcih0LCBpID0ge30pIHtcbiAgICAgICAgdCA9IHQubWFwKHQgPT4gKHQud2lkdGggJiYgKHQuX3dpZHRoID0gdC53aWR0aCksIHQuaGVpZ2h0ICYmICh0Ll9oZWlnaHQgPSB0LmhlaWdodCksIHQpKSwgc3VwZXIoZSghMCwge30sIE0sIGkpKSwgdGhpcy5iaW5kSGFuZGxlcnMoKSwgdGhpcy5zdGF0ZSA9IFwiaW5pdFwiLCB0aGlzLnNldEl0ZW1zKHQpLCB0aGlzLmF0dGFjaFBsdWdpbnMoUi5QbHVnaW5zKSwgdGhpcy50cmlnZ2VyKFwiaW5pdFwiKSwgITAgPT09IHRoaXMub3B0aW9uKFwiaGlkZVNjcm9sbGJhclwiKSAmJiB0aGlzLmhpZGVTY3JvbGxiYXIoKSwgdGhpcy5pbml0TGF5b3V0KCksIHRoaXMuaW5pdENhcm91c2VsKCksIHRoaXMuYXR0YWNoRXZlbnRzKCksIEkuc2V0KHRoaXMuaWQsIHRoaXMpLCB0aGlzLnRyaWdnZXIoXCJwcmVwYXJlXCIpLCB0aGlzLnN0YXRlID0gXCJyZWFkeVwiLCB0aGlzLnRyaWdnZXIoXCJyZWFkeVwiKSwgdGhpcy4kY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwiZmFsc2VcIiksIHRoaXMub3B0aW9uKFwidHJhcEZvY3VzXCIpICYmIHRoaXMuZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9uKHQsIC4uLmUpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuZ2V0U2xpZGUoKTtcbiAgICAgICAgbGV0IHMgPSBpID8gaVt0XSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gcyA/IChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHMgJiYgKHMgPSBzLmNhbGwodGhpcywgdGhpcywgLi4uZSkpLCBzKSA6IHN1cGVyLm9wdGlvbih0LCAuLi5lKTtcbiAgICAgIH1cblxuICAgICAgYmluZEhhbmRsZXJzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgW1wib25Nb3VzZWRvd25cIiwgXCJvbktleWRvd25cIiwgXCJvbkNsaWNrXCIsIFwib25Gb2N1c1wiLCBcIm9uQ3JlYXRlU2xpZGVcIiwgXCJvblNldHRsZVwiLCBcIm9uVG91Y2hNb3ZlXCIsIFwib25Ub3VjaEVuZFwiLCBcIm9uVHJhbnNmb3JtXCJdKSB0aGlzW3RdID0gdGhpc1t0XS5iaW5kKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2hFdmVudHMoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlZG93biksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub25LZXlkb3duLCAhMCksIHRoaXMub3B0aW9uKFwidHJhcEZvY3VzXCIpICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLm9uRm9jdXMsICEwKSwgdGhpcy4kY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgfVxuXG4gICAgICBkZXRhY2hFdmVudHMoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlZG93biksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub25LZXlkb3duLCAhMCksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLm9uRm9jdXMsICEwKSwgdGhpcy4kY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgfVxuXG4gICAgICBpbml0TGF5b3V0KCkge1xuICAgICAgICB0aGlzLiRyb290ID0gdGhpcy5vcHRpb24oXCJwYXJlbnRFbFwiKSB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICBsZXQgdCA9IHRoaXMub3B0aW9uKFwidGVtcGxhdGUubWFpblwiKTtcbiAgICAgICAgdCAmJiAodGhpcy4kcm9vdC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgdGhpcy5sb2NhbGl6ZSh0KSksIHRoaXMuJGNvbnRhaW5lciA9IHRoaXMuJHJvb3QucXVlcnlTZWxlY3RvcihcIi5mYW5jeWJveF9fY29udGFpbmVyXCIpKSwgdGhpcy4kY29udGFpbmVyIHx8ICh0aGlzLiRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB0aGlzLiRyb290LmFwcGVuZENoaWxkKHRoaXMuJGNvbnRhaW5lcikpLCB0aGlzLiRjb250YWluZXIub25zY3JvbGwgPSAoKSA9PiAodGhpcy4kY29udGFpbmVyLnNjcm9sbExlZnQgPSAwLCAhMSksIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgICAgICBjbGFzczogXCJmYW5jeWJveF9fY29udGFpbmVyXCIsXG4gICAgICAgICAgcm9sZTogXCJkaWFsb2dcIixcbiAgICAgICAgICB0YWJJbmRleDogXCItMVwiLFxuICAgICAgICAgIFwiYXJpYS1tb2RhbFwiOiBcInRydWVcIixcbiAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLmxvY2FsaXplKFwie3tNT0RBTH19XCIpXG4gICAgICAgIH0pLmZvckVhY2godCA9PiB0aGlzLiRjb250YWluZXIuc2V0QXR0cmlidXRlKC4uLnQpKSwgdGhpcy5vcHRpb24oXCJhbmltYXRlZFwiKSAmJiB0aGlzLiRjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImlzLWFuaW1hdGVkXCIpLCB0aGlzLiRiYWNrZHJvcCA9IHRoaXMuJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLmZhbmN5Ym94X19iYWNrZHJvcFwiKSwgdGhpcy4kYmFja2Ryb3AgfHwgKHRoaXMuJGJhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGhpcy4kYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X19iYWNrZHJvcFwiKSwgdGhpcy4kY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuJGJhY2tkcm9wKSksIHRoaXMuJGNhcm91c2VsID0gdGhpcy4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuZmFuY3lib3hfX2Nhcm91c2VsXCIpLCB0aGlzLiRjYXJvdXNlbCB8fCAodGhpcy4kY2Fyb3VzZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB0aGlzLiRjYXJvdXNlbC5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3hfX2Nhcm91c2VsXCIpLCB0aGlzLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy4kY2Fyb3VzZWwpKSwgdGhpcy4kY29udGFpbmVyLkZhbmN5Ym94ID0gdGhpcywgdGhpcy5pZCA9IHRoaXMuJGNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoXCJpZFwiKSwgdGhpcy5pZCB8fCAodGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZCB8fCArK0YsIHRoaXMuJGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImZhbmN5Ym94LVwiICsgdGhpcy5pZCkpO1xuICAgICAgICBjb25zdCBlID0gdGhpcy5vcHRpb24oXCJtYWluQ2xhc3NcIik7XG4gICAgICAgIHJldHVybiBlICYmIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLmUuc3BsaXQoXCIgXCIpKSwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJ3aXRoLWZhbmN5Ym94XCIpLCB0aGlzLnRyaWdnZXIoXCJpbml0TGF5b3V0XCIpLCB0aGlzO1xuICAgICAgfVxuXG4gICAgICBzZXRJdGVtcyh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdCkge1xuICAgICAgICAgIGNvbnN0IHQgPSBpLiR0cmlnZ2VyO1xuXG4gICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0LmRhdGFzZXQgfHwge307XG4gICAgICAgICAgICBpLnNyYyA9IGUuc3JjIHx8IHQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSB8fCBpLnNyYywgaS50eXBlID0gZS50eXBlIHx8IGkudHlwZSwgIWkuc3JjICYmIHQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICYmIChpLnNyYyA9IHQuY3VycmVudFNyYyB8fCBpLiR0cmlnZ2VyLnNyYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHMgPSBpLiR0aHVtYjtcblxuICAgICAgICAgIGlmICghcykge1xuICAgICAgICAgICAgbGV0IHQgPSBpLiR0cmlnZ2VyICYmIGkuJHRyaWdnZXIub3JpZ1RhcmdldDtcbiAgICAgICAgICAgIHQgJiYgKHMgPSB0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCA/IHQgOiB0LnF1ZXJ5U2VsZWN0b3IoXCJpbWc6bm90KFthcmlhLWhpZGRlbl0pXCIpKSwgIXMgJiYgaS4kdHJpZ2dlciAmJiAocyA9IGkuJHRyaWdnZXIgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ID8gaS4kdHJpZ2dlciA6IGkuJHRyaWdnZXIucXVlcnlTZWxlY3RvcihcImltZzpub3QoW2FyaWEtaGlkZGVuXSlcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkuJHRodW1iID0gcyB8fCBudWxsO1xuICAgICAgICAgIGxldCBvID0gaS50aHVtYjtcbiAgICAgICAgICAhbyAmJiBzICYmIChvID0gcy5jdXJyZW50U3JjIHx8IHMuc3JjLCAhbyAmJiBzLmRhdGFzZXQgJiYgKG8gPSBzLmRhdGFzZXQubGF6eVNyYyB8fCBzLmRhdGFzZXQuc3JjKSksIG8gfHwgXCJpbWFnZVwiICE9PSBpLnR5cGUgfHwgKG8gPSBpLnNyYyksIGkudGh1bWIgPSBvIHx8IG51bGwsIGkuY2FwdGlvbiA9IGkuY2FwdGlvbiB8fCBcIlwiLCBlLnB1c2goaSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLml0ZW1zID0gZTtcbiAgICAgIH1cblxuICAgICAgaW5pdENhcm91c2VsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5DYXJvdXNlbCA9IG5ldyB5KHRoaXMuJGNhcm91c2VsLCBlKCEwLCB7fSwge1xuICAgICAgICAgIHByZWZpeDogXCJcIixcbiAgICAgICAgICBjbGFzc05hbWVzOiB7XG4gICAgICAgICAgICB2aWV3cG9ydDogXCJmYW5jeWJveF9fdmlld3BvcnRcIixcbiAgICAgICAgICAgIHRyYWNrOiBcImZhbmN5Ym94X190cmFja1wiLFxuICAgICAgICAgICAgc2xpZGU6IFwiZmFuY3lib3hfX3NsaWRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRleHRTZWxlY3Rpb246ICEwLFxuICAgICAgICAgIHByZWxvYWQ6IHRoaXMub3B0aW9uKFwicHJlbG9hZFwiKSxcbiAgICAgICAgICBmcmljdGlvbjogLjg4LFxuICAgICAgICAgIHNsaWRlczogdGhpcy5pdGVtcyxcbiAgICAgICAgICBpbml0aWFsUGFnZTogdGhpcy5vcHRpb25zLnN0YXJ0SW5kZXgsXG4gICAgICAgICAgc2xpZGVzUGVyUGFnZTogMSxcbiAgICAgICAgICBpbmZpbml0ZVg6IHRoaXMub3B0aW9uKFwiaW5maW5pdGVcIiksXG4gICAgICAgICAgaW5maW5pdGVZOiAhMCxcbiAgICAgICAgICBsMTBuOiB0aGlzLm9wdGlvbihcImwxMG5cIiksXG4gICAgICAgICAgRG90czogITEsXG4gICAgICAgICAgTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgICAgICBtYWluOiBcImZhbmN5Ym94X19uYXZcIixcbiAgICAgICAgICAgICAgYnV0dG9uOiBcImNhcm91c2VsX19idXR0b25cIixcbiAgICAgICAgICAgICAgbmV4dDogXCJpcy1uZXh0XCIsXG4gICAgICAgICAgICAgIHByZXY6IFwiaXMtcHJldlwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBQYW56b29tOiB7XG4gICAgICAgICAgICB0ZXh0U2VsZWN0aW9uOiAhMCxcbiAgICAgICAgICAgIHBhbk9ubHlab29tZWQ6ICgpID0+IHRoaXMuQ2Fyb3VzZWwgJiYgdGhpcy5DYXJvdXNlbC5wYWdlcyAmJiB0aGlzLkNhcm91c2VsLnBhZ2VzLmxlbmd0aCA8IDIgJiYgIXRoaXMub3B0aW9uKFwiZHJhZ1RvQ2xvc2VcIiksXG4gICAgICAgICAgICBsb2NrQXhpczogKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5DYXJvdXNlbCkge1xuICAgICAgICAgICAgICAgIGxldCB0ID0gXCJ4XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uKFwiZHJhZ1RvQ2xvc2VcIikgJiYgKHQgKz0gXCJ5XCIpLCB0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCIqXCI6ICh0LCAuLi5lKSA9PiB0aGlzLnRyaWdnZXIoYENhcm91c2VsLiR7dH1gLCAuLi5lKSxcbiAgICAgICAgICAgIGluaXQ6IHQgPT4gdGhpcy5DYXJvdXNlbCA9IHQsXG4gICAgICAgICAgICBjcmVhdGVTbGlkZTogdGhpcy5vbkNyZWF0ZVNsaWRlLFxuICAgICAgICAgICAgc2V0dGxlOiB0aGlzLm9uU2V0dGxlXG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLm9wdGlvbihcIkNhcm91c2VsXCIpKSksIHRoaXMub3B0aW9uKFwiZHJhZ1RvQ2xvc2VcIikgJiYgdGhpcy5DYXJvdXNlbC5QYW56b29tLm9uKHtcbiAgICAgICAgICB0b3VjaE1vdmU6IHRoaXMub25Ub3VjaE1vdmUsXG4gICAgICAgICAgYWZ0ZXJUcmFuc2Zvcm06IHRoaXMub25UcmFuc2Zvcm0sXG4gICAgICAgICAgdG91Y2hFbmQ6IHRoaXMub25Ub3VjaEVuZFxuICAgICAgICB9KSwgdGhpcy50cmlnZ2VyKFwiaW5pdENhcm91c2VsXCIpLCB0aGlzO1xuICAgICAgfVxuXG4gICAgICBvbkNyZWF0ZVNsaWRlKHQsIGUpIHtcbiAgICAgICAgbGV0IGkgPSBlLmNhcHRpb24gfHwgXCJcIjtcblxuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0aGlzLm9wdGlvbnMuY2FwdGlvbiAmJiAoaSA9IHRoaXMub3B0aW9ucy5jYXB0aW9uLmNhbGwodGhpcywgdGhpcywgdGhpcy5DYXJvdXNlbCwgZSkpLCBcInN0cmluZ1wiID09IHR5cGVvZiBpICYmIGkubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICAgICAgcyA9IGBmYW5jeWJveF9fY2FwdGlvbl8ke3RoaXMuaWR9XyR7ZS5pbmRleH1gO1xuICAgICAgICAgIHQuY2xhc3NOYW1lID0gXCJmYW5jeWJveF9fY2FwdGlvblwiLCB0LmlubmVySFRNTCA9IGksIHQuc2V0QXR0cmlidXRlKFwiaWRcIiwgcyksIGUuJGNhcHRpb24gPSBlLiRlbC5hcHBlbmRDaGlsZCh0KSwgZS4kZWwuY2xhc3NMaXN0LmFkZChcImhhcy1jYXB0aW9uXCIpLCBlLiRlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25TZXR0bGUoKSB7XG4gICAgICAgIHRoaXMub3B0aW9uKFwiYXV0b0ZvY3VzXCIpICYmIHRoaXMuZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgb25Gb2N1cyh0KSB7XG4gICAgICAgIHRoaXMuaXNUb3Btb3N0KCkgJiYgdGhpcy5mb2N1cyh0KTtcbiAgICAgIH1cblxuICAgICAgb25DbGljayh0KSB7XG4gICAgICAgIGlmICh0LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgbGV0IGUgPSB0LmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgICAgICBpZiAoZS5tYXRjaGVzKFwiW2RhdGEtZmFuY3lib3gtY2xvc2VdXCIpKSByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpLCB2b2lkIFIuY2xvc2UoITEsIHQpO1xuICAgICAgICBpZiAoZS5tYXRjaGVzKFwiW2RhdGEtZmFuY3lib3gtbmV4dF1cIikpIHJldHVybiB0LnByZXZlbnREZWZhdWx0KCksIHZvaWQgUi5uZXh0KCk7XG4gICAgICAgIGlmIChlLm1hdGNoZXMoXCJbZGF0YS1mYW5jeWJveC1wcmV2XVwiKSkgcmV0dXJuIHQucHJldmVudERlZmF1bHQoKSwgdm9pZCBSLnByZXYoKTtcbiAgICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBpZiAoaS5jbG9zZXN0KFwiW2NvbnRlbnRlZGl0YWJsZV1cIikpIHJldHVybjtcbiAgICAgICAgICBlLm1hdGNoZXMoeCkgfHwgaS5ibHVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5jbG9zZXN0KFwiLmZhbmN5Ym94X19jb250ZW50XCIpKSByZXR1cm47XG4gICAgICAgIGlmIChnZXRTZWxlY3Rpb24oKS50b1N0cmluZygpLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICBpZiAoITEgPT09IHRoaXMudHJpZ2dlcihcImNsaWNrXCIsIHQpKSByZXR1cm47XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbihcImNsaWNrXCIpKSB7XG4gICAgICAgICAgY2FzZSBcImNsb3NlXCI6XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJuZXh0XCI6XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvblRvdWNoTW92ZSgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuZ2V0U2xpZGUoKS5QYW56b29tO1xuICAgICAgICByZXR1cm4gIXQgfHwgMSA9PT0gdC5jb250ZW50LnNjYWxlO1xuICAgICAgfVxuXG4gICAgICBvblRvdWNoRW5kKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHQuZHJhZ09mZnNldC55O1xuICAgICAgICBNYXRoLmFicyhlKSA+PSAxNTAgfHwgTWF0aC5hYnMoZSkgPj0gMzUgJiYgdC5kcmFnT2Zmc2V0LnRpbWUgPCAzNTAgPyAodGhpcy5vcHRpb24oXCJoaWRlQ2xhc3NcIikgJiYgKHRoaXMuZ2V0U2xpZGUoKS5oaWRlQ2xhc3MgPSBcImZhbmN5Ym94LXRocm93T3V0XCIgKyAodC5jb250ZW50LnkgPCAwID8gXCJVcFwiIDogXCJEb3duXCIpKSwgdGhpcy5jbG9zZSgpKSA6IFwieVwiID09PSB0LmxvY2tBeGlzICYmIHQucGFuVG8oe1xuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG9uVHJhbnNmb3JtKHQpIHtcbiAgICAgICAgaWYgKHRoaXMuJGJhY2tkcm9wKSB7XG4gICAgICAgICAgY29uc3QgZSA9IE1hdGguYWJzKHQuY29udGVudC55KSxcbiAgICAgICAgICAgICAgICBpID0gZSA8IDEgPyBcIlwiIDogTWF0aC5tYXgoLjMzLCBNYXRoLm1pbigxLCAxIC0gZSAvIHQuY29udGVudC5maXRIZWlnaHQgKiAxLjUpKTtcbiAgICAgICAgICB0aGlzLiRjb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLWZhbmN5Ym94LXRzXCIsIGkgPyBcIjBzXCIgOiBcIlwiKSwgdGhpcy4kY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1mYW5jeWJveC1vcGFjaXR5XCIsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uTW91c2Vkb3duKCkge1xuICAgICAgICBcInJlYWR5XCIgPT09IHRoaXMuc3RhdGUgJiYgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiaXMtdXNpbmctbW91c2VcIik7XG4gICAgICB9XG5cbiAgICAgIG9uS2V5ZG93bih0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1RvcG1vc3QoKSkgcmV0dXJuO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJpcy11c2luZy1tb3VzZVwiKTtcbiAgICAgICAgY29uc3QgZSA9IHQua2V5LFxuICAgICAgICAgICAgICBpID0gdGhpcy5vcHRpb24oXCJrZXlib2FyZFwiKTtcbiAgICAgICAgaWYgKCFpIHx8IHQuY3RybEtleSB8fCB0LmFsdEtleSB8fCB0LnNoaWZ0S2V5KSByZXR1cm47XG4gICAgICAgIGNvbnN0IHMgPSB0LmNvbXBvc2VkUGF0aCgpWzBdLFxuICAgICAgICAgICAgICBvID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsYXNzTGlzdCxcbiAgICAgICAgICAgICAgbiA9IG8gJiYgby5jb250YWlucyhcImNhcm91c2VsX19idXR0b25cIik7XG5cbiAgICAgICAgaWYgKFwiRXNjYXBlXCIgIT09IGUgJiYgIW4pIHtcbiAgICAgICAgICBpZiAodC50YXJnZXQuaXNDb250ZW50RWRpdGFibGUgfHwgLTEgIT09IFtcIkJVVFRPTlwiLCBcIlRFWFRBUkVBXCIsIFwiT1BUSU9OXCIsIFwiSU5QVVRcIiwgXCJTRUxFQ1RcIiwgXCJWSURFT1wiXS5pbmRleE9mKHMubm9kZU5hbWUpKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoITEgPT09IHRoaXMudHJpZ2dlcihcImtleWRvd25cIiwgZSwgdCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgYSA9IGlbZV07XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdGhpc1thXSAmJiB0aGlzW2FdKCk7XG4gICAgICB9XG5cbiAgICAgIGdldFNsaWRlKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5DYXJvdXNlbDtcbiAgICAgICAgaWYgKCF0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgZSA9IG51bGwgPT09IHQucGFnZSA/IHQub3B0aW9uKFwiaW5pdGlhbFBhZ2VcIikgOiB0LnBhZ2UsXG4gICAgICAgICAgICAgIGkgPSB0LnBhZ2VzIHx8IFtdO1xuICAgICAgICByZXR1cm4gaS5sZW5ndGggJiYgaVtlXSA/IGlbZV0uc2xpZGVzWzBdIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgZm9jdXModCkge1xuICAgICAgICBpZiAoUi5pZ25vcmVGb2N1c0NoYW5nZSkgcmV0dXJuO1xuICAgICAgICBpZiAoW1wiaW5pdFwiLCBcImNsb3NpbmdcIiwgXCJjdXN0b21DbG9zaW5nXCIsIFwiZGVzdHJveVwiXS5pbmRleE9mKHRoaXMuc3RhdGUpID4gLTEpIHJldHVybjtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuJGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgaSA9IHRoaXMuZ2V0U2xpZGUoKSxcbiAgICAgICAgICAgICAgcyA9IFwiZG9uZVwiID09PSBpLnN0YXRlID8gaS4kZWwgOiBudWxsO1xuICAgICAgICBpZiAocyAmJiBzLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSByZXR1cm47XG4gICAgICAgIHQgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCBSLmlnbm9yZUZvY3VzQ2hhbmdlID0gITA7XG4gICAgICAgIGNvbnN0IG8gPSBBcnJheS5mcm9tKGUucXVlcnlTZWxlY3RvckFsbCh4KSk7XG4gICAgICAgIGxldCBuLFxuICAgICAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IHQgb2Ygbykge1xuICAgICAgICAgIGNvbnN0IGUgPSB0Lm9mZnNldFBhcmVudCxcbiAgICAgICAgICAgICAgICBpID0gcyAmJiBzLmNvbnRhaW5zKHQpLFxuICAgICAgICAgICAgICAgIG8gPSAhdGhpcy5DYXJvdXNlbC4kdmlld3BvcnQuY29udGFpbnModCk7XG4gICAgICAgICAgZSAmJiAoaSB8fCBvKSA/IChhLnB1c2godCksIHZvaWQgMCAhPT0gdC5kYXRhc2V0Lm9yaWdUYWJpbmRleCAmJiAodC50YWJJbmRleCA9IHQuZGF0YXNldC5vcmlnVGFiaW5kZXgsIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1vcmlnLXRhYmluZGV4XCIpKSwgKHQuaGFzQXR0cmlidXRlKFwiYXV0b0ZvY3VzXCIpIHx8ICFuICYmIGkgJiYgIXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY2Fyb3VzZWxfX2J1dHRvblwiKSkgJiYgKG4gPSB0KSkgOiAodC5kYXRhc2V0Lm9yaWdUYWJpbmRleCA9IHZvaWQgMCA9PT0gdC5kYXRhc2V0Lm9yaWdUYWJpbmRleCA/IHQuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgOiB0LmRhdGFzZXQub3JpZ1RhYmluZGV4LCB0LnRhYkluZGV4ID0gLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdCA/IGEuaW5kZXhPZih0LnRhcmdldCkgPiAtMSA/IHRoaXMubGFzdEZvY3VzID0gdC50YXJnZXQgOiB0aGlzLmxhc3RGb2N1cyA9PT0gZSA/IHcoYVthLmxlbmd0aCAtIDFdKSA6IHcoZSkgOiB0aGlzLm9wdGlvbihcImF1dG9Gb2N1c1wiKSAmJiBuID8gdyhuKSA6IGEuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KSA8IDAgJiYgdyhlKSwgdGhpcy5sYXN0Rm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50LCBSLmlnbm9yZUZvY3VzQ2hhbmdlID0gITE7XG4gICAgICB9XG5cbiAgICAgIGhpZGVTY3JvbGxiYXIoKSB7XG4gICAgICAgIGlmICghdikgcmV0dXJuO1xuICAgICAgICBjb25zdCB0ID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsXG4gICAgICAgICAgICAgIGUgPSBcImZhbmN5Ym94LXN0eWxlLW5vc2Nyb2xsXCI7XG4gICAgICAgIGxldCBpID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSk7XG4gICAgICAgIGkgfHwgdCA+IDAgJiYgKGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiksIGkuaWQgPSBlLCBpLnR5cGUgPSBcInRleHQvY3NzXCIsIGkuaW5uZXJIVE1MID0gYC5jb21wZW5zYXRlLWZvci1zY3JvbGxiYXIge3BhZGRpbmctcmlnaHQ6ICR7dH1weDt9YCwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKGkpLCBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJjb21wZW5zYXRlLWZvci1zY3JvbGxiYXJcIikpO1xuICAgICAgfVxuXG4gICAgICByZXZlYWxTY3JvbGxiYXIoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImNvbXBlbnNhdGUtZm9yLXNjcm9sbGJhclwiKTtcbiAgICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmFuY3lib3gtc3R5bGUtbm9zY3JvbGxcIik7XG4gICAgICAgIHQgJiYgdC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJDb250ZW50KHQpIHtcbiAgICAgICAgdGhpcy5DYXJvdXNlbC50cmlnZ2VyKFwicmVtb3ZlU2xpZGVcIiwgdCksIHQuJGNvbnRlbnQgJiYgKHQuJGNvbnRlbnQucmVtb3ZlKCksIHQuJGNvbnRlbnQgPSBudWxsKSwgdC4kY2xvc2VCdXR0b24gJiYgKHQuJGNsb3NlQnV0dG9uLnJlbW92ZSgpLCB0LiRjbG9zZUJ1dHRvbiA9IG51bGwpLCB0Ll9jbGFzc05hbWUgJiYgdC4kZWwuY2xhc3NMaXN0LnJlbW92ZSh0Ll9jbGFzc05hbWUpO1xuICAgICAgfVxuXG4gICAgICBzZXRDb250ZW50KHQsIGUsIGkgPSB7fSkge1xuICAgICAgICBsZXQgcztcbiAgICAgICAgY29uc3QgbyA9IHQuJGVsO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSBbXCJpbWdcIiwgXCJpZnJhbWVcIiwgXCJ2aWRlb1wiLCBcImF1ZGlvXCJdLmluZGV4T2YoZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA+IC0xID8gKHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBzLmFwcGVuZENoaWxkKGUpKSA6IHMgPSBlO2Vsc2Uge1xuICAgICAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChlKTtcbiAgICAgICAgICBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgcy5hcHBlbmRDaGlsZCh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodC5maWx0ZXIgJiYgIXQuZXJyb3IgJiYgKHMgPSBzLnF1ZXJ5U2VsZWN0b3IodC5maWx0ZXIpKSwgcyBpbnN0YW5jZW9mIEVsZW1lbnQpIHJldHVybiB0Ll9jbGFzc05hbWUgPSBgaGFzLSR7aS5zdWZmaXggfHwgdC50eXBlIHx8IFwidW5rbm93blwifWAsIG8uY2xhc3NMaXN0LmFkZCh0Ll9jbGFzc05hbWUpLCBzLmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveF9fY29udGVudFwiKSwgXCJub25lXCIgIT09IHMuc3R5bGUuZGlzcGxheSAmJiBcIm5vbmVcIiAhPT0gZ2V0Q29tcHV0ZWRTdHlsZShzKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKSB8fCAocy5zdHlsZS5kaXNwbGF5ID0gdC5kaXNwbGF5IHx8IHRoaXMub3B0aW9uKFwiZGVmYXVsdERpc3BsYXlcIikgfHwgXCJmbGV4XCIpLCB0LmlkICYmIHMuc2V0QXR0cmlidXRlKFwiaWRcIiwgdC5pZCksIHQuJGNvbnRlbnQgPSBzLCBvLnByZXBlbmQocyksIHRoaXMubWFuYWdlQ2xvc2VCdXR0b24odCksIFwibG9hZGluZ1wiICE9PSB0LnN0YXRlICYmIHRoaXMucmV2ZWFsQ29udGVudCh0KSwgcztcbiAgICAgICAgdGhpcy5zZXRFcnJvcih0LCBcInt7RUxFTUVOVF9OT1RfRk9VTkR9fVwiKTtcbiAgICAgIH1cblxuICAgICAgbWFuYWdlQ2xvc2VCdXR0b24odCkge1xuICAgICAgICBjb25zdCBlID0gdm9pZCAwID09PSB0LmNsb3NlQnV0dG9uID8gdGhpcy5vcHRpb24oXCJjbG9zZUJ1dHRvblwiKSA6IHQuY2xvc2VCdXR0b247XG4gICAgICAgIGlmICghZSB8fCBcInRvcFwiID09PSBlICYmIHRoaXMuJGNsb3NlQnV0dG9uKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICBpLmNsYXNzTGlzdC5hZGQoXCJjYXJvdXNlbF9fYnV0dG9uXCIsIFwiaXMtY2xvc2VcIiksIGkuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdGhpcy5vcHRpb25zLmwxMG4uQ0xPU0UpLCBpLmlubmVySFRNTCA9IHRoaXMub3B0aW9uKFwidGVtcGxhdGUuY2xvc2VCdXR0b25cIiksIGkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHQgPT4gdGhpcy5jbG9zZSh0KSksIFwiaW5zaWRlXCIgPT09IGUgPyAodC4kY2xvc2VCdXR0b24gJiYgdC4kY2xvc2VCdXR0b24ucmVtb3ZlKCksIHQuJGNsb3NlQnV0dG9uID0gdC4kY29udGVudC5hcHBlbmRDaGlsZChpKSkgOiB0aGlzLiRjbG9zZUJ1dHRvbiA9IHRoaXMuJGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoaSwgdGhpcy4kY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICByZXZlYWxDb250ZW50KHQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwicmV2ZWFsXCIsIHQpLCB0LiRjb250ZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgICAgICBsZXQgZSA9ICExO1xuICAgICAgICB0LmVycm9yIHx8IFwibG9hZGluZ1wiID09PSB0LnN0YXRlIHx8IG51bGwgIT09IHRoaXMuQ2Fyb3VzZWwucHJldlBhZ2UgfHwgdC5pbmRleCAhPT0gdGhpcy5vcHRpb25zLnN0YXJ0SW5kZXggfHwgKGUgPSB2b2lkIDAgPT09IHQuc2hvd0NsYXNzID8gdGhpcy5vcHRpb24oXCJzaG93Q2xhc3NcIikgOiB0LnNob3dDbGFzcyksIGUgPyAodC5zdGF0ZSA9IFwiYW5pbWF0aW5nXCIsIHRoaXMuYW5pbWF0ZUNTUyh0LiRjb250ZW50LCBlLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kb25lKHQpO1xuICAgICAgICB9KSkgOiB0aGlzLmRvbmUodCk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGVDU1ModCwgZSwgaSkge1xuICAgICAgICBpZiAodCAmJiB0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiYW5pbWF0aW9uZW5kXCIsIHtcbiAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICBjYW5jZWxhYmxlOiAhMFxuICAgICAgICB9KSksICF0IHx8ICFlKSByZXR1cm4gdm9pZCAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpICYmIGkoKSk7XG5cbiAgICAgICAgY29uc3QgcyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgby5jdXJyZW50VGFyZ2V0ID09PSB0aGlzICYmICh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgcyksIGkgJiYgaSgpLCB0LmNsYXNzTGlzdC5yZW1vdmUoZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBzKSwgdC5jbGFzc0xpc3QuYWRkKGUpO1xuICAgICAgfVxuXG4gICAgICBkb25lKHQpIHtcbiAgICAgICAgdC5zdGF0ZSA9IFwiZG9uZVwiLCB0aGlzLnRyaWdnZXIoXCJkb25lXCIsIHQpO1xuICAgICAgICBjb25zdCBlID0gdGhpcy5nZXRTbGlkZSgpO1xuICAgICAgICBlICYmIHQuaW5kZXggPT09IGUuaW5kZXggJiYgdGhpcy5vcHRpb24oXCJhdXRvRm9jdXNcIikgJiYgdGhpcy5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBzZXRFcnJvcih0LCBlKSB7XG4gICAgICAgIHQuZXJyb3IgPSBlLCB0aGlzLmhpZGVMb2FkaW5nKHQpLCB0aGlzLmNsZWFyQ29udGVudCh0KTtcbiAgICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGkuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94LWVycm9yXCIpLCBpLmlubmVySFRNTCA9IHRoaXMubG9jYWxpemUoZSB8fCBcIjxwPnt7RVJST1J9fTwvcD5cIiksIHRoaXMuc2V0Q29udGVudCh0LCBpLCB7XG4gICAgICAgICAgc3VmZml4OiBcImVycm9yXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNob3dMb2FkaW5nKHQpIHtcbiAgICAgICAgdC5zdGF0ZSA9IFwibG9hZGluZ1wiLCB0LiRlbC5jbGFzc0xpc3QuYWRkKFwiaXMtbG9hZGluZ1wiKTtcbiAgICAgICAgbGV0IGUgPSB0LiRlbC5xdWVyeVNlbGVjdG9yKFwiLmZhbmN5Ym94X19zcGlubmVyXCIpO1xuICAgICAgICBlIHx8IChlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgZS5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3hfX3NwaW5uZXJcIiksIGUuaW5uZXJIVE1MID0gdGhpcy5vcHRpb24oXCJ0ZW1wbGF0ZS5zcGlubmVyXCIpLCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5DYXJvdXNlbC5QYW56b29tLnZlbG9jaXR5IHx8IHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSksIHQuJGVsLnByZXBlbmQoZSkpO1xuICAgICAgfVxuXG4gICAgICBoaWRlTG9hZGluZyh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0LiRlbCAmJiB0LiRlbC5xdWVyeVNlbGVjdG9yKFwiLmZhbmN5Ym94X19zcGlubmVyXCIpO1xuICAgICAgICBlICYmIChlLnJlbW92ZSgpLCB0LiRlbC5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtbG9hZGluZ1wiKSksIFwibG9hZGluZ1wiID09PSB0LnN0YXRlICYmICh0aGlzLnRyaWdnZXIoXCJsb2FkXCIsIHQpLCB0LnN0YXRlID0gXCJyZWFkeVwiKTtcbiAgICAgIH1cblxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuQ2Fyb3VzZWw7XG4gICAgICAgIHQgJiYgdC5wYWdlcy5sZW5ndGggPiAxICYmIHQuc2xpZGVOZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHByZXYoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLkNhcm91c2VsO1xuICAgICAgICB0ICYmIHQucGFnZXMubGVuZ3RoID4gMSAmJiB0LnNsaWRlUHJldigpO1xuICAgICAgfVxuXG4gICAgICBqdW1wVG8oLi4udCkge1xuICAgICAgICB0aGlzLkNhcm91c2VsICYmIHRoaXMuQ2Fyb3VzZWwuc2xpZGVUbyguLi50KTtcbiAgICAgIH1cblxuICAgICAgaXNDbG9zaW5nKCkge1xuICAgICAgICByZXR1cm4gW1wiY2xvc2luZ1wiLCBcImN1c3RvbUNsb3NpbmdcIiwgXCJkZXN0cm95XCJdLmluY2x1ZGVzKHRoaXMuc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBpc1RvcG1vc3QoKSB7XG4gICAgICAgIHJldHVybiBSLmdldEluc3RhbmNlKCkuaWQgPT0gdGhpcy5pZDtcbiAgICAgIH1cblxuICAgICAgY2xvc2UodCkge1xuICAgICAgICBpZiAodCAmJiB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuaXNDbG9zaW5nKCkpIHJldHVybjtcbiAgICAgICAgaWYgKCExID09PSB0aGlzLnRyaWdnZXIoXCJzaG91bGRDbG9zZVwiLCB0KSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9IFwiY2xvc2luZ1wiLCB0aGlzLkNhcm91c2VsLlBhbnpvb20uZGVzdHJveSgpLCB0aGlzLmRldGFjaEV2ZW50cygpLCB0aGlzLnRyaWdnZXIoXCJjbG9zaW5nXCIsIHQpLCBcImRlc3Ryb3lcIiA9PT0gdGhpcy5zdGF0ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpLCB0aGlzLiRjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImlzLWNsb3NpbmdcIik7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmdldFNsaWRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuQ2Fyb3VzZWwuc2xpZGVzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgdC4kY29udGVudCAmJiB0LmluZGV4ICE9PSBlLmluZGV4ICYmIHRoaXMuQ2Fyb3VzZWwudHJpZ2dlcihcInJlbW92ZVNsaWRlXCIsIHQpO1xuICAgICAgICB9KSwgXCJjbG9zaW5nXCIgPT09IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICBjb25zdCB0ID0gdm9pZCAwID09PSBlLmhpZGVDbGFzcyA/IHRoaXMub3B0aW9uKFwiaGlkZUNsYXNzXCIpIDogZS5oaWRlQ2xhc3M7XG4gICAgICAgICAgdGhpcy5hbmltYXRlQ1NTKGUuJGNvbnRlbnQsIHQsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgIH0sICEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoXCJkZXN0cm95XCIgPT09IHRoaXMuc3RhdGUpIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiZGVzdHJveVwiLCB0aGlzLnRyaWdnZXIoXCJkZXN0cm95XCIpO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5vcHRpb24oXCJwbGFjZUZvY3VzQmFja1wiKSA/IHRoaXMub3B0aW9uKFwidHJpZ2dlclRhcmdldFwiLCB0aGlzLmdldFNsaWRlKCkuJHRyaWdnZXIpIDogbnVsbDtcbiAgICAgICAgdGhpcy5DYXJvdXNlbC5kZXN0cm95KCksIHRoaXMuZGV0YWNoUGx1Z2lucygpLCB0aGlzLkNhcm91c2VsID0gbnVsbCwgdGhpcy5vcHRpb25zID0ge30sIHRoaXMuZXZlbnRzID0ge30sIHRoaXMuJGNvbnRhaW5lci5yZW1vdmUoKSwgdGhpcy4kY29udGFpbmVyID0gdGhpcy4kYmFja2Ryb3AgPSB0aGlzLiRjYXJvdXNlbCA9IG51bGwsIHQgJiYgdyh0KSwgSS5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgIGNvbnN0IGUgPSBSLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGUgPyBlLmZvY3VzKCkgOiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJ3aXRoLWZhbmN5Ym94XCIpLCBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJpcy11c2luZy1tb3VzZVwiKSwgdGhpcy5yZXZlYWxTY3JvbGxiYXIoKSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBzaG93KHQsIGUgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFIodCwgZSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBmcm9tRXZlbnQodCwgZSA9IHt9KSB7XG4gICAgICAgIGlmICh0LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHQuYnV0dG9uICYmIDAgIT09IHQuYnV0dG9uKSByZXR1cm47XG4gICAgICAgIGlmICh0LmN0cmxLZXkgfHwgdC5tZXRhS2V5IHx8IHQuc2hpZnRLZXkpIHJldHVybjtcbiAgICAgICAgY29uc3QgaSA9IHQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICAgIGxldCBzLFxuICAgICAgICAgICAgbyxcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICBhID0gaTtcblxuICAgICAgICBpZiAoKGEubWF0Y2hlcyhcIltkYXRhLWZhbmN5Ym94LXRyaWdnZXJdXCIpIHx8IChhID0gYS5jbG9zZXN0KFwiW2RhdGEtZmFuY3lib3gtdHJpZ2dlcl1cIikpKSAmJiAoZS50cmlnZ2VyVGFyZ2V0ID0gYSwgcyA9IGEgJiYgYS5kYXRhc2V0ICYmIGEuZGF0YXNldC5mYW5jeWJveFRyaWdnZXIpLCBzKSB7XG4gICAgICAgICAgY29uc3QgdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLWZhbmN5Ym94PVwiJHtzfVwiXWApLFxuICAgICAgICAgICAgICAgIGUgPSBwYXJzZUludChhLmRhdGFzZXQuZmFuY3lib3hJbmRleCwgMTApIHx8IDA7XG4gICAgICAgICAgYSA9IHQubGVuZ3RoID8gdFtlXSA6IGE7XG4gICAgICAgIH1cblxuICAgICAgICBBcnJheS5mcm9tKFIub3BlbmVycy5rZXlzKCkpLnJldmVyc2UoKS5zb21lKGUgPT4ge1xuICAgICAgICAgIG4gPSBhIHx8IGk7XG4gICAgICAgICAgbGV0IHMgPSAhMTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuIGluc3RhbmNlb2YgRWxlbWVudCAmJiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSB8fCBlIGluc3RhbmNlb2YgU3RyaW5nKSAmJiAocyA9IG4ubWF0Y2hlcyhlKSB8fCAobiA9IG4uY2xvc2VzdChlKSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHQpIHt9XG5cbiAgICAgICAgICByZXR1cm4gISFzICYmICh0LnByZXZlbnREZWZhdWx0KCksIG8gPSBlLCAhMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgciA9ICExO1xuXG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgZS5ldmVudCA9IHQsIGUudGFyZ2V0ID0gbiwgbi5vcmlnVGFyZ2V0ID0gaSwgciA9IFIuZnJvbU9wZW5lcihvLCBlKTtcbiAgICAgICAgICBjb25zdCBzID0gUi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgIHMgJiYgXCJyZWFkeVwiID09PSBzLnN0YXRlICYmIHQuZGV0YWlsICYmIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcImlzLXVzaW5nLW1vdXNlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBmcm9tT3BlbmVyKHQsIGkgPSB7fSkge1xuICAgICAgICBsZXQgcyA9IFtdLFxuICAgICAgICAgICAgbyA9IGkuc3RhcnRJbmRleCB8fCAwLFxuICAgICAgICAgICAgbiA9IGkudGFyZ2V0IHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGEgPSB2b2lkIDAgIT09IChpID0gZSh7fSwgaSwgUi5vcGVuZXJzLmdldCh0KSkpLmdyb3VwQWxsICYmIGkuZ3JvdXBBbGwsXG4gICAgICAgICAgICAgIHIgPSB2b2lkIDAgPT09IGkuZ3JvdXBBdHRyID8gXCJkYXRhLWZhbmN5Ym94XCIgOiBpLmdyb3VwQXR0cixcbiAgICAgICAgICAgICAgaCA9IHIgJiYgbiA/IG4uZ2V0QXR0cmlidXRlKGAke3J9YCkgOiBcIlwiO1xuXG4gICAgICAgIGlmICghbiB8fCBoIHx8IGEpIHtcbiAgICAgICAgICBjb25zdCBlID0gaS5yb290IHx8IChuID8gbi5nZXRSb290Tm9kZSgpIDogZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgcyA9IFtdLnNsaWNlLmNhbGwoZS5xdWVyeVNlbGVjdG9yQWxsKHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuICYmICFhICYmIChzID0gaCA/IHMuZmlsdGVyKHQgPT4gdC5nZXRBdHRyaWJ1dGUoYCR7cn1gKSA9PT0gaCkgOiBbbl0pLCAhcy5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgbCA9IFIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgcmV0dXJuICEobCAmJiBzLmluZGV4T2YobC5vcHRpb25zLiR0cmlnZ2VyKSA+IC0xKSAmJiAobyA9IG4gPyBzLmluZGV4T2YobikgOiBvLCBzID0gcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBjb25zdCBlID0gW1wiZmFsc2VcIiwgXCIwXCIsIFwibm9cIiwgXCJudWxsXCIsIFwidW5kZWZpbmVkXCJdLFxuICAgICAgICAgICAgICAgIGkgPSBbXCJ0cnVlXCIsIFwiMVwiLCBcInllc1wiXSxcbiAgICAgICAgICAgICAgICBzID0gT2JqZWN0LmFzc2lnbih7fSwgdC5kYXRhc2V0KSxcbiAgICAgICAgICAgICAgICBvID0ge307XG5cbiAgICAgICAgICBmb3IgKGxldCBbdCwgbl0gb2YgT2JqZWN0LmVudHJpZXMocykpIGlmIChcImZhbmN5Ym94XCIgIT09IHQpIGlmIChcIndpZHRoXCIgPT09IHQgfHwgXCJoZWlnaHRcIiA9PT0gdCkgb1tgXyR7dH1gXSA9IG47ZWxzZSBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiB8fCBuIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKG4pID4gLTEpIG9bdF0gPSAhMTtlbHNlIGlmIChpLmluZGV4T2Yob1t0XSkgPiAtMSkgb1t0XSA9ICEwO2Vsc2UgdHJ5IHtcbiAgICAgICAgICAgICAgb1t0XSA9IEpTT04ucGFyc2Uobik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIG9bdF0gPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBvW3RdID0gbjtcblxuICAgICAgICAgIHJldHVybiB0IGluc3RhbmNlb2YgRWxlbWVudCAmJiAoby4kdHJpZ2dlciA9IHQpLCBvO1xuICAgICAgICB9KSwgbmV3IFIocywgZSh7fSwgaSwge1xuICAgICAgICAgIHN0YXJ0SW5kZXg6IG8sXG4gICAgICAgICAgJHRyaWdnZXI6IG5cbiAgICAgICAgfSkpKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGJpbmQodCwgZSA9IHt9KSB7XG4gICAgICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgUi5mcm9tRXZlbnQsICExKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHYgJiYgKFIub3BlbmVycy5zaXplIHx8ICgvY29tcGxldGV8aW50ZXJhY3RpdmV8bG9hZGVkLy50ZXN0KGRvY3VtZW50LnJlYWR5U3RhdGUpID8gaSgpIDogZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgaSkpLCBSLm9wZW5lcnMuc2V0KHQsIGUpKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIHVuYmluZCh0KSB7XG4gICAgICAgIFIub3BlbmVycy5kZWxldGUodCksIFIub3BlbmVycy5zaXplIHx8IFIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgZGVzdHJveSgpIHtcbiAgICAgICAgbGV0IHQ7XG5cbiAgICAgICAgZm9yICg7IHQgPSBSLmdldEluc3RhbmNlKCk7KSB0LmRlc3Ryb3koKTtcblxuICAgICAgICBSLm9wZW5lcnMgPSBuZXcgTWFwKCksIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIFIuZnJvbUV2ZW50LCAhMSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgICAgIGlmICh0KSByZXR1cm4gSS5nZXQodCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKEkudmFsdWVzKCkpLnJldmVyc2UoKS5maW5kKHQgPT4gIXQuaXNDbG9zaW5nKCkgJiYgdCkgfHwgbnVsbDtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGNsb3NlKHQgPSAhMCwgZSkge1xuICAgICAgICBpZiAodCkgZm9yIChjb25zdCB0IG9mIEkudmFsdWVzKCkpIHQuY2xvc2UoZSk7ZWxzZSB7XG4gICAgICAgICAgY29uc3QgdCA9IFIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICB0ICYmIHQuY2xvc2UoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGljIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHQgPSBSLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHQgJiYgdC5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBwcmV2KCkge1xuICAgICAgICBjb25zdCB0ID0gUi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB0ICYmIHQucHJldigpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgUi52ZXJzaW9uID0gXCI0LjAuMzFcIiwgUi5kZWZhdWx0cyA9IE0sIFIub3BlbmVycyA9IG5ldyBNYXAoKSwgUi5QbHVnaW5zID0gTywgUi5iaW5kKFwiW2RhdGEtZmFuY3lib3hdXCIpO1xuXG4gICAgZm9yIChjb25zdCBbdCwgZV0gb2YgT2JqZWN0LmVudHJpZXMoUi5QbHVnaW5zIHx8IHt9KSkgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlLmNyZWF0ZSAmJiBlLmNyZWF0ZShSKTtcblxuICAgIHZhciB3cGNmN0VsbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy53cGNmNycpO1xuXG4gICAgaWYgKHdwY2Y3RWxtKSB7XG4gICAgICB3cGNmN0VsbS5hZGRFdmVudExpc3RlbmVyKCd3cGNmN21haWxzZW50JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICBjbG9zZSgpO1xuICAgICAgfSwgZmFsc2UpO1xuICAgICAgd3BjZjdFbG0uYWRkRXZlbnRMaXN0ZW5lcignd3BjZjdzdWJtaXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3N1Ym1pdHRlZCcpO1xuICAgICAgICBjb25zb2xlLmxvZyhldmVudC5kZXRhaWwuYXBpUmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgIFIuc2hvdyhbe1xuICAgICAgICAgIHNyYzogZXZlbnQuZGV0YWlsLmFwaVJlc3BvbnNlLm1lc3NhZ2UsXG4gICAgICAgICAgdHlwZTogXCJodG1sXCJcbiAgICAgICAgfV0pO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4gICAgZnVuY3Rpb24gdW53cmFwRXhwb3J0cyAoeCkge1xuICAgIFx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG4gICAgXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG4gICAgfVxuXG4gICAgdmFyIG5vdWlzbGlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgICBmYWN0b3J5KGV4cG9ydHMpIDtcbiAgICB9KShjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAgICAgZXhwb3J0cy5QaXBzTW9kZSA9IHZvaWQgMDtcblxuICAgICAgKGZ1bmN0aW9uIChQaXBzTW9kZSkge1xuICAgICAgICBQaXBzTW9kZVtcIlJhbmdlXCJdID0gXCJyYW5nZVwiO1xuICAgICAgICBQaXBzTW9kZVtcIlN0ZXBzXCJdID0gXCJzdGVwc1wiO1xuICAgICAgICBQaXBzTW9kZVtcIlBvc2l0aW9uc1wiXSA9IFwicG9zaXRpb25zXCI7XG4gICAgICAgIFBpcHNNb2RlW1wiQ291bnRcIl0gPSBcImNvdW50XCI7XG4gICAgICAgIFBpcHNNb2RlW1wiVmFsdWVzXCJdID0gXCJ2YWx1ZXNcIjtcbiAgICAgIH0pKGV4cG9ydHMuUGlwc01vZGUgfHwgKGV4cG9ydHMuUGlwc01vZGUgPSB7fSkpO1xuXG4gICAgICBleHBvcnRzLlBpcHNUeXBlID0gdm9pZCAwO1xuXG4gICAgICAoZnVuY3Rpb24gKFBpcHNUeXBlKSB7XG4gICAgICAgIFBpcHNUeXBlW1BpcHNUeXBlW1wiTm9uZVwiXSA9IC0xXSA9IFwiTm9uZVwiO1xuICAgICAgICBQaXBzVHlwZVtQaXBzVHlwZVtcIk5vVmFsdWVcIl0gPSAwXSA9IFwiTm9WYWx1ZVwiO1xuICAgICAgICBQaXBzVHlwZVtQaXBzVHlwZVtcIkxhcmdlVmFsdWVcIl0gPSAxXSA9IFwiTGFyZ2VWYWx1ZVwiO1xuICAgICAgICBQaXBzVHlwZVtQaXBzVHlwZVtcIlNtYWxsVmFsdWVcIl0gPSAyXSA9IFwiU21hbGxWYWx1ZVwiO1xuICAgICAgfSkoZXhwb3J0cy5QaXBzVHlwZSB8fCAoZXhwb3J0cy5QaXBzVHlwZSA9IHt9KSk7IC8vcmVnaW9uIEhlbHBlciBNZXRob2RzXG5cblxuICAgICAgZnVuY3Rpb24gaXNWYWxpZEZvcm1hdHRlcihlbnRyeSkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZFBhcnRpYWxGb3JtYXR0ZXIoZW50cnkpICYmIHR5cGVvZiBlbnRyeS5mcm9tID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGVudHJ5KSB7XG4gICAgICAgIC8vIHBhcnRpYWwgZm9ybWF0dGVycyBvbmx5IG5lZWQgYSB0byBmdW5jdGlvbiBhbmQgbm90IGEgZnJvbSBmdW5jdGlvblxuICAgICAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBlbnRyeS50byA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsKSB7XG4gICAgICAgIGVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gQmluZGFibGUgdmVyc2lvblxuXG5cbiAgICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSAvLyBSZW1vdmVzIGR1cGxpY2F0ZXMgZnJvbSBhbiBhcnJheS5cblxuXG4gICAgICBmdW5jdGlvbiB1bmlxdWUoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHJldHVybiAhdGhpc1thXSA/IHRoaXNbYV0gPSB0cnVlIDogZmFsc2U7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH0gLy8gUm91bmQgYSB2YWx1ZSB0byB0aGUgY2xvc2VzdCAndG8nLlxuXG5cbiAgICAgIGZ1bmN0aW9uIGNsb3Nlc3QodmFsdWUsIHRvKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gdG8pICogdG87XG4gICAgICB9IC8vIEN1cnJlbnQgcG9zaXRpb24gb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQuXG5cblxuICAgICAgZnVuY3Rpb24gb2Zmc2V0KGVsZW0sIG9yaWVudGF0aW9uKSB7XG4gICAgICAgIHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGdldFBhZ2VPZmZzZXQoZG9jKTsgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNvbnRhaW5zIGxlZnQgc2Nyb2xsIGluIENocm9tZSBvbiBBbmRyb2lkLlxuICAgICAgICAvLyBJIGhhdmVuJ3QgZm91bmQgYSBmZWF0dXJlIGRldGVjdGlvbiB0aGF0IHByb3ZlcyB0aGlzLiBXb3JzdCBjYXNlXG4gICAgICAgIC8vIHNjZW5hcmlvIG9uIG1pcy1tYXRjaDogdGhlICd0YXAnIGZlYXR1cmUgb24gaG9yaXpvbnRhbCBzbGlkZXJzIGJyZWFrcy5cblxuICAgICAgICBpZiAoL3dlYmtpdC4qQ2hyb21lLipNb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgcGFnZU9mZnNldC54ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcmllbnRhdGlvbiA/IHJlY3QudG9wICsgcGFnZU9mZnNldC55IC0gZG9jRWxlbS5jbGllbnRUb3AgOiByZWN0LmxlZnQgKyBwYWdlT2Zmc2V0LnggLSBkb2NFbGVtLmNsaWVudExlZnQ7XG4gICAgICB9IC8vIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgbnVtZXJpY2FsLlxuXG5cbiAgICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oYSkgJiYgaXNGaW5pdGUoYSk7XG4gICAgICB9IC8vIFNldHMgYSBjbGFzcyBhbmQgcmVtb3ZlcyBpdCBhZnRlciBbZHVyYXRpb25dIG1zLlxuXG5cbiAgICAgIGZ1bmN0aW9uIGFkZENsYXNzRm9yKGVsZW1lbnQsIGNsYXNzTmFtZSwgZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBMaW1pdHMgYSB2YWx1ZSB0byAwIC0gMTAwXG5cblxuICAgICAgZnVuY3Rpb24gbGltaXQoYSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oYSwgMTAwKSwgMCk7XG4gICAgICB9IC8vIFdyYXBzIGEgdmFyaWFibGUgYXMgYW4gYXJyYXksIGlmIGl0IGlzbid0IG9uZSB5ZXQuXG4gICAgICAvLyBOb3RlIHRoYXQgYW4gaW5wdXQgYXJyYXkgaXMgcmV0dXJuZWQgYnkgcmVmZXJlbmNlIVxuXG5cbiAgICAgIGZ1bmN0aW9uIGFzQXJyYXkoYSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XG4gICAgICB9IC8vIENvdW50cyBkZWNpbWFsc1xuXG5cbiAgICAgIGZ1bmN0aW9uIGNvdW50RGVjaW1hbHMobnVtU3RyKSB7XG4gICAgICAgIG51bVN0ciA9IFN0cmluZyhudW1TdHIpO1xuICAgICAgICB2YXIgcGllY2VzID0gbnVtU3RyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHBpZWNlcy5sZW5ndGggPiAxID8gcGllY2VzWzFdLmxlbmd0aCA6IDA7XG4gICAgICB9IC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNhZGRfY2xhc3NcblxuXG4gICAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QgJiYgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20vI3JlbW92ZV9jbGFzc1xuXG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCAmJiAhL1xccy8udGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXnxcXFxcYilcIiArIGNsYXNzTmFtZS5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXFxcYnwkKVwiLCBcImdpXCIpLCBcIiBcIik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaHR0cHM6Ly9wbGFpbmpzLmNvbS9qYXZhc2NyaXB0L2F0dHJpYnV0ZXMvYWRkaW5nLXJlbW92aW5nLWFuZC10ZXN0aW5nLWZvci1jbGFzc2VzLTkvXG5cblxuICAgICAgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0ID8gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkgOiBuZXcgUmVnRXhwKFwiXFxcXGJcIiArIGNsYXNzTmFtZSArIFwiXFxcXGJcIikudGVzdChlbC5jbGFzc05hbWUpO1xuICAgICAgfSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3Njcm9sbFkjTm90ZXNcblxuXG4gICAgICBmdW5jdGlvbiBnZXRQYWdlT2Zmc2V0KGRvYykge1xuICAgICAgICB2YXIgc3VwcG9ydFBhZ2VPZmZzZXQgPSB3aW5kb3cucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGlzQ1NTMUNvbXBhdCA9IChkb2MuY29tcGF0TW9kZSB8fCBcIlwiKSA9PT0gXCJDU1MxQ29tcGF0XCI7XG4gICAgICAgIHZhciB4ID0gc3VwcG9ydFBhZ2VPZmZzZXQgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiBpc0NTUzFDb21wYXQgPyBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgOiBkb2MuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgeSA9IHN1cHBvcnRQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogaXNDU1MxQ29tcGF0ID8gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBkb2MuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgICB9IC8vIHdlIHByb3ZpZGUgYSBmdW5jdGlvbiB0byBjb21wdXRlIGNvbnN0YW50cyBpbnN0ZWFkXG4gICAgICAvLyBvZiBhY2Nlc3Npbmcgd2luZG93LiogYXMgc29vbiBhcyB0aGUgbW9kdWxlIG5lZWRzIGl0XG4gICAgICAvLyBzbyB0aGF0IHdlIGRvIG5vdCBjb21wdXRlIGFueXRoaW5nIGlmIG5vdCBuZWVkZWRcblxuXG4gICAgICBmdW5jdGlvbiBnZXRBY3Rpb25zKCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGV2ZW50cyB0byBiaW5kLiBJRTExIGltcGxlbWVudHMgcG9pbnRlckV2ZW50cyB3aXRob3V0XG4gICAgICAgIC8vIGEgcHJlZml4LCB3aGljaCBicmVha3MgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBJRTEwIGltcGxlbWVudGF0aW9uLlxuICAgICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCA/IHtcbiAgICAgICAgICBzdGFydDogXCJwb2ludGVyZG93blwiLFxuICAgICAgICAgIG1vdmU6IFwicG9pbnRlcm1vdmVcIixcbiAgICAgICAgICBlbmQ6IFwicG9pbnRlcnVwXCJcbiAgICAgICAgfSA6IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCA/IHtcbiAgICAgICAgICBzdGFydDogXCJNU1BvaW50ZXJEb3duXCIsXG4gICAgICAgICAgbW92ZTogXCJNU1BvaW50ZXJNb3ZlXCIsXG4gICAgICAgICAgZW5kOiBcIk1TUG9pbnRlclVwXCJcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBzdGFydDogXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiLFxuICAgICAgICAgIG1vdmU6IFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLFxuICAgICAgICAgIGVuZDogXCJtb3VzZXVwIHRvdWNoZW5kXCJcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWRcbiAgICAgIC8vIElzc3VlICM3ODVcblxuXG4gICAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1Bhc3NpdmUoKSB7XG4gICAgICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBvcHRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuQ1NTICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuICAgICAgfSAvL2VuZHJlZ2lvblxuICAgICAgLy9yZWdpb24gUmFuZ2UgQ2FsY3VsYXRpb25cbiAgICAgIC8vIERldGVybWluZSB0aGUgc2l6ZSBvZiBhIHN1Yi1yYW5nZSBpbiByZWxhdGlvbiB0byBhIGZ1bGwgcmFuZ2UuXG5cblxuICAgICAgZnVuY3Rpb24gc3ViUmFuZ2VSYXRpbyhwYSwgcGIpIHtcbiAgICAgICAgcmV0dXJuIDEwMCAvIChwYiAtIHBhKTtcbiAgICAgIH0gLy8gKHBlcmNlbnRhZ2UpIEhvdyBtYW55IHBlcmNlbnQgaXMgdGhpcyB2YWx1ZSBvZiB0aGlzIHJhbmdlP1xuXG5cbiAgICAgIGZ1bmN0aW9uIGZyb21QZXJjZW50YWdlKHJhbmdlLCB2YWx1ZSwgc3RhcnRSYW5nZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgKiAxMDAgLyAocmFuZ2Vbc3RhcnRSYW5nZSArIDFdIC0gcmFuZ2Vbc3RhcnRSYW5nZV0pO1xuICAgICAgfSAvLyAocGVyY2VudGFnZSkgV2hlcmUgaXMgdGhpcyB2YWx1ZSBvbiB0aGlzIHJhbmdlP1xuXG5cbiAgICAgIGZ1bmN0aW9uIHRvUGVyY2VudGFnZShyYW5nZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZyb21QZXJjZW50YWdlKHJhbmdlLCByYW5nZVswXSA8IDAgPyB2YWx1ZSArIE1hdGguYWJzKHJhbmdlWzBdKSA6IHZhbHVlIC0gcmFuZ2VbMF0sIDApO1xuICAgICAgfSAvLyAodmFsdWUpIEhvdyBtdWNoIGlzIHRoaXMgcGVyY2VudGFnZSBvbiB0aGlzIHJhbmdlP1xuXG5cbiAgICAgIGZ1bmN0aW9uIGlzUGVyY2VudGFnZShyYW5nZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICogKHJhbmdlWzFdIC0gcmFuZ2VbMF0pIC8gMTAwICsgcmFuZ2VbMF07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEoodmFsdWUsIGFycikge1xuICAgICAgICB2YXIgaiA9IDE7XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlID49IGFycltqXSkge1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqO1xuICAgICAgfSAvLyAocGVyY2VudGFnZSkgSW5wdXQgYSB2YWx1ZSwgZmluZCB3aGVyZSwgb24gYSBzY2FsZSBvZiAwLTEwMCwgaXQgYXBwbGllcy5cblxuXG4gICAgICBmdW5jdGlvbiB0b1N0ZXBwaW5nKHhWYWwsIHhQY3QsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSB4VmFsLnNsaWNlKC0xKVswXSkge1xuICAgICAgICAgIHJldHVybiAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhWYWwpO1xuICAgICAgICB2YXIgdmEgPSB4VmFsW2ogLSAxXTtcbiAgICAgICAgdmFyIHZiID0geFZhbFtqXTtcbiAgICAgICAgdmFyIHBhID0geFBjdFtqIC0gMV07XG4gICAgICAgIHZhciBwYiA9IHhQY3Rbal07XG4gICAgICAgIHJldHVybiBwYSArIHRvUGVyY2VudGFnZShbdmEsIHZiXSwgdmFsdWUpIC8gc3ViUmFuZ2VSYXRpbyhwYSwgcGIpO1xuICAgICAgfSAvLyAodmFsdWUpIElucHV0IGEgcGVyY2VudGFnZSwgZmluZCB3aGVyZSBpdCBpcyBvbiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxuXG5cbiAgICAgIGZ1bmN0aW9uIGZyb21TdGVwcGluZyh4VmFsLCB4UGN0LCB2YWx1ZSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyByYW5nZSBncm91cCB0aGF0IGZpdHMgMTAwXG4gICAgICAgIGlmICh2YWx1ZSA+PSAxMDApIHtcbiAgICAgICAgICByZXR1cm4geFZhbC5zbGljZSgtMSlbMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhQY3QpO1xuICAgICAgICB2YXIgdmEgPSB4VmFsW2ogLSAxXTtcbiAgICAgICAgdmFyIHZiID0geFZhbFtqXTtcbiAgICAgICAgdmFyIHBhID0geFBjdFtqIC0gMV07XG4gICAgICAgIHZhciBwYiA9IHhQY3Rbal07XG4gICAgICAgIHJldHVybiBpc1BlcmNlbnRhZ2UoW3ZhLCB2Yl0sICh2YWx1ZSAtIHBhKSAqIHN1YlJhbmdlUmF0aW8ocGEsIHBiKSk7XG4gICAgICB9IC8vIChwZXJjZW50YWdlKSBHZXQgdGhlIHN0ZXAgdGhhdCBhcHBsaWVzIGF0IGEgY2VydGFpbiB2YWx1ZS5cblxuXG4gICAgICBmdW5jdGlvbiBnZXRTdGVwKHhQY3QsIHhTdGVwcywgc25hcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAxMDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhQY3QpO1xuICAgICAgICB2YXIgYSA9IHhQY3RbaiAtIDFdO1xuICAgICAgICB2YXIgYiA9IHhQY3Rbal07IC8vIElmICdzbmFwJyBpcyBzZXQsIHN0ZXBzIGFyZSB1c2VkIGFzIGZpeGVkIHBvaW50cyBvbiB0aGUgc2xpZGVyLlxuXG4gICAgICAgIGlmIChzbmFwKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBwb3NpdGlvbiwgYSBvciBiLlxuICAgICAgICAgIGlmICh2YWx1ZSAtIGEgPiAoYiAtIGEpIC8gMikge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXhTdGVwc1tqIC0gMV0pIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geFBjdFtqIC0gMV0gKyBjbG9zZXN0KHZhbHVlIC0geFBjdFtqIC0gMV0sIHhTdGVwc1tqIC0gMV0pO1xuICAgICAgfSAvL2VuZHJlZ2lvblxuICAgICAgLy9yZWdpb24gU3BlY3RydW1cblxuXG4gICAgICB2YXIgU3BlY3RydW0gPVxuICAgICAgLyoqIEBjbGFzcyAqL1xuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTcGVjdHJ1bShlbnRyeSwgc25hcCwgc2luZ2xlU3RlcCkge1xuICAgICAgICAgIHRoaXMueFBjdCA9IFtdO1xuICAgICAgICAgIHRoaXMueFZhbCA9IFtdO1xuICAgICAgICAgIHRoaXMueFN0ZXBzID0gW107XG4gICAgICAgICAgdGhpcy54TnVtU3RlcHMgPSBbXTtcbiAgICAgICAgICB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwID0gW107XG4gICAgICAgICAgdGhpcy54U3RlcHMgPSBbc2luZ2xlU3RlcCB8fCBmYWxzZV07XG4gICAgICAgICAgdGhpcy54TnVtU3RlcHMgPSBbZmFsc2VdO1xuICAgICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XG4gICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgIHZhciBvcmRlcmVkID0gW107IC8vIE1hcCB0aGUgb2JqZWN0IGtleXMgdG8gYW4gYXJyYXkuXG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIG9yZGVyZWQucHVzaChbYXNBcnJheShlbnRyeVtpbmRleF0pLCBpbmRleF0pO1xuICAgICAgICAgIH0pOyAvLyBTb3J0IGFsbCBlbnRyaWVzIGJ5IHZhbHVlIChudW1lcmljIHNvcnQpLlxuXG4gICAgICAgICAgb3JkZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYVswXVswXSAtIGJbMF1bMF07XG4gICAgICAgICAgfSk7IC8vIENvbnZlcnQgYWxsIGVudHJpZXMgdG8gc3VicmFuZ2VzLlxuXG4gICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgb3JkZXJlZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRW50cnlQb2ludChvcmRlcmVkW2luZGV4XVsxXSwgb3JkZXJlZFtpbmRleF1bMF0pO1xuICAgICAgICAgIH0gLy8gU3RvcmUgdGhlIGFjdHVhbCBzdGVwIHZhbHVlcy5cbiAgICAgICAgICAvLyB4U3RlcHMgaXMgc29ydGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHhQY3QgYW5kIHhWYWwuXG5cblxuICAgICAgICAgIHRoaXMueE51bVN0ZXBzID0gdGhpcy54U3RlcHMuc2xpY2UoMCk7IC8vIENvbnZlcnQgYWxsIG51bWVyaWMgc3RlcHMgdG8gdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHN1YnJhbmdlIHRoZXkgcmVwcmVzZW50LlxuXG4gICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy54TnVtU3RlcHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN0ZXBQb2ludChpbmRleCwgdGhpcy54TnVtU3RlcHNbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2VzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy54TnVtU3RlcHMubGVuZ3RoIC0gMTsgaW5kZXgrKykge1xuICAgICAgICAgICAgZGlzdGFuY2VzW2luZGV4XSA9IGZyb21QZXJjZW50YWdlKHRoaXMueFZhbCwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGlzdGFuY2VzO1xuICAgICAgICB9OyAvLyBDYWxjdWxhdGUgdGhlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugb3ZlciB0aGUgd2hvbGUgc2NhbGUgb2YgcmFuZ2VzLlxuICAgICAgICAvLyBkaXJlY3Rpb246IDAgPSBiYWNrd2FyZHMgLyAxID0gZm9yd2FyZHNcblxuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXRBYnNvbHV0ZURpc3RhbmNlID0gZnVuY3Rpb24gKHZhbHVlLCBkaXN0YW5jZXMsIGRpcmVjdGlvbikge1xuICAgICAgICAgIHZhciB4UGN0X2luZGV4ID0gMDsgLy8gQ2FsY3VsYXRlIHJhbmdlIHdoZXJlIHRvIHN0YXJ0IGNhbGN1bGF0aW9uXG5cbiAgICAgICAgICBpZiAodmFsdWUgPCB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB3aGlsZSAodmFsdWUgPiB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdKSB7XG4gICAgICAgICAgICAgIHhQY3RfaW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB4UGN0X2luZGV4ID0gdGhpcy54UGN0Lmxlbmd0aCAtIDI7XG4gICAgICAgICAgfSAvLyBJZiBsb29raW5nIGJhY2t3YXJkcyBhbmQgdGhlIHZhbHVlIGlzIGV4YWN0bHkgYXQgYSByYW5nZSBzZXBhcmF0b3IgdGhlbiBsb29rIG9uZSByYW5nZSBmdXJ0aGVyXG5cblxuICAgICAgICAgIGlmICghZGlyZWN0aW9uICYmIHZhbHVlID09PSB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdKSB7XG4gICAgICAgICAgICB4UGN0X2luZGV4Kys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGlzdGFuY2VzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0X2ZhY3RvcjtcbiAgICAgICAgICB2YXIgcmVzdF9mYWN0b3IgPSAxO1xuICAgICAgICAgIHZhciByZXN0X3JlbF9kaXN0YW5jZSA9IGRpc3RhbmNlc1t4UGN0X2luZGV4XTtcbiAgICAgICAgICB2YXIgcmFuZ2VfcGN0ID0gMDtcbiAgICAgICAgICB2YXIgcmVsX3JhbmdlX2Rpc3RhbmNlID0gMDtcbiAgICAgICAgICB2YXIgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSAwO1xuICAgICAgICAgIHZhciByYW5nZV9jb3VudGVyID0gMDsgLy8gQ2FsY3VsYXRlIHdoYXQgcGFydCBvZiB0aGUgc3RhcnQgcmFuZ2UgdGhlIHZhbHVlIGlzXG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBzdGFydF9mYWN0b3IgPSAodmFsdWUgLSB0aGlzLnhQY3RbeFBjdF9pbmRleF0pIC8gKHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0gLSB0aGlzLnhQY3RbeFBjdF9pbmRleF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydF9mYWN0b3IgPSAodGhpcy54UGN0W3hQY3RfaW5kZXggKyAxXSAtIHZhbHVlKSAvICh0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdIC0gdGhpcy54UGN0W3hQY3RfaW5kZXhdKTtcbiAgICAgICAgICB9IC8vIERvIHVudGlsIHRoZSBjb21wbGV0ZSBkaXN0YW5jZSBhY3Jvc3MgcmFuZ2VzIGlzIGNhbGN1bGF0ZWRcblxuXG4gICAgICAgICAgd2hpbGUgKHJlc3RfcmVsX2Rpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwZXJjZW50YWdlIG9mIHRvdGFsIHJhbmdlXG4gICAgICAgICAgICByYW5nZV9wY3QgPSB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDEgKyByYW5nZV9jb3VudGVyXSAtIHRoaXMueFBjdFt4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl07IC8vIERldGVjdCBpZiB0aGUgbWFyZ2luLCBwYWRkaW5nIG9yIGxpbWl0IGlzIGxhcmdlciB0aGVuIHRoZSBjdXJyZW50IHJhbmdlIGFuZCBjYWxjdWxhdGVcblxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlc1t4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl0gKiByZXN0X2ZhY3RvciArIDEwMCAtIHN0YXJ0X2ZhY3RvciAqIDEwMCA+IDEwMCkge1xuICAgICAgICAgICAgICAvLyBJZiBsYXJnZXIgdGhlbiB0YWtlIHRoZSBwZXJjZW50dWFsIGRpc3RhbmNlIG9mIHRoZSB3aG9sZSByYW5nZVxuICAgICAgICAgICAgICByZWxfcmFuZ2VfZGlzdGFuY2UgPSByYW5nZV9wY3QgKiBzdGFydF9mYWN0b3I7IC8vIFJlc3QgZmFjdG9yIG9mIHJlbGF0aXZlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugc3RpbGwgdG8gYmUgY2FsY3VsYXRlZFxuXG4gICAgICAgICAgICAgIHJlc3RfZmFjdG9yID0gKHJlc3RfcmVsX2Rpc3RhbmNlIC0gMTAwICogc3RhcnRfZmFjdG9yKSAvIGRpc3RhbmNlc1t4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl07IC8vIFNldCBzdGFydCBmYWN0b3IgdG8gMSBhcyBmb3IgbmV4dCByYW5nZSBpdCBkb2VzIG5vdCBhcHBseS5cblxuICAgICAgICAgICAgICBzdGFydF9mYWN0b3IgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gSWYgc21hbGxlciBvciBlcXVhbCB0aGVuIHRha2UgdGhlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugb2YgdGhlIGNhbGN1bGF0ZSBwZXJjZW50dWFsIHBhcnQgb2YgdGhhdCByYW5nZVxuICAgICAgICAgICAgICByZWxfcmFuZ2VfZGlzdGFuY2UgPSBkaXN0YW5jZXNbeFBjdF9pbmRleCArIHJhbmdlX2NvdW50ZXJdICogcmFuZ2VfcGN0IC8gMTAwICogcmVzdF9mYWN0b3I7IC8vIE5vIHJlc3QgbGVmdCBhcyB0aGUgcmVzdCBmaXRzIGluIGN1cnJlbnQgcmFuZ2VcblxuICAgICAgICAgICAgICByZXN0X2ZhY3RvciA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSBhYnNfZGlzdGFuY2VfY291bnRlciAtIHJlbF9yYW5nZV9kaXN0YW5jZTsgLy8gTGltaXQgcmFuZ2UgdG8gZmlyc3QgcmFuZ2Ugd2hlbiBkaXN0YW5jZSBiZWNvbWVzIG91dHNpZGUgb2YgbWluaW11bSByYW5nZVxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLnhQY3QubGVuZ3RoICsgcmFuZ2VfY291bnRlciA+PSAxKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VfY291bnRlci0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhYnNfZGlzdGFuY2VfY291bnRlciA9IGFic19kaXN0YW5jZV9jb3VudGVyICsgcmVsX3JhbmdlX2Rpc3RhbmNlOyAvLyBMaW1pdCByYW5nZSB0byBsYXN0IHJhbmdlIHdoZW4gZGlzdGFuY2UgYmVjb21lcyBvdXRzaWRlIG9mIG1heGltdW0gcmFuZ2VcblxuICAgICAgICAgICAgICBpZiAodGhpcy54UGN0Lmxlbmd0aCAtIHJhbmdlX2NvdW50ZXIgPj0gMSkge1xuICAgICAgICAgICAgICAgIHJhbmdlX2NvdW50ZXIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBSZXN0IG9mIHJlbGF0aXZlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugc3RpbGwgdG8gYmUgY2FsY3VsYXRlZFxuXG5cbiAgICAgICAgICAgIHJlc3RfcmVsX2Rpc3RhbmNlID0gZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXSAqIHJlc3RfZmFjdG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZSArIGFic19kaXN0YW5jZV9jb3VudGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS50b1N0ZXBwaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b1N0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5mcm9tU3RlcHBpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbVN0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmdldFN0ZXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldFN0ZXAodGhpcy54UGN0LCB0aGlzLnhTdGVwcywgdGhpcy5zbmFwLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXREZWZhdWx0U3RlcCA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNEb3duLCBzaXplKSB7XG4gICAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpOyAvLyBXaGVuIGF0IHRoZSB0b3Agb3Igc3RlcHBpbmcgZG93biwgbG9vayBhdCB0aGUgcHJldmlvdXMgc3ViLXJhbmdlXG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IDEwMCB8fCBpc0Rvd24gJiYgdmFsdWUgPT09IHRoaXMueFBjdFtqIC0gMV0pIHtcbiAgICAgICAgICAgIGogPSBNYXRoLm1heChqIC0gMSwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICh0aGlzLnhWYWxbal0gLSB0aGlzLnhWYWxbaiAtIDFdKSAvIHNpemU7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmdldE5lYXJieVN0ZXBzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGVwQmVmb3JlOiB7XG4gICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHRoaXMueFZhbFtqIC0gMl0sXG4gICAgICAgICAgICAgIHN0ZXA6IHRoaXMueE51bVN0ZXBzW2ogLSAyXSxcbiAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaiAtIDJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpc1N0ZXA6IHtcbiAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2ogLSAxXSxcbiAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbaiAtIDFdLFxuICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqIC0gMV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGVwQWZ0ZXI6IHtcbiAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2pdLFxuICAgICAgICAgICAgICBzdGVwOiB0aGlzLnhOdW1TdGVwc1tqXSxcbiAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbal1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5jb3VudFN0ZXBEZWNpbWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RlcERlY2ltYWxzID0gdGhpcy54TnVtU3RlcHMubWFwKGNvdW50RGVjaW1hbHMpO1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBzdGVwRGVjaW1hbHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5oYXNOb1NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueFZhbFswXSA9PT0gdGhpcy54VmFsW3RoaXMueFZhbC5sZW5ndGggLSAxXTtcbiAgICAgICAgfTsgLy8gT3V0c2lkZSB0ZXN0aW5nXG5cblxuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0ZXAodGhpcy50b1N0ZXBwaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmhhbmRsZUVudHJ5UG9pbnQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHBlcmNlbnRhZ2U7IC8vIENvdmVydCBtaW4vbWF4IHN5bnRheCB0byAwIGFuZCAxMDAuXG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAxMDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KGluZGV4KTtcbiAgICAgICAgICB9IC8vIENoZWNrIGZvciBjb3JyZWN0IGlucHV0LlxuXG5cbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYyhwZXJjZW50YWdlKSB8fCAhaXNOdW1lcmljKHZhbHVlWzBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3JhbmdlJyB2YWx1ZSBpc24ndCBudW1lcmljLlwiKTtcbiAgICAgICAgICB9IC8vIFN0b3JlIHZhbHVlcy5cblxuXG4gICAgICAgICAgdGhpcy54UGN0LnB1c2gocGVyY2VudGFnZSk7XG4gICAgICAgICAgdGhpcy54VmFsLnB1c2godmFsdWVbMF0pO1xuICAgICAgICAgIHZhciB2YWx1ZTEgPSBOdW1iZXIodmFsdWVbMV0pOyAvLyBOYU4gd2lsbCBldmFsdWF0ZSB0byBmYWxzZSB0b28sIGJ1dCB0byBrZWVwXG4gICAgICAgICAgLy8gbG9nZ2luZyBjbGVhciwgc2V0IHN0ZXAgZXhwbGljaXRseS4gTWFrZSBzdXJlXG4gICAgICAgICAgLy8gbm90IHRvIG92ZXJyaWRlIHRoZSAnc3RlcCcgc2V0dGluZyB3aXRoIGZhbHNlLlxuXG4gICAgICAgICAgaWYgKCFwZXJjZW50YWdlKSB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlMSkpIHtcbiAgICAgICAgICAgICAgdGhpcy54U3RlcHNbMF0gPSB2YWx1ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueFN0ZXBzLnB1c2goaXNOYU4odmFsdWUxKSA/IGZhbHNlIDogdmFsdWUxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwLnB1c2goMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmhhbmRsZVN0ZXBQb2ludCA9IGZ1bmN0aW9uIChpLCBuKSB7XG4gICAgICAgICAgLy8gSWdub3JlICdmYWxzZScgc3RlcHBpbmcuXG4gICAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcblxuXG4gICAgICAgICAgaWYgKHRoaXMueFZhbFtpXSA9PT0gdGhpcy54VmFsW2kgKyAxXSkge1xuICAgICAgICAgICAgdGhpcy54U3RlcHNbaV0gPSB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2ldID0gdGhpcy54VmFsW2ldO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gRmFjdG9yIHRvIHJhbmdlIHJhdGlvXG5cblxuICAgICAgICAgIHRoaXMueFN0ZXBzW2ldID0gZnJvbVBlcmNlbnRhZ2UoW3RoaXMueFZhbFtpXSwgdGhpcy54VmFsW2kgKyAxXV0sIG4sIDApIC8gc3ViUmFuZ2VSYXRpbyh0aGlzLnhQY3RbaV0sIHRoaXMueFBjdFtpICsgMV0pO1xuICAgICAgICAgIHZhciB0b3RhbFN0ZXBzID0gKHRoaXMueFZhbFtpICsgMV0gLSB0aGlzLnhWYWxbaV0pIC8gdGhpcy54TnVtU3RlcHNbaV07XG4gICAgICAgICAgdmFyIGhpZ2hlc3RTdGVwID0gTWF0aC5jZWlsKE51bWJlcih0b3RhbFN0ZXBzLnRvRml4ZWQoMykpIC0gMSk7XG4gICAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnhWYWxbaV0gKyB0aGlzLnhOdW1TdGVwc1tpXSAqIGhpZ2hlc3RTdGVwO1xuICAgICAgICAgIHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaV0gPSBzdGVwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBTcGVjdHJ1bTtcbiAgICAgIH0oKTsgLy9lbmRyZWdpb25cbiAgICAgIC8vcmVnaW9uIE9wdGlvbnNcblxuICAgICAgLypcdEV2ZXJ5IGlucHV0IG9wdGlvbiBpcyB0ZXN0ZWQgYW5kIHBhcnNlZC4gVGhpcyB3aWxsIHByZXZlbnRcbiAgICAgICAgICBlbmRsZXNzIHZhbGlkYXRpb24gaW4gaW50ZXJuYWwgbWV0aG9kcy4gVGhlc2UgdGVzdHMgYXJlXG4gICAgICAgICAgc3RydWN0dXJlZCB3aXRoIGFuIGl0ZW0gZm9yIGV2ZXJ5IG9wdGlvbiBhdmFpbGFibGUuIEFuXG4gICAgICAgICAgb3B0aW9uIGNhbiBiZSBtYXJrZWQgYXMgcmVxdWlyZWQgYnkgc2V0dGluZyB0aGUgJ3InIGZsYWcuXG4gICAgICAgICAgVGhlIHRlc3RpbmcgZnVuY3Rpb24gaXMgcHJvdmlkZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICAgICAgICAgIC0gVGhlIHByb3ZpZGVkIHZhbHVlIGZvciB0aGUgb3B0aW9uO1xuICAgICAgICAgICAgICAtIEEgcmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9iamVjdDtcbiAgICAgICAgICAgICAgLSBUaGUgbmFtZSBmb3IgdGhlIG9wdGlvbjtcbiAgICAgICAgICAgVGhlIHRlc3RpbmcgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSB3aGVuIGFuIGVycm9yIGlzIGRldGVjdGVkLFxuICAgICAgICAgIG9yIHRydWUgd2hlbiBldmVyeXRoaW5nIGlzIE9LLiBJdCBjYW4gYWxzbyBtb2RpZnkgdGhlIG9wdGlvblxuICAgICAgICAgIG9iamVjdCwgdG8gbWFrZSBzdXJlIGFsbCB2YWx1ZXMgY2FuIGJlIGNvcnJlY3RseSBsb29wZWQgZWxzZXdoZXJlLiAqL1xuICAgICAgLy9yZWdpb24gRGVmYXVsdHNcblxuXG4gICAgICB2YXIgZGVmYXVsdEZvcm1hdHRlciA9IHtcbiAgICAgICAgdG86IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHZhbHVlLnRvRml4ZWQoMik7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb206IE51bWJlclxuICAgICAgfTtcbiAgICAgIHZhciBjc3NDbGFzc2VzID0ge1xuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIGJhc2U6IFwiYmFzZVwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIGhhbmRsZTogXCJoYW5kbGVcIixcbiAgICAgICAgaGFuZGxlTG93ZXI6IFwiaGFuZGxlLWxvd2VyXCIsXG4gICAgICAgIGhhbmRsZVVwcGVyOiBcImhhbmRsZS11cHBlclwiLFxuICAgICAgICB0b3VjaEFyZWE6IFwidG91Y2gtYXJlYVwiLFxuICAgICAgICBob3Jpem9udGFsOiBcImhvcml6b250YWxcIixcbiAgICAgICAgdmVydGljYWw6IFwidmVydGljYWxcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJiYWNrZ3JvdW5kXCIsXG4gICAgICAgIGNvbm5lY3Q6IFwiY29ubmVjdFwiLFxuICAgICAgICBjb25uZWN0czogXCJjb25uZWN0c1wiLFxuICAgICAgICBsdHI6IFwibHRyXCIsXG4gICAgICAgIHJ0bDogXCJydGxcIixcbiAgICAgICAgdGV4dERpcmVjdGlvbkx0cjogXCJ0eHQtZGlyLWx0clwiLFxuICAgICAgICB0ZXh0RGlyZWN0aW9uUnRsOiBcInR4dC1kaXItcnRsXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZHJhZzogXCJzdGF0ZS1kcmFnXCIsXG4gICAgICAgIHRhcDogXCJzdGF0ZS10YXBcIixcbiAgICAgICAgYWN0aXZlOiBcImFjdGl2ZVwiLFxuICAgICAgICB0b29sdGlwOiBcInRvb2x0aXBcIixcbiAgICAgICAgcGlwczogXCJwaXBzXCIsXG4gICAgICAgIHBpcHNIb3Jpem9udGFsOiBcInBpcHMtaG9yaXpvbnRhbFwiLFxuICAgICAgICBwaXBzVmVydGljYWw6IFwicGlwcy12ZXJ0aWNhbFwiLFxuICAgICAgICBtYXJrZXI6IFwibWFya2VyXCIsXG4gICAgICAgIG1hcmtlckhvcml6b250YWw6IFwibWFya2VyLWhvcml6b250YWxcIixcbiAgICAgICAgbWFya2VyVmVydGljYWw6IFwibWFya2VyLXZlcnRpY2FsXCIsXG4gICAgICAgIG1hcmtlck5vcm1hbDogXCJtYXJrZXItbm9ybWFsXCIsXG4gICAgICAgIG1hcmtlckxhcmdlOiBcIm1hcmtlci1sYXJnZVwiLFxuICAgICAgICBtYXJrZXJTdWI6IFwibWFya2VyLXN1YlwiLFxuICAgICAgICB2YWx1ZTogXCJ2YWx1ZVwiLFxuICAgICAgICB2YWx1ZUhvcml6b250YWw6IFwidmFsdWUtaG9yaXpvbnRhbFwiLFxuICAgICAgICB2YWx1ZVZlcnRpY2FsOiBcInZhbHVlLXZlcnRpY2FsXCIsXG4gICAgICAgIHZhbHVlTm9ybWFsOiBcInZhbHVlLW5vcm1hbFwiLFxuICAgICAgICB2YWx1ZUxhcmdlOiBcInZhbHVlLWxhcmdlXCIsXG4gICAgICAgIHZhbHVlU3ViOiBcInZhbHVlLXN1YlwiXG4gICAgICB9OyAvLyBOYW1lc3BhY2VzIG9mIGludGVybmFsIGV2ZW50IGxpc3RlbmVyc1xuXG4gICAgICB2YXIgSU5URVJOQUxfRVZFTlRfTlMgPSB7XG4gICAgICAgIHRvb2x0aXBzOiBcIi5fX3Rvb2x0aXBzXCIsXG4gICAgICAgIGFyaWE6IFwiLl9fYXJpYVwiXG4gICAgICB9OyAvL2VuZHJlZ2lvblxuXG4gICAgICBmdW5jdGlvbiB0ZXN0U3RlcChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdzdGVwJyBpcyBub3QgbnVtZXJpYy5cIik7XG4gICAgICAgIH0gLy8gVGhlIHN0ZXAgb3B0aW9uIGNhbiBzdGlsbCBiZSB1c2VkIHRvIHNldCBzdGVwcGluZ1xuICAgICAgICAvLyBmb3IgbGluZWFyIHNsaWRlcnMuIE92ZXJ3cml0dGVuIGlmIHNldCBpbiAncmFuZ2UnLlxuXG5cbiAgICAgICAgcGFyc2VkLnNpbmdsZVN0ZXAgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkUGFnZU11bHRpcGxpZXIocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAna2V5Ym9hcmRQYWdlTXVsdGlwbGllcicgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkUGFnZU11bHRpcGxpZXIgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkTXVsdGlwbGllcihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdrZXlib2FyZE11bHRpcGxpZXInIGlzIG5vdCBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5rZXlib2FyZE11bHRpcGxpZXIgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkRGVmYXVsdFN0ZXAocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAna2V5Ym9hcmREZWZhdWx0U3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkRGVmYXVsdFN0ZXAgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdFJhbmdlKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gRmlsdGVyIGluY29ycmVjdCBpbnB1dC5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdyYW5nZScgaXMgbm90IGFuIG9iamVjdC5cIik7XG4gICAgICAgIH0gLy8gQ2F0Y2ggbWlzc2luZyBzdGFydCBvciBlbmQuXG5cblxuICAgICAgICBpZiAoZW50cnkubWluID09PSB1bmRlZmluZWQgfHwgZW50cnkubWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBNaXNzaW5nICdtaW4nIG9yICdtYXgnIGluICdyYW5nZScuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLnNwZWN0cnVtID0gbmV3IFNwZWN0cnVtKGVudHJ5LCBwYXJzZWQuc25hcCB8fCBmYWxzZSwgcGFyc2VkLnNpbmdsZVN0ZXApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0U3RhcnQocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBlbnRyeSA9IGFzQXJyYXkoZW50cnkpOyAvLyBWYWxpZGF0ZSBpbnB1dC4gVmFsdWVzIGFyZW4ndCB0ZXN0ZWQsIGFzIHRoZSBwdWJsaWMgLnZhbCBtZXRob2RcbiAgICAgICAgLy8gd2lsbCBhbHdheXMgcHJvdmlkZSBhIHZhbGlkIGxvY2F0aW9uLlxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyeSkgfHwgIWVudHJ5Lmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdzdGFydCcgb3B0aW9uIGlzIGluY29ycmVjdC5cIik7XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIG51bWJlciBvZiBoYW5kbGVzLlxuXG5cbiAgICAgICAgcGFyc2VkLmhhbmRsZXMgPSBlbnRyeS5sZW5ndGg7IC8vIFdoZW4gdGhlIHNsaWRlciBpcyBpbml0aWFsaXplZCwgdGhlIC52YWwgbWV0aG9kIHdpbGxcbiAgICAgICAgLy8gYmUgY2FsbGVkIHdpdGggdGhlIHN0YXJ0IG9wdGlvbnMuXG5cbiAgICAgICAgcGFyc2VkLnN0YXJ0ID0gZW50cnk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RTbmFwKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnc25hcCcgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcbiAgICAgICAgfSAvLyBFbmZvcmNlIDEwMCUgc3RlcHBpbmcgd2l0aGluIHN1YnJhbmdlcy5cblxuXG4gICAgICAgIHBhcnNlZC5zbmFwID0gZW50cnk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RBbmltYXRlKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnYW5pbWF0ZScgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcbiAgICAgICAgfSAvLyBFbmZvcmNlIDEwMCUgc3RlcHBpbmcgd2l0aGluIHN1YnJhbmdlcy5cblxuXG4gICAgICAgIHBhcnNlZC5hbmltYXRlID0gZW50cnk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RBbmltYXRpb25EdXJhdGlvbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnYW5pbWF0aW9uRHVyYXRpb24nIG9wdGlvbiBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5hbmltYXRpb25EdXJhdGlvbiA9IGVudHJ5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0Q29ubmVjdChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIHZhciBjb25uZWN0ID0gW2ZhbHNlXTtcbiAgICAgICAgdmFyIGk7IC8vIE1hcCBsZWdhY3kgb3B0aW9uc1xuXG4gICAgICAgIGlmIChlbnRyeSA9PT0gXCJsb3dlclwiKSB7XG4gICAgICAgICAgZW50cnkgPSBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5ID09PSBcInVwcGVyXCIpIHtcbiAgICAgICAgICBlbnRyeSA9IFtmYWxzZSwgdHJ1ZV07XG4gICAgICAgIH0gLy8gSGFuZGxlIGJvb2xlYW4gb3B0aW9uc1xuXG5cbiAgICAgICAgaWYgKGVudHJ5ID09PSB0cnVlIHx8IGVudHJ5ID09PSBmYWxzZSkge1xuICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25uZWN0LnB1c2goZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbm5lY3QucHVzaChmYWxzZSk7XG4gICAgICAgIH0gLy8gUmVqZWN0IGludmFsaWQgaW5wdXRcbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZW50cnkpIHx8ICFlbnRyeS5sZW5ndGggfHwgZW50cnkubGVuZ3RoICE9PSBwYXJzZWQuaGFuZGxlcyArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnY29ubmVjdCcgb3B0aW9uIGRvZXNuJ3QgbWF0Y2ggaGFuZGxlIGNvdW50LlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25uZWN0ID0gZW50cnk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQuY29ubmVjdCA9IGNvbm5lY3Q7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RPcmllbnRhdGlvbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIFNldCBvcmllbnRhdGlvbiB0byBhbiBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFzeVxuICAgICAgICAvLyBhcnJheSBzZWxlY3Rpb24uXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcbiAgICAgICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0TWFyZ2luKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ21hcmdpbicgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH0gLy8gSXNzdWUgIzU4MlxuXG5cbiAgICAgICAgaWYgKGVudHJ5ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLm1hcmdpbiA9IHBhcnNlZC5zcGVjdHJ1bS5nZXREaXN0YW5jZShlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RMaW1pdChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdsaW1pdCcgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQubGltaXQgPSBwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnkpO1xuXG4gICAgICAgIGlmICghcGFyc2VkLmxpbWl0IHx8IHBhcnNlZC5oYW5kbGVzIDwgMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdsaW1pdCcgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIG9uIGxpbmVhciBzbGlkZXJzIHdpdGggMiBvciBtb3JlIGhhbmRsZXMuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RQYWRkaW5nKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgdmFyIGluZGV4O1xuXG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSAmJiAhQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbnVtZXJpYyBvciBhcnJheSBvZiBleGFjdGx5IDIgbnVtYmVycy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkgJiYgIShlbnRyeS5sZW5ndGggPT09IDIgfHwgaXNOdW1lcmljKGVudHJ5WzBdKSB8fCBpc051bWVyaWMoZW50cnlbMV0pKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBudW1lcmljIG9yIGFycmF5IG9mIGV4YWN0bHkgMiBudW1iZXJzLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICBlbnRyeSA9IFtlbnRyeSwgZW50cnldO1xuICAgICAgICB9IC8vICdnZXREaXN0YW5jZScgcmV0dXJucyBmYWxzZSBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgICAgICBwYXJzZWQucGFkZGluZyA9IFtwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnlbMF0pLCBwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnlbMV0pXTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXJzZWQuc3BlY3RydW0ueE51bVN0ZXBzLmxlbmd0aCAtIDE7IGluZGV4KyspIHtcbiAgICAgICAgICAvLyBsYXN0IFwicmFuZ2VcIiBjYW4ndCBjb250YWluIHN0ZXAgc2l6ZSBhcyBpdCBpcyBwdXJlbHkgYW4gZW5kcG9pbnQuXG4gICAgICAgICAgaWYgKHBhcnNlZC5wYWRkaW5nWzBdW2luZGV4XSA8IDAgfHwgcGFyc2VkLnBhZGRpbmdbMV1baW5kZXhdIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyKHMpLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxQYWRkaW5nID0gZW50cnlbMF0gKyBlbnRyeVsxXTtcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSBwYXJzZWQuc3BlY3RydW0ueFZhbFswXTtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHBhcnNlZC5zcGVjdHJ1bS54VmFsW3BhcnNlZC5zcGVjdHJ1bS54VmFsLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmICh0b3RhbFBhZGRpbmcgLyAobGFzdFZhbHVlIC0gZmlyc3RWYWx1ZSkgPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IG5vdCBleGNlZWQgMTAwJSBvZiB0aGUgcmFuZ2UuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3REaXJlY3Rpb24ocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBTZXQgZGlyZWN0aW9uIGFzIGEgbnVtZXJpY2FsIHZhbHVlIGZvciBlYXN5IHBhcnNpbmcuXG4gICAgICAgIC8vIEludmVydCBjb25uZWN0aW9uIGZvciBSVEwgc2xpZGVycywgc28gdGhhdCB0aGUgcHJvcGVyXG4gICAgICAgIC8vIGhhbmRsZXMgZ2V0IHRoZSBjb25uZWN0L2JhY2tncm91bmQgY2xhc3Nlcy5cbiAgICAgICAgc3dpdGNoIChlbnRyeSkge1xuICAgICAgICAgIGNhc2UgXCJsdHJcIjpcbiAgICAgICAgICAgIHBhcnNlZC5kaXIgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwicnRsXCI6XG4gICAgICAgICAgICBwYXJzZWQuZGlyID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdkaXJlY3Rpb24nIG9wdGlvbiB3YXMgbm90IHJlY29nbml6ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RCZWhhdmlvdXIocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGlucHV0IGlzIGEgc3RyaW5nLlxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2JlaGF2aW91cicgbXVzdCBiZSBhIHN0cmluZyBjb250YWluaW5nIG9wdGlvbnMuXCIpO1xuICAgICAgICB9IC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgYW55IGtleXdvcmRzLlxuICAgICAgICAvLyBOb25lIGFyZSByZXF1aXJlZC5cblxuXG4gICAgICAgIHZhciB0YXAgPSBlbnRyeS5pbmRleE9mKFwidGFwXCIpID49IDA7XG4gICAgICAgIHZhciBkcmFnID0gZW50cnkuaW5kZXhPZihcImRyYWdcIikgPj0gMDtcbiAgICAgICAgdmFyIGZpeGVkID0gZW50cnkuaW5kZXhPZihcImZpeGVkXCIpID49IDA7XG4gICAgICAgIHZhciBzbmFwID0gZW50cnkuaW5kZXhPZihcInNuYXBcIikgPj0gMDtcbiAgICAgICAgdmFyIGhvdmVyID0gZW50cnkuaW5kZXhPZihcImhvdmVyXCIpID49IDA7XG4gICAgICAgIHZhciB1bmNvbnN0cmFpbmVkID0gZW50cnkuaW5kZXhPZihcInVuY29uc3RyYWluZWRcIikgPj0gMDtcbiAgICAgICAgdmFyIGRyYWdBbGwgPSBlbnRyeS5pbmRleE9mKFwiZHJhZy1hbGxcIikgPj0gMDtcbiAgICAgICAgdmFyIHNtb290aFN0ZXBzID0gZW50cnkuaW5kZXhPZihcInNtb290aC1zdGVwc1wiKSA+PSAwO1xuXG4gICAgICAgIGlmIChmaXhlZCkge1xuICAgICAgICAgIGlmIChwYXJzZWQuaGFuZGxlcyAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2ZpeGVkJyBiZWhhdmlvdXIgbXVzdCBiZSB1c2VkIHdpdGggMiBoYW5kbGVzXCIpO1xuICAgICAgICAgIH0gLy8gVXNlIG1hcmdpbiB0byBlbmZvcmNlIGZpeGVkIHN0YXRlXG5cblxuICAgICAgICAgIHRlc3RNYXJnaW4ocGFyc2VkLCBwYXJzZWQuc3RhcnRbMV0gLSBwYXJzZWQuc3RhcnRbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuY29uc3RyYWluZWQgJiYgKHBhcnNlZC5tYXJnaW4gfHwgcGFyc2VkLmxpbWl0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICd1bmNvbnN0cmFpbmVkJyBiZWhhdmlvdXIgY2Fubm90IGJlIHVzZWQgd2l0aCBtYXJnaW4gb3IgbGltaXRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQuZXZlbnRzID0ge1xuICAgICAgICAgIHRhcDogdGFwIHx8IHNuYXAsXG4gICAgICAgICAgZHJhZzogZHJhZyxcbiAgICAgICAgICBkcmFnQWxsOiBkcmFnQWxsLFxuICAgICAgICAgIHNtb290aFN0ZXBzOiBzbW9vdGhTdGVwcyxcbiAgICAgICAgICBmaXhlZDogZml4ZWQsXG4gICAgICAgICAgc25hcDogc25hcCxcbiAgICAgICAgICBob3ZlcjogaG92ZXIsXG4gICAgICAgICAgdW5jb25zdHJhaW5lZDogdW5jb25zdHJhaW5lZFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0VG9vbHRpcHMocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5ID09PSB0cnVlIHx8IGlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGVudHJ5KSkge1xuICAgICAgICAgIHBhcnNlZC50b29sdGlwcyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudHJ5ID0gYXNBcnJheShlbnRyeSk7XG5cbiAgICAgICAgICBpZiAoZW50cnkubGVuZ3RoICE9PSBwYXJzZWQuaGFuZGxlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogbXVzdCBwYXNzIGEgZm9ybWF0dGVyIGZvciBhbGwgaGFuZGxlcy5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciAhPT0gXCJib29sZWFuXCIgJiYgIWlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3Rvb2x0aXBzJyBtdXN0IGJlIHBhc3NlZCBhIGZvcm1hdHRlciBvciAnZmFsc2UnLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXJzZWQudG9vbHRpcHMgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0SGFuZGxlQXR0cmlidXRlcyhwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogbXVzdCBwYXNzIGEgYXR0cmlidXRlcyBmb3IgYWxsIGhhbmRsZXMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmhhbmRsZUF0dHJpYnV0ZXMgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdEFyaWFGb3JtYXQocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdhcmlhRm9ybWF0JyByZXF1aXJlcyAndG8nIG1ldGhvZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQuYXJpYUZvcm1hdCA9IGVudHJ5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0Rm9ybWF0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRm9ybWF0dGVyKGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdmb3JtYXQnIHJlcXVpcmVzICd0bycgYW5kICdmcm9tJyBtZXRob2RzLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5mb3JtYXQgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkU3VwcG9ydChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2tleWJvYXJkU3VwcG9ydCcgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5rZXlib2FyZFN1cHBvcnQgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdERvY3VtZW50RWxlbWVudChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYWR2YW5jZWQgb3B0aW9uLiBQYXNzZWQgdmFsdWVzIGFyZSB1c2VkIHdpdGhvdXQgdmFsaWRhdGlvbi5cbiAgICAgICAgcGFyc2VkLmRvY3VtZW50RWxlbWVudCA9IGVudHJ5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0Q3NzUHJlZml4KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIiAmJiBlbnRyeSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnY3NzUHJlZml4JyBtdXN0IGJlIGEgc3RyaW5nIG9yIGBmYWxzZWAuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmNzc1ByZWZpeCA9IGVudHJ5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0Q3NzQ2xhc3NlcyhwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnY3NzQ2xhc3NlcycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQuY3NzUHJlZml4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXMgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3Nlc1trZXldID0gcGFyc2VkLmNzc1ByZWZpeCArIGVudHJ5W2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXMgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBUZXN0IGFsbCBkZXZlbG9wZXIgc2V0dGluZ3MgYW5kIHBhcnNlIHRvIGFzc3VtcHRpb24tc2FmZSB2YWx1ZXMuXG5cblxuICAgICAgZnVuY3Rpb24gdGVzdE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICAvLyBUbyBwcm92ZSBhIGZpeCBmb3IgIzUzNywgZnJlZXplIG9wdGlvbnMgaGVyZS5cbiAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBpcyBtb2RpZmllZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICAgIC8vIE9iamVjdC5mcmVlemUob3B0aW9ucyk7XG4gICAgICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICAgICAgbWFyZ2luOiBudWxsLFxuICAgICAgICAgIGxpbWl0OiBudWxsLFxuICAgICAgICAgIHBhZGRpbmc6IG51bGwsXG4gICAgICAgICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogMzAwLFxuICAgICAgICAgIGFyaWFGb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXIsXG4gICAgICAgICAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0dGVyXG4gICAgICAgIH07IC8vIFRlc3RzIGFyZSBleGVjdXRlZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgcHJlc2VudGVkIGhlcmUuXG5cbiAgICAgICAgdmFyIHRlc3RzID0ge1xuICAgICAgICAgIHN0ZXA6IHtcbiAgICAgICAgICAgIHI6IGZhbHNlLFxuICAgICAgICAgICAgdDogdGVzdFN0ZXBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleWJvYXJkUGFnZU11bHRpcGxpZXI6IHtcbiAgICAgICAgICAgIHI6IGZhbHNlLFxuICAgICAgICAgICAgdDogdGVzdEtleWJvYXJkUGFnZU11bHRpcGxpZXJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleWJvYXJkTXVsdGlwbGllcjoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0S2V5Ym9hcmRNdWx0aXBsaWVyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXlib2FyZERlZmF1bHRTdGVwOiB7XG4gICAgICAgICAgICByOiBmYWxzZSxcbiAgICAgICAgICAgIHQ6IHRlc3RLZXlib2FyZERlZmF1bHRTdGVwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgcjogdHJ1ZSxcbiAgICAgICAgICAgIHQ6IHRlc3RTdGFydFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29ubmVjdDoge1xuICAgICAgICAgICAgcjogdHJ1ZSxcbiAgICAgICAgICAgIHQ6IHRlc3RDb25uZWN0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXJlY3Rpb246IHtcbiAgICAgICAgICAgIHI6IHRydWUsXG4gICAgICAgICAgICB0OiB0ZXN0RGlyZWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbmFwOiB7XG4gICAgICAgICAgICByOiBmYWxzZSxcbiAgICAgICAgICAgIHQ6IHRlc3RTbmFwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbmltYXRlOiB7XG4gICAgICAgICAgICByOiBmYWxzZSxcbiAgICAgICAgICAgIHQ6IHRlc3RBbmltYXRlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0QW5pbWF0aW9uRHVyYXRpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICByOiB0cnVlLFxuICAgICAgICAgICAgdDogdGVzdFJhbmdlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcmllbnRhdGlvbjoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0T3JpZW50YXRpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hcmdpbjoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0TWFyZ2luXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsaW1pdDoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0TGltaXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIHI6IGZhbHNlLFxuICAgICAgICAgICAgdDogdGVzdFBhZGRpbmdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJlaGF2aW91cjoge1xuICAgICAgICAgICAgcjogdHJ1ZSxcbiAgICAgICAgICAgIHQ6IHRlc3RCZWhhdmlvdXJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFyaWFGb3JtYXQ6IHtcbiAgICAgICAgICAgIHI6IGZhbHNlLFxuICAgICAgICAgICAgdDogdGVzdEFyaWFGb3JtYXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0Rm9ybWF0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwczoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0VG9vbHRpcHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleWJvYXJkU3VwcG9ydDoge1xuICAgICAgICAgICAgcjogdHJ1ZSxcbiAgICAgICAgICAgIHQ6IHRlc3RLZXlib2FyZFN1cHBvcnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRvY3VtZW50RWxlbWVudDoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0RG9jdW1lbnRFbGVtZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjc3NQcmVmaXg6IHtcbiAgICAgICAgICAgIHI6IHRydWUsXG4gICAgICAgICAgICB0OiB0ZXN0Q3NzUHJlZml4XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjc3NDbGFzc2VzOiB7XG4gICAgICAgICAgICByOiB0cnVlLFxuICAgICAgICAgICAgdDogdGVzdENzc0NsYXNzZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhbmRsZUF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHI6IGZhbHNlLFxuICAgICAgICAgICAgdDogdGVzdEhhbmRsZUF0dHJpYnV0ZXNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICBjb25uZWN0OiBmYWxzZSxcbiAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgICAgYmVoYXZpb3VyOiBcInRhcFwiLFxuICAgICAgICAgIG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgICBrZXlib2FyZFN1cHBvcnQ6IHRydWUsXG4gICAgICAgICAgY3NzUHJlZml4OiBcIm5vVWktXCIsXG4gICAgICAgICAgY3NzQ2xhc3NlczogY3NzQ2xhc3NlcyxcbiAgICAgICAgICBrZXlib2FyZFBhZ2VNdWx0aXBsaWVyOiA1LFxuICAgICAgICAgIGtleWJvYXJkTXVsdGlwbGllcjogMSxcbiAgICAgICAgICBrZXlib2FyZERlZmF1bHRTdGVwOiAxMFxuICAgICAgICB9OyAvLyBBcmlhRm9ybWF0IGRlZmF1bHRzIHRvIHJlZ3VsYXIgZm9ybWF0LCBpZiBhbnkuXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICYmICFvcHRpb25zLmFyaWFGb3JtYXQpIHtcbiAgICAgICAgICBvcHRpb25zLmFyaWFGb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcbiAgICAgICAgfSAvLyBSdW4gYWxsIG9wdGlvbnMgdGhyb3VnaCBhIHRlc3RpbmcgbWVjaGFuaXNtIHRvIGVuc3VyZSBjb3JyZWN0XG4gICAgICAgIC8vIGlucHV0LiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCBvcHRpb25zIG1pZ2h0IGdldCBtb2RpZmllZCB0b1xuICAgICAgICAvLyBiZSBoYW5kbGVkIHByb3Blcmx5LiBFLmcuIHdyYXBwaW5nIGludGVnZXJzIGluIGFycmF5cy5cblxuXG4gICAgICAgIE9iamVjdC5rZXlzKHRlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIG9wdGlvbiBpc24ndCBzZXQsIGJ1dCBpdCBpcyByZXF1aXJlZCwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgaWYgKCFpc1NldChvcHRpb25zW25hbWVdKSAmJiBkZWZhdWx0c1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGVzdHNbbmFtZV0ucikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnXCIgKyBuYW1lICsgXCInIGlzIHJlcXVpcmVkLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRlc3RzW25hbWVdLnQocGFyc2VkLCAhaXNTZXQob3B0aW9uc1tuYW1lXSkgPyBkZWZhdWx0c1tuYW1lXSA6IG9wdGlvbnNbbmFtZV0pO1xuICAgICAgICB9KTsgLy8gRm9yd2FyZCBwaXBzIG9wdGlvbnNcblxuICAgICAgICBwYXJzZWQucGlwcyA9IG9wdGlvbnMucGlwczsgLy8gQWxsIHJlY2VudCBicm93c2VycyBhY2NlcHQgdW5wcmVmaXhlZCB0cmFuc2Zvcm0uXG4gICAgICAgIC8vIFdlIG5lZWQgLW1zLSBmb3IgSUU5IGFuZCAtd2Via2l0LSBmb3Igb2xkZXIgQW5kcm9pZDtcbiAgICAgICAgLy8gQXNzdW1lIHVzZSBvZiAtd2Via2l0LSBpZiB1bnByZWZpeGVkIGFuZCAtbXMtIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICAgICAvLyBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PXRyYW5zZm9ybXMyZFxuXG4gICAgICAgIHZhciBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG1zUHJlZml4ID0gZC5zdHlsZS5tc1RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbm9QcmVmaXggPSBkLnN0eWxlLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJzZWQudHJhbnNmb3JtUnVsZSA9IG5vUHJlZml4ID8gXCJ0cmFuc2Zvcm1cIiA6IG1zUHJlZml4ID8gXCJtc1RyYW5zZm9ybVwiIDogXCJ3ZWJraXRUcmFuc2Zvcm1cIjsgLy8gUGlwcyBkb24ndCBtb3ZlLCBzbyB3ZSBjYW4gcGxhY2UgdGhlbSB1c2luZyBsZWZ0L3RvcC5cblxuICAgICAgICB2YXIgc3R5bGVzID0gW1tcImxlZnRcIiwgXCJ0b3BcIl0sIFtcInJpZ2h0XCIsIFwiYm90dG9tXCJdXTtcbiAgICAgICAgcGFyc2VkLnN0eWxlID0gc3R5bGVzW3BhcnNlZC5kaXJdW3BhcnNlZC5vcnRdO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfSAvL2VuZHJlZ2lvblxuXG5cbiAgICAgIGZ1bmN0aW9uIHNjb3BlKHRhcmdldCwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xuICAgICAgICB2YXIgc3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgPSBnZXRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSgpO1xuICAgICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gc3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgJiYgZ2V0U3VwcG9ydHNQYXNzaXZlKCk7IC8vIEFsbCB2YXJpYWJsZXMgbG9jYWwgdG8gJ3Njb3BlJyBhcmUgcHJlZml4ZWQgd2l0aCAnc2NvcGVfJ1xuICAgICAgICAvLyBTbGlkZXIgRE9NIE5vZGVzXG5cbiAgICAgICAgdmFyIHNjb3BlX1RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdmFyIHNjb3BlX0Jhc2U7XG4gICAgICAgIHZhciBzY29wZV9IYW5kbGVzO1xuICAgICAgICB2YXIgc2NvcGVfQ29ubmVjdHM7XG4gICAgICAgIHZhciBzY29wZV9QaXBzO1xuICAgICAgICB2YXIgc2NvcGVfVG9vbHRpcHM7IC8vIFNsaWRlciBzdGF0ZSB2YWx1ZXNcblxuICAgICAgICB2YXIgc2NvcGVfU3BlY3RydW0gPSBvcHRpb25zLnNwZWN0cnVtO1xuICAgICAgICB2YXIgc2NvcGVfVmFsdWVzID0gW107XG4gICAgICAgIHZhciBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHNjb3BlX0hhbmRsZU51bWJlcnMgPSBbXTtcbiAgICAgICAgdmFyIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCA9IDA7XG4gICAgICAgIHZhciBzY29wZV9FdmVudHMgPSB7fTsgLy8gRG9jdW1lbnQgTm9kZXNcblxuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIHNjb3BlX0RvY3VtZW50RWxlbWVudCA9IG9wdGlvbnMuZG9jdW1lbnRFbGVtZW50IHx8IHNjb3BlX0RvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdmFyIHNjb3BlX0JvZHkgPSBzY29wZV9Eb2N1bWVudC5ib2R5OyAvLyBGb3IgaG9yaXpvbnRhbCBzbGlkZXJzIGluIHN0YW5kYXJkIGx0ciBkb2N1bWVudHMsXG4gICAgICAgIC8vIG1ha2UgLm5vVWktb3JpZ2luIG92ZXJmbG93IHRvIHRoZSBsZWZ0IHNvIHRoZSBkb2N1bWVudCBkb2Vzbid0IHNjcm9sbC5cblxuICAgICAgICB2YXIgc2NvcGVfRGlyT2Zmc2V0ID0gc2NvcGVfRG9jdW1lbnQuZGlyID09PSBcInJ0bFwiIHx8IG9wdGlvbnMub3J0ID09PSAxID8gMCA6IDEwMDsgLy8gQ3JlYXRlcyBhIG5vZGUsIGFkZHMgaXQgdG8gdGFyZ2V0LCByZXR1cm5zIHRoZSBuZXcgbm9kZS5cblxuICAgICAgICBmdW5jdGlvbiBhZGROb2RlVG8oYWRkVGFyZ2V0LCBjbGFzc05hbWUpIHtcbiAgICAgICAgICB2YXIgZGl2ID0gc2NvcGVfRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGRpdiwgY2xhc3NOYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRUYXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgICByZXR1cm4gZGl2O1xuICAgICAgICB9IC8vIEFwcGVuZCBhIG9yaWdpbiB0byB0aGUgYmFzZVxuXG5cbiAgICAgICAgZnVuY3Rpb24gYWRkT3JpZ2luKGJhc2UsIGhhbmRsZU51bWJlcikge1xuICAgICAgICAgIHZhciBvcmlnaW4gPSBhZGROb2RlVG8oYmFzZSwgb3B0aW9ucy5jc3NDbGFzc2VzLm9yaWdpbik7XG4gICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZE5vZGVUbyhvcmlnaW4sIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGUpO1xuICAgICAgICAgIGFkZE5vZGVUbyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50b3VjaEFyZWEpO1xuICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWhhbmRsZVwiLCBTdHJpbmcoaGFuZGxlTnVtYmVyKSk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5rZXlib2FyZFN1cHBvcnQpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXhcbiAgICAgICAgICAgIC8vIDAgPSBmb2N1c2FibGUgYW5kIHJlYWNoYWJsZVxuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICAgICAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50S2V5ZG93bihldmVudCwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmhhbmRsZUF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXNfMSA9IG9wdGlvbnMuaGFuZGxlQXR0cmlidXRlc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGF0dHJpYnV0ZXNfMVthdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic2xpZGVyXCIpO1xuICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIG9wdGlvbnMub3J0ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIpO1xuXG4gICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlTG93ZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlTnVtYmVyID09PSBvcHRpb25zLmhhbmRsZXMgLSAxKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGVVcHBlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICAgICAgfSAvLyBJbnNlcnQgbm9kZXMgZm9yIGNvbm5lY3QgZWxlbWVudHNcblxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZENvbm5lY3QoYmFzZSwgYWRkKSB7XG4gICAgICAgICAgaWYgKCFhZGQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWRkTm9kZVRvKGJhc2UsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5jb25uZWN0KTtcbiAgICAgICAgfSAvLyBBZGQgaGFuZGxlcyB0byB0aGUgc2xpZGVyIGJhc2UuXG5cblxuICAgICAgICBmdW5jdGlvbiBhZGRFbGVtZW50cyhjb25uZWN0T3B0aW9ucywgYmFzZSkge1xuICAgICAgICAgIHZhciBjb25uZWN0QmFzZSA9IGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdHMpO1xuICAgICAgICAgIHNjb3BlX0hhbmRsZXMgPSBbXTtcbiAgICAgICAgICBzY29wZV9Db25uZWN0cyA9IFtdO1xuICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChjb25uZWN0QmFzZSwgY29ubmVjdE9wdGlvbnNbMF0pKTsgLy8gWzo6OjpPPT09PU89PT09Tz09PT1dXG4gICAgICAgICAgLy8gY29ubmVjdE9wdGlvbnMgPSBbMCwgMSwgMSwgMV1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5oYW5kbGVzOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEtlZXAgYSBsaXN0IG9mIGFsbCBhZGRlZCBoYW5kbGVzLlxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5wdXNoKGFkZE9yaWdpbihiYXNlLCBpKSk7XG4gICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzW2ldID0gaTtcbiAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChjb25uZWN0QmFzZSwgY29ubmVjdE9wdGlvbnNbaSArIDFdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEluaXRpYWxpemUgYSBzaW5nbGUgc2xpZGVyLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gYWRkU2xpZGVyKGFkZFRhcmdldCkge1xuICAgICAgICAgIC8vIEFwcGx5IGNsYXNzZXMgYW5kIGRhdGEgdG8gdGhlIHRhcmdldC5cbiAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXJnZXQpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyID09PSAwKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5sdHIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5ydGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLm9ydCA9PT0gMCkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuaG9yaXpvbnRhbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZlcnRpY2FsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGV4dERpcmVjdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoYWRkVGFyZ2V0KS5kaXJlY3Rpb247XG5cbiAgICAgICAgICBpZiAodGV4dERpcmVjdGlvbiA9PT0gXCJydGxcIikge1xuICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGV4dERpcmVjdGlvblJ0bCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRleHREaXJlY3Rpb25MdHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhZGROb2RlVG8oYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuYmFzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRUb29sdGlwKGhhbmRsZSwgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLnRvb2x0aXBzIHx8ICFvcHRpb25zLnRvb2x0aXBzW2hhbmRsZU51bWJlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWRkTm9kZVRvKGhhbmRsZS5maXJzdENoaWxkLCBvcHRpb25zLmNzc0NsYXNzZXMudG9vbHRpcCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1NsaWRlckRpc2FibGVkKCkge1xuICAgICAgICAgIHJldHVybiBzY29wZV9UYXJnZXQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gICAgICAgIH0gLy8gRGlzYWJsZSB0aGUgc2xpZGVyIGRyYWdnaW5nIGlmIGFueSBoYW5kbGUgaXMgZGlzYWJsZWRcblxuXG4gICAgICAgIGZ1bmN0aW9uIGlzSGFuZGxlRGlzYWJsZWQoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlT3JpZ2luLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVG9vbHRpcHMoKSB7XG4gICAgICAgICAgaWYgKHNjb3BlX1Rvb2x0aXBzKSB7XG4gICAgICAgICAgICByZW1vdmVFdmVudChcInVwZGF0ZVwiICsgSU5URVJOQUxfRVZFTlRfTlMudG9vbHRpcHMpO1xuICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMuZm9yRWFjaChmdW5jdGlvbiAodG9vbHRpcCkge1xuICAgICAgICAgICAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodG9vbHRpcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUaGUgdG9vbHRpcHMgb3B0aW9uIGlzIGEgc2hvcnRoYW5kIGZvciB1c2luZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cblxuICAgICAgICBmdW5jdGlvbiB0b29sdGlwcygpIHtcbiAgICAgICAgICByZW1vdmVUb29sdGlwcygpOyAvLyBUb29sdGlwcyBhcmUgYWRkZWQgd2l0aCBvcHRpb25zLnRvb2x0aXBzIGluIG9yaWdpbmFsIG9yZGVyLlxuXG4gICAgICAgICAgc2NvcGVfVG9vbHRpcHMgPSBzY29wZV9IYW5kbGVzLm1hcChhZGRUb29sdGlwKTtcbiAgICAgICAgICBiaW5kRXZlbnQoXCJ1cGRhdGVcIiArIElOVEVSTkFMX0VWRU5UX05TLnRvb2x0aXBzLCBmdW5jdGlvbiAodmFsdWVzLCBoYW5kbGVOdW1iZXIsIHVuZW5jb2RlZCkge1xuICAgICAgICAgICAgaWYgKCFzY29wZV9Ub29sdGlwcyB8fCAhb3B0aW9ucy50b29sdGlwcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY29wZV9Ub29sdGlwc1toYW5kbGVOdW1iZXJdID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHZhbHVlc1toYW5kbGVOdW1iZXJdO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdLnRvKHVuZW5jb2RlZFtoYW5kbGVOdW1iZXJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHNbaGFuZGxlTnVtYmVyXS5pbm5lckhUTUwgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFyaWEoKSB7XG4gICAgICAgICAgcmVtb3ZlRXZlbnQoXCJ1cGRhdGVcIiArIElOVEVSTkFMX0VWRU5UX05TLmFyaWEpO1xuICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZVwiICsgSU5URVJOQUxfRVZFTlRfTlMuYXJpYSwgZnVuY3Rpb24gKHZhbHVlcywgaGFuZGxlTnVtYmVyLCB1bmVuY29kZWQsIHRhcCwgcG9zaXRpb25zKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgQXJpYSBWYWx1ZXMgZm9yIGFsbCBoYW5kbGVzLCBhcyBhIGNoYW5nZSBpbiBvbmUgY2hhbmdlcyBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIHRoZSBuZXh0LlxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2NvcGVfSGFuZGxlc1tpbmRleF07XG4gICAgICAgICAgICAgIHZhciBtaW4gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaW5kZXgsIDAsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICB2YXIgbWF4ID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGluZGV4LCAxMDAsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICB2YXIgbm93ID0gcG9zaXRpb25zW2luZGV4XTsgLy8gRm9ybWF0dGVkIHZhbHVlIGZvciBkaXNwbGF5XG5cbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBTdHJpbmcob3B0aW9ucy5hcmlhRm9ybWF0LnRvKHVuZW5jb2RlZFtpbmRleF0pKTsgLy8gTWFwIHRvIHNsaWRlciByYW5nZSB2YWx1ZXNcblxuICAgICAgICAgICAgICBtaW4gPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobWluKS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICBtYXggPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobWF4KS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICBub3cgPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobm93KS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1pblwiLCBtaW4pO1xuICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1heFwiLCBtYXgpO1xuICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiLCBub3cpO1xuICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZXRleHRcIiwgdGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwKHBpcHMpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIHJhbmdlLlxuICAgICAgICAgIGlmIChwaXBzLm1vZGUgPT09IGV4cG9ydHMuUGlwc01vZGUuUmFuZ2UgfHwgcGlwcy5tb2RlID09PSBleHBvcnRzLlBpcHNNb2RlLlN0ZXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0ueFZhbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGlwcy5tb2RlID09PSBleHBvcnRzLlBpcHNNb2RlLkNvdW50KSB7XG4gICAgICAgICAgICBpZiAocGlwcy52YWx1ZXMgPCAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICd2YWx1ZXMnICg+PSAyKSByZXF1aXJlZCBmb3IgbW9kZSAnY291bnQnLlwiKTtcbiAgICAgICAgICAgIH0gLy8gRGl2aWRlIDAgLSAxMDAgaW4gJ2NvdW50JyBwYXJ0cy5cblxuXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBwaXBzLnZhbHVlcyAtIDE7XG4gICAgICAgICAgICB2YXIgc3ByZWFkID0gMTAwIC8gaW50ZXJ2YWw7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107IC8vIExpc3QgdGhlc2UgcGFydHMgYW5kIGhhdmUgdGhlbSBoYW5kbGVkIGFzICdwb3NpdGlvbnMnLlxuXG4gICAgICAgICAgICB3aGlsZSAoaW50ZXJ2YWwtLSkge1xuICAgICAgICAgICAgICB2YWx1ZXNbaW50ZXJ2YWxdID0gaW50ZXJ2YWwgKiBzcHJlYWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gbWFwVG9SYW5nZSh2YWx1ZXMsIHBpcHMuc3RlcHBlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBpcHMubW9kZSA9PT0gZXhwb3J0cy5QaXBzTW9kZS5Qb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIE1hcCBhbGwgcGVyY2VudGFnZXMgdG8gb24tcmFuZ2UgdmFsdWVzLlxuICAgICAgICAgICAgcmV0dXJuIG1hcFRvUmFuZ2UocGlwcy52YWx1ZXMsIHBpcHMuc3RlcHBlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBpcHMubW9kZSA9PT0gZXhwb3J0cy5QaXBzTW9kZS5WYWx1ZXMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBtdXN0IGJlIHN0ZXBwZWQsIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHBlcmNlbnRhZ2UgZmlyc3QuXG4gICAgICAgICAgICBpZiAocGlwcy5zdGVwcGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwaXBzLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwZXJjZW50YWdlLCBhcHBseSBzdGVwLCByZXR1cm4gdG8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodmFsdWUpKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSAvLyBPdGhlcndpc2UsIHdlIGNhbiBzaW1wbHkgdXNlIHRoZSB2YWx1ZXMuXG5cblxuICAgICAgICAgICAgcmV0dXJuIHBpcHMudmFsdWVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbXTsgLy8gcGlwcy5tb2RlID0gbmV2ZXJcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1hcFRvUmFuZ2UodmFsdWVzLCBzdGVwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHN0ZXBwZWQgPyBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3ByZWFkKHBpcHMpIHtcbiAgICAgICAgICBmdW5jdGlvbiBzYWZlSW5jcmVtZW50KHZhbHVlLCBpbmNyZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIGZsb2F0aW5nIHBvaW50IHZhcmlhbmNlIGJ5IGRyb3BwaW5nIHRoZSBzbWFsbGVzdCBkZWNpbWFsIHBsYWNlcy5cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoKHZhbHVlICsgaW5jcmVtZW50KS50b0ZpeGVkKDcpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZ3JvdXAgPSBnZXRHcm91cChwaXBzKTtcbiAgICAgICAgICB2YXIgaW5kZXhlcyA9IHt9O1xuICAgICAgICAgIHZhciBmaXJzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsWzBdO1xuICAgICAgICAgIHZhciBsYXN0SW5SYW5nZSA9IHNjb3BlX1NwZWN0cnVtLnhWYWxbc2NvcGVfU3BlY3RydW0ueFZhbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgaWdub3JlRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgaWdub3JlTGFzdCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBwcmV2UGN0ID0gMDsgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZ3JvdXAsIHNvcnQgaXQgYW5kIGZpbHRlciBhd2F5IGFsbCBkdXBsaWNhdGVzLlxuXG4gICAgICAgICAgZ3JvdXAgPSB1bmlxdWUoZ3JvdXAuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgfSkpOyAvLyBNYWtlIHN1cmUgdGhlIHJhbmdlIHN0YXJ0cyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50LlxuXG4gICAgICAgICAgaWYgKGdyb3VwWzBdICE9PSBmaXJzdEluUmFuZ2UpIHtcbiAgICAgICAgICAgIGdyb3VwLnVuc2hpZnQoZmlyc3RJblJhbmdlKTtcbiAgICAgICAgICAgIGlnbm9yZUZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIExpa2V3aXNlIGZvciB0aGUgbGFzdCBvbmUuXG5cblxuICAgICAgICAgIGlmIChncm91cFtncm91cC5sZW5ndGggLSAxXSAhPT0gbGFzdEluUmFuZ2UpIHtcbiAgICAgICAgICAgIGdyb3VwLnB1c2gobGFzdEluUmFuZ2UpO1xuICAgICAgICAgICAgaWdub3JlTGFzdCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGVwIGFuZCB0aGUgbG93ZXIgKyB1cHBlciBwb3NpdGlvbnMuXG4gICAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIHE7XG4gICAgICAgICAgICB2YXIgbG93ID0gY3VycmVudDtcbiAgICAgICAgICAgIHZhciBoaWdoID0gZ3JvdXBbaW5kZXggKyAxXTtcbiAgICAgICAgICAgIHZhciBuZXdQY3Q7XG4gICAgICAgICAgICB2YXIgcGN0RGlmZmVyZW5jZTtcbiAgICAgICAgICAgIHZhciBwY3RQb3M7XG4gICAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICAgIHZhciBzdGVwcztcbiAgICAgICAgICAgIHZhciByZWFsU3RlcHM7XG4gICAgICAgICAgICB2YXIgc3RlcFNpemU7XG4gICAgICAgICAgICB2YXIgaXNTdGVwcyA9IHBpcHMubW9kZSA9PT0gZXhwb3J0cy5QaXBzTW9kZS5TdGVwczsgLy8gV2hlbiB1c2luZyAnc3RlcHMnIG1vZGUsIHVzZSB0aGUgcHJvdmlkZWQgc3RlcHMuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlJ2xsIHN0ZXAgb24gdG8gdGhlIG5leHQgc3VicmFuZ2UuXG5cbiAgICAgICAgICAgIGlmIChpc1N0ZXBzKSB7XG4gICAgICAgICAgICAgIHN0ZXAgPSBzY29wZV9TcGVjdHJ1bS54TnVtU3RlcHNbaW5kZXhdO1xuICAgICAgICAgICAgfSAvLyBEZWZhdWx0IHRvIGEgJ2Z1bGwnIHN0ZXAuXG5cblxuICAgICAgICAgICAgaWYgKCFzdGVwKSB7XG4gICAgICAgICAgICAgIHN0ZXAgPSBoaWdoIC0gbG93O1xuICAgICAgICAgICAgfSAvLyBJZiBoaWdoIGlzIHVuZGVmaW5lZCB3ZSBhcmUgYXQgdGhlIGxhc3Qgc3VicmFuZ2UuIE1ha2Ugc3VyZSBpdCBpdGVyYXRlcyBvbmNlICgjMTA4OClcblxuXG4gICAgICAgICAgICBpZiAoaGlnaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGhpZ2ggPSBsb3c7XG4gICAgICAgICAgICB9IC8vIE1ha2Ugc3VyZSBzdGVwIGlzbid0IDAsIHdoaWNoIHdvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3AgKCM2NTQpXG5cblxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KHN0ZXAsIDAuMDAwMDAwMSk7IC8vIEZpbmQgYWxsIHN0ZXBzIGluIHRoZSBzdWJyYW5nZS5cblxuICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IGhpZ2g7IGkgPSBzYWZlSW5jcmVtZW50KGksIHN0ZXApKSB7XG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcGVyY2VudGFnZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgc3RlcCxcbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzaXplIGZvciB0aGUgc3VicmFuZ2UuXG4gICAgICAgICAgICAgIG5ld1BjdCA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcoaSk7XG4gICAgICAgICAgICAgIHBjdERpZmZlcmVuY2UgPSBuZXdQY3QgLSBwcmV2UGN0O1xuICAgICAgICAgICAgICBzdGVwcyA9IHBjdERpZmZlcmVuY2UgLyAocGlwcy5kZW5zaXR5IHx8IDEpO1xuICAgICAgICAgICAgICByZWFsU3RlcHMgPSBNYXRoLnJvdW5kKHN0ZXBzKTsgLy8gVGhpcyByYXRpbyByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgcGVyY2VudGFnZS1zcGFjZSBhIHBvaW50IGluZGljYXRlcy5cbiAgICAgICAgICAgICAgLy8gRm9yIGEgZGVuc2l0eSAxIHRoZSBwb2ludHMvcGVyY2VudGFnZSA9IDEuIEZvciBkZW5zaXR5IDIsIHRoYXQgcGVyY2VudGFnZSBuZWVkcyB0byBiZSByZS1kaXZpZGVkLlxuICAgICAgICAgICAgICAvLyBSb3VuZCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgdG8gYW4gZXZlbiBudW1iZXIsIHRoZW4gZGl2aWRlIGJ5IHR3b1xuICAgICAgICAgICAgICAvLyB0byBzcHJlYWQgdGhlIG9mZnNldCBvbiBib3RoIHNpZGVzIG9mIHRoZSByYW5nZS5cblxuICAgICAgICAgICAgICBzdGVwU2l6ZSA9IHBjdERpZmZlcmVuY2UgLyByZWFsU3RlcHM7IC8vIERpdmlkZSBhbGwgcG9pbnRzIGV2ZW5seSwgYWRkaW5nIHRoZSBjb3JyZWN0IG51bWJlciB0byB0aGlzIHN1YnJhbmdlLlxuICAgICAgICAgICAgICAvLyBSdW4gdXAgdG8gPD0gc28gdGhhdCAxMDAlIGdldHMgYSBwb2ludCwgZXZlbnQgaWYgaWdub3JlTGFzdCBpcyBzZXQuXG5cbiAgICAgICAgICAgICAgZm9yIChxID0gMTsgcSA8PSByZWFsU3RlcHM7IHEgKz0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSByYXRpbyBiZXR3ZWVuIHRoZSByb3VuZGVkIHZhbHVlIGFuZCB0aGUgYWN0dWFsIHNpemUgbWlnaHQgYmUgfjElIG9mZi5cbiAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IHRoZSBwZXJjZW50YWdlIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIHBvaW50c1xuICAgICAgICAgICAgICAgIC8vIHBlciBzdWJyYW5nZS4gZGVuc2l0eSA9IDEgd2lsbCByZXN1bHQgaW4gMTAwIHBvaW50cyBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBmdWxsIHJhbmdlLCAyIGZvciA1MCwgNCBmb3IgMjUsIGV0Yy5cbiAgICAgICAgICAgICAgICBwY3RQb3MgPSBwcmV2UGN0ICsgcSAqIHN0ZXBTaXplO1xuICAgICAgICAgICAgICAgIGluZGV4ZXNbcGN0UG9zLnRvRml4ZWQoNSldID0gW3Njb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhwY3RQb3MpLCAwXTtcbiAgICAgICAgICAgICAgfSAvLyBEZXRlcm1pbmUgdGhlIHBvaW50IHR5cGUuXG5cblxuICAgICAgICAgICAgICB0eXBlID0gZ3JvdXAuaW5kZXhPZihpKSA+IC0xID8gZXhwb3J0cy5QaXBzVHlwZS5MYXJnZVZhbHVlIDogaXNTdGVwcyA/IGV4cG9ydHMuUGlwc1R5cGUuU21hbGxWYWx1ZSA6IGV4cG9ydHMuUGlwc1R5cGUuTm9WYWx1ZTsgLy8gRW5mb3JjZSB0aGUgJ2lnbm9yZUZpcnN0JyBvcHRpb24gYnkgb3ZlcndyaXRpbmcgdGhlIHR5cGUgZm9yIDAuXG5cbiAgICAgICAgICAgICAgaWYgKCFpbmRleCAmJiBpZ25vcmVGaXJzdCAmJiBpICE9PSBoaWdoKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IDA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIShpID09PSBoaWdoICYmIGlnbm9yZUxhc3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgJ3R5cGUnIG9mIHRoaXMgcG9pbnQuIDAgPSBwbGFpbiwgMSA9IHJlYWwgdmFsdWUsIDIgPSBzdGVwIHZhbHVlLlxuICAgICAgICAgICAgICAgIGluZGV4ZXNbbmV3UGN0LnRvRml4ZWQoNSldID0gW2ksIHR5cGVdO1xuICAgICAgICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcGVyY2VudGFnZSBjb3VudC5cblxuXG4gICAgICAgICAgICAgIHByZXZQY3QgPSBuZXdQY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRNYXJraW5nKHNwcmVhZCwgZmlsdGVyRnVuYywgZm9ybWF0dGVyKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcblxuICAgICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGVfRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICB2YXIgdmFsdWVTaXplQ2xhc3NlcyA9IChfYSA9IHt9LCBfYVtleHBvcnRzLlBpcHNUeXBlLk5vbmVdID0gXCJcIiwgX2FbZXhwb3J0cy5QaXBzVHlwZS5Ob1ZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZU5vcm1hbCwgX2FbZXhwb3J0cy5QaXBzVHlwZS5MYXJnZVZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZUxhcmdlLCBfYVtleHBvcnRzLlBpcHNUeXBlLlNtYWxsVmFsdWVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlU3ViLCBfYSk7XG4gICAgICAgICAgdmFyIG1hcmtlclNpemVDbGFzc2VzID0gKF9iID0ge30sIF9iW2V4cG9ydHMuUGlwc1R5cGUuTm9uZV0gPSBcIlwiLCBfYltleHBvcnRzLlBpcHNUeXBlLk5vVmFsdWVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlck5vcm1hbCwgX2JbZXhwb3J0cy5QaXBzVHlwZS5MYXJnZVZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJMYXJnZSwgX2JbZXhwb3J0cy5QaXBzVHlwZS5TbWFsbFZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJTdWIsIF9iKTtcbiAgICAgICAgICB2YXIgdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlSG9yaXpvbnRhbCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlVmVydGljYWxdO1xuICAgICAgICAgIHZhciBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlckhvcml6b250YWwsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJWZXJ0aWNhbF07XG4gICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHMpO1xuICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIG9wdGlvbnMub3J0ID09PSAwID8gb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNIb3Jpem9udGFsIDogb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNWZXJ0aWNhbCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRDbGFzc2VzKHR5cGUsIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIGEgPSBzb3VyY2UgPT09IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZTtcbiAgICAgICAgICAgIHZhciBvcmllbnRhdGlvbkNsYXNzZXMgPSBhID8gdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgOiBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXM7XG4gICAgICAgICAgICB2YXIgc2l6ZUNsYXNzZXMgPSBhID8gdmFsdWVTaXplQ2xhc3NlcyA6IG1hcmtlclNpemVDbGFzc2VzO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSArIFwiIFwiICsgb3JpZW50YXRpb25DbGFzc2VzW29wdGlvbnMub3J0XSArIFwiIFwiICsgc2l6ZUNsYXNzZXNbdHlwZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYWRkU3ByZWFkKG9mZnNldCwgdmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgZnVuY3Rpb24sIGlmIGl0IGlzIHNldC5cbiAgICAgICAgICAgIHR5cGUgPSBmaWx0ZXJGdW5jID8gZmlsdGVyRnVuYyh2YWx1ZSwgdHlwZSkgOiB0eXBlO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5QaXBzVHlwZS5Ob25lKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gLy8gQWRkIGEgbWFya2VyIGZvciBldmVyeSBwb2ludFxuXG5cbiAgICAgICAgICAgIHZhciBub2RlID0gYWRkTm9kZVRvKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gZ2V0Q2xhc3Nlcyh0eXBlLCBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyKTtcbiAgICAgICAgICAgIG5vZGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSBvZmZzZXQgKyBcIiVcIjsgLy8gVmFsdWVzIGFyZSBvbmx5IGFwcGVuZGVkIGZvciBwb2ludHMgbWFya2VkICcxJyBvciAnMicuXG5cbiAgICAgICAgICAgIGlmICh0eXBlID4gZXhwb3J0cy5QaXBzVHlwZS5Ob1ZhbHVlKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBhZGROb2RlVG8oZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGdldENsYXNzZXModHlwZSwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlKTtcbiAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgICBub2RlLnN0eWxlW29wdGlvbnMuc3R5bGVdID0gb2Zmc2V0ICsgXCIlXCI7XG4gICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gU3RyaW5nKGZvcm1hdHRlci50byh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQXBwZW5kIGFsbCBwb2ludHMuXG5cblxuICAgICAgICAgIE9iamVjdC5rZXlzKHNwcmVhZCkuZm9yRWFjaChmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICBhZGRTcHJlYWQob2Zmc2V0LCBzcHJlYWRbb2Zmc2V0XVswXSwgc3ByZWFkW29mZnNldF1bMV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlUGlwcygpIHtcbiAgICAgICAgICBpZiAoc2NvcGVfUGlwcykge1xuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudChzY29wZV9QaXBzKTtcbiAgICAgICAgICAgIHNjb3BlX1BpcHMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBpcHMocGlwcykge1xuICAgICAgICAgIC8vIEZpeCAjNjY5XG4gICAgICAgICAgcmVtb3ZlUGlwcygpO1xuICAgICAgICAgIHZhciBzcHJlYWQgPSBnZW5lcmF0ZVNwcmVhZChwaXBzKTtcbiAgICAgICAgICB2YXIgZmlsdGVyID0gcGlwcy5maWx0ZXI7XG4gICAgICAgICAgdmFyIGZvcm1hdCA9IHBpcHMuZm9ybWF0IHx8IHtcbiAgICAgICAgICAgIHRvOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLnJvdW5kKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzY29wZV9QaXBzID0gc2NvcGVfVGFyZ2V0LmFwcGVuZENoaWxkKGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXIsIGZvcm1hdCkpO1xuICAgICAgICAgIHJldHVybiBzY29wZV9QaXBzO1xuICAgICAgICB9IC8vIFNob3J0aGFuZCBmb3IgYmFzZSBkaW1lbnNpb25zLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gYmFzZVNpemUoKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSBzY29wZV9CYXNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHZhciBhbHQgPSBcIm9mZnNldFwiICsgW1wiV2lkdGhcIiwgXCJIZWlnaHRcIl1bb3B0aW9ucy5vcnRdO1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLm9ydCA9PT0gMCA/IHJlY3Qud2lkdGggfHwgc2NvcGVfQmFzZVthbHRdIDogcmVjdC5oZWlnaHQgfHwgc2NvcGVfQmFzZVthbHRdO1xuICAgICAgICB9IC8vIEhhbmRsZXIgZm9yIGF0dGFjaGluZyBldmVudHMgdHJvdWdoIGEgcHJveHkuXG5cblxuICAgICAgICBmdW5jdGlvbiBhdHRhY2hFdmVudChldmVudHMsIGVsZW1lbnQsIGNhbGxiYWNrLCBkYXRhKSB7XG4gICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byAnZmlsdGVyJyBldmVudHMgdG8gdGhlIHNsaWRlci5cbiAgICAgICAgICAvLyBlbGVtZW50IGlzIGEgbm9kZSwgbm90IGEgbm9kZUxpc3RcbiAgICAgICAgICB2YXIgbWV0aG9kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGZpeEV2ZW50KGV2ZW50LCBkYXRhLnBhZ2VPZmZzZXQsIGRhdGEudGFyZ2V0IHx8IGVsZW1lbnQpOyAvLyBmaXhFdmVudCByZXR1cm5zIGZhbHNlIGlmIHRoaXMgZXZlbnQgaGFzIGEgZGlmZmVyZW50IHRhcmdldFxuICAgICAgICAgICAgLy8gd2hlbiBoYW5kbGluZyAobXVsdGktKSB0b3VjaCBldmVudHM7XG5cbiAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IC8vIGRvTm90UmVqZWN0IGlzIHBhc3NlZCBieSBhbGwgZW5kIGV2ZW50cyB0byBtYWtlIHN1cmUgcmVsZWFzZWQgdG91Y2hlc1xuICAgICAgICAgICAgLy8gYXJlIG5vdCByZWplY3RlZCwgbGVhdmluZyB0aGUgc2xpZGVyIFwic3R1Y2tcIiB0byB0aGUgY3Vyc29yO1xuXG5cbiAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgJiYgIWRhdGEuZG9Ob3RSZWplY3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyBTdG9wIGlmIGFuIGFjdGl2ZSAndGFwJyB0cmFuc2l0aW9uIGlzIHRha2luZyBwbGFjZS5cblxuXG4gICAgICAgICAgICBpZiAoaGFzQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwKSAmJiAhZGF0YS5kb05vdFJlamVjdCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcblxuXG4gICAgICAgICAgICBpZiAoZXZlbnRzID09PSBhY3Rpb25zLnN0YXJ0ICYmIGUuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9ucyA+IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XG5cblxuICAgICAgICAgICAgaWYgKGRhdGEuaG92ZXIgJiYgZS5idXR0b25zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gLy8gJ3N1cHBvcnRzUGFzc2l2ZScgaXMgb25seSB0cnVlIGlmIGEgYnJvd3NlciBhbHNvIHN1cHBvcnRzIHRvdWNoLWFjdGlvbjogbm9uZSBpbiBDU1MuXG4gICAgICAgICAgICAvLyBpT1Mgc2FmYXJpIGRvZXMgbm90LCBzbyBpdCBkb2Vzbid0IGdldCB0byBiZW5lZml0IGZyb20gcGFzc2l2ZSBzY3JvbGxpbmcuIGlPUyBkb2VzIHN1cHBvcnRcbiAgICAgICAgICAgIC8vIHRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uLCBidXQgdGhhdCBhbGxvd3MgcGFubmluZywgd2hpY2ggYnJlYWtzXG4gICAgICAgICAgICAvLyBzbGlkZXJzIGFmdGVyIHpvb21pbmcvb24gbm9uLXJlc3BvbnNpdmUgcGFnZXMuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzMxMTJcblxuXG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRzUGFzc2l2ZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUuY2FsY1BvaW50ID0gZS5wb2ludHNbb3B0aW9ucy5vcnRdOyAvLyBDYWxsIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIGV2ZW50IFsgYW5kIGFkZGl0aW9uYWwgZGF0YSBdLlxuXG4gICAgICAgICAgICBjYWxsYmFjayhlLCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIG1ldGhvZHMgPSBbXTsgLy8gQmluZCBhIGNsb3N1cmUgb24gdGhlIHRhcmdldCBmb3IgZXZlcnkgZXZlbnQgdHlwZS5cblxuICAgICAgICAgIGV2ZW50cy5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBtZXRob2QsIHN1cHBvcnRzUGFzc2l2ZSA/IHtcbiAgICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgICAgfSA6IGZhbHNlKTtcbiAgICAgICAgICAgIG1ldGhvZHMucHVzaChbZXZlbnROYW1lLCBtZXRob2RdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kcztcbiAgICAgICAgfSAvLyBQcm92aWRlIGEgY2xlYW4gZXZlbnQgd2l0aCBzdGFuZGFyZGl6ZWQgb2Zmc2V0IHZhbHVlcy5cblxuXG4gICAgICAgIGZ1bmN0aW9uIGZpeEV2ZW50KGUsIHBhZ2VPZmZzZXQsIGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgLy8gRmlsdGVyIHRoZSBldmVudCB0byByZWdpc3RlciB0aGUgdHlwZSwgd2hpY2ggY2FuIGJlXG4gICAgICAgICAgLy8gdG91Y2gsIG1vdXNlIG9yIHBvaW50ZXIuIE9mZnNldCBjaGFuZ2VzIG5lZWQgdG8gYmVcbiAgICAgICAgICAvLyBtYWRlIG9uIGFuIGV2ZW50IHNwZWNpZmljIGJhc2lzLlxuICAgICAgICAgIHZhciB0b3VjaCA9IGUudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPT09IDA7XG4gICAgICAgICAgdmFyIG1vdXNlID0gZS50eXBlLmluZGV4T2YoXCJtb3VzZVwiKSA9PT0gMDtcbiAgICAgICAgICB2YXIgcG9pbnRlciA9IGUudHlwZS5pbmRleE9mKFwicG9pbnRlclwiKSA9PT0gMDtcbiAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgdmFyIHkgPSAwOyAvLyBJRTEwIGltcGxlbWVudGVkIHBvaW50ZXIgZXZlbnRzIHdpdGggYSBwcmVmaXg7XG5cbiAgICAgICAgICBpZiAoZS50eXBlLmluZGV4T2YoXCJNU1BvaW50ZXJcIikgPT09IDApIHtcbiAgICAgICAgICAgIHBvaW50ZXIgPSB0cnVlO1xuICAgICAgICAgIH0gLy8gRXJyb25lb3VzIGV2ZW50cyBzZWVtIHRvIGJlIHBhc3NlZCBpbiBvY2Nhc2lvbmFsbHkgb24gaU9TL2lQYWRPUyBhZnRlciB1c2VyIGZpbmlzaGVzIGludGVyYWN0aW5nIHdpdGhcbiAgICAgICAgICAvLyB0aGUgc2xpZGVyLiBUaGV5IGFwcGVhciB0byBiZSBvZiB0eXBlIE1vdXNlRXZlbnQsIHlldCB0aGV5IGRvbid0IGhhdmUgdXN1YWwgcHJvcGVydGllcyBzZXQuIElnbm9yZVxuICAgICAgICAgIC8vIGV2ZW50cyB0aGF0IGhhdmUgbm8gdG91Y2hlcyBvciBidXR0b25zIGFzc29jaWF0ZWQgd2l0aCB0aGVtLiAoIzEwNTcsICMxMDc5LCAjMTA5NSlcblxuXG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJtb3VzZWRvd25cIiAmJiAhZS5idXR0b25zICYmICFlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IC8vIFRoZSBvbmx5IHRoaW5nIG9uZSBoYW5kbGUgc2hvdWxkIGJlIGNvbmNlcm5lZCBhYm91dCBpcyB0aGUgdG91Y2hlcyB0aGF0IG9yaWdpbmF0ZWQgb24gdG9wIG9mIGl0LlxuXG5cbiAgICAgICAgICBpZiAodG91Y2gpIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIHRvdWNoIG9yaWdpbmF0ZWQgb24gdGhlIHRhcmdldC5cbiAgICAgICAgICAgIHZhciBpc1RvdWNoT25UYXJnZXQgPSBmdW5jdGlvbiAoY2hlY2tUb3VjaCkge1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gY2hlY2tUb3VjaC50YXJnZXQ7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQgPT09IGV2ZW50VGFyZ2V0IHx8IGV2ZW50VGFyZ2V0LmNvbnRhaW5zKHRhcmdldCkgfHwgZS5jb21wb3NlZCAmJiBlLmNvbXBvc2VkUGF0aCgpLnNoaWZ0KCkgPT09IGV2ZW50VGFyZ2V0O1xuICAgICAgICAgICAgfTsgLy8gSW4gdGhlIGNhc2Ugb2YgdG91Y2hzdGFydCBldmVudHMsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXJlIGlzIHN0aWxsIG5vIG1vcmUgdGhhbiBvbmVcbiAgICAgICAgICAgIC8vIHRvdWNoIG9uIHRoZSB0YXJnZXQgc28gd2UgbG9vayBhbW9uZ3N0IGFsbCB0b3VjaGVzLlxuXG5cbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiKSB7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXRUb3VjaGVzID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGUudG91Y2hlcywgaXNUb3VjaE9uVGFyZ2V0KTsgLy8gRG8gbm90IHN1cHBvcnQgbW9yZSB0aGFuIG9uZSB0b3VjaCBwZXIgaGFuZGxlLlxuXG4gICAgICAgICAgICAgIGlmICh0YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB4ID0gdGFyZ2V0VG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgICAgeSA9IHRhcmdldFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJbiB0aGUgb3RoZXIgY2FzZXMsIGZpbmQgb24gY2hhbmdlZFRvdWNoZXMgaXMgZW5vdWdoLlxuICAgICAgICAgICAgICB2YXIgdGFyZ2V0VG91Y2ggPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGUuY2hhbmdlZFRvdWNoZXMsIGlzVG91Y2hPblRhcmdldCk7IC8vIENhbmNlbCBpZiB0aGUgdGFyZ2V0IHRvdWNoIGhhcyBub3QgbW92ZWQuXG5cbiAgICAgICAgICAgICAgaWYgKCF0YXJnZXRUb3VjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHggPSB0YXJnZXRUb3VjaC5wYWdlWDtcbiAgICAgICAgICAgICAgeSA9IHRhcmdldFRvdWNoLnBhZ2VZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhZ2VPZmZzZXQgPSBwYWdlT2Zmc2V0IHx8IGdldFBhZ2VPZmZzZXQoc2NvcGVfRG9jdW1lbnQpO1xuXG4gICAgICAgICAgaWYgKG1vdXNlIHx8IHBvaW50ZXIpIHtcbiAgICAgICAgICAgIHggPSBlLmNsaWVudFggKyBwYWdlT2Zmc2V0Lng7XG4gICAgICAgICAgICB5ID0gZS5jbGllbnRZICsgcGFnZU9mZnNldC55O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUucGFnZU9mZnNldCA9IHBhZ2VPZmZzZXQ7XG4gICAgICAgICAgZS5wb2ludHMgPSBbeCwgeV07XG4gICAgICAgICAgZS5jdXJzb3IgPSBtb3VzZSB8fCBwb2ludGVyOyAvLyBGaXggIzQzNVxuXG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0gLy8gVHJhbnNsYXRlIGEgY29vcmRpbmF0ZSBpbiB0aGUgZG9jdW1lbnQgdG8gYSBwZXJjZW50YWdlIG9uIHRoZSBzbGlkZXJcblxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGNQb2ludFRvUGVyY2VudGFnZShjYWxjUG9pbnQpIHtcbiAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjYWxjUG9pbnQgLSBvZmZzZXQoc2NvcGVfQmFzZSwgb3B0aW9ucy5vcnQpO1xuICAgICAgICAgIHZhciBwcm9wb3NhbCA9IGxvY2F0aW9uICogMTAwIC8gYmFzZVNpemUoKTsgLy8gQ2xhbXAgcHJvcG9zYWwgYmV0d2VlbiAwJSBhbmQgMTAwJVxuICAgICAgICAgIC8vIE91dC1vZi1ib3VuZCBjb29yZGluYXRlcyBtYXkgb2NjdXIgd2hlbiAubm9VaS1iYXNlIHBzZXVkby1lbGVtZW50c1xuICAgICAgICAgIC8vIGFyZSB1c2VkIChlLmcuIGNvbnRhaW5lZCBoYW5kbGVzIGZlYXR1cmUpXG5cbiAgICAgICAgICBwcm9wb3NhbCA9IGxpbWl0KHByb3Bvc2FsKTtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBwcm9wb3NhbCA6IHByb3Bvc2FsO1xuICAgICAgICB9IC8vIEZpbmQgaGFuZGxlIGNsb3Nlc3QgdG8gYSBjZXJ0YWluIHBlcmNlbnRhZ2Ugb24gdGhlIHNsaWRlclxuXG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShjbGlja2VkUG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgc21hbGxlc3REaWZmZXJlbmNlID0gMTAwO1xuICAgICAgICAgIHZhciBoYW5kbGVOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIERpc2FibGVkIGhhbmRsZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgIGlmIChpc0hhbmRsZURpc2FibGVkKGluZGV4KSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoYW5kbGVQb3NpdGlvbiA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgZGlmZmVyZW5jZVdpdGhUaGlzSGFuZGxlID0gTWF0aC5hYnMoaGFuZGxlUG9zaXRpb24gLSBjbGlja2VkUG9zaXRpb24pOyAvLyBJbml0aWFsIHN0YXRlXG5cbiAgICAgICAgICAgIHZhciBjbGlja0F0RWRnZSA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA9PT0gMTAwICYmIHNtYWxsZXN0RGlmZmVyZW5jZSA9PT0gMTAwOyAvLyBEaWZmZXJlbmNlIHdpdGggdGhpcyBoYW5kbGUgaXMgc21hbGxlciB0aGFuIHRoZSBwcmV2aW91c2x5IGNoZWNrZWQgaGFuZGxlXG5cbiAgICAgICAgICAgIHZhciBpc0Nsb3NlciA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA8IHNtYWxsZXN0RGlmZmVyZW5jZTtcbiAgICAgICAgICAgIHZhciBpc0Nsb3NlckFmdGVyID0gZGlmZmVyZW5jZVdpdGhUaGlzSGFuZGxlIDw9IHNtYWxsZXN0RGlmZmVyZW5jZSAmJiBjbGlja2VkUG9zaXRpb24gPiBoYW5kbGVQb3NpdGlvbjtcblxuICAgICAgICAgICAgaWYgKGlzQ2xvc2VyIHx8IGlzQ2xvc2VyQWZ0ZXIgfHwgY2xpY2tBdEVkZ2UpIHtcbiAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyID0gaW5kZXg7XG4gICAgICAgICAgICAgIHNtYWxsZXN0RGlmZmVyZW5jZSA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlTnVtYmVyO1xuICAgICAgICB9IC8vIEZpcmUgJ2VuZCcgd2hlbiBhIG1vdXNlIG9yIHBlbiBsZWF2ZXMgdGhlIGRvY3VtZW50LlxuXG5cbiAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRMZWF2ZShldmVudCwgZGF0YSkge1xuICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBcIm1vdXNlb3V0XCIgJiYgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkhUTUxcIiAmJiBldmVudC5yZWxhdGVkVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudEVuZChldmVudCwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEhhbmRsZSBtb3ZlbWVudCBvbiBkb2N1bWVudCBmb3IgaGFuZGxlIGFuZCByYW5nZSBkcmFnLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRNb3ZlKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgLy8gRml4ICM0OThcbiAgICAgICAgICAvLyBDaGVjayB2YWx1ZSBvZiAuYnV0dG9ucyBpbiAnc3RhcnQnIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFMTAgbW9iaWxlIChkYXRhLmJ1dHRvbnNQcm9wZXJ0eSkuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy85MjcwMDUvbW9iaWxlLWllMTAtd2luZG93cy1waG9uZS1idXR0b25zLXByb3BlcnR5LW9mLXBvaW50ZXJtb3ZlLWV2ZW50LWFsd2F5cy16ZXJvXG4gICAgICAgICAgLy8gSUU5IGhhcyAuYnV0dG9ucyBhbmQgLndoaWNoIHplcm8gb24gbW91c2Vtb3ZlLlxuICAgICAgICAgIC8vIEZpcmVmb3ggYnJlYWtzIHRoZSBzcGVjIE1ETiBkZWZpbmVzLlxuICAgICAgICAgIGlmIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKFwiTVNJRSA5XCIpID09PSAtMSAmJiBldmVudC5idXR0b25zID09PSAwICYmIGRhdGEuYnV0dG9uc1Byb3BlcnR5ICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRFbmQoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgIH0gLy8gQ2hlY2sgaWYgd2UgYXJlIG1vdmluZyB1cCBvciBkb3duXG5cblxuICAgICAgICAgIHZhciBtb3ZlbWVudCA9IChvcHRpb25zLmRpciA/IC0xIDogMSkgKiAoZXZlbnQuY2FsY1BvaW50IC0gZGF0YS5zdGFydENhbGNQb2ludCk7IC8vIENvbnZlcnQgdGhlIG1vdmVtZW50IGludG8gYSBwZXJjZW50YWdlIG9mIHRoZSBzbGlkZXIgd2lkdGgvaGVpZ2h0XG5cbiAgICAgICAgICB2YXIgcHJvcG9zYWwgPSBtb3ZlbWVudCAqIDEwMCAvIGRhdGEuYmFzZVNpemU7XG4gICAgICAgICAgbW92ZUhhbmRsZXMobW92ZW1lbnQgPiAwLCBwcm9wb3NhbCwgZGF0YS5sb2NhdGlvbnMsIGRhdGEuaGFuZGxlTnVtYmVycywgZGF0YS5jb25uZWN0KTtcbiAgICAgICAgfSAvLyBVbmJpbmQgbW92ZSBldmVudHMgb24gZG9jdW1lbnQsIGNhbGwgY2FsbGJhY2tzLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRFbmQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAvLyBUaGUgaGFuZGxlIGlzIG5vIGxvbmdlciBhY3RpdmUsIHNvIHJlbW92ZSB0aGUgY2xhc3MuXG4gICAgICAgICAgaWYgKGRhdGEuaGFuZGxlKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhkYXRhLmhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XG4gICAgICAgICAgICBzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgLT0gMTtcbiAgICAgICAgICB9IC8vIFVuYmluZCB0aGUgbW92ZSBhbmQgZW5kIGV2ZW50cywgd2hpY2ggYXJlIGFkZGVkIG9uICdzdGFydCcuXG5cblxuICAgICAgICAgIGRhdGEubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHNjb3BlX0RvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNbMF0sIGNbMV0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGRyYWdnaW5nIGNsYXNzLlxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZyk7XG4gICAgICAgICAgICBzZXRaaW5kZXgoKTsgLy8gUmVtb3ZlIGN1cnNvciBzdHlsZXMgYW5kIHRleHQtc2VsZWN0aW9uIGV2ZW50cyBib3VuZCB0byB0aGUgYm9keS5cblxuICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xuICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICAgIHNjb3BlX0JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5ldmVudHMuc21vb3RoU3RlcHMpIHtcbiAgICAgICAgICAgIGRhdGEuaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0sIHRydWUsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGEuaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJjaGFuZ2VcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwiZW5kXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gQmluZCBtb3ZlIGV2ZW50cyBvbiBkb2N1bWVudC5cblxuXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50U3RhcnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgZXZlbnQgaWYgYW55IGhhbmRsZSBpcyBkaXNhYmxlZFxuICAgICAgICAgIGlmIChkYXRhLmhhbmRsZU51bWJlcnMuc29tZShpc0hhbmRsZURpc2FibGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoYW5kbGU7XG5cbiAgICAgICAgICBpZiAoZGF0YS5oYW5kbGVOdW1iZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbZGF0YS5oYW5kbGVOdW1iZXJzWzBdXTtcbiAgICAgICAgICAgIGhhbmRsZSA9IGhhbmRsZU9yaWdpbi5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCArPSAxOyAvLyBNYXJrIHRoZSBoYW5kbGUgYXMgJ2FjdGl2ZScgc28gaXQgY2FuIGJlIHN0eWxlZC5cblxuICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuYWN0aXZlKTtcbiAgICAgICAgICB9IC8vIEEgZHJhZyBzaG91bGQgbmV2ZXIgcHJvcGFnYXRlIHVwIHRvIHRoZSAndGFwJyBldmVudC5cblxuXG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFJlY29yZCB0aGUgZXZlbnQgbGlzdGVuZXJzLlxuXG4gICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdOyAvLyBBdHRhY2ggdGhlIG1vdmUgYW5kIGVuZCBldmVudHMuXG5cbiAgICAgICAgICB2YXIgbW92ZUV2ZW50ID0gYXR0YWNoRXZlbnQoYWN0aW9ucy5tb3ZlLCBzY29wZV9Eb2N1bWVudEVsZW1lbnQsIGV2ZW50TW92ZSwge1xuICAgICAgICAgICAgLy8gVGhlIGV2ZW50IHRhcmdldCBoYXMgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHByb3BhZ2F0ZSB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgd2Uga2VlcFxuICAgICAgICAgICAgLy8gcmVseWluZyBvbiBpdCB0byBleHRyYWN0IHRhcmdldCB0b3VjaGVzLlxuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgICAgIGNvbm5lY3Q6IGRhdGEuY29ubmVjdCxcbiAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgc3RhcnRDYWxjUG9pbnQ6IGV2ZW50LmNhbGNQb2ludCxcbiAgICAgICAgICAgIGJhc2VTaXplOiBiYXNlU2l6ZSgpLFxuICAgICAgICAgICAgcGFnZU9mZnNldDogZXZlbnQucGFnZU9mZnNldCxcbiAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVycyxcbiAgICAgICAgICAgIGJ1dHRvbnNQcm9wZXJ0eTogZXZlbnQuYnV0dG9ucyxcbiAgICAgICAgICAgIGxvY2F0aW9uczogc2NvcGVfTG9jYXRpb25zLnNsaWNlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBhdHRhY2hFdmVudChhY3Rpb25zLmVuZCwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBldmVudEVuZCwge1xuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXG4gICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgb3V0RXZlbnQgPSBhdHRhY2hFdmVudChcIm1vdXNlb3V0XCIsIHNjb3BlX0RvY3VtZW50RWxlbWVudCwgZG9jdW1lbnRMZWF2ZSwge1xuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXG4gICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcbiAgICAgICAgICB9KTsgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgcHVzaGVkIHRoZSBsaXN0ZW5lcnMgaW4gdGhlIGxpc3RlbmVyIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRpbmdcbiAgICAgICAgICAvLyBhIG5ldyBvbmUgYXMgaXQgaGFzIGFscmVhZHkgYmVlbiBwYXNzZWQgdG8gdGhlIGV2ZW50IGhhbmRsZXJzLlxuXG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2guYXBwbHkobGlzdGVuZXJzLCBtb3ZlRXZlbnQuY29uY2F0KGVuZEV2ZW50LCBvdXRFdmVudCkpOyAvLyBUZXh0IHNlbGVjdGlvbiBpc24ndCBhbiBpc3N1ZSBvbiB0b3VjaCBkZXZpY2VzLFxuICAgICAgICAgIC8vIHNvIGFkZGluZyBjdXJzb3Igc3R5bGVzIGNhbiBiZSBza2lwcGVkLlxuXG4gICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xuICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgJ0knIGN1cnNvciBhbmQgZXh0ZW5kIHRoZSByYW5nZS1kcmFnIGN1cnNvci5cbiAgICAgICAgICAgIHNjb3BlX0JvZHkuc3R5bGUuY3Vyc29yID0gZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjsgLy8gTWFyayB0aGUgdGFyZ2V0IHdpdGggYSBkcmFnZ2luZyBzdGF0ZS5cblxuICAgICAgICAgICAgaWYgKHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBhZGRDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnKTtcbiAgICAgICAgICAgIH0gLy8gUHJldmVudCB0ZXh0IHNlbGVjdGlvbiB3aGVuIGRyYWdnaW5nIHRoZSBoYW5kbGVzLlxuICAgICAgICAgICAgLy8gSW4gbm9VaVNsaWRlciA8PSA5LjIuMCwgdGhpcyB3YXMgaGFuZGxlZCBieSBjYWxsaW5nIHByZXZlbnREZWZhdWx0IG9uIG1vdXNlL3RvdWNoIHN0YXJ0L21vdmUsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBzY3JvbGwgYmxvY2tpbmcuIFRoZSBzZWxlY3RzdGFydCBldmVudCBpcyBzdXBwb3J0ZWQgYnkgRmlyZUZveCBzdGFydGluZyBmcm9tIHZlcnNpb24gNTIsXG4gICAgICAgICAgICAvLyBtZWFuaW5nIHRoZSBvbmx5IGhvbGRvdXQgaXMgaU9TIFNhZmFyaS4gVGhpcyBkb2Vzbid0IG1hdHRlcjogdGV4dCBzZWxlY3Rpb24gaXNuJ3QgdHJpZ2dlcmVkIHRoZXJlLlxuICAgICAgICAgICAgLy8gVGhlICdjdXJzb3InIGZsYWcgaXMgZmFsc2UuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXNlbGVjdHN0YXJ0XG5cblxuICAgICAgICAgICAgc2NvcGVfQm9keS5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgcHJldmVudERlZmF1bHQsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJzdGFydFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIE1vdmUgY2xvc2VzdCBoYW5kbGUgdG8gdGFwcGVkIGxvY2F0aW9uLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRUYXAoZXZlbnQpIHtcbiAgICAgICAgICAvLyBUaGUgdGFwIGV2ZW50IHNob3VsZG4ndCBwcm9wYWdhdGUgdXBcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB2YXIgcHJvcG9zYWwgPSBjYWxjUG9pbnRUb1BlcmNlbnRhZ2UoZXZlbnQuY2FsY1BvaW50KTtcbiAgICAgICAgICB2YXIgaGFuZGxlTnVtYmVyID0gZ2V0Q2xvc2VzdEhhbmRsZShwcm9wb3NhbCk7IC8vIFRhY2tsZSB0aGUgY2FzZSB0aGF0IGFsbCBoYW5kbGVzIGFyZSAnZGlzYWJsZWQnLlxuXG4gICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIEZsYWcgdGhlIHNsaWRlciBhcyBpdCBpcyBub3cgaW4gYSB0cmFuc2l0aW9uYWwgc3RhdGUuXG4gICAgICAgICAgLy8gVHJhbnNpdGlvbiB0YWtlcyBhIGNvbmZpZ3VyYWJsZSBhbW91bnQgb2YgbXMgKGRlZmF1bHQgMzAwKS4gUmUtZW5hYmxlIHRoZSBzbGlkZXIgYWZ0ZXIgdGhhdC5cblxuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICBhZGRDbGFzc0ZvcihzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXAsIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHByb3Bvc2FsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBzZXRaaW5kZXgoKTtcbiAgICAgICAgICBmaXJlRXZlbnQoXCJzbGlkZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJjaGFuZ2VcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldmVudFN0YXJ0KGV2ZW50LCB7XG4gICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IFtoYW5kbGVOdW1iZXJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRmlyZXMgYSAnaG92ZXInIGV2ZW50IGZvciBhIGhvdmVyZWQgbW91c2UvcGVuIHBvc2l0aW9uLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRIb3ZlcihldmVudCkge1xuICAgICAgICAgIHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xuICAgICAgICAgIHZhciB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAocHJvcG9zYWwpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XG4gICAgICAgICAgT2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXRFdmVudCkge1xuICAgICAgICAgICAgaWYgKFwiaG92ZXJcIiA9PT0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdKSB7XG4gICAgICAgICAgICAgIHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjb3BlX1NlbGYsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gSGFuZGxlcyBrZXlkb3duIG9uIGZvY3VzZWQgaGFuZGxlc1xuICAgICAgICAvLyBEb24ndCBtb3ZlIHRoZSBkb2N1bWVudCB3aGVuIHByZXNzaW5nIGFycm93IGtleXMgb24gZm9jdXNlZCBoYW5kbGVzXG5cblxuICAgICAgICBmdW5jdGlvbiBldmVudEtleWRvd24oZXZlbnQsIGhhbmRsZU51bWJlcikge1xuICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgfHwgaXNIYW5kbGVEaXNhYmxlZChoYW5kbGVOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhvcml6b250YWxLZXlzID0gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdO1xuICAgICAgICAgIHZhciB2ZXJ0aWNhbEtleXMgPSBbXCJEb3duXCIsIFwiVXBcIl07XG4gICAgICAgICAgdmFyIGxhcmdlU3RlcEtleXMgPSBbXCJQYWdlRG93blwiLCBcIlBhZ2VVcFwiXTtcbiAgICAgICAgICB2YXIgZWRnZUtleXMgPSBbXCJIb21lXCIsIFwiRW5kXCJdO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyICYmICFvcHRpb25zLm9ydCkge1xuICAgICAgICAgICAgLy8gT24gYW4gcmlnaHQtdG8tbGVmdCBzbGlkZXIsIHRoZSBsZWZ0IGFuZCByaWdodCBrZXlzIGFjdCBpbnZlcnRlZFxuICAgICAgICAgICAgaG9yaXpvbnRhbEtleXMucmV2ZXJzZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vcnQgJiYgIW9wdGlvbnMuZGlyKSB7XG4gICAgICAgICAgICAvLyBPbiBhIHRvcC10by1ib3R0b20gc2xpZGVyLCB0aGUgdXAgYW5kIGRvd24ga2V5cyBhY3QgaW52ZXJ0ZWRcbiAgICAgICAgICAgIHZlcnRpY2FsS2V5cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsYXJnZVN0ZXBLZXlzLnJldmVyc2UoKTtcbiAgICAgICAgICB9IC8vIFN0cmlwIFwiQXJyb3dcIiBmb3IgSUUgY29tcGF0aWJpbGl0eS4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5XG5cblxuICAgICAgICAgIHZhciBrZXkgPSBldmVudC5rZXkucmVwbGFjZShcIkFycm93XCIsIFwiXCIpO1xuICAgICAgICAgIHZhciBpc0xhcmdlRG93biA9IGtleSA9PT0gbGFyZ2VTdGVwS2V5c1swXTtcbiAgICAgICAgICB2YXIgaXNMYXJnZVVwID0ga2V5ID09PSBsYXJnZVN0ZXBLZXlzWzFdO1xuICAgICAgICAgIHZhciBpc0Rvd24gPSBrZXkgPT09IHZlcnRpY2FsS2V5c1swXSB8fCBrZXkgPT09IGhvcml6b250YWxLZXlzWzBdIHx8IGlzTGFyZ2VEb3duO1xuICAgICAgICAgIHZhciBpc1VwID0ga2V5ID09PSB2ZXJ0aWNhbEtleXNbMV0gfHwga2V5ID09PSBob3Jpem9udGFsS2V5c1sxXSB8fCBpc0xhcmdlVXA7XG4gICAgICAgICAgdmFyIGlzTWluID0ga2V5ID09PSBlZGdlS2V5c1swXTtcbiAgICAgICAgICB2YXIgaXNNYXggPSBrZXkgPT09IGVkZ2VLZXlzWzFdO1xuXG4gICAgICAgICAgaWYgKCFpc0Rvd24gJiYgIWlzVXAgJiYgIWlzTWluICYmICFpc01heCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgdG87XG5cbiAgICAgICAgICBpZiAoaXNVcCB8fCBpc0Rvd24pIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBpc0Rvd24gPyAwIDogMTtcbiAgICAgICAgICAgIHZhciBzdGVwcyA9IGdldE5leHRTdGVwc0ZvckhhbmRsZShoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBzdGVwc1tkaXJlY3Rpb25dOyAvLyBBdCB0aGUgZWRnZSBvZiBhIHNsaWRlciwgZG8gbm90aGluZ1xuXG4gICAgICAgICAgICBpZiAoc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IC8vIE5vIHN0ZXAgc2V0LCB1c2UgdGhlIGRlZmF1bHQgb2YgMTAlIG9mIHRoZSBzdWItcmFuZ2VcblxuXG4gICAgICAgICAgICBpZiAoc3RlcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc3RlcCA9IHNjb3BlX1NwZWN0cnVtLmdldERlZmF1bHRTdGVwKHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdLCBpc0Rvd24sIG9wdGlvbnMua2V5Ym9hcmREZWZhdWx0U3RlcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0xhcmdlVXAgfHwgaXNMYXJnZURvd24pIHtcbiAgICAgICAgICAgICAgc3RlcCAqPSBvcHRpb25zLmtleWJvYXJkUGFnZU11bHRpcGxpZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGVwICo9IG9wdGlvbnMua2V5Ym9hcmRNdWx0aXBsaWVyO1xuICAgICAgICAgICAgfSAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcblxuXG4gICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoc3RlcCwgMC4wMDAwMDAxKTsgLy8gRGVjcmVtZW50IGZvciBkb3duIHN0ZXBzXG5cbiAgICAgICAgICAgIHN0ZXAgPSAoaXNEb3duID8gLTEgOiAxKSAqIHN0ZXA7XG4gICAgICAgICAgICB0byA9IHNjb3BlX1ZhbHVlc1toYW5kbGVOdW1iZXJdICsgc3RlcDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF4KSB7XG4gICAgICAgICAgICAvLyBFbmQga2V5XG4gICAgICAgICAgICB0byA9IG9wdGlvbnMuc3BlY3RydW0ueFZhbFtvcHRpb25zLnNwZWN0cnVtLnhWYWwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhvbWUga2V5XG4gICAgICAgICAgICB0byA9IG9wdGlvbnMuc3BlY3RydW0ueFZhbFswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHRvKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgZmlyZUV2ZW50KFwic2xpZGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICBmaXJlRXZlbnQoXCJjaGFuZ2VcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gQXR0YWNoIGV2ZW50cyB0byBzZXZlcmFsIHNsaWRlciBwYXJ0cy5cblxuXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRTbGlkZXJFdmVudHMoYmVoYXZpb3VyKSB7XG4gICAgICAgICAgLy8gQXR0YWNoIHRoZSBzdGFuZGFyZCBkcmFnIGV2ZW50IHRvIHRoZSBoYW5kbGVzLlxuICAgICAgICAgIGlmICghYmVoYXZpb3VyLmZpeGVkKSB7XG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGFyZSBvbmx5IGJvdW5kIHRvIHRoZSB2aXN1YWwgaGFuZGxlXG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQsIG5vdCB0aGUgJ3JlYWwnIG9yaWdpbiBlbGVtZW50LlxuICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBoYW5kbGUuY2hpbGRyZW5bMF0sIGV2ZW50U3RhcnQsIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBbaW5kZXhdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBBdHRhY2ggdGhlIHRhcCBldmVudCB0byB0aGUgc2xpZGVyIGJhc2UuXG5cblxuICAgICAgICAgIGlmIChiZWhhdmlvdXIudGFwKSB7XG4gICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBzY29wZV9CYXNlLCBldmVudFRhcCwge30pO1xuICAgICAgICAgIH0gLy8gRmlyZSBob3ZlciBldmVudHNcblxuXG4gICAgICAgICAgaWYgKGJlaGF2aW91ci5ob3Zlcikge1xuICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5tb3ZlLCBzY29wZV9CYXNlLCBldmVudEhvdmVyLCB7XG4gICAgICAgICAgICAgIGhvdmVyOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIE1ha2UgdGhlIHJhbmdlIGRyYWdnYWJsZS5cblxuXG4gICAgICAgICAgaWYgKGJlaGF2aW91ci5kcmFnKSB7XG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb25uZWN0LCBpbmRleCkge1xuICAgICAgICAgICAgICBpZiAoY29ubmVjdCA9PT0gZmFsc2UgfHwgaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHNjb3BlX0Nvbm5lY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaGFuZGxlQmVmb3JlID0gc2NvcGVfSGFuZGxlc1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgICB2YXIgaGFuZGxlQWZ0ZXIgPSBzY29wZV9IYW5kbGVzW2luZGV4XTtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50SG9sZGVycyA9IFtjb25uZWN0XTtcbiAgICAgICAgICAgICAgdmFyIGhhbmRsZXNUb0RyYWcgPSBbaGFuZGxlQmVmb3JlLCBoYW5kbGVBZnRlcl07XG4gICAgICAgICAgICAgIHZhciBoYW5kbGVOdW1iZXJzVG9EcmFnID0gW2luZGV4IC0gMSwgaW5kZXhdO1xuICAgICAgICAgICAgICBhZGRDbGFzcyhjb25uZWN0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZ2dhYmxlKTsgLy8gV2hlbiB0aGUgcmFuZ2UgaXMgZml4ZWQsIHRoZSBlbnRpcmUgcmFuZ2UgY2FuXG4gICAgICAgICAgICAgIC8vIGJlIGRyYWdnZWQgYnkgdGhlIGhhbmRsZXMuIFRoZSBoYW5kbGUgaW4gdGhlIGZpcnN0XG4gICAgICAgICAgICAgIC8vIG9yaWdpbiB3aWxsIHByb3BhZ2F0ZSB0aGUgc3RhcnQgZXZlbnQgdXB3YXJkLFxuICAgICAgICAgICAgICAvLyBidXQgaXQgbmVlZHMgdG8gYmUgYm91bmQgbWFudWFsbHkgb24gdGhlIG90aGVyLlxuXG4gICAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuZml4ZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudEhvbGRlcnMucHVzaChoYW5kbGVCZWZvcmUuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVycy5wdXNoKGhhbmRsZUFmdGVyLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuZHJhZ0FsbCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXNUb0RyYWcgPSBzY29wZV9IYW5kbGVzO1xuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnNUb0RyYWcgPSBzY29wZV9IYW5kbGVOdW1iZXJzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgZXZlbnRIb2xkZXIsIGV2ZW50U3RhcnQsIHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZXM6IGhhbmRsZXNUb0RyYWcsXG4gICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBoYW5kbGVOdW1iZXJzVG9EcmFnLFxuICAgICAgICAgICAgICAgICAgY29ubmVjdDogY29ubmVjdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBBdHRhY2ggYW4gZXZlbnQgdG8gdGhpcyBzbGlkZXIsIHBvc3NpYmx5IGluY2x1ZGluZyBhIG5hbWVzcGFjZVxuXG5cbiAgICAgICAgZnVuY3Rpb24gYmluZEV2ZW50KG5hbWVzcGFjZWRFdmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XSA9IHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdIHx8IFtdO1xuICAgICAgICAgIHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdLnB1c2goY2FsbGJhY2spOyAvLyBJZiB0aGUgZXZlbnQgYm91bmQgaXMgJ3VwZGF0ZSwnIGZpcmUgaXQgaW1tZWRpYXRlbHkgZm9yIGFsbCBoYW5kbGVzLlxuXG4gICAgICAgICAgaWYgKG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF0gPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbiAoYSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzSW50ZXJuYWxOYW1lc3BhY2UobmFtZXNwYWNlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gSU5URVJOQUxfRVZFTlRfTlMuYXJpYSB8fCBuYW1lc3BhY2UgPT09IElOVEVSTkFMX0VWRU5UX05TLnRvb2x0aXBzO1xuICAgICAgICB9IC8vIFVuZG8gYXR0YWNobWVudCBvZiBldmVudFxuXG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnQobmFtZXNwYWNlZEV2ZW50KSB7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gbmFtZXNwYWNlZEV2ZW50ICYmIG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF07XG4gICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGV2ZW50ID8gbmFtZXNwYWNlZEV2ZW50LnN1YnN0cmluZyhldmVudC5sZW5ndGgpIDogbmFtZXNwYWNlZEV2ZW50O1xuICAgICAgICAgIE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoYmluZCkge1xuICAgICAgICAgICAgdmFyIHRFdmVudCA9IGJpbmQuc3BsaXQoXCIuXCIpWzBdO1xuICAgICAgICAgICAgdmFyIHROYW1lc3BhY2UgPSBiaW5kLnN1YnN0cmluZyh0RXZlbnQubGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKCghZXZlbnQgfHwgZXZlbnQgPT09IHRFdmVudCkgJiYgKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSB0TmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgICAvLyBvbmx5IGRlbGV0ZSBwcm90ZWN0ZWQgaW50ZXJuYWwgZXZlbnQgaWYgaW50ZW50aW9uYWxcbiAgICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsTmFtZXNwYWNlKHROYW1lc3BhY2UpIHx8IG5hbWVzcGFjZSA9PT0gdE5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY29wZV9FdmVudHNbYmluZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBFeHRlcm5hbCBldmVudCBoYW5kbGluZ1xuXG5cbiAgICAgICAgZnVuY3Rpb24gZmlyZUV2ZW50KGV2ZW50TmFtZSwgaGFuZGxlTnVtYmVyLCB0YXApIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldEV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgc2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoIC8vIFVzZSB0aGUgc2xpZGVyIHB1YmxpYyBBUEkgYXMgdGhlIHNjb3BlICgndGhpcycpXG4gICAgICAgICAgICAgICAgc2NvcGVfU2VsZiwgLy8gUmV0dXJuIHZhbHVlcyBhcyBhcnJheSwgc28gYXJnXzFbYXJnXzJdIGlzIGFsd2F5cyB2YWxpZC5cbiAgICAgICAgICAgICAgICBzY29wZV9WYWx1ZXMubWFwKG9wdGlvbnMuZm9ybWF0LnRvKSwgLy8gSGFuZGxlIGluZGV4LCAwIG9yIDFcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXIsIC8vIFVuLWZvcm1hdHRlZCBzbGlkZXIgdmFsdWVzXG4gICAgICAgICAgICAgICAgc2NvcGVfVmFsdWVzLnNsaWNlKCksIC8vIEV2ZW50IGlzIGZpcmVkIGJ5IHRhcCwgdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgICAgICAgIHRhcCB8fCBmYWxzZSwgLy8gTGVmdCBvZmZzZXQgb2YgdGhlIGhhbmRsZSwgaW4gcmVsYXRpb24gdG8gdGhlIHNsaWRlclxuICAgICAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpLCAvLyBhZGQgdGhlIHNsaWRlciBwdWJsaWMgQVBJIHRvIGFuIGFjY2Vzc2libGUgcGFyYW1ldGVyIHdoZW4gdGhpcyBpcyB1bmF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIHNjb3BlX1NlbGYpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBTcGxpdCBvdXQgdGhlIGhhbmRsZSBwb3NpdGlvbmluZyBsb2dpYyBzbyB0aGUgTW92ZSBldmVudCBjYW4gdXNlIGl0LCB0b29cblxuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrSGFuZGxlUG9zaXRpb24ocmVmZXJlbmNlLCBoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkLCBnZXRWYWx1ZSwgc21vb3RoU3RlcHMpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2U7IC8vIEZvciBzbGlkZXJzIHdpdGggbXVsdGlwbGUgaGFuZGxlcywgbGltaXQgbW92ZW1lbnQgdG8gdGhlIG90aGVyIGhhbmRsZS5cbiAgICAgICAgICAvLyBBcHBseSB0aGUgbWFyZ2luIG9wdGlvbiBieSBhZGRpbmcgaXQgdG8gdGhlIGhhbmRsZSBwb3NpdGlvbnMuXG5cbiAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmICFvcHRpb25zLmV2ZW50cy51bmNvbnN0cmFpbmVkKSB7XG4gICAgICAgICAgICBpZiAobG9va0JhY2t3YXJkICYmIGhhbmRsZU51bWJlciA+IDApIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSwgb3B0aW9ucy5tYXJnaW4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9va0ZvcndhcmQgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gc2NvcGVfU3BlY3RydW0uZ2V0QWJzb2x1dGVEaXN0YW5jZShyZWZlcmVuY2VbaGFuZGxlTnVtYmVyICsgMV0sIG9wdGlvbnMubWFyZ2luLCB0cnVlKTtcbiAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gVGhlIGxpbWl0IG9wdGlvbiBoYXMgdGhlIG9wcG9zaXRlIGVmZmVjdCwgbGltaXRpbmcgaGFuZGxlcyB0byBhXG4gICAgICAgICAgLy8gbWF4aW11bSBkaXN0YW5jZSBmcm9tIGFub3RoZXIuIExpbWl0IG11c3QgYmUgPiAwLCBhcyBvdGhlcndpc2VcbiAgICAgICAgICAvLyBoYW5kbGVzIHdvdWxkIGJlIHVubW92YWJsZS5cblxuXG4gICAgICAgICAgaWYgKHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSAmJiBvcHRpb25zLmxpbWl0KSB7XG4gICAgICAgICAgICBpZiAobG9va0JhY2t3YXJkICYmIGhhbmRsZU51bWJlciA+IDApIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSwgb3B0aW9ucy5saW1pdCwgZmFsc2UpO1xuICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSwgb3B0aW9ucy5saW1pdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFRoZSBwYWRkaW5nIG9wdGlvbiBrZWVwcyB0aGUgaGFuZGxlcyBhIGNlcnRhaW4gZGlzdGFuY2UgZnJvbSB0aGVcbiAgICAgICAgICAvLyBlZGdlcyBvZiB0aGUgc2xpZGVyLiBQYWRkaW5nIG11c3QgYmUgPiAwLlxuXG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gc2NvcGVfU3BlY3RydW0uZ2V0QWJzb2x1dGVEaXN0YW5jZSgwLCBvcHRpb25zLnBhZGRpbmdbMF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKDEwMCwgb3B0aW9ucy5wYWRkaW5nWzFdLCB0cnVlKTtcbiAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghc21vb3RoU3RlcHMpIHtcbiAgICAgICAgICAgIHRvID0gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCh0byk7XG4gICAgICAgICAgfSAvLyBMaW1pdCBwZXJjZW50YWdlIHRvIHRoZSAwIC0gMTAwIHJhbmdlXG5cblxuICAgICAgICAgIHRvID0gbGltaXQodG8pOyAvLyBSZXR1cm4gZmFsc2UgaWYgaGFuZGxlIGNhbid0IG1vdmVcblxuICAgICAgICAgIGlmICh0byA9PT0gcmVmZXJlbmNlW2hhbmRsZU51bWJlcl0gJiYgIWdldFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9IC8vIFVzZXMgc2xpZGVyIG9yaWVudGF0aW9uIHRvIGNyZWF0ZSBDU1MgcnVsZXMuIGEgPSBiYXNlIHZhbHVlO1xuXG5cbiAgICAgICAgZnVuY3Rpb24gaW5SdWxlT3JkZXIodiwgYSkge1xuICAgICAgICAgIHZhciBvID0gb3B0aW9ucy5vcnQ7XG4gICAgICAgICAgcmV0dXJuIChvID8gYSA6IHYpICsgXCIsIFwiICsgKG8gPyB2IDogYSk7XG4gICAgICAgIH0gLy8gTW92ZXMgaGFuZGxlKHMpIGJ5IGEgcGVyY2VudGFnZVxuICAgICAgICAvLyAoYm9vbCwgJSB0byBtb3ZlLCBbJSB3aGVyZSBoYW5kbGUgc3RhcnRlZCwgLi4uXSwgW2luZGV4IGluIHNjb3BlX0hhbmRsZXMsIC4uLl0pXG5cblxuICAgICAgICBmdW5jdGlvbiBtb3ZlSGFuZGxlcyh1cHdhcmQsIHByb3Bvc2FsLCBsb2NhdGlvbnMsIGhhbmRsZU51bWJlcnMsIGNvbm5lY3QpIHtcbiAgICAgICAgICB2YXIgcHJvcG9zYWxzID0gbG9jYXRpb25zLnNsaWNlKCk7IC8vIFN0b3JlIGZpcnN0IGhhbmRsZSBub3csIHNvIHdlIHN0aWxsIGhhdmUgaXQgaW4gY2FzZSBoYW5kbGVOdW1iZXJzIGlzIHJldmVyc2VkXG5cbiAgICAgICAgICB2YXIgZmlyc3RIYW5kbGUgPSBoYW5kbGVOdW1iZXJzWzBdO1xuICAgICAgICAgIHZhciBzbW9vdGhTdGVwcyA9IG9wdGlvbnMuZXZlbnRzLnNtb290aFN0ZXBzO1xuICAgICAgICAgIHZhciBiID0gWyF1cHdhcmQsIHVwd2FyZF07XG4gICAgICAgICAgdmFyIGYgPSBbdXB3YXJkLCAhdXB3YXJkXTsgLy8gQ29weSBoYW5kbGVOdW1iZXJzIHNvIHdlIGRvbid0IGNoYW5nZSB0aGUgZGF0YXNldFxuXG4gICAgICAgICAgaGFuZGxlTnVtYmVycyA9IGhhbmRsZU51bWJlcnMuc2xpY2UoKTsgLy8gQ2hlY2sgdG8gc2VlIHdoaWNoIGhhbmRsZSBpcyAnbGVhZGluZycuXG4gICAgICAgICAgLy8gSWYgdGhhdCBvbmUgY2FuJ3QgbW92ZSB0aGUgc2Vjb25kIGNhbid0IGVpdGhlci5cblxuICAgICAgICAgIGlmICh1cHdhcmQpIHtcbiAgICAgICAgICAgIGhhbmRsZU51bWJlcnMucmV2ZXJzZSgpO1xuICAgICAgICAgIH0gLy8gU3RlcCAxOiBnZXQgdGhlIG1heGltdW0gcGVyY2VudGFnZSB0aGF0IGFueSBvZiB0aGUgaGFuZGxlcyBjYW4gbW92ZVxuXG5cbiAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZU51bWJlciwgbykge1xuICAgICAgICAgICAgICB2YXIgdG8gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHByb3Bvc2FscywgaGFuZGxlTnVtYmVyLCBwcm9wb3NhbHNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLCBiW29dLCBmW29dLCBmYWxzZSwgc21vb3RoU3RlcHMpOyAvLyBTdG9wIGlmIG9uZSBvZiB0aGUgaGFuZGxlcyBjYW4ndCBtb3ZlLlxuXG4gICAgICAgICAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9wb3NhbCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcG9zYWwgPSB0byAtIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdID0gdG87XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdXNpbmcgb25lIGhhbmRsZSwgY2hlY2sgYmFja3dhcmQgQU5EIGZvcndhcmRcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGIgPSBmID0gW3RydWVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGF0ZSA9IGZhbHNlOyAvLyBTdGVwIDI6IFRyeSB0byBzZXQgdGhlIGhhbmRsZXMgd2l0aCB0aGUgZm91bmQgcGVyY2VudGFnZVxuXG4gICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIsIG8pIHtcbiAgICAgICAgICAgIHN0YXRlID0gc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgbG9jYXRpb25zW2hhbmRsZU51bWJlcl0gKyBwcm9wb3NhbCwgYltvXSwgZltvXSwgZmFsc2UsIHNtb290aFN0ZXBzKSB8fCBzdGF0ZTtcbiAgICAgICAgICB9KTsgLy8gU3RlcCAzOiBJZiBhIGhhbmRsZSBtb3ZlZCwgZmlyZSBldmVudHNcblxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9KTsgLy8gSWYgdGFyZ2V0IGlzIGEgY29ubmVjdCwgdGhlbiBmaXJlIGRyYWcgZXZlbnRcblxuICAgICAgICAgICAgaWYgKGNvbm5lY3QgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZpcmVFdmVudChcImRyYWdcIiwgZmlyc3RIYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUYWtlcyBhIGJhc2UgdmFsdWUgYW5kIGFuIG9mZnNldC4gVGhpcyBvZmZzZXQgaXMgdXNlZCBmb3IgdGhlIGNvbm5lY3QgYmFyIHNpemUuXG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIGRlc2lnbiBmb3IgdGhpcyBmZWF0dXJlLCB0aGUgb3JpZ2luIGVsZW1lbnQgd2FzIDElIHdpZGUuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIGEgcm91bmRpbmcgYnVnIGluIENocm9tZSBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGZlYXR1cmVcbiAgICAgICAgLy8gaW4gdGhpcyBtYW5uZXI6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTc5ODIyM1xuXG5cbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBhIC0gYiA6IGE7XG4gICAgICAgIH0gLy8gVXBkYXRlcyBzY29wZV9Mb2NhdGlvbnMgYW5kIHNjb3BlX1ZhbHVlcywgdXBkYXRlcyB2aXN1YWwgc3RhdGVcblxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUhhbmRsZVBvc2l0aW9uKGhhbmRsZU51bWJlciwgdG8pIHtcbiAgICAgICAgICAvLyBVcGRhdGUgbG9jYXRpb25zLlxuICAgICAgICAgIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID0gdG87IC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIHRoZSBzbGlkZXIgc3RlcHBpbmcvcmFuZ2UuXG5cbiAgICAgICAgICBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XG4gICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKHRvLCAwKSAtIHNjb3BlX0Rpck9mZnNldDtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRlUnVsZSA9IFwidHJhbnNsYXRlKFwiICsgaW5SdWxlT3JkZXIodHJhbnNsYXRpb24gKyBcIiVcIiwgXCIwXCIpICsgXCIpXCI7XG4gICAgICAgICAgc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLnN0eWxlW29wdGlvbnMudHJhbnNmb3JtUnVsZV0gPSB0cmFuc2xhdGVSdWxlO1xuICAgICAgICAgIHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICB1cGRhdGVDb25uZWN0KGhhbmRsZU51bWJlciArIDEpO1xuICAgICAgICB9IC8vIEhhbmRsZXMgYmVmb3JlIHRoZSBzbGlkZXIgbWlkZGxlIGFyZSBzdGFja2VkIGxhdGVyID0gaGlnaGVyLFxuICAgICAgICAvLyBIYW5kbGVzIGFmdGVyIHRoZSBtaWRkbGUgbGF0ZXIgaXMgbG93ZXJcbiAgICAgICAgLy8gW1s3XSBbOF0gLi4uLi4uLi4uLiB8IC4uLi4uLi4uLi4gWzVdIFs0XVxuXG5cbiAgICAgICAgZnVuY3Rpb24gc2V0WmluZGV4KCkge1xuICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgZGlyID0gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0gPiA1MCA/IC0xIDogMTtcbiAgICAgICAgICAgIHZhciB6SW5kZXggPSAzICsgKHNjb3BlX0hhbmRsZXMubGVuZ3RoICsgZGlyICogaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoekluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBUZXN0IHN1Z2dlc3RlZCB2YWx1ZXMgYW5kIGFwcGx5IG1hcmdpbiwgc3RlcC5cbiAgICAgICAgLy8gaWYgZXhhY3RJbnB1dCBpcyB0cnVlLCBkb24ndCBydW4gY2hlY2tIYW5kbGVQb3NpdGlvbiwgdGhlbiB0aGUgaGFuZGxlIGNhbiBiZSBwbGFjZWQgaW4gYmV0d2VlbiBzdGVwcyAoIzQzNilcblxuXG4gICAgICAgIGZ1bmN0aW9uIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkLCBleGFjdElucHV0LCBzbW9vdGhTdGVwcykge1xuICAgICAgICAgIGlmICghZXhhY3RJbnB1dCkge1xuICAgICAgICAgICAgdG8gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaGFuZGxlTnVtYmVyLCB0bywgbG9va0JhY2t3YXJkLCBsb29rRm9yd2FyZCwgZmFsc2UsIHNtb290aFN0ZXBzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG8gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0byk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gVXBkYXRlcyBzdHlsZSBhdHRyaWJ1dGUgZm9yIGNvbm5lY3Qgbm9kZXNcblxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3QoaW5kZXgpIHtcbiAgICAgICAgICAvLyBTa2lwIGNvbm5lY3RzIHNldCB0byBmYWxzZVxuICAgICAgICAgIGlmICghc2NvcGVfQ29ubmVjdHNbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICAgIHZhciBoID0gMTAwO1xuXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICBsID0gc2NvcGVfTG9jYXRpb25zW2luZGV4IC0gMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSBzY29wZV9Db25uZWN0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBoID0gc2NvcGVfTG9jYXRpb25zW2luZGV4XTtcbiAgICAgICAgICB9IC8vIFdlIHVzZSB0d28gcnVsZXM6XG4gICAgICAgICAgLy8gJ3RyYW5zbGF0ZScgdG8gY2hhbmdlIHRoZSBsZWZ0L3RvcCBvZmZzZXQ7XG4gICAgICAgICAgLy8gJ3NjYWxlJyB0byBjaGFuZ2UgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50O1xuICAgICAgICAgIC8vIEFzIHRoZSBlbGVtZW50IGhhcyBhIHdpZHRoIG9mIDEwMCUsIGEgdHJhbnNsYXRpb24gb2YgMTAwJSBpcyBlcXVhbCB0byAxMDAlIG9mIHRoZSBwYXJlbnQgKC5ub1VpLWJhc2UpXG5cblxuICAgICAgICAgIHZhciBjb25uZWN0V2lkdGggPSBoIC0gbDtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRlUnVsZSA9IFwidHJhbnNsYXRlKFwiICsgaW5SdWxlT3JkZXIodHJhbnNmb3JtRGlyZWN0aW9uKGwsIGNvbm5lY3RXaWR0aCkgKyBcIiVcIiwgXCIwXCIpICsgXCIpXCI7XG4gICAgICAgICAgdmFyIHNjYWxlUnVsZSA9IFwic2NhbGUoXCIgKyBpblJ1bGVPcmRlcihjb25uZWN0V2lkdGggLyAxMDAsIFwiMVwiKSArIFwiKVwiO1xuICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzW2luZGV4XS5zdHlsZVtvcHRpb25zLnRyYW5zZm9ybVJ1bGVdID0gdHJhbnNsYXRlUnVsZSArIFwiIFwiICsgc2NhbGVSdWxlO1xuICAgICAgICB9IC8vIFBhcnNlcyB2YWx1ZSBwYXNzZWQgdG8gLnNldCBtZXRob2QuIFJldHVybnMgY3VycmVudCB2YWx1ZSBpZiBub3QgcGFyc2UtYWJsZS5cblxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVUb1ZhbHVlKHRvLCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIHdpdGggbnVsbCBpbmRpY2F0ZXMgYW4gJ2lnbm9yZScuXG4gICAgICAgICAgLy8gSW5wdXR0aW5nICdmYWxzZScgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAodG8gPT09IG51bGwgfHwgdG8gPT09IGZhbHNlIHx8IHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICB9IC8vIElmIGEgZm9ybWF0dGVkIG51bWJlciB3YXMgcGFzc2VkLCBhdHRlbXB0IHRvIGRlY29kZSBpdC5cblxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdG8gPSBTdHJpbmcodG8pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvID0gb3B0aW9ucy5mb3JtYXQuZnJvbSh0byk7XG5cbiAgICAgICAgICBpZiAodG8gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodG8pO1xuICAgICAgICAgIH0gLy8gSWYgcGFyc2luZyB0aGUgbnVtYmVyIGZhaWxlZCwgdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxuXG5cbiAgICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzTmFOKHRvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfSAvLyBTZXQgdGhlIHNsaWRlciB2YWx1ZS5cblxuXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU2V0KGlucHV0LCBmaXJlU2V0RXZlbnQsIGV4YWN0SW5wdXQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzID0gYXNBcnJheShpbnB1dCk7XG4gICAgICAgICAgdmFyIGlzSW5pdCA9IHNjb3BlX0xvY2F0aW9uc1swXSA9PT0gdW5kZWZpbmVkOyAvLyBFdmVudCBmaXJlcyBieSBkZWZhdWx0XG5cbiAgICAgICAgICBmaXJlU2V0RXZlbnQgPSBmaXJlU2V0RXZlbnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmaXJlU2V0RXZlbnQ7IC8vIEFuaW1hdGlvbiBpcyBvcHRpb25hbC5cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGluaXRpYWwgdmFsdWVzIHdlcmUgc2V0IGJlZm9yZSB1c2luZyBhbmltYXRlZCBwbGFjZW1lbnQuXG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlICYmICFpc0luaXQpIHtcbiAgICAgICAgICAgIGFkZENsYXNzRm9yKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgfSAvLyBGaXJzdCBwYXNzLCB3aXRob3V0IGxvb2tBaGVhZCBidXQgd2l0aCBsb29rQmFja3dhcmQuIFZhbHVlcyBhcmUgc2V0IGZyb20gbGVmdCB0byByaWdodC5cblxuXG4gICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlc1toYW5kbGVOdW1iZXJdLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCBmYWxzZSwgZXhhY3RJbnB1dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGkgPSBzY29wZV9IYW5kbGVOdW1iZXJzLmxlbmd0aCA9PT0gMSA/IDAgOiAxOyAvLyBTcHJlYWQgaGFuZGxlcyBldmVubHkgYWNyb3NzIHRoZSBzbGlkZXIgaWYgdGhlIHJhbmdlIGhhcyBubyBzaXplIChtaW49bWF4KVxuXG4gICAgICAgICAgaWYgKGlzSW5pdCAmJiBzY29wZV9TcGVjdHJ1bS5oYXNOb1NpemUoKSkge1xuICAgICAgICAgICAgZXhhY3RJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnNbMF0gPSAwO1xuXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHZhciBzcGFjZV8xID0gMTAwIC8gKHNjb3BlX0hhbmRsZU51bWJlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0gPSBoYW5kbGVOdW1iZXIgKiBzcGFjZV8xO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFNlY29uZGFyeSBwYXNzZXMuIE5vdyB0aGF0IGFsbCBiYXNlIHZhbHVlcyBhcmUgc2V0LCBhcHBseSBjb25zdHJhaW50cy5cbiAgICAgICAgICAvLyBJdGVyYXRlIGFsbCBoYW5kbGVzIHRvIGVuc3VyZSBjb25zdHJhaW50cyBhcmUgYXBwbGllZCBmb3IgdGhlIGVudGlyZSBzbGlkZXIgKElzc3VlICMxMDA5KVxuXG5cbiAgICAgICAgICBmb3IgKDsgaSA8IHNjb3BlX0hhbmRsZU51bWJlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdLCB0cnVlLCB0cnVlLCBleGFjdElucHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFppbmRleCgpO1xuICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTsgLy8gRmlyZSB0aGUgZXZlbnQgb25seSBmb3IgaGFuZGxlcyB0aGF0IHJlY2VpdmVkIGEgbmV3IHZhbHVlLCBhcyBwZXIgIzU3OVxuXG4gICAgICAgICAgICBpZiAodmFsdWVzW2hhbmRsZU51bWJlcl0gIT09IG51bGwgJiYgZmlyZVNldEV2ZW50KSB7XG4gICAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIFJlc2V0IHNsaWRlciB0byBpbml0aWFsIHZhbHVlc1xuXG5cbiAgICAgICAgZnVuY3Rpb24gdmFsdWVSZXNldChmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0LCBmaXJlU2V0RXZlbnQpO1xuICAgICAgICB9IC8vIFNldCB2YWx1ZSBmb3IgYSBzaW5nbGUgaGFuZGxlXG5cblxuICAgICAgICBmdW5jdGlvbiB2YWx1ZVNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHZhbHVlLCBmaXJlU2V0RXZlbnQsIGV4YWN0SW5wdXQpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgbnVtZXJpYyBpbnB1dFxuICAgICAgICAgIGhhbmRsZU51bWJlciA9IE51bWJlcihoYW5kbGVOdW1iZXIpO1xuXG4gICAgICAgICAgaWYgKCEoaGFuZGxlTnVtYmVyID49IDAgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBpbnZhbGlkIGhhbmRsZSBudW1iZXIsIGdvdDogXCIgKyBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgIH0gLy8gTG9vayBib3RoIGJhY2t3YXJkIGFuZCBmb3J3YXJkLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRoaXMgaGFuZGxlIHRvIFwicHVzaFwiIG90aGVyIGhhbmRsZXMgKCM5NjApO1xuICAgICAgICAgIC8vIFRoZSBleGFjdElucHV0IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGlnbm9yZSBzbGlkZXIgc3RlcHBpbmcgKCM0MzYpXG5cblxuICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCB0cnVlLCBleGFjdElucHV0KTtcbiAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcblxuICAgICAgICAgIGlmIChmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBHZXQgdGhlIHNsaWRlciB2YWx1ZS5cblxuXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlR2V0KHVuZW5jb2RlZCkge1xuICAgICAgICAgIGlmICh1bmVuY29kZWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdW5lbmNvZGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVuZW5jb2RlZCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGEgY29weSBvZiB0aGUgcmF3IHZhbHVlc1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1ZhbHVlcy5sZW5ndGggPT09IDEgPyBzY29wZV9WYWx1ZXNbMF0gOiBzY29wZV9WYWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbHVlcyA9IHNjb3BlX1ZhbHVlcy5tYXAob3B0aW9ucy5mb3JtYXQudG8pOyAvLyBJZiBvbmx5IG9uZSBoYW5kbGUgaXMgdXNlZCwgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxuXG4gICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfSAvLyBSZW1vdmVzIGNsYXNzZXMgZnJvbSB0aGUgcm9vdCBhbmQgZW1wdGllcyBpdC5cblxuXG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHByb3RlY3RlZCBpbnRlcm5hbCBsaXN0ZW5lcnNcbiAgICAgICAgICByZW1vdmVFdmVudChJTlRFUk5BTF9FVkVOVF9OUy5hcmlhKTtcbiAgICAgICAgICByZW1vdmVFdmVudChJTlRFUk5BTF9FVkVOVF9OUy50b29sdGlwcyk7XG4gICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5jc3NDbGFzc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzW2tleV0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgd2hpbGUgKHNjb3BlX1RhcmdldC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBzY29wZV9UYXJnZXQucmVtb3ZlQ2hpbGQoc2NvcGVfVGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSBzY29wZV9UYXJnZXQubm9VaVNsaWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHRTdGVwc0ZvckhhbmRsZShoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICB2YXIgbmVhcmJ5U3RlcHMgPSBzY29wZV9TcGVjdHJ1bS5nZXROZWFyYnlTdGVwcyhsb2NhdGlvbik7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgdmFyIGluY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XG4gICAgICAgICAgdmFyIGRlY3JlbWVudCA9IG51bGw7IC8vIElmIHNuYXBwZWQsIGRpcmVjdGx5IHVzZSBkZWZpbmVkIHN0ZXAgdmFsdWVcblxuICAgICAgICAgIGlmIChvcHRpb25zLnNuYXApIHtcbiAgICAgICAgICAgIHJldHVybiBbdmFsdWUgLSBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLnN0YXJ0VmFsdWUgfHwgbnVsbCwgbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgLSB2YWx1ZSB8fCBudWxsXTtcbiAgICAgICAgICB9IC8vIElmIHRoZSBuZXh0IHZhbHVlIGluIHRoaXMgc3RlcCBtb3ZlcyBpbnRvIHRoZSBuZXh0IHN0ZXAsXG4gICAgICAgICAgLy8gdGhlIGluY3JlbWVudCBpcyB0aGUgc3RhcnQgb2YgdGhlIG5leHQgc3RlcCAtIHRoZSBjdXJyZW50IHZhbHVlXG5cblxuICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgKyBpbmNyZW1lbnQgPiBuZWFyYnlTdGVwcy5zdGVwQWZ0ZXIuc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBuZWFyYnlTdGVwcy5zdGVwQWZ0ZXIuc3RhcnRWYWx1ZSAtIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gSWYgdGhlIHZhbHVlIGlzIGJleW9uZCB0aGUgc3RhcnRpbmcgcG9pbnRcblxuXG4gICAgICAgICAgaWYgKHZhbHVlID4gbmVhcmJ5U3RlcHMudGhpc1N0ZXAuc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgZGVjcmVtZW50ID0gbmVhcmJ5U3RlcHMudGhpc1N0ZXAuc3RlcDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuc3RlcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlY3JlbWVudCA9IGZhbHNlO1xuICAgICAgICAgIH0gLy8gSWYgYSBoYW5kbGUgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgc3RlcCwgaXQgYWx3YXlzIHN0ZXBzIGJhY2sgaW50byB0aGUgcHJldmlvdXMgc3RlcCBmaXJzdFxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVjcmVtZW50ID0gdmFsdWUgLSBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLmhpZ2hlc3RTdGVwO1xuICAgICAgICAgIH0gLy8gTm93LCBpZiBhdCB0aGUgc2xpZGVyIGVkZ2VzLCB0aGVyZSBpcyBubyBpbi9kZWNyZW1lbnRcblxuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uID09PSAxMDApIHtcbiAgICAgICAgICAgIGluY3JlbWVudCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChsb2NhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgZGVjcmVtZW50ID0gbnVsbDtcbiAgICAgICAgICB9IC8vIEFzIHBlciAjMzkxLCB0aGUgY29tcGFyaXNvbiBmb3IgdGhlIGRlY3JlbWVudCBzdGVwIGNhbiBoYXZlIHNvbWUgcm91bmRpbmcgaXNzdWVzLlxuXG5cbiAgICAgICAgICB2YXIgc3RlcERlY2ltYWxzID0gc2NvcGVfU3BlY3RydW0uY291bnRTdGVwRGVjaW1hbHMoKTsgLy8gUm91bmQgcGVyICMzOTFcblxuICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IG51bGwgJiYgaW5jcmVtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaW5jcmVtZW50ID0gTnVtYmVyKGluY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkZWNyZW1lbnQgIT09IG51bGwgJiYgZGVjcmVtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVjcmVtZW50ID0gTnVtYmVyKGRlY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbZGVjcmVtZW50LCBpbmNyZW1lbnRdO1xuICAgICAgICB9IC8vIEdldCB0aGUgY3VycmVudCBzdGVwIHNpemUgZm9yIHRoZSBzbGlkZXIuXG5cblxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0U3RlcHMoKSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlX0hhbmRsZU51bWJlcnMubWFwKGdldE5leHRTdGVwc0ZvckhhbmRsZSk7XG4gICAgICAgIH0gLy8gVXBkYXRhYmxlOiBtYXJnaW4sIGxpbWl0LCBwYWRkaW5nLCBzdGVwLCByYW5nZSwgYW5pbWF0ZSwgc25hcFxuXG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhvcHRpb25zVG9VcGRhdGUsIGZpcmVTZXRFdmVudCkge1xuICAgICAgICAgIC8vIFNwZWN0cnVtIGlzIGNyZWF0ZWQgdXNpbmcgdGhlIHJhbmdlLCBzbmFwLCBkaXJlY3Rpb24gYW5kIHN0ZXAgb3B0aW9ucy5cbiAgICAgICAgICAvLyAnc25hcCcgYW5kICdzdGVwJyBjYW4gYmUgdXBkYXRlZC5cbiAgICAgICAgICAvLyBJZiAnc25hcCcgYW5kICdzdGVwJyBhcmUgbm90IHBhc3NlZCwgdGhleSBzaG91bGQgcmVtYWluIHVuY2hhbmdlZC5cbiAgICAgICAgICB2YXIgdiA9IHZhbHVlR2V0KCk7XG4gICAgICAgICAgdmFyIHVwZGF0ZUFibGUgPSBbXCJtYXJnaW5cIiwgXCJsaW1pdFwiLCBcInBhZGRpbmdcIiwgXCJyYW5nZVwiLCBcImFuaW1hdGVcIiwgXCJzbmFwXCIsIFwic3RlcFwiLCBcImZvcm1hdFwiLCBcInBpcHNcIiwgXCJ0b29sdGlwc1wiXTsgLy8gT25seSBjaGFuZ2Ugb3B0aW9ucyB0aGF0IHdlJ3JlIGFjdHVhbGx5IHBhc3NlZCB0byB1cGRhdGUuXG5cbiAgICAgICAgICB1cGRhdGVBYmxlLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB1bmRlZmluZWQuIG51bGwgcmVtb3ZlcyB0aGUgdmFsdWUuXG4gICAgICAgICAgICBpZiAob3B0aW9uc1RvVXBkYXRlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxPcHRpb25zW25hbWVdID0gb3B0aW9uc1RvVXBkYXRlW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBuZXdPcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zKTsgLy8gTG9hZCBuZXcgb3B0aW9ucyBpbnRvIHRoZSBzbGlkZXIgc3RhdGVcblxuICAgICAgICAgIHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNUb1VwZGF0ZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSBuZXdPcHRpb25zW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNjb3BlX1NwZWN0cnVtID0gbmV3T3B0aW9ucy5zcGVjdHJ1bTsgLy8gTGltaXQsIG1hcmdpbiBhbmQgcGFkZGluZyBkZXBlbmQgb24gdGhlIHNwZWN0cnVtIGJ1dCBhcmUgc3RvcmVkIG91dHNpZGUgb2YgaXQuICgjNjc3KVxuXG4gICAgICAgICAgb3B0aW9ucy5tYXJnaW4gPSBuZXdPcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICBvcHRpb25zLmxpbWl0ID0gbmV3T3B0aW9ucy5saW1pdDtcbiAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBuZXdPcHRpb25zLnBhZGRpbmc7IC8vIFVwZGF0ZSBwaXBzLCByZW1vdmVzIGV4aXN0aW5nLlxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMucGlwcykge1xuICAgICAgICAgICAgcGlwcyhvcHRpb25zLnBpcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVQaXBzKCk7XG4gICAgICAgICAgfSAvLyBVcGRhdGUgdG9vbHRpcHMsIHJlbW92ZXMgZXhpc3RpbmcuXG5cblxuICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXBzKSB7XG4gICAgICAgICAgICB0b29sdGlwcygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVUb29sdGlwcygpO1xuICAgICAgICAgIH0gLy8gSW52YWxpZGF0ZSB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBzbyB2YWx1ZVNldCBmb3JjZXMgYW4gdXBkYXRlLlxuXG5cbiAgICAgICAgICBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcbiAgICAgICAgICB2YWx1ZVNldChpc1NldChvcHRpb25zVG9VcGRhdGUuc3RhcnQpID8gb3B0aW9uc1RvVXBkYXRlLnN0YXJ0IDogdiwgZmlyZVNldEV2ZW50KTtcbiAgICAgICAgfSAvLyBJbml0aWFsaXphdGlvbiBzdGVwc1xuXG5cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBTbGlkZXIoKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBiYXNlIGVsZW1lbnQsIGluaXRpYWxpemUgSFRNTCBhbmQgc2V0IGNsYXNzZXMuXG4gICAgICAgICAgLy8gQWRkIGhhbmRsZXMgYW5kIGNvbm5lY3QgZWxlbWVudHMuXG4gICAgICAgICAgc2NvcGVfQmFzZSA9IGFkZFNsaWRlcihzY29wZV9UYXJnZXQpO1xuICAgICAgICAgIGFkZEVsZW1lbnRzKG9wdGlvbnMuY29ubmVjdCwgc2NvcGVfQmFzZSk7IC8vIEF0dGFjaCB1c2VyIGV2ZW50cy5cblxuICAgICAgICAgIGJpbmRTbGlkZXJFdmVudHMob3B0aW9ucy5ldmVudHMpOyAvLyBVc2UgdGhlIHB1YmxpYyB2YWx1ZSBtZXRob2QgdG8gc2V0IHRoZSBzdGFydCB2YWx1ZXMuXG5cbiAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0KTtcblxuICAgICAgICAgIGlmIChvcHRpb25zLnBpcHMpIHtcbiAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwcykge1xuICAgICAgICAgICAgdG9vbHRpcHMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcmlhKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR1cFNsaWRlcigpO1xuICAgICAgICB2YXIgc2NvcGVfU2VsZiA9IHtcbiAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgICAgIHN0ZXBzOiBnZXROZXh0U3RlcHMsXG4gICAgICAgICAgb246IGJpbmRFdmVudCxcbiAgICAgICAgICBvZmY6IHJlbW92ZUV2ZW50LFxuICAgICAgICAgIGdldDogdmFsdWVHZXQsXG4gICAgICAgICAgc2V0OiB2YWx1ZVNldCxcbiAgICAgICAgICBzZXRIYW5kbGU6IHZhbHVlU2V0SGFuZGxlLFxuICAgICAgICAgIHJlc2V0OiB2YWx1ZVJlc2V0LFxuICAgICAgICAgIC8vIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZywgZG9uJ3QgdXNlIHRoaXMgaW4geW91ciBhcHBsaWNhdGlvbi5cbiAgICAgICAgICBfX21vdmVIYW5kbGVzOiBmdW5jdGlvbiAodXB3YXJkLCBwcm9wb3NhbCwgaGFuZGxlTnVtYmVycykge1xuICAgICAgICAgICAgbW92ZUhhbmRsZXModXB3YXJkLCBwcm9wb3NhbCwgc2NvcGVfTG9jYXRpb25zLCBoYW5kbGVOdW1iZXJzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wdGlvbnM6IG9yaWdpbmFsT3B0aW9ucyxcbiAgICAgICAgICB1cGRhdGVPcHRpb25zOiB1cGRhdGVPcHRpb25zLFxuICAgICAgICAgIHRhcmdldDogc2NvcGVfVGFyZ2V0LFxuICAgICAgICAgIHJlbW92ZVBpcHM6IHJlbW92ZVBpcHMsXG4gICAgICAgICAgcmVtb3ZlVG9vbHRpcHM6IHJlbW92ZVRvb2x0aXBzLFxuICAgICAgICAgIGdldFBvc2l0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0VG9vbHRpcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9Ub29sdGlwcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldE9yaWdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9IYW5kbGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGlwczogcGlwcyAvLyBJc3N1ZSAjNTk0XG5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNjb3BlX1NlbGY7XG4gICAgICB9IC8vIFJ1biB0aGUgc3RhbmRhcmQgaW5pdGlhbGl6ZXJcblxuXG4gICAgICBmdW5jdGlvbiBpbml0aWFsaXplKHRhcmdldCwgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQubm9kZU5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBjcmVhdGUgcmVxdWlyZXMgYSBzaW5nbGUgZWxlbWVudCwgZ290OiBcIiArIHRhcmdldCk7XG4gICAgICAgIH0gLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cblxuXG4gICAgICAgIGlmICh0YXJnZXQubm9VaVNsaWRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6IFNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cIik7XG4gICAgICAgIH0gLy8gVGVzdCB0aGUgb3B0aW9ucyBhbmQgY3JlYXRlIHRoZSBzbGlkZXIgZW52aXJvbm1lbnQ7XG5cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRlc3RPcHRpb25zKG9yaWdpbmFsT3B0aW9ucyk7XG4gICAgICAgIHZhciBhcGkgPSBzY29wZSh0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucyk7XG4gICAgICAgIHRhcmdldC5ub1VpU2xpZGVyID0gYXBpO1xuICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm91aXNsaWRlciA9IHtcbiAgICAgICAgLy8gRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLCBkb24ndCB1c2UgdGhpcyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAgICBfX3NwZWN0cnVtOiBTcGVjdHJ1bSxcbiAgICAgICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgY2xhc3NlcywgYWxsb3dzIGdsb2JhbCBjaGFuZ2VzLlxuICAgICAgICAvLyBVc2UgdGhlIGNzc0NsYXNzZXMgb3B0aW9uIGZvciBjaGFuZ2VzIHRvIG9uZSBzbGlkZXIuXG4gICAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXMsXG4gICAgICAgIGNyZWF0ZTogaW5pdGlhbGl6ZVxuICAgICAgfTtcbiAgICAgIGV4cG9ydHMuY3JlYXRlID0gaW5pdGlhbGl6ZTtcbiAgICAgIGV4cG9ydHMuY3NzQ2xhc3NlcyA9IGNzc0NsYXNzZXM7XG4gICAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IG5vdWlzbGlkZXI7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBub1VpU2xpZGVyID0gdW53cmFwRXhwb3J0cyhub3Vpc2xpZGVyKTtcblxuICAgIC8qKlxyXG4gICAgICogaW1wb3J0IG1haW4gRmFzaGlvbiBTbGlkZXIgZnVuY3Rpb25cclxuICAgICAqL1xuXG4gICAgLyplbmQgb2YgaW5sdWRlcyovXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCByZWFkeSk7XG5cbiAgICBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgIC8qKlxyXG4gICAgICAgKiBGYXNoaW9uIFNsaWRlciBlbGVtZW50XHJcbiAgICAgICAqL1xuICAgICAgY29uc3Qgc2xpZGVyRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZmFzaGlvbi1zbGlkZXInKTtcbiAgICAgIC8qKlxyXG4gICAgICAgKiBJbml0IEZhc2hpb24gU2xpZGVyXHJcbiAgICAgICAqXHJcbiAgICAgICAqIGFyZ3VtZW50OiBwYXNzIC5mYXNoaW9uLXNsaWRlciBlbGVtZW50XHJcbiAgICAgICAqL1xuXG4gICAgICBjcmVhdGVGYXNoaW9uU2xpZGVyKHNsaWRlckVsKTsgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICAgbGV0IGJ1cmdlckJ0bnMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5idXJnZXJcIildO1xuICAgICAgbGV0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYm9keVwiKTtcbiAgICAgIGxldCBodG1sID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWxcIik7XG5cbiAgICAgIGZvciAoY29uc3QgYnVyZ2VyQnRuIG9mIGJ1cmdlckJ0bnMpIHtcbiAgICAgICAgYnVyZ2VyQnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYm9keS5jbGFzc0xpc3QudG9nZ2xlKFwiYWN0aXZlXCIpO1xuICAgICAgICAgIGh0bWwuY2xhc3NMaXN0LnRvZ2dsZShcImFjdGl2ZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucHJpc2Utc2xpZGVyJykpIHtcbiAgICAgICAgbGV0IHNsaWRlclByaXNlID0gbmV3IFN3aXBlcihcIi5wcmlzZS1zbGlkZXJcIiwge1xuICAgICAgICAgIG1vZHVsZXM6IFtOYXZpZ2F0aW9uLCBBdXRvcGxheV0sXG4gICAgICAgICAgd2F0Y2hPdmVyZmxvdzogdHJ1ZSxcbiAgICAgICAgICBzcGVlZDogODAwLFxuICAgICAgICAgIG9ic2VydmVyOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVQYXJlbnRzOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVTbGlkZUNoaWxkcmVuOiB0cnVlLFxuICAgICAgICAgIGdyYWJDdXJzb3I6IHRydWUsXG4gICAgICAgICAgbmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgbmV4dEVsOiBcIi5wbGFucy1uYXZpZ2F0aW9uIC5idXR0b24tbmV4dFwiLFxuICAgICAgICAgICAgcHJldkVsOiBcIi5wbGFucy1uYXZpZ2F0aW9uIC5idXR0b24tcHJldlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdXRvcGxheToge1xuICAgICAgICAgICAgZGVsYXk6IDI1MDAsXG4gICAgICAgICAgICBkaXNhYmxlT25JbnRlcmFjdGlvbjogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvcGxheS5zdG9wKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvcGxheS5zdGFydCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnJlYWtwb2ludHM6IHtcbiAgICAgICAgICAgIDMyMDoge1xuICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLjM1LFxuICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDE1LFxuICAgICAgICAgICAgICBjZW50ZXJlZFNsaWRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgbG9vcDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDYzOToge1xuICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDE1LFxuICAgICAgICAgICAgICBjZW50ZXJlZFNsaWRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgbG9vcDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDc2ODoge1xuICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDMwLFxuICAgICAgICAgICAgICBjZW50ZXJlZFNsaWRlczogZmFsc2UsXG4gICAgICAgICAgICAgIGxvb3A6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxMDI0OiB7XG4gICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDIsXG4gICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMzAsXG4gICAgICAgICAgICAgIGNlbnRlcmVkU2xpZGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbG9vcDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxMjgwOiB7XG4gICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMzBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJldmlld3Mtc2xpZGVyJykpIHtcbiAgICAgICAgbGV0IHNsaWRlclJldmlldyA9IG5ldyBTd2lwZXIoXCIucmV2aWV3cy1zbGlkZXJcIiwge1xuICAgICAgICAgIG1vZHVsZXM6IFtOYXZpZ2F0aW9uLCBBdXRvcGxheV0sXG4gICAgICAgICAgd2F0Y2hPdmVyZmxvdzogdHJ1ZSxcbiAgICAgICAgICBzcGVlZDogODAwLFxuICAgICAgICAgIG9ic2VydmVyOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVQYXJlbnRzOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVTbGlkZUNoaWxkcmVuOiB0cnVlLFxuICAgICAgICAgIGdyYWJDdXJzb3I6IHRydWUsXG4gICAgICAgICAgbmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgbmV4dEVsOiBcIi5yZXZpZXdzLW5hdmlnYXRpb24gLmJ1dHRvbi1uZXh0XCIsXG4gICAgICAgICAgICBwcmV2RWw6IFwiLnJldmlld3MtbmF2aWdhdGlvbiAuYnV0dG9uLXByZXZcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXV0b3BsYXk6IHtcbiAgICAgICAgICAgIGRlbGF5OiAyNTAwLFxuICAgICAgICAgICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b3BsYXkuc3RvcCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b3BsYXkuc3RhcnQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGJyZWFrcG9pbnRzOiB7XG4gICAgICAgICAgICAzMjA6IHtcbiAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMS4zNSxcbiAgICAgICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxNSxcbiAgICAgICAgICAgICAgY2VudGVyZWRTbGlkZXM6IHRydWUsXG4gICAgICAgICAgICAgIGxvb3A6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA2Mzk6IHtcbiAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMixcbiAgICAgICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxNSxcbiAgICAgICAgICAgICAgY2VudGVyZWRTbGlkZXM6IGZhbHNlLFxuICAgICAgICAgICAgICBsb29wOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTAyNDoge1xuICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAzLFxuICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDMwLFxuICAgICAgICAgICAgICBjZW50ZXJlZFNsaWRlczogZmFsc2UsXG4gICAgICAgICAgICAgIGxvb3A6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTI4MDoge1xuICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAzLFxuICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDYwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLXN3aXBlcicpKSB7XG4gICAgICAgIGxldCBwYWdlU3dpcGVyID0gbmV3IFN3aXBlcihcIi5wYWdlLXN3aXBlclwiLCB7XG4gICAgICAgICAgbW9kdWxlczogW1BhZ2luYXRpb24sIFNjcm9sbGJhciwgZnJlZU1vZGUsIE1vdXNld2hlZWxdLFxuICAgICAgICAgIHdyYXBwZXJDbGFzczogXCJwYWdlX193cmFwcGVyXCIsXG4gICAgICAgICAgc2xpZGVDbGFzczogXCJwYWdlX19zY3JlZW5cIixcbiAgICAgICAgICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogJ2F1dG8nLFxuICAgICAgICAgIG1vdXNld2hlZWw6IHtcbiAgICAgICAgICAgIHNlbnNpdGl2aXRpOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbml0OiBmYWxzZSxcbiAgICAgICAgICB3YXRjaE92ZXJmbG93OiB0cnVlLFxuICAgICAgICAgIHNwZWVkOiA4MDAsXG4gICAgICAgICAgb2JzZXJ2ZXI6IHRydWUsXG4gICAgICAgICAgb2JzZXJ2ZVBhcmVudHM6IHRydWUsXG4gICAgICAgICAgb2JzZXJ2ZVNsaWRlQ2hpbGRyZW46IHRydWUsXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2V0U2Nyb2xsVHlwZSgpO1xuICAgICAgICAgICAgICBzY3JlZW5Db250ZW50UGFnZ2luZygpO1xuICAgICAgICAgICAgICBoaWRlVG9Ub3BCdG4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2V0U2Nyb2xsVHlwZSgpO1xuICAgICAgICAgICAgICBzY3JlZW5Db250ZW50UGFnZ2luZygpO1xuICAgICAgICAgICAgICBzZXRXaWR0aFBhZ2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlckluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaGlkZVRvVG9wQnRuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY3JvbGxiYXI6IHtcbiAgICAgICAgICAgIGVsOiAnLnBhZ2VfX3Njcm9sbCcsXG4gICAgICAgICAgICBkcmFnQ2xhc3M6ICdwYWdlX19kcmFnLXNjcm9sbCcsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYWdlU3dpcGVyLmluaXQoKTtcblxuICAgICAgICBmdW5jdGlvbiBzZXRTY3JvbGxUeXBlKCkge1xuICAgICAgICAgIGxldCB3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2VfX3dyYXBwZXInKTtcbiAgICAgICAgICBsZXQgcGFnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21haW4ucGFnZScpO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdfZnJlZScpKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ19mcmVlJyk7XG4gICAgICAgICAgICBwYWdlLmNsYXNzTGlzdC5yZW1vdmUoJ19mcmVlJyk7XG4gICAgICAgICAgICBwYWdlU3dpcGVyLnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhZ2VTd2lwZXIuc2xpZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgcGFnZVNsaWRlID0gcGFnZVN3aXBlci5zbGlkZXNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgcGFnZVNsaWRlQ29udGVudCA9IHBhZ2VTbGlkZS5xdWVyeVNlbGVjdG9yKCcuc2NyZWVuX19jb250ZW50Jyk7XG5cbiAgICAgICAgICAgIGlmIChwYWdlU2xpZGVDb250ZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhZ2VTbGlkZUNvbnRlbnRIZWlnaHQgPSBwYWdlU2xpZGVDb250ZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgICBpZiAocGFnZVNsaWRlQ29udGVudEhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBhZ2VTbGlkZUNvbnRlbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBhZ2VTbGlkZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnX2ZyZWUnKTtcbiAgICAgICAgICAgICAgICBwYWdlLmNsYXNzTGlzdC5hZGQoJ19mcmVlJyk7XG4gICAgICAgICAgICAgICAgcGFnZVN3aXBlci5wYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gMTkyMCB8fCB3aW5kb3cuaW5uZXJIZWlnaHQgPD0gNzY3KSB7XG4gICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnX2ZyZWUnKTtcbiAgICAgICAgICAgICAgcGFnZS5jbGFzc0xpc3QuYWRkKCdfZnJlZScpO1xuICAgICAgICAgICAgICBwYWdlU3dpcGVyLnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRXaWR0aFBhZ2UoKSB7XG4gICAgICAgICAgbGV0IHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cbiAgICAgICAgICBpZiAod2luZG93V2lkdGggPCAxMjgwKSB7XG4gICAgICAgICAgICBwYWdlU3dpcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFnZVN3aXBlci5pbml0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2NyZWVuQ29udGVudFBhZ2dpbmcoKSB7XG4gICAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZV9fd3JhcHBlcicpO1xuICAgICAgICAgIGxldCBoZWFkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkZXInKTtcbiAgICAgICAgICBsZXQgc2NyZWVuQ29udGVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc2NyZWVuX19jb250ZW50Jyk7XG4gICAgICAgICAgbGV0IGhlYWRlckhlaWdodCA9IGhlYWRlci5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHNjcmVlbkNvbnRlbnQgb2Ygc2NyZWVuQ29udGVudHMpIHtcbiAgICAgICAgICAgIGlmICghd3JhcHBlci5jbGFzc0xpc3QuY29udGFpbnMoJ19mcmVlJykpIHtcbiAgICAgICAgICAgICAgc2NyZWVuQ29udGVudC5zdHlsZS5wYWRkaW5nVG9wID0gaGVhZGVySGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNjcmVlbkNvbnRlbnQuc3R5bGUucGFkZGluZ1RvcCA9ICcwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b1RvcFBhZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG8tdG9wLXBhZ2UnKTtcblxuICAgICAgICBpZiAodG9Ub3BQYWdlKSB7XG4gICAgICAgICAgdG9Ub3BQYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBwYWdlU3dpcGVyLnNsaWRlVG8oMCwgODAwKTtcblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDwgMTI3OSkge1xuICAgICAgICAgICAgICBsZXQgYm9keSA9ICdib2R5JztcbiAgICAgICAgICAgICAgc2Nyb2xsVG9CbG9jayhlLCBib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhZ2VTd2lwZXIub24oJ3NsaWRlQ2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGhpZGVUb1RvcEJ0bigpO1xuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGUgPT4ge1xuICAgICAgICAgIGhpZGVUb1RvcEJ0bigpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBoaWRlVG9Ub3BCdG4oKSB7XG4gICAgICAgICAgbGV0IGFjdGl2ZUluZGV4U2xpZGUgPSBwYWdlU3dpcGVyLmFjdGl2ZUluZGV4O1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZUluZGV4U2xpZGUgPT09IDApIHtcbiAgICAgICAgICAgIGxldCB0b1RvcFBhZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG8tdG9wLXBhZ2UnKTtcbiAgICAgICAgICAgIHRvVG9wUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b1RvcFBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc2Nyb2xsIHJpb1xuXG5cbiAgICAgIGxldCB0b1RvcFBhZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG8tdG9wLXBhZ2UnKTtcblxuICAgICAgaWYgKHRvVG9wUGFnZSAmJiAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2Utc3dpcGVyJykpIHtcbiAgICAgICAgdG9Ub3BQYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgbGV0IGJvZHkgPSAnYm9keSc7XG4gICAgICAgICAgc2Nyb2xsVG9CbG9jayhlLCBib2R5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNjcm9sbFRvQmxvY2soZSwgaWQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcbiAgICAgICAgICBibG9jazogJ3N0YXJ0J1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gc2Nyb2xsIHJpbyBlbmRcblxuXG4gICAgICB2YXIgaXNJT1MgPSAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG4gICAgICBpZiAoaXNJT1MpIHtcbiAgICAgICAgbGV0IHZpZGVvcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy52aWRlbycpO1xuICAgICAgICB2aWRlb3MuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICB2YXIgY2FudmFzVmlkZW8gPSBuZXcgQ2FudmFzVmlkZW9QbGF5ZXIoe1xuICAgICAgICAgICAgdmlkZW9TZWxlY3RvcjogJyMnICsgZS5nZXRBdHRyaWJ1dGUoJ2lkJykgKyAnIC52aWRlb19fdmlkZW8nLFxuICAgICAgICAgICAgY2FudmFzU2VsZWN0b3I6ICcjJyArIGUuZ2V0QXR0cmlidXRlKCdpZCcpICsgJyAudmlkZW9fX2NhbnZhcycsXG4gICAgICAgICAgICB0aW1lbGluZVNlbGVjdG9yOiBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgICAgICAgICAgbWFrZUxvb3A6IHRydWUsXG4gICAgICAgICAgICBwYXVzZU9uQ2xpY2s6IGZhbHNlLFxuICAgICAgICAgICAgYXVkaW86IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIEhUTUw1IHZpZGVvXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy52aWRlb19fY2FudmFzJylbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH0gLy8gc2NyZW5uIHByb2Nlc3NcblxuXG4gICAgICBsZXQgd29ya0l0ZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLndvcmstaXRlbXMgLml0ZW0nKTtcbiAgICAgIGxldCBwYWdlU2NyZWVuUHJvY2VzcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlX19zY3JlZW4tLXByb2Nlc3MnKTtcbiAgICAgIGxldCBkZWxleSA9IDIwMDtcblxuICAgICAgaWYgKHBhZ2VTY3JlZW5Qcm9jZXNzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFuaW1TY3JlblByb2Nlc3MoKSB7XG4gICAgICAgICAgd29ya0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IGRlbGV5ICsgJ21zJztcbiAgICAgICAgICAgIGRlbGV5ICs9IDEwMDtcblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDwgMTAyNCkge1xuICAgICAgICAgICAgICBpdGVtLnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IDAgKyAnbXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbVNjcmVuUHJvY2VzcygpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xuICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8IDEwMjQpIHtcbiAgICAgICAgICAgIGxldCB3b3JrSXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcud29yay1pdGVtcyAuaXRlbScpO1xuICAgICAgICAgICAgd29ya0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgIGl0ZW0uc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gMCArICdtcyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV5ID0gMjAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCArIDEwMCA+PSBvZmZzZXQocGFnZVNjcmVlblByb2Nlc3MpKSB7XG4gICAgICAgICAgICBwYWdlU2NyZWVuUHJvY2Vzcy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUtYW5pbScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWdlU2NyZWVuUHJvY2Vzcy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUtYW5pbScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gb2Zmc2V0KGVsKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgcmV0dXJuIHJlY3QudG9wICsgc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNoZWNrYm94IGlucHV0XG5cblxuICAgICAgbGV0IGlucHV0Q2hlY2tib3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbdHlwZT1cImNoZWNrYm94XCJdJyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDaGVja2JveC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaW5wdXRDaGVja2JveFtpXTtcbiAgICAgICAgYWRkQ2xhc3NUb0xhYmVsKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGUgPT4ge1xuICAgICAgICAgIGxldCB0YXJnZXRFbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgICAgICAgYWRkQ2xhc3NUb0xhYmVsKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkQ2xhc3NUb0xhYmVsKGlucHV0KSB7XG4gICAgICAgIGxldCBwYXJlbnRMYWJlbCA9IGlucHV0LmNsb3Nlc3QoJ2xhYmVsJyk7XG5cbiAgICAgICAgaWYgKGlucHV0LmNoZWNrZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBwYXJlbnRMYWJlbC5jbGFzc0xpc3QuYWRkKCdjaGVja2VkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50TGFiZWwuY2xhc3NMaXN0LnJlbW92ZSgnY2hlY2tlZCcpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNoZWNrYm94IGlucHV0IGVuZFxuICAgICAgLy8gcmVxdWlyZWQgaW5wdXRcblxuXG4gICAgICBsZXQgaW5wdXRSZXF1aXJlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy53cGNmNy12YWxpZGF0ZXMtYXMtcmVxdWlyZWQnKTtcblxuICAgICAgaWYgKGlucHV0UmVxdWlyZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IGlucHV0UmVxdWlyZWRbaV07XG4gICAgICAgICAgbGV0IHBhcmVudEZpZWxkc2V0ID0gZWxlbWVudC5jbG9zZXN0KCdmaWVsZHNldCcpO1xuXG4gICAgICAgICAgaWYgKHBhcmVudEZpZWxkc2V0KSB7XG4gICAgICAgICAgICBwYXJlbnRGaWVsZHNldC5jbGFzc0xpc3QuYWRkKCdyZXF1aXJlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyByZXF1aXJlZCBpbnB1dCBlbmRcbiAgICAgIC8vIHJhbmdlIGlucHV0XG5cblxuICAgICAgdmFyIHBpcHNSYW5nZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNwaXBzLXJhbmdlJyk7XG5cbiAgICAgIGlmIChwaXBzUmFuZ2UpIHtcbiAgICAgICAgcGlwc1JhbmdlLmZvckVhY2gocmFuZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgICAnbWluJzogWzEsIDFdLFxuICAgICAgICAgICAgJzExLjExJSc6IFsyLCAxXSxcbiAgICAgICAgICAgICcyMi4yMiUnOiBbMywgMV0sXG4gICAgICAgICAgICAnMzMuMzMlJzogWzQsIDFdLFxuICAgICAgICAgICAgJzQ0LjQ0JSc6IFs1LCAxXSxcbiAgICAgICAgICAgICc1NS41NSUnOiBbNiwgMV0sXG4gICAgICAgICAgICAnNjYuNjYlJzogWzcsIDFdLFxuICAgICAgICAgICAgJzc3Ljc3JSc6IFs4LCAxXSxcbiAgICAgICAgICAgICc4OC44OCUnOiBbOSwgMV0sXG4gICAgICAgICAgICAnbWF4JzogWzEwLCAxXVxuICAgICAgICAgIH07XG4gICAgICAgICAgbm9VaVNsaWRlci5jcmVhdGUocmFuZ2VFbGVtZW50LCB7XG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGNvbm5lY3Q6ICdsb3dlcicsXG4gICAgICAgICAgICBzdGVwOiAxLFxuICAgICAgICAgICAgcGlwczoge1xuICAgICAgICAgICAgICBtb2RlOiAncmFuZ2UnLFxuICAgICAgICAgICAgICBkZW5zaXR5OiAnbm9uZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByYW5nZUVsZW1lbnQubm9VaVNsaWRlci5vbigndXBkYXRlJywgZnVuY3Rpb24gKHZhbHVlcywgaGFuZGxlKSB7XG4gICAgICAgICAgICBsZXQgcGlwc1JhbmdlRmllbGRzZXQgPSByYW5nZUVsZW1lbnQuY2xvc2VzdCgnZmllbGRzZXQnKTtcbiAgICAgICAgICAgIGxldCBwaXBzUmFuZ2VJbnB1dCA9IHBpcHNSYW5nZUZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3IoJyNwaXBzLXJhbmdlLWlucHV0Jyk7XG4gICAgICAgICAgICBwaXBzUmFuZ2VJbnB1dC52YWx1ZSA9IE1hdGgucm91bmQodmFsdWVzW2hhbmRsZV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gcmFuZ2UgaW5wdXQgZW5kXG5cblxuICAgICAgY29uc3Qgc3BvbGxlcnNBcnJheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNwb2xsZXJzXScpO1xuXG4gICAgICBpZiAoc3BvbGxlcnNBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vINCf0L7Qu9GD0YfQtdC90LjQtSDQvtCx0YvRh9C90YvRhSDRgdC70L7QudC70LXRgNC+0LJcbiAgICAgICAgY29uc3Qgc3BvbGxlcnNSZWd1bGFyID0gQXJyYXkuZnJvbShzcG9sbGVyc0FycmF5KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4LCBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuICFpdGVtLmRhdGFzZXQuc3BvbGxlcnMuc3BsaXQoXCIsXCIpWzBdO1xuICAgICAgICB9KTsgLy8g0JjQvdC40YbQuNCw0LvQuNC30LDRhtC40Y8g0L7QsdGL0YfQvdGL0YUg0YHQu9C+0LnQu9C10YDQvtCyXG5cbiAgICAgICAgaWYgKHNwb2xsZXJzUmVndWxhci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaW5pdFNwb2xsZXJzKHNwb2xsZXJzUmVndWxhcik7XG4gICAgICAgIH0gLy8g0J/QvtC70YPRh9C10L3QuNC1INGB0LvQvtC50LvQtdGA0L7QsiDRgSDQvNC10LTQuNCwINC30LDQv9GA0L7RgdCw0LzQuFxuXG5cbiAgICAgICAgY29uc3Qgc3BvbGxlcnNNZWRpYSA9IEFycmF5LmZyb20oc3BvbGxlcnNBcnJheSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgc2VsZikge1xuICAgICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQuc3BvbGxlcnMuc3BsaXQoXCIsXCIpWzBdO1xuICAgICAgICB9KTsgLy8g0JjQvdC40YbQuNCw0LvQuNC30LDRhtC40Y8g0YHQu9C+0LnQu9C10YDQvtCyINGBINC80LXQtNC40LAg0LfQsNC/0YDQvtGB0LDQvNC4XG5cbiAgICAgICAgaWYgKHNwb2xsZXJzTWVkaWEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGJyZWFrcG9pbnRzQXJyYXkgPSBbXTtcbiAgICAgICAgICBzcG9sbGVyc01lZGlhLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBpdGVtLmRhdGFzZXQuc3BvbGxlcnM7XG4gICAgICAgICAgICBjb25zdCBicmVha3BvaW50ID0ge307XG4gICAgICAgICAgICBjb25zdCBwYXJhbXNBcnJheSA9IHBhcmFtcy5zcGxpdChcIixcIik7XG4gICAgICAgICAgICBicmVha3BvaW50LnZhbHVlID0gcGFyYW1zQXJyYXlbMF07XG4gICAgICAgICAgICBicmVha3BvaW50LnR5cGUgPSBwYXJhbXNBcnJheVsxXSA/IHBhcmFtc0FycmF5WzFdLnRyaW0oKSA6IFwibWF4XCI7XG4gICAgICAgICAgICBicmVha3BvaW50Lml0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgYnJlYWtwb2ludHNBcnJheS5wdXNoKGJyZWFrcG9pbnQpO1xuICAgICAgICAgIH0pOyAvLyDQn9C+0LvRg9GH0LDQtdC8INGD0L3QuNC60LDQu9GM0L3Ri9C1INCx0YDQtdC50LrQv9C+0LjQvdGC0YtcblxuICAgICAgICAgIGxldCBtZWRpYVF1ZXJpZXMgPSBicmVha3BvaW50c0FycmF5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuICcoJyArIGl0ZW0udHlwZSArIFwiLXdpZHRoOiBcIiArIGl0ZW0udmFsdWUgKyBcInB4KSxcIiArIGl0ZW0udmFsdWUgKyAnLCcgKyBpdGVtLnR5cGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWVkaWFRdWVyaWVzID0gbWVkaWFRdWVyaWVzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaW5kZXgsIHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmluZGV4T2YoaXRlbSkgPT09IGluZGV4O1xuICAgICAgICAgIH0pOyAvLyDQoNCw0LHQvtGC0LDQtdC8INGBINC60LDQttC00YvQvCDQsdGA0LXQudC60L/QvtC40L3RgtC+0LxcblxuICAgICAgICAgIG1lZGlhUXVlcmllcy5mb3JFYWNoKGJyZWFrcG9pbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zQXJyYXkgPSBicmVha3BvaW50LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhQnJlYWtwb2ludCA9IHBhcmFtc0FycmF5WzFdO1xuICAgICAgICAgICAgY29uc3QgbWVkaWFUeXBlID0gcGFyYW1zQXJyYXlbMl07XG4gICAgICAgICAgICBjb25zdCBtYXRjaE1lZGlhID0gd2luZG93Lm1hdGNoTWVkaWEocGFyYW1zQXJyYXlbMF0pOyAvLyDQntCx0YrQtdC60YLRiyDRgSDQvdGD0LbQvdGL0LzQuCDRg9GB0LvQvtCy0LjRj9C80LhcblxuICAgICAgICAgICAgY29uc3Qgc3BvbGxlcnNBcnJheSA9IGJyZWFrcG9pbnRzQXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgIGlmIChpdGVtLnZhbHVlID09PSBtZWRpYUJyZWFrcG9pbnQgJiYgaXRlbS50eXBlID09PSBtZWRpYVR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7IC8vINCh0L7QsdGL0YLQuNC1XG5cbiAgICAgICAgICAgIG1hdGNoTWVkaWEuYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpbml0U3BvbGxlcnMoc3BvbGxlcnNBcnJheSwgbWF0Y2hNZWRpYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluaXRTcG9sbGVycyhzcG9sbGVyc0FycmF5LCBtYXRjaE1lZGlhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyDQmNC90LjRhtC40LDQu9C40LfQsNGG0LjRj1xuXG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFNwb2xsZXJzKHNwb2xsZXJzQXJyYXksIG1hdGNoTWVkaWEgPSBmYWxzZSkge1xuICAgICAgICAgIHNwb2xsZXJzQXJyYXkuZm9yRWFjaChzcG9sbGVyc0Jsb2NrID0+IHtcbiAgICAgICAgICAgIHNwb2xsZXJzQmxvY2sgPSBtYXRjaE1lZGlhID8gc3BvbGxlcnNCbG9jay5pdGVtIDogc3BvbGxlcnNCbG9jaztcblxuICAgICAgICAgICAgaWYgKG1hdGNoTWVkaWEubWF0Y2hlcyB8fCAhbWF0Y2hNZWRpYSkge1xuICAgICAgICAgICAgICBzcG9sbGVyc0Jsb2NrLmNsYXNzTGlzdC5hZGQoJ19pbml0Jyk7XG4gICAgICAgICAgICAgIGluaXRTcG9sbGVyQm9keShzcG9sbGVyc0Jsb2NrKTtcbiAgICAgICAgICAgICAgc3BvbGxlcnNCbG9jay5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgc2V0U3BvbGxlckFjdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzcG9sbGVyc0Jsb2NrLmNsYXNzTGlzdC5yZW1vdmUoJ19pbml0Jyk7XG4gICAgICAgICAgICAgIGluaXRTcG9sbGVyQm9keShzcG9sbGVyc0Jsb2NrLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHNwb2xsZXJzQmxvY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHNldFNwb2xsZXJBY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vINCg0LDQsdC+0YLQsCDRgSDQutC+0L3RgtC10L3RgtC+0LxcblxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRTcG9sbGVyQm9keShzcG9sbGVyc0Jsb2NrLCBoaWRlU3BvbGxlckJvZHkgPSB0cnVlKSB7XG4gICAgICAgICAgY29uc3Qgc3BvbGxlclRpdGxlcyA9IHNwb2xsZXJzQmxvY2sucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc3BvbGxlcl0nKTtcblxuICAgICAgICAgIGlmIChzcG9sbGVyVGl0bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNwb2xsZXJUaXRsZXMuZm9yRWFjaChzcG9sbGVyVGl0bGUgPT4ge1xuICAgICAgICAgICAgICBpZiAoaGlkZVNwb2xsZXJCb2R5KSB7XG4gICAgICAgICAgICAgICAgc3BvbGxlclRpdGxlLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcblxuICAgICAgICAgICAgICAgIGlmICghc3BvbGxlclRpdGxlLmNsYXNzTGlzdC5jb250YWlucygnX2FjdGl2ZScpKSB7XG4gICAgICAgICAgICAgICAgICBzcG9sbGVyVGl0bGUubmV4dEVsZW1lbnRTaWJsaW5nLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwb2xsZXJUaXRsZS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgICAgICAgc3BvbGxlclRpdGxlLm5leHRFbGVtZW50U2libGluZy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0U3BvbGxlckFjdGlvbihlKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSBlLnRhcmdldDtcblxuICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3BvbGxlcicpIHx8IGVsLmNsb3Nlc3QoJ1tkYXRhLXNwb2xsZXJdJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwb2xsZXJUaXRsZSA9IGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zcG9sbGVyJykgPyBlbCA6IGVsLmNsb3Nlc3QoJ1tkYXRhLXNwb2xsZXJdJyk7XG4gICAgICAgICAgICBjb25zdCBzcG9sbGVyc0Jsb2NrID0gc3BvbGxlclRpdGxlLmNsb3Nlc3QoJ1tkYXRhLXNwb2xsZXJzXScpO1xuICAgICAgICAgICAgY29uc3Qgb25lU3BvbGxlciA9IHNwb2xsZXJzQmxvY2suaGFzQXR0cmlidXRlKCdkYXRhLW9uZS1zcG9sbGVyJykgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICghc3BvbGxlcnNCbG9jay5xdWVyeVNlbGVjdG9yQWxsKCcuX3NsaWRlJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChvbmVTcG9sbGVyICYmICFzcG9sbGVyVGl0bGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdfYWN0aXZlJykpIHtcbiAgICAgICAgICAgICAgICBoaWRlU3BvbGxlcnNCb2R5KHNwb2xsZXJzQmxvY2spO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3BvbGxlclRpdGxlLmNsYXNzTGlzdC50b2dnbGUoJ19hY3RpdmUnKTtcblxuICAgICAgICAgICAgICBfc2xpZGVUb2dnbGUoc3BvbGxlclRpdGxlLm5leHRFbGVtZW50U2libGluZywgNTAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhpZGVTcG9sbGVyc0JvZHkoc3BvbGxlcnNCbG9jaykge1xuICAgICAgICAgIGNvbnN0IHNwb2xsZXJBY3RpdmVUaXRsZSA9IHNwb2xsZXJzQmxvY2sucXVlcnlTZWxlY3RvcignW2RhdGEtc3BvbGxlcl0uX2FjdGl2ZScpO1xuXG4gICAgICAgICAgaWYgKHNwb2xsZXJBY3RpdmVUaXRsZSkge1xuICAgICAgICAgICAgc3BvbGxlckFjdGl2ZVRpdGxlLmNsYXNzTGlzdC5yZW1vdmUoJ19hY3RpdmUnKTtcblxuICAgICAgICAgICAgX3NsaWRlVXAoc3BvbGxlckFjdGl2ZVRpdGxlLm5leHRFbGVtZW50U2libGluZywgNTAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgLy9TbGlkZVRvZ2dsZVxuXG5cbiAgICAgIGxldCBfc2xpZGVVcCA9ICh0YXJnZXQsIGR1cmF0aW9uID0gNTAwKSA9PiB7XG4gICAgICAgIGlmICghdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnX3NsaWRlJykpIHtcbiAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnX3NsaWRlJyk7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICdoZWlnaHQsIG1hcmdpbiwgcGFkZGluZyc7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uICsgJ21zJztcbiAgICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0Lm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgICAgdGFyZ2V0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUucGFkZGluZ1RvcCA9IDA7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLnBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5tYXJnaW5Ub3AgPSAwO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAwO1xuICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncGFkZGluZy10b3AnKTtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncGFkZGluZy1ib3R0b20nKTtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnbWFyZ2luLXRvcCcpO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdtYXJnaW4tYm90dG9tJyk7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zaXRpb24tZHVyYXRpb24nKTtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbi1wcm9wZXJ0eScpO1xuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ19zbGlkZScpO1xuICAgICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbGV0IF9zbGlkZURvd24gPSAodGFyZ2V0LCBkdXJhdGlvbiA9IDUwMCkgPT4ge1xuICAgICAgICBpZiAoIXRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ19zbGlkZScpKSB7XG4gICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ19zbGlkZScpO1xuXG4gICAgICAgICAgaWYgKHRhcmdldC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRhcmdldC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgaGVpZ2h0ID0gdGFyZ2V0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUucGFkZGluZ1RvcCA9IDA7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLnBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5tYXJnaW5Ub3AgPSAwO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAwO1xuICAgICAgICAgIHRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IFwiaGVpZ2h0LCBtYXJnaW4sIHBhZGRpbmdcIjtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gKyAnbXMnO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncGFkZGluZy10b3AnKTtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BhZGRpbmctYm90dG9tJyk7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdtYXJnaW4tdG9wJyk7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdtYXJnaW4tYm90dG9tJyk7XG4gICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbi1kdXJhdGlvbicpO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uLXByb3BlcnR5Jyk7XG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnX3NsaWRlJyk7XG4gICAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBsZXQgX3NsaWRlVG9nZ2xlID0gKHRhcmdldCwgZHVyYXRpb24gPSA1MDApID0+IHtcbiAgICAgICAgaWYgKHRhcmdldC5oaWRkZW4pIHtcbiAgICAgICAgICByZXR1cm4gX3NsaWRlRG93bih0YXJnZXQsIGR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3NsaWRlVXAodGFyZ2V0LCBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07IC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICAgLypcclxuICAgICAg0JTQu9GPINGA0L7QtNC40YLQtdC70Y8g0YHQu9C+0LnQu9C10YDQvtCyINC/0LjRiNC10Lwg0LDRgtGA0LjQsdGD0YIgZGF0YS1zcG9sbGVyc1xyXG4gICAgICDQlNC70Y8g0LfQsNCz0L7Qu9C+0LLQutC+0LIg0YHQu9C+0LnQu9C10YDQvtCyINC/0LjRiNC10Lwg0LDRgtGA0LjQsdGD0YIgZGF0YS1zcG9sbGVyXHJcbiAgICAgINCV0YHQu9C4INC90YPQttC90L4g0LLQutC70Y7Rh9Cw0YLRjFxc0LLRi9C60LvRjtGH0LDRgtGMINGA0LDQsdC+0YLRgyDRgdC/0L7QudC70LXRgNC+0LIg0L3QsCDRgNCw0LfQvdGL0YUg0YDQsNC30LzQtdGA0LDRhSDRjdC60YDQsNC90L7QslxyXG4gICAgICDQv9C40YjQtdC8INC/0LDRgNCw0LzQtdGC0YDRiyDRiNC40YDQuNC90Ysg0Lgg0YLQuNC/0LAg0LHRgNC10LnQutC/0L7QuNC90YLQsC5cclxuICAgICAg0J3QsNC/0YDQuNC80LXRgDpcclxuICAgICAgZGF0YS1zcG9sbGVycz1cIjk5MixtYXhcIiAtINGB0L/QvtC50LvQtdGA0Ysg0LHRg9C00YPRgiDRgNCw0LHQvtGC0LDRgtGMINGC0L7Qu9GM0LrQviDQvdCwINGN0LrRgNCw0L3QsNGFINC80LXQvdGM0YjQtSDQuNC70Lgg0YDQsNCy0L3QviA5OTJweFxyXG4gICAgICBkYXRhLXNwb2xsZXJzPVwiNzY4LG1pblwiIC0g0YHQv9C+0LnQu9C10YDRiyDQsdGD0LTRg9GCINGA0LDQsdC+0YLQsNGC0Ywg0YLQvtC70YzQutC+INC90LAg0Y3QutGA0LDQvdCw0YUg0LHQvtC70YzRiNC1INC40LvQuCDRgNCw0LLQvdC+IDc2OHB4XHJcbiAgICAgIFxuICAgICAg0JXRgdC70Lgg0L3Rg9C20L3QviDRh9GC0L4g0LHRiyDQsiDQsdC70L7QutC1INC+0YLQutGA0YvQstCw0LvRgdGPINCx0L7Qu9GM0LrQviDQvtC00LjQvSDRgdC70L7QudC70LXRgCDQtNC+0LHQsNCy0LvRj9C10Lwg0LDRgtGA0LjQsdGD0YIgZGF0YS1vbmUtc3BvbGxlclxyXG4gICAgICAqL1xuXG4gICAgfVxuXG59KSkpO1xuIl0sImZpbGUiOiJtYWluLmpzIn0=
