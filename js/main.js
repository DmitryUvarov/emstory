(function (factory) {
    typeof define === 'function' && define.amd ? define('main', factory) :
    factory();
}((function () { 'use strict';

    /**
     * SSR Window 4.0.2
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: December 13, 2021
     */

    /* eslint-disable no-param-reassign */
    function isObject(obj) {
      return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
    }

    function extend(target = {}, src = {}) {
      Object.keys(src).forEach(key => {
        if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
          extend(target[key], src[key]);
        }
      });
    }

    const ssrDocument = {
      body: {},

      addEventListener() {},

      removeEventListener() {},

      activeElement: {
        blur() {},

        nodeName: ''
      },

      querySelector() {
        return null;
      },

      querySelectorAll() {
        return [];
      },

      getElementById() {
        return null;
      },

      createEvent() {
        return {
          initEvent() {}

        };
      },

      createElement() {
        return {
          children: [],
          childNodes: [],
          style: {},

          setAttribute() {},

          getElementsByTagName() {
            return [];
          }

        };
      },

      createElementNS() {
        return {};
      },

      importNode() {
        return null;
      },

      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
      }
    };

    function getDocument() {
      const doc = typeof document !== 'undefined' ? document : {};
      extend(doc, ssrDocument);
      return doc;
    }

    const ssrWindow = {
      document: ssrDocument,
      navigator: {
        userAgent: ''
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
      },
      history: {
        replaceState() {},

        pushState() {},

        go() {},

        back() {}

      },
      CustomEvent: function CustomEvent() {
        return this;
      },

      addEventListener() {},

      removeEventListener() {},

      getComputedStyle() {
        return {
          getPropertyValue() {
            return '';
          }

        };
      },

      Image() {},

      Date() {},

      screen: {},

      setTimeout() {},

      clearTimeout() {},

      matchMedia() {
        return {};
      },

      requestAnimationFrame(callback) {
        if (typeof setTimeout === 'undefined') {
          callback();
          return null;
        }

        return setTimeout(callback, 0);
      },

      cancelAnimationFrame(id) {
        if (typeof setTimeout === 'undefined') {
          return;
        }

        clearTimeout(id);
      }

    };

    function getWindow() {
      const win = typeof window !== 'undefined' ? window : {};
      extend(win, ssrWindow);
      return win;
    }

    /**
     * Dom7 4.0.4
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2022, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: January 11, 2022
     */
    /* eslint-disable no-proto */

    function makeReactive(obj) {
      const proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get() {
          return proto;
        },

        set(value) {
          proto.__proto__ = value;
        }

      });
    }

    class Dom7 extends Array {
      constructor(items) {
        if (typeof items === 'number') {
          super(items);
        } else {
          super(...(items || []));
          makeReactive(this);
        }
      }

    }

    function arrayFlat(arr = []) {
      const res = [];
      arr.forEach(el => {
        if (Array.isArray(el)) {
          res.push(...arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }

    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }

    function arrayUnique(arr) {
      const uniqueArray = [];

      for (let i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }

      return uniqueArray;
    }


    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }

      const a = [];
      const res = context.querySelectorAll(selector);

      for (let i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }

      return a;
    }

    function $(selector, context) {
      const window = getWindow();
      const document = getDocument();
      let arr = [];

      if (!context && selector instanceof Dom7) {
        return selector;
      }

      if (!selector) {
        return new Dom7(arr);
      }

      if (typeof selector === 'string') {
        const html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          let toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          const tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (let i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);

      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
      }

      return new Dom7(arrayUnique(arr));
    }

    $.fn = Dom7.prototype; // eslint-disable-next-line

    function addClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        el.classList.add(...classNames);
      });
      return this;
    }

    function removeClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        el.classList.remove(...classNames);
      });
      return this;
    }

    function toggleClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        classNames.forEach(className => {
          el.classList.toggle(className);
        });
      });
    }

    function hasClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      return arrayFilter(this, el => {
        return classNames.filter(className => el.classList.contains(className)).length > 0;
      }).length > 0;
    }

    function attr(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs


      for (let i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (const attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }

      return this;
    }

    function removeAttr(attr) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }

      return this;
    }

    function transform(transform) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }

      return this;
    }

    function transition(duration) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
      }

      return this;
    }

    function on(...args) {
      let [eventType, targetSelector, listener, capture] = args;

      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }

      if (!capture) capture = false;

      function handleLiveEvent(e) {
        const target = e.target;
        if (!target) return;
        const eventData = e.target.dom7EventData || [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
          const parents = $(target).parents(); // eslint-disable-line

          for (let k = 0; k < parents.length; k += 1) {
            if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
          }
        }
      }

      function handleEvent(e) {
        const eventData = e && e.target ? e.target.dom7EventData || [] : [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        listener.apply(this, eventData);
      }

      const events = eventType.split(' ');
      let j;

      for (let i = 0; i < this.length; i += 1) {
        const el = this[i];

        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener,
              proxyListener: handleEvent
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
            el.dom7LiveListeners[event].push({
              listener,
              proxyListener: handleLiveEvent
            });
            el.addEventListener(event, handleLiveEvent, capture);
          }
        }
      }

      return this;
    }

    function off(...args) {
      let [eventType, targetSelector, listener, capture] = args;

      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }

      if (!capture) capture = false;
      const events = eventType.split(' ');

      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];

        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];
          let handlers;

          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }

          if (handlers && handlers.length) {
            for (let k = handlers.length - 1; k >= 0; k -= 1) {
              const handler = handlers[k];

              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }

      return this;
    }

    function trigger(...args) {
      const window = getWindow();
      const events = args[0].split(' ');
      const eventData = args[1];

      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];

        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];

          if (window.CustomEvent) {
            const evt = new window.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }

      return this;
    }

    function transitionEnd(callback) {
      const dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }

      if (callback) {
        dom.on('transitionend', fireCallBack);
      }

      return this;
    }

    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles = this.styles();
          return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
        }

        return this[0].offsetWidth;
      }

      return null;
    }

    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles = this.styles();
          return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
        }

        return this[0].offsetHeight;
      }

      return null;
    }

    function offset() {
      if (this.length > 0) {
        const window = getWindow();
        const document = getDocument();
        const el = this[0];
        const box = el.getBoundingClientRect();
        const body = document.body;
        const clientTop = el.clientTop || body.clientTop || 0;
        const clientLeft = el.clientLeft || body.clientLeft || 0;
        const scrollTop = el === window ? window.scrollY : el.scrollTop;
        const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }

      return null;
    }

    function styles() {
      const window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }

    function css(props, value) {
      const window = getWindow();
      let i;

      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (const prop in props) {
              this[i].style[prop] = props[prop];
            }
          }

          return this;
        }
      }

      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }

        return this;
      }

      return this;
    }

    function each(callback) {
      if (!callback) return this;
      this.forEach((el, index) => {
        callback.apply(el, [el, index]);
      });
      return this;
    }

    function filter(callback) {
      const result = arrayFilter(this, callback);
      return $(result);
    }

    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }

      for (let i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }

      return this;
    }

    function text(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }

      for (let i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }

      return this;
    }

    function is(selector) {
      const window = getWindow();
      const document = getDocument();
      const el = this[0];
      let compareWith;
      let i;
      if (!el || typeof selector === 'undefined') return false;

      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $(selector);

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      if (selector === document) {
        return el === document;
      }

      if (selector === window) {
        return el === window;
      }

      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      return false;
    }

    function index() {
      let child = this[0];
      let i;

      if (child) {
        i = 0; // eslint-disable-next-line

        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }

        return i;
      }

      return undefined;
    }

    function eq(index) {
      if (typeof index === 'undefined') return this;
      const length = this.length;

      if (index > length - 1) {
        return $([]);
      }

      if (index < 0) {
        const returnIndex = length + index;
        if (returnIndex < 0) return $([]);
        return $([this[returnIndex]]);
      }

      return $([this[index]]);
    }

    function append(...els) {
      let newChild;
      const document = getDocument();

      for (let k = 0; k < els.length; k += 1) {
        newChild = els[k];

        for (let i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (let j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }

      return this;
    }

    function prepend(newChild) {
      const document = getDocument();
      let i;
      let j;

      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    }

    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return $([this[0].nextElementSibling]);
          }

          return $([]);
        }

        if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function nextAll(selector) {
      const nextEls = [];
      let el = this[0];
      if (!el) return $([]);

      while (el.nextElementSibling) {
        const next = el.nextElementSibling; // eslint-disable-line

        if (selector) {
          if ($(next).is(selector)) nextEls.push(next);
        } else nextEls.push(next);

        el = next;
      }

      return $(nextEls);
    }

    function prev(selector) {
      if (this.length > 0) {
        const el = this[0];

        if (selector) {
          if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
            return $([el.previousElementSibling]);
          }

          return $([]);
        }

        if (el.previousElementSibling) return $([el.previousElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function prevAll(selector) {
      const prevEls = [];
      let el = this[0];
      if (!el) return $([]);

      while (el.previousElementSibling) {
        const prev = el.previousElementSibling; // eslint-disable-line

        if (selector) {
          if ($(prev).is(selector)) prevEls.push(prev);
        } else prevEls.push(prev);

        el = prev;
      }

      return $(prevEls);
    }

    function parent(selector) {
      const parents = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $(parents);
    }

    function parents(selector) {
      const parents = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        let parent = this[i].parentNode; // eslint-disable-line

        while (parent) {
          if (selector) {
            if ($(parent).is(selector)) parents.push(parent);
          } else {
            parents.push(parent);
          }

          parent = parent.parentNode;
        }
      }

      return $(parents);
    }

    function closest(selector) {
      let closest = this; // eslint-disable-line

      if (typeof selector === 'undefined') {
        return $([]);
      }

      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }

      return closest;
    }

    function find(selector) {
      const foundElements = [];

      for (let i = 0; i < this.length; i += 1) {
        const found = this[i].querySelectorAll(selector);

        for (let j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }

      return $(foundElements);
    }

    function children(selector) {
      const children = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        const childNodes = this[i].children;

        for (let j = 0; j < childNodes.length; j += 1) {
          if (!selector || $(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }

      return $(children);
    }

    function remove() {
      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }

      return this;
    }

    const Methods = {
      addClass,
      removeClass,
      hasClass,
      toggleClass,
      attr,
      removeAttr,
      transform,
      transition,
      on,
      off,
      trigger,
      transitionEnd,
      outerWidth,
      outerHeight,
      styles,
      offset,
      css,
      each,
      html,
      text,
      is,
      index,
      eq,
      append,
      prepend,
      next,
      nextAll,
      prev,
      prevAll,
      parent,
      parents,
      closest,
      find,
      children,
      filter,
      remove
    };
    Object.keys(Methods).forEach(methodName => {
      Object.defineProperty($.fn, methodName, {
        value: Methods[methodName],
        writable: true
      });
    });

    function deleteProps(obj) {
      const object = obj;
      Object.keys(object).forEach(key => {
        try {
          object[key] = null;
        } catch (e) {// no getter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    }

    function nextTick(callback, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return setTimeout(callback, delay);
    }

    function now() {
      return Date.now();
    }

    function getComputedStyle$1(el) {
      const window = getWindow();
      let style;

      if (window.getComputedStyle) {
        style = window.getComputedStyle(el, null);
      }

      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }

      if (!style) {
        style = el.style;
      }

      return style;
    }

    function getTranslate(el, axis) {
      if (axis === void 0) {
        axis = 'x';
      }

      const window = getWindow();
      let matrix;
      let curTransform;
      let transformMatrix;
      const curStyle = getComputedStyle$1(el);

      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
        else curTransform = parseFloat(matrix[4]);
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
        else curTransform = parseFloat(matrix[5]);
      }

      return curTransform || 0;
    }

    function isObject$1(o) {
      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }

    function isNode(node) {
      // eslint-disable-next-line
      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
      }

      return node && (node.nodeType === 1 || node.nodeType === 11);
    }

    function extend$1() {
      const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
      const noExtend = ['__proto__', 'constructor', 'prototype'];

      for (let i = 1; i < arguments.length; i += 1) {
        const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
          const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);

          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            const nextKey = keysArray[nextIndex];
            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                to[nextKey] = {};

                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }

    function setCSSProperty(el, varName, varValue) {
      el.style.setProperty(varName, varValue);
    }

    function animateCSSModeScroll(_ref) {
      let {
        swiper,
        targetPosition,
        side
      } = _ref;
      const window = getWindow();
      const startPosition = -swiper.translate;
      let startTime = null;
      let time;
      const duration = swiper.params.speed;
      swiper.wrapperEl.style.scrollSnapType = 'none';
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      const dir = targetPosition > startPosition ? 'next' : 'prev';

      const isOutOfBound = (current, target) => {
        return dir === 'next' && current >= target || dir === 'prev' && current <= target;
      };

      const animate = () => {
        time = new Date().getTime();

        if (startTime === null) {
          startTime = time;
        }

        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);

        if (isOutOfBound(currentPosition, targetPosition)) {
          currentPosition = targetPosition;
        }

        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });

        if (isOutOfBound(currentPosition, targetPosition)) {
          swiper.wrapperEl.style.overflow = 'hidden';
          swiper.wrapperEl.style.scrollSnapType = '';
          setTimeout(() => {
            swiper.wrapperEl.style.overflow = '';
            swiper.wrapperEl.scrollTo({
              [side]: currentPosition
            });
          });
          window.cancelAnimationFrame(swiper.cssModeFrameID);
          return;
        }

        swiper.cssModeFrameID = window.requestAnimationFrame(animate);
      };

      animate();
    }

    let support;

    function calcSupport() {
      const window = getWindow();
      const document = getDocument();
      return {
        smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
        passiveListener: function checkPassiveListener() {
          let supportsPassive = false;

          try {
            const opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get() {
                supportsPassive = true;
              }

            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {// No support
          }

          return supportsPassive;
        }(),
        gestures: function checkGestures() {
          return 'ongesturestart' in window;
        }()
      };
    }

    function getSupport() {
      if (!support) {
        support = calcSupport();
      }

      return support;
    }

    let deviceCached;

    function calcDevice(_temp) {
      let {
        userAgent
      } = _temp === void 0 ? {} : _temp;
      const support = getSupport();
      const window = getWindow();
      const platform = window.navigator.platform;
      const ua = userAgent || window.navigator.userAgent;
      const device = {
        ios: false,
        android: false
      };
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      const windows = platform === 'Win32';
      let macos = platform === 'MacIntel'; // iPadOs 13 fix

      const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

      if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      } // Android


      if (android && !windows) {
        device.os = 'android';
        device.android = true;
      }

      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // Export object


      return device;
    }

    function getDevice(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }

      if (!deviceCached) {
        deviceCached = calcDevice(overrides);
      }

      return deviceCached;
    }

    let browser;

    function calcBrowser() {
      const window = getWindow();

      function isSafari() {
        const ua = window.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }

      return {
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
      };
    }

    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }

      return browser;
    }

    function Resize(_ref) {
      let {
        swiper,
        on,
        emit
      } = _ref;
      const window = getWindow();
      let observer = null;
      let animationFrame = null;

      const resizeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('beforeResize');
        emit('resize');
      };

      const createObserver = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        observer = new ResizeObserver(entries => {
          animationFrame = window.requestAnimationFrame(() => {
            const {
              width,
              height
            } = swiper;
            let newWidth = width;
            let newHeight = height;
            entries.forEach(_ref2 => {
              let {
                contentBoxSize,
                contentRect,
                target
              } = _ref2;
              if (target && target !== swiper.el) return;
              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
            });

            if (newWidth !== width || newHeight !== height) {
              resizeHandler();
            }
          });
        });
        observer.observe(swiper.el);
      };

      const removeObserver = () => {
        if (animationFrame) {
          window.cancelAnimationFrame(animationFrame);
        }

        if (observer && observer.unobserve && swiper.el) {
          observer.unobserve(swiper.el);
          observer = null;
        }
      };

      const orientationChangeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('orientationchange');
      };

      on('init', () => {
        if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
          createObserver();
          return;
        }

        window.addEventListener('resize', resizeHandler);
        window.addEventListener('orientationchange', orientationChangeHandler);
      });
      on('destroy', () => {
        removeObserver();
        window.removeEventListener('resize', resizeHandler);
        window.removeEventListener('orientationchange', orientationChangeHandler);
      });
    }

    function Observer(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      const observers = [];
      const window = getWindow();

      const attach = function (target, options) {
        if (options === void 0) {
          options = {};
        }

        const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
        const observer = new ObserverFunc(mutations => {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            emit('observerUpdate', mutations[0]);
            return;
          }

          const observerUpdate = function observerUpdate() {
            emit('observerUpdate', mutations[0]);
          };

          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(observerUpdate);
          } else {
            window.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData
        });
        observers.push(observer);
      };

      const init = () => {
        if (!swiper.params.observer) return;

        if (swiper.params.observeParents) {
          const containerParents = swiper.$el.parents();

          for (let i = 0; i < containerParents.length; i += 1) {
            attach(containerParents[i]);
          }
        } // Observe container


        attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren
        }); // Observe wrapper

        attach(swiper.$wrapperEl[0], {
          attributes: false
        });
      };

      const destroy = () => {
        observers.forEach(observer => {
          observer.disconnect();
        });
        observers.splice(0, observers.length);
      };

      extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false
      });
      on('init', init);
      on('destroy', destroy);
    }

    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
      on(events, handler, priority) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(event => {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      },

      once(events, handler, priority) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (typeof handler !== 'function') return self;

        function onceHandler() {
          self.off(events, onceHandler);

          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          handler.apply(self, args);
        }

        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
      },

      onAny(handler, priority) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';

        if (self.eventsAnyListeners.indexOf(handler) < 0) {
          self.eventsAnyListeners[method](handler);
        }

        return self;
      },

      offAny(handler) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (!self.eventsAnyListeners) return self;
        const index = self.eventsAnyListeners.indexOf(handler);

        if (index >= 0) {
          self.eventsAnyListeners.splice(index, 1);
        }

        return self;
      },

      off(events, handler) {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(event => {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach((eventHandler, index) => {
              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      },

      emit() {
        const self = this;
        if (!self.eventsListeners || self.destroyed) return self;
        if (!self.eventsListeners) return self;
        let events;
        let data;
        let context;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }

        data.unshift(context);
        const eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(event => {
          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
            self.eventsAnyListeners.forEach(eventHandler => {
              eventHandler.apply(context, [event, ...data]);
            });
          }

          if (self.eventsListeners && self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(eventHandler => {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      }

    };

    function updateSize() {
      const swiper = this;
      let width;
      let height;
      const $el = swiper.$el;

      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }

      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }

      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
      } // Subtract paddings


      width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
      height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
      Object.assign(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height
      });
    }

    function updateSlides() {
      const swiper = this;

      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
          return property;
        } // prettier-ignore


        return {
          'width': 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          'marginRight': 'marginBottom'
        }[property];
      }

      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }

      const params = swiper.params;
      const {
        $wrapperEl,
        size: swiperSize,
        rtlTranslate: rtl,
        wrongRTL
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      let snapGrid = [];
      const slidesGrid = [];
      const slidesSizesGrid = [];
      let offsetBefore = params.slidesOffsetBefore;

      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }

      let offsetAfter = params.slidesOffsetAfter;

      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }

      const previousSnapGridLength = swiper.snapGrid.length;
      const previousSlidesGridLength = swiper.slidesGrid.length;
      let spaceBetween = params.spaceBetween;
      let slidePosition = -offsetBefore;
      let prevSlideSize = 0;
      let index = 0;

      if (typeof swiperSize === 'undefined') {
        return;
      }

      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
      }

      swiper.virtualSize = -spaceBetween; // reset margins

      if (rtl) slides.css({
        marginLeft: '',
        marginBottom: '',
        marginTop: ''
      });else slides.css({
        marginRight: '',
        marginBottom: '',
        marginTop: ''
      }); // reset cssMode offsets

      if (params.centeredSlides && params.cssMode) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
      }

      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;

      if (gridEnabled) {
        swiper.grid.initSlides(slidesLength);
      } // Calc slides


      let slideSize;
      const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
        return typeof params.breakpoints[key].slidesPerView !== 'undefined';
      }).length > 0;

      for (let i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        const slide = slides.eq(i);

        if (gridEnabled) {
          swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
        }

        if (slide.css('display') === 'none') continue; // eslint-disable-line

        if (params.slidesPerView === 'auto') {
          if (shouldResetSlideSize) {
            slides[i].style[getDirectionLabel('width')] = ``;
          }

          const slideStyles = getComputedStyle(slide[0]);
          const currentTransform = slide[0].style.transform;
          const currentWebKitTransform = slide[0].style.webkitTransform;

          if (currentTransform) {
            slide[0].style.transform = 'none';
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = 'none';
          }

          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            const width = getDirectionPropertyValue(slideStyles, 'width');
            const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
            const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
            const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
            const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
            const boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              const {
                clientWidth,
                offsetWidth
              } = slide[0];
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }

          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }

          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);

          if (slides[i]) {
            slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
          }
        }

        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }

        slidesSizesGrid.push(slideSize);

        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }

        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
      }

      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;

      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({
          width: `${swiper.virtualSize + params.spaceBetween}px`
        });
      }

      if (params.setWrapperSize) {
        $wrapperEl.css({
          [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
        });
      }

      if (gridEnabled) {
        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
      } // Remove last grid elements depending on width


      if (!params.centeredSlides) {
        const newSlidesGrid = [];

        for (let i = 0; i < snapGrid.length; i += 1) {
          let slidesGridItem = snapGrid[i];
          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);

          if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(slidesGridItem);
          }
        }

        snapGrid = newSlidesGrid;

        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }

      if (snapGrid.length === 0) snapGrid = [0];

      if (params.spaceBetween !== 0) {
        const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
        slides.filter((_, slideIndex) => {
          if (!params.cssMode) return true;

          if (slideIndex === slides.length - 1) {
            return false;
          }

          return true;
        }).css({
          [key]: `${spaceBetween}px`
        });
      }

      if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach(slideSizeValue => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        const maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(snap => {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }

      if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach(slideSizeValue => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;

        if (allSlidesSize < swiperSize) {
          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
          snapGrid.forEach((snap, snapIndex) => {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach((snap, snapIndex) => {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }

      Object.assign(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid
      });

      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
        const addToSnapGrid = -swiper.snapGrid[0];
        const addToSlidesGrid = -swiper.slidesGrid[0];
        swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
        swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
      }

      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }

      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }

      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }

      if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
      }

      if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
        const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);

        if (slidesLength <= params.maxBackfaceHiddenSlides) {
          if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
        } else if (hasClassBackfaceClassAdded) {
          swiper.$el.removeClass(backFaceHiddenClass);
        }
      }
    }

    function updateAutoHeight(speed) {
      const swiper = this;
      const activeSlides = [];
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      let newHeight = 0;
      let i;

      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }

      const getSlideByIndex = index => {
        if (isVirtual) {
          return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
        }

        return swiper.slides.eq(index)[0];
      }; // Find slides currently in view


      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          (swiper.visibleSlides || $([])).each(slide => {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            const index = swiper.activeIndex + i;
            if (index > swiper.slides.length && !isVirtual) break;
            activeSlides.push(getSlideByIndex(index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      } // Find new height from highest slide in view


      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          const height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      } // Update Height


      if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);
    }

    function updateSlidesOffset() {
      const swiper = this;
      const slides = swiper.slides;

      for (let i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
      }
    }

    function updateSlidesProgress(translate) {
      if (translate === void 0) {
        translate = this && this.translate || 0;
      }

      const swiper = this;
      const params = swiper.params;
      const {
        slides,
        rtlTranslate: rtl,
        snapGrid
      } = swiper;
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
      let offsetCenter = -translate;
      if (rtl) offsetCenter = translate; // Visible Slides

      slides.removeClass(params.slideVisibleClass);
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];

      for (let i = 0; i < slides.length; i += 1) {
        const slide = slides[i];
        let slideOffset = slide.swiperSlideOffset;

        if (params.cssMode && params.centeredSlides) {
          slideOffset -= slides[0].swiperSlideOffset;
        }

        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        const slideBefore = -(offsetCenter - slideOffset);
        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

        if (isVisible) {
          swiper.visibleSlides.push(slide);
          swiper.visibleSlidesIndexes.push(i);
          slides.eq(i).addClass(params.slideVisibleClass);
        }

        slide.progress = rtl ? -slideProgress : slideProgress;
        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
      }

      swiper.visibleSlides = $(swiper.visibleSlides);
    }

    function updateProgress(translate) {
      const swiper = this;

      if (typeof translate === 'undefined') {
        const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
      }

      const params = swiper.params;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      let {
        progress,
        isBeginning,
        isEnd
      } = swiper;
      const wasBeginning = isBeginning;
      const wasEnd = isEnd;

      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }

      Object.assign(swiper, {
        progress,
        isBeginning,
        isEnd
      });
      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }

      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }

      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit('fromEdge');
      }

      swiper.emit('progress', progress);
    }

    function updateSlidesClasses() {
      const swiper = this;
      const {
        slides,
        params,
        $wrapperEl,
        activeIndex,
        realIndex
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
      let activeSlide;

      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
      } else {
        activeSlide = slides.eq(activeIndex);
      } // Active classes


      activeSlide.addClass(params.slideActiveClass);

      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        }
      } // Next Slide


      let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);

      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      } // Prev Slide


      let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);

      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }

      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
        }

        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
        }
      }

      swiper.emitSlidesClasses();
    }

    function updateActiveIndex(newActiveIndex) {
      const swiper = this;
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      const {
        slidesGrid,
        snapGrid,
        params,
        activeIndex: previousIndex,
        realIndex: previousRealIndex,
        snapIndex: previousSnapIndex
      } = swiper;
      let activeIndex = newActiveIndex;
      let snapIndex;

      if (typeof activeIndex === 'undefined') {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        } // Normalize slideIndex


        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }

      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }

      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }

        return;
      } // Get real index


      const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
      Object.assign(swiper, {
        snapIndex,
        realIndex,
        previousIndex,
        activeIndex
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');

      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }

      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }

    function updateClickedSlide(e) {
      const swiper = this;
      const params = swiper.params;
      const slide = $(e).closest(`.${params.slideClass}`)[0];
      let slideFound = false;
      let slideIndex;

      if (slide) {
        for (let i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) {
            slideFound = true;
            slideIndex = i;
            break;
          }
        }
      }

      if (slide && slideFound) {
        swiper.clickedSlide = slide;

        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }

      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }

    var update = {
      updateSize,
      updateSlides,
      updateAutoHeight,
      updateSlidesOffset,
      updateSlidesProgress,
      updateProgress,
      updateSlidesClasses,
      updateActiveIndex,
      updateClickedSlide
    };

    function getSwiperTranslate(axis) {
      if (axis === void 0) {
        axis = this.isHorizontal() ? 'x' : 'y';
      }

      const swiper = this;
      const {
        params,
        rtlTranslate: rtl,
        translate,
        $wrapperEl
      } = swiper;

      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }

      if (params.cssMode) {
        return translate;
      }

      let currentTranslate = getTranslate($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }

    function setTranslate(translate, byController) {
      const swiper = this;
      const {
        rtlTranslate: rtl,
        params,
        $wrapperEl,
        wrapperEl,
        progress
      } = swiper;
      let x = 0;
      let y = 0;
      const z = 0;

      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }

      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }

      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
      }

      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }

      swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate() {
      return -this.snapGrid[0];
    }

    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }

    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
      if (translate === void 0) {
        translate = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (translateBounds === void 0) {
        translateBounds = true;
      }

      const swiper = this;
      const {
        params,
        wrapperEl
      } = swiper;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }

      const minTranslate = swiper.minTranslate();
      const maxTranslate = swiper.maxTranslate();
      let newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

      swiper.updateProgress(newTranslate);

      if (params.cssMode) {
        const isH = swiper.isHorizontal();

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper,
              targetPosition: -newTranslate,
              side: isH ? 'left' : 'top'
            });
            return true;
          }

          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: -newTranslate,
            behavior: 'smooth'
          });
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;

              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
        }
      }

      return true;
    }

    var translate = {
      getTranslate: getSwiperTranslate,
      setTranslate,
      minTranslate,
      maxTranslate,
      translateTo
    };

    function setTransition(duration, byController) {
      const swiper = this;

      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }

      swiper.emit('setTransition', duration, byController);
    }

    function transitionEmit(_ref) {
      let {
        swiper,
        runCallbacks,
        direction,
        step
      } = _ref;
      const {
        activeIndex,
        previousIndex
      } = swiper;
      let dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }

      swiper.emit(`transition${step}`);

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit(`slideResetTransition${step}`);
          return;
        }

        swiper.emit(`slideChangeTransition${step}`);

        if (dir === 'next') {
          swiper.emit(`slideNextTransition${step}`);
        } else {
          swiper.emit(`slidePrevTransition${step}`);
        }
      }
    }

    function transitionStart(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      const swiper = this;
      const {
        params
      } = swiper;
      if (params.cssMode) return;

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: 'Start'
      });
    }

    function transitionEnd$1(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      const swiper = this;
      const {
        params
      } = swiper;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
      transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: 'End'
      });
    }

    var transition$1 = {
      setTransition,
      transitionStart,
      transitionEnd: transitionEnd$1
    };

    function slideTo(index, speed, runCallbacks, internal, initial) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (typeof index !== 'number' && typeof index !== 'string') {
        throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
      }

      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        const indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        const isValidNumber = isFinite(indexAsNumber);

        if (!isValidNumber) {
          throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.


        index = indexAsNumber;
      }

      const swiper = this;
      let slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
      const {
        params,
        snapGrid,
        slidesGrid,
        previousIndex,
        activeIndex,
        rtlTranslate: rtl,
        wrapperEl,
        enabled
      } = swiper;

      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
      }

      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }

      const translate = -snapGrid[snapIndex]; // Update progress

      swiper.updateProgress(translate); // Normalize slideIndex

      if (params.normalizeSlideIndex) {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          const normalizedTranslate = -Math.floor(translate * 100);
          const normalizedGrid = Math.floor(slidesGrid[i] * 100);
          const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
              slideIndex = i;
            } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
              slideIndex = i + 1;
            }
          } else if (normalizedTranslate >= normalizedGrid) {
            slideIndex = i;
          }
        }
      } // Directions locks


      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
          return false;
        }

        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }

      let direction;
      if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
        swiper.updateActiveIndex(slideIndex); // Update Height

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }

        swiper.updateSlidesClasses();

        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }

        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }

        return false;
      }

      if (params.cssMode) {
        const isH = swiper.isHorizontal();
        const t = rtl ? translate : -translate;

        if (speed === 0) {
          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

          if (isVirtual) {
            swiper.wrapperEl.style.scrollSnapType = 'none';
            swiper._immediateVirtual = true;
          }

          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;

          if (isVirtual) {
            requestAnimationFrame(() => {
              swiper.wrapperEl.style.scrollSnapType = '';
              swiper._swiperImmediateVirtual = false;
            });
          }
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper,
              targetPosition: t,
              side: isH ? 'left' : 'top'
            });
            return true;
          }

          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: t,
            behavior: 'smooth'
          });
        }

        return true;
      }

      swiper.setTransition(speed);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);

      if (speed === 0) {
        swiper.transitionEnd(runCallbacks, direction);
      } else if (!swiper.animating) {
        swiper.animating = true;

        if (!swiper.onSlideToWrapperTransitionEnd) {
          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
          };
        }

        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
      }

      return true;
    }

    function slideToLoop(index, speed, runCallbacks, internal) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        const indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        const isValidNumber = isFinite(indexAsNumber);

        if (!isValidNumber) {
          throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.


        index = indexAsNumber;
      }

      const swiper = this;
      let newIndex = index;

      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }

      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      const swiper = this;
      const {
        animating,
        enabled,
        params
      } = swiper;
      if (!enabled) return swiper;
      let perGroup = params.slidesPerGroup;

      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
      }

      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      if (params.rewind && swiper.isEnd) {
        return swiper.slideTo(0, speed, runCallbacks, internal);
      }

      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      const swiper = this;
      const {
        params,
        animating,
        snapGrid,
        slidesGrid,
        rtlTranslate,
        enabled
      } = swiper;
      if (!enabled) return swiper;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      const translate = rtlTranslate ? swiper.translate : -swiper.translate;

      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }

      const normalizedTranslate = normalize(translate);
      const normalizedSnapGrid = snapGrid.map(val => normalize(val));
      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

      if (typeof prevSnap === 'undefined' && params.cssMode) {
        let prevSnapIndex;
        snapGrid.forEach((snap, snapIndex) => {
          if (normalizedTranslate >= snap) {
            // prevSnap = snap;
            prevSnapIndex = snapIndex;
          }
        });

        if (typeof prevSnapIndex !== 'undefined') {
          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
        }
      }

      let prevIndex = 0;

      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;

        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
          prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
          prevIndex = Math.max(prevIndex, 0);
        }
      }

      if (params.rewind && swiper.isBeginning) {
        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
      }

      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      const swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed, runCallbacks, internal, threshold) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (threshold === void 0) {
        threshold = 0.5;
      }

      const swiper = this;
      let index = swiper.activeIndex;
      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        const currentSnap = swiper.snapGrid[snapIndex];
        const nextSnap = swiper.snapGrid[snapIndex + 1];

        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        const prevSnap = swiper.snapGrid[snapIndex - 1];
        const currentSnap = swiper.snapGrid[snapIndex];

        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }

      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index, speed, runCallbacks, internal);
    }

    function slideToClickedSlide() {
      const swiper = this;
      const {
        params,
        $wrapperEl
      } = swiper;
      const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      let slideToIndex = swiper.clickedIndex;
      let realIndex;

      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
            nextTick(() => {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }

    var slide = {
      slideTo,
      slideToLoop,
      slideNext,
      slidePrev,
      slideReset,
      slideToClosest,
      slideToClickedSlide
    };

    function loopCreate() {
      const swiper = this;
      const document = getDocument();
      const {
        params,
        $wrapperEl
      } = swiper; // Remove duplicated slides

      const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
      $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
      let slides = $selector.children(`.${params.slideClass}`);

      if (params.loopFillGroupWithBlank) {
        const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

        if (blankSlidesNum !== params.slidesPerGroup) {
          for (let i = 0; i < blankSlidesNum; i += 1) {
            const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
            $selector.append(blankNode);
          }

          slides = $selector.children(`.${params.slideClass}`);
        }
      }

      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;

      if (swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit) {
        swiper.loopedSlides = slides.length;
      }

      const prependSlides = [];
      const appendSlides = [];
      slides.each((el, index) => {
        $(el).attr('data-swiper-slide-index', index);
      });

      for (let i = 0; i < swiper.loopedSlides; i += 1) {
        const index = i - Math.floor(i / slides.length) * slides.length;
        appendSlides.push(slides.eq(index)[0]);
        prependSlides.unshift(slides.eq(slides.length - index - 1)[0]);
      }

      for (let i = 0; i < appendSlides.length; i += 1) {
        $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }

      for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
        $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }

    function loopFix() {
      const swiper = this;
      swiper.emit('beforeLoopFix');
      const {
        activeIndex,
        slides,
        loopedSlides,
        allowSlidePrev,
        allowSlideNext,
        snapGrid,
        rtlTranslate: rtl
      } = swiper;
      let newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      const snapTranslate = -snapGrid[activeIndex];
      const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }

      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit('loopFix');
    }

    function loopDestroy() {
      const swiper = this;
      const {
        $wrapperEl,
        params,
        slides
      } = swiper;
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
      slides.removeAttr('data-swiper-slide-index');
    }

    var loop = {
      loopCreate,
      loopFix,
      loopDestroy
    };

    function setGrabCursor(moving) {
      const swiper = this;
      if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
      const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
      el.style.cursor = 'move';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor() {
      const swiper = this;

      if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
      }

      swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    }

    var grabCursor = {
      setGrabCursor,
      unsetGrabCursor
    };

    function closestElement(selector, base) {
      if (base === void 0) {
        base = this;
      }

      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        const found = el.closest(selector);

        if (!found && !el.getRootNode) {
          return null;
        }

        return found || __closestFrom(el.getRootNode().host);
      }

      return __closestFrom(base);
    }

    function onTouchStart(event) {
      const swiper = this;
      const document = getDocument();
      const window = getWindow();
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        enabled
      } = swiper;
      if (!enabled) return;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }

      if (!swiper.animating && params.cssMode && params.loop) {
        swiper.loopFix();
      }

      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      let $targetEl = $(e.target);

      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }

      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return; // change target el for shadow root component

      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

      if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
        $targetEl = $(event.path[0]);
      }

      const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
      const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
        swiper.allowClick = true;
        return;
      }

      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }

      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      const startX = touches.currentX;
      const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === 'prevent') {
          event.preventDefault();
        } else {
          return;
        }
      }

      Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;

      if (e.type !== 'touchstart') {
        let preventDefault = true;

        if ($targetEl.is(data.focusableElements)) {
          preventDefault = false;

          if ($targetEl[0].nodeName === 'SELECT') {
            data.isTouched = false;
          }
        }

        if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
          document.activeElement.blur();
        }

        const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
          e.preventDefault();
        }
      }

      if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
        swiper.freeMode.onTouchStart();
      }

      swiper.emit('touchStart', e);
    }

    function onTouchMove(event) {
      const document = getDocument();
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        enabled
      } = swiper;
      if (!enabled) return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }

        return;
      }

      if (data.isTouchEvent && e.type !== 'touchmove') return;
      const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }

      if (!swiper.allowTouchMove) {
        if (!$(e.target).is(data.focusableElements)) {
          swiper.allowClick = false;
        }

        if (data.isTouched) {
          Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY
          });
          data.touchStartTime = now();
        }

        return;
      }

      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
          return;
        }
      }

      if (data.isTouchEvent && document.activeElement) {
        if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }

      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }

      if (e.targetTouches && e.targetTouches.length > 1) return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      const diffX = touches.currentX - touches.startX;
      const diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

      if (typeof data.isScrolling === 'undefined') {
        let touchAngle;

        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }

      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }

      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }

      if (!data.startMoving) {
        return;
      }

      swiper.allowClick = false;

      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }

      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }

      if (!data.isMoved) {
        if (params.loop && !params.cssMode) {
          swiper.loopFix();
        }

        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);

        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }

        data.allowMomentumBounce = false; // Grab Cursor

        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }

        swiper.emit('sliderFirstMove', e);
      }

      swiper.emit('sliderMove', e);
      data.isMoved = true;
      let diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) diff = -diff;
      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;
      let disableParentSwiper = true;
      let resistanceRatio = params.resistanceRatio;

      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }

      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }

      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      } // Directions locks


      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      } // Threshold


      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }

      if (!params.followFinger || params.cssMode) return; // Update active index in free mode

      if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
        swiper.freeMode.onTouchMove();
      } // Update progress


      swiper.updateProgress(data.currentTranslate); // Update translate

      swiper.setTranslate(data.currentTranslate);
    }

    function onTouchEnd(event) {
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        slidesGrid,
        enabled
      } = swiper;
      if (!enabled) return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }

      data.allowTouchCallbacks = false;

      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }

        data.isMoved = false;
        data.startMoving = false;
        return;
      } // Return Grab Cursor


      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      } // Time diff


      const touchEndTime = now();
      const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

      if (swiper.allowClick) {
        const pathTree = e.path || e.composedPath && e.composedPath();
        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
        swiper.emit('tap click', e);

        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }

      data.lastClickTime = now();
      nextTick(() => {
        if (!swiper.destroyed) swiper.allowClick = true;
      });

      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }

      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      let currentPos;

      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }

      if (params.cssMode) {
        return;
      }

      if (swiper.params.freeMode && params.freeMode.enabled) {
        swiper.freeMode.onTouchEnd({
          currentPos
        });
        return;
      } // Find current slide


      let stopIndex = 0;
      let groupSize = swiper.slidesSizesGrid[0];

      for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

        if (typeof slidesGrid[i + increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      }

      let rewindFirstIndex = null;
      let rewindLastIndex = null;

      if (params.rewind) {
        if (swiper.isBeginning) {
          rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        } else if (swiper.isEnd) {
          rewindFirstIndex = 0;
        }
      } // Find current slide size


      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
        }

        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) {
            swiper.slideTo(stopIndex + increment);
          } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
            swiper.slideTo(rewindLastIndex);
          } else {
            swiper.slideTo(stopIndex);
          }
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
          }

          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }

    function onResize() {
      const swiper = this;
      const {
        params,
        el
      } = swiper;
      if (el && el.offsetWidth === 0) return; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      } // Save locks


      const {
        allowSlideNext,
        allowSlidePrev,
        snapGrid
      } = swiper; // Disable locks on resize

      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();

      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      } // Return locks after resize


      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;

      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }

    function onClick(e) {
      const swiper = this;
      if (!swiper.enabled) return;

      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();

        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }

    function onScroll() {
      const swiper = this;
      const {
        wrapperEl,
        rtlTranslate,
        enabled
      } = swiper;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;

      if (swiper.isHorizontal()) {
        swiper.translate = -wrapperEl.scrollLeft;
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      } // eslint-disable-next-line


      if (swiper.translate === 0) swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }

      swiper.emit('setTranslate', swiper.translate, false);
    }

    let dummyEventAttached = false;

    function dummyEventListener() {}

    const events = (swiper, method) => {
      const document = getDocument();
      const {
        params,
        touchEvents,
        el,
        wrapperEl,
        device,
        support
      } = swiper;
      const capture = !!params.nested;
      const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
      const swiperMethod = method; // Touch Events

      if (!support.touch) {
        el[domMethod](touchEvents.start, swiper.onTouchStart, false);
        document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
        document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
      } else {
        const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
        el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
          passive: false,
          capture
        } : capture);
        el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);

        if (touchEvents.cancel) {
          el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        el[domMethod]('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl[domMethod]('scroll', swiper.onScroll);
      } // Resize handler


      if (params.updateOnWindowResize) {
        swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
      } else {
        swiper[swiperMethod]('observerUpdate', onResize, true);
      }
    };

    function attachEvents() {
      const swiper = this;
      const document = getDocument();
      const {
        params,
        support
      } = swiper;
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);

      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }

      swiper.onClick = onClick.bind(swiper);

      if (support.touch && !dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }

      events(swiper, 'on');
    }

    function detachEvents() {
      const swiper = this;
      events(swiper, 'off');
    }

    var events$1 = {
      attachEvents,
      detachEvents
    };

    const isGridEnabled = (swiper, params) => {
      return swiper.grid && params.grid && params.grid.rows > 1;
    };

    function setBreakpoint() {
      const swiper = this;
      const {
        activeIndex,
        initialized,
        loopedSlides = 0,
        params,
        $el
      } = swiper;
      const breakpoints = params.breakpoints;
      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

      const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
      const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
      const breakpointParams = breakpointOnlyParams || swiper.originalParams;
      const wasMultiRow = isGridEnabled(swiper, params);
      const isMultiRow = isGridEnabled(swiper, breakpointParams);
      const wasEnabled = params.enabled;

      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(`${params.containerModifierClass}grid`);

        if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
          $el.addClass(`${params.containerModifierClass}grid-column`);
        }

        swiper.emitContainerClasses();
      } // Toggle navigation, pagination, scrollbar


      ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
        const wasModuleEnabled = params[prop] && params[prop].enabled;
        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;

        if (wasModuleEnabled && !isModuleEnabled) {
          swiper[prop].disable();
        }

        if (!wasModuleEnabled && isModuleEnabled) {
          swiper[prop].enable();
        }
      });
      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      extend$1(swiper.params, breakpointParams);
      const isEnabled = swiper.params.enabled;
      Object.assign(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });

      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }

      swiper.currentBreakpoint = breakpoint;
      swiper.emit('_beforeBreakpoint', breakpointParams);

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }

    function getBreakpoint(breakpoints, base, containerEl) {
      if (base === void 0) {
        base = 'window';
      }

      if (!breakpoints || base === 'container' && !containerEl) return undefined;
      let breakpoint = false;
      const window = getWindow();
      const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
      const points = Object.keys(breakpoints).map(point => {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          const minRatio = parseFloat(point.substr(1));
          const value = currentHeight * minRatio;
          return {
            value,
            point
          };
        }

        return {
          value: point,
          point
        };
      });
      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));

      for (let i = 0; i < points.length; i += 1) {
        const {
          point,
          value
        } = points[i];

        if (base === 'window') {
          if (window.matchMedia(`(min-width: ${value}px)`).matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }

      return breakpoint || 'max';
    }

    var breakpoints = {
      setBreakpoint,
      getBreakpoint
    };

    function prepareClasses(entries, prefix) {
      const resultClasses = [];
      entries.forEach(item => {
        if (typeof item === 'object') {
          Object.keys(item).forEach(classNames => {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === 'string') {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }

    function addClasses() {
      const swiper = this;
      const {
        classNames,
        params,
        rtl,
        $el,
        device,
        support
      } = swiper; // prettier-ignore

      const suffixes = prepareClasses(['initialized', params.direction, {
        'pointer-events': !support.touch
      }, {
        'free-mode': swiper.params.freeMode && params.freeMode.enabled
      }, {
        'autoheight': params.autoHeight
      }, {
        'rtl': rtl
      }, {
        'grid': params.grid && params.grid.rows > 1
      }, {
        'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
      }, {
        'android': device.android
      }, {
        'ios': device.ios
      }, {
        'css-mode': params.cssMode
      }, {
        'centered': params.cssMode && params.centeredSlides
      }, {
        'watch-progress': params.watchSlidesProgress
      }], params.containerModifierClass);
      classNames.push(...suffixes);
      $el.addClass([...classNames].join(' '));
      swiper.emitContainerClasses();
    }

    function removeClasses() {
      const swiper = this;
      const {
        $el,
        classNames
      } = swiper;
      $el.removeClass(classNames.join(' '));
      swiper.emitContainerClasses();
    }

    var classes = {
      addClasses,
      removeClasses
    };

    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
      const window = getWindow();
      let image;

      function onReady() {
        if (callback) callback();
      }

      const isPicture = $(imageEl).parent('picture')[0];

      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new window.Image();
          image.onload = onReady;
          image.onerror = onReady;

          if (sizes) {
            image.sizes = sizes;
          }

          if (srcset) {
            image.srcset = srcset;
          }

          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }

    function preloadImages() {
      const swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');

      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }

      for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
        const imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
      }
    }

    var images = {
      loadImage,
      preloadImages
    };

    function checkOverflow() {
      const swiper = this;
      const {
        isLocked: wasLocked,
        params
      } = swiper;
      const {
        slidesOffsetBefore
      } = params;

      if (slidesOffsetBefore) {
        const lastSlideIndex = swiper.slides.length - 1;
        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
        swiper.isLocked = swiper.size > lastSlideRightEdge;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }

      if (params.allowSlideNext === true) {
        swiper.allowSlideNext = !swiper.isLocked;
      }

      if (params.allowSlidePrev === true) {
        swiper.allowSlidePrev = !swiper.isLocked;
      }

      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
      }

      if (wasLocked !== swiper.isLocked) {
        swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
      }
    }

    var checkOverflow$1 = {
      checkOverflow
    };

    var defaults = {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'wrapper',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: true,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: 'input, select, option, textarea, button, video, label',
      // Overrides
      width: null,
      height: null,
      //
      preventInteractionOnTransition: false,
      // ssr
      userAgent: null,
      url: null,
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      // Autoheight
      autoHeight: false,
      // Set wrapper width
      setWrapperSize: false,
      // Virtual Translate
      virtualTranslate: false,
      // Effects
      effect: 'slide',
      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
      // Breakpoints
      breakpoints: undefined,
      breakpointsBase: 'window',
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: false,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      // in px
      slidesOffsetAfter: 0,
      // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: true,
      // Round length
      roundLengths: false,
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      // Unique Navigation Elements
      uniqueNavElements: true,
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
      // Progress
      watchSlidesProgress: false,
      // Cursor
      grabCursor: false,
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      // Images
      preloadImages: true,
      updateOnImagesReady: true,
      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopedSlidesLimit: true,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
      // rewind
      rewind: false,
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,
      // Passive Listeners
      passiveListeners: true,
      maxBackfaceHiddenSlides: 10,
      // NS
      containerModifierClass: 'swiper-',
      // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',
      // Callbacks
      runCallbacksOnInit: true,
      // Internals
      _emitClasses: false
    };

    function moduleExtendParams(params, allModulesParams) {
      return function extendParams(obj) {
        if (obj === void 0) {
          obj = {};
        }

        const moduleParamName = Object.keys(obj)[0];
        const moduleParams = obj[moduleParamName];

        if (typeof moduleParams !== 'object' || moduleParams === null) {
          extend$1(allModulesParams, obj);
          return;
        }

        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
          params[moduleParamName] = {
            auto: true
          };
        }

        if (!(moduleParamName in params && 'enabled' in moduleParams)) {
          extend$1(allModulesParams, obj);
          return;
        }

        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }

        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }

        if (!params[moduleParamName]) params[moduleParamName] = {
          enabled: false
        };
        extend$1(allModulesParams, obj);
      };
    }

    /* eslint no-param-reassign: "off" */
    const prototypes = {
      eventsEmitter,
      update,
      translate,
      transition: transition$1,
      slide,
      loop,
      grabCursor,
      events: events$1,
      breakpoints,
      checkOverflow: checkOverflow$1,
      classes,
      images
    };
    const extendedDefaults = {};

    class Swiper {
      constructor() {
        let el;
        let params;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
          params = args[0];
        } else {
          [el, params] = args;
        }

        if (!params) params = {};
        params = extend$1({}, params);
        if (el && !params.el) params.el = el;

        if (params.el && $(params.el).length > 1) {
          const swipers = [];
          $(params.el).each(containerEl => {
            const newParams = extend$1({}, params, {
              el: containerEl
            });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        } // Swiper Instance


        const swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
          userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        swiper.modules = [...swiper.__modules__];

        if (params.modules && Array.isArray(params.modules)) {
          swiper.modules.push(...params.modules);
        }

        const allModulesParams = {};
        swiper.modules.forEach(mod => {
          mod({
            swiper,
            extendParams: moduleExtendParams(params, allModulesParams),
            on: swiper.on.bind(swiper),
            once: swiper.once.bind(swiper),
            off: swiper.off.bind(swiper),
            emit: swiper.emit.bind(swiper)
          });
        }); // Extend defaults with modules params

        const swiperParams = extend$1({}, defaults, allModulesParams); // Extend defaults with passed params

        swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend$1({}, swiper.params);
        swiper.passedParams = extend$1({}, params); // add event listeners

        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach(eventName => {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }

        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        } // Save Dom lib


        swiper.$ = $; // Extend Swiper

        Object.assign(swiper, {
          enabled: swiper.params.enabled,
          el,
          // Classes
          classNames: [],
          // Slides
          slides: $(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],

          // isDirection
          isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },

          isVertical() {
            return swiper.params.direction === 'vertical';
          },

          // Indexes
          activeIndex: 0,
          realIndex: 0,
          //
          isBeginning: true,
          isEnd: false,
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
          // Touch Events
          touchEvents: function touchEvents() {
            const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            const desktop = ['pointerdown', 'pointermove', 'pointerup'];
            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3]
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2]
            };
            return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          }(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            focusableElements: swiper.params.focusableElements,
            // Last click time
            lastClickTime: now(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined
          },
          // Clicks
          allowClick: true,
          // Touches
          allowTouchMove: swiper.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          },
          // Images
          imagesToLoad: [],
          imagesLoaded: 0
        });
        swiper.emit('_swiper'); // Init

        if (swiper.params.init) {
          swiper.init();
        } // Return app instance


        return swiper;
      }

      enable() {
        const swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;

        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }

        swiper.emit('enable');
      }

      disable() {
        const swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;

        if (swiper.params.grabCursor) {
          swiper.unsetGrabCursor();
        }

        swiper.emit('disable');
      }

      setProgress(progress, speed) {
        const swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        const min = swiper.minTranslate();
        const max = swiper.maxTranslate();
        const current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      emitContainerClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const cls = swiper.el.className.split(' ').filter(className => {
          return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit('_containerClasses', cls.join(' '));
      }

      getSlideClasses(slideEl) {
        const swiper = this;
        if (swiper.destroyed) return '';
        return slideEl.className.split(' ').filter(className => {
          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(' ');
      }

      emitSlidesClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const updates = [];
        swiper.slides.each(slideEl => {
          const classNames = swiper.getSlideClasses(slideEl);
          updates.push({
            slideEl,
            classNames
          });
          swiper.emit('_slideClass', slideEl, classNames);
        });
        swiper.emit('_slideClasses', updates);
      }

      slidesPerViewDynamic(view, exact) {
        if (view === void 0) {
          view = 'current';
        }

        if (exact === void 0) {
          exact = false;
        }

        const swiper = this;
        const {
          params,
          slides,
          slidesGrid,
          slidesSizesGrid,
          size: swiperSize,
          activeIndex
        } = swiper;
        let spv = 1;

        if (params.centeredSlides) {
          let slideSize = slides[activeIndex].swiperSlideSize;
          let breakLoop;

          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }

          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
        } else {
          // eslint-disable-next-line
          if (view === 'current') {
            for (let i = activeIndex + 1; i < slides.length; i += 1) {
              const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;

              if (slideInView) {
                spv += 1;
              }
            }
          } else {
            // previous
            for (let i = activeIndex - 1; i >= 0; i -= 1) {
              const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;

              if (slideInView) {
                spv += 1;
              }
            }
          }
        }

        return spv;
      }

      update() {
        const swiper = this;
        if (!swiper || swiper.destroyed) return;
        const {
          snapGrid,
          params
        } = swiper; // Breakpoints

        if (params.breakpoints) {
          swiper.setBreakpoint();
        }

        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        function setTranslate() {
          const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        let translated;

        if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
          setTranslate();

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }

          if (!translated) {
            setTranslate();
          }
        }

        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }

        swiper.emit('update');
      }

      changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
          needUpdate = true;
        }

        const swiper = this;
        const currentDirection = swiper.params.direction;

        if (!newDirection) {
          // eslint-disable-next-line
          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }

        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
          return swiper;
        }

        swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each(slideEl => {
          if (newDirection === 'vertical') {
            slideEl.style.width = '';
          } else {
            slideEl.style.height = '';
          }
        });
        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();
        return swiper;
      }

      changeLanguageDirection(direction) {
        const swiper = this;
        if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
        swiper.rtl = direction === 'rtl';
        swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;

        if (swiper.rtl) {
          swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);
          swiper.el.dir = 'rtl';
        } else {
          swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);
          swiper.el.dir = 'ltr';
        }

        swiper.update();
      }

      mount(el) {
        const swiper = this;
        if (swiper.mounted) return true; // Find el

        const $el = $(el || swiper.params.el);
        el = $el[0];

        if (!el) {
          return false;
        }

        el.swiper = swiper;

        const getWrapperSelector = () => {
          return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
        };

        const getWrapper = () => {
          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            const res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

            res.children = options => $el.children(options);

            return res;
          }

          if (!$el.children) {
            return $($el).children(getWrapperSelector());
          }

          return $el.children(getWrapperSelector());
        }; // Find Wrapper


        let $wrapperEl = getWrapper();

        if ($wrapperEl.length === 0 && swiper.params.createElements) {
          const document = getDocument();
          const wrapper = document.createElement('div');
          $wrapperEl = $(wrapper);
          wrapper.className = swiper.params.wrapperClass;
          $el.append(wrapper);
          $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
            $wrapperEl.append(slideEl);
          });
        }

        Object.assign(swiper, {
          $el,
          el,
          $wrapperEl,
          wrapperEl: $wrapperEl[0],
          mounted: true,
          // RTL
          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
          wrongRTL: $wrapperEl.css('display') === '-webkit-box'
        });
        return true;
      }

      init(el) {
        const swiper = this;
        if (swiper.initialized) return swiper;
        const mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit('beforeInit'); // Set breakpoint

        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        } // Add Classes


        swiper.addClasses(); // Create loop

        if (swiper.params.loop) {
          swiper.loopCreate();
        } // Update size


        swiper.updateSize(); // Update slides

        swiper.updateSlides();

        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        } // Set Grab Cursor


        if (swiper.params.grabCursor && swiper.enabled) {
          swiper.setGrabCursor();
        }

        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        } // Slide To Initial Slide


        if (swiper.params.loop) {
          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        } // Attach events


        swiper.attachEvents(); // Init Flag

        swiper.initialized = true; // Emit

        swiper.emit('init');
        swiper.emit('afterInit');
        return swiper;
      }

      destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
          deleteInstance = true;
        }

        if (cleanStyles === void 0) {
          cleanStyles = true;
        }

        const swiper = this;
        const {
          params,
          $el,
          $wrapperEl,
          slides
        } = swiper;

        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
          return null;
        }

        swiper.emit('beforeDestroy'); // Init Flag

        swiper.initialized = false; // Detach events

        swiper.detachEvents(); // Destroy loop

        if (params.loop) {
          swiper.loopDestroy();
        } // Cleanup styles


        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr('style');
          $wrapperEl.removeAttr('style');

          if (slides && slides.length) {
            slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
          }
        }

        swiper.emit('destroy'); // Detach emitter events

        Object.keys(swiper.eventsListeners).forEach(eventName => {
          swiper.off(eventName);
        });

        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          deleteProps(swiper);
        }

        swiper.destroyed = true;
        return null;
      }

      static extendDefaults(newDefaults) {
        extend$1(extendedDefaults, newDefaults);
      }

      static get extendedDefaults() {
        return extendedDefaults;
      }

      static get defaults() {
        return defaults;
      }

      static installModule(mod) {
        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
        const modules = Swiper.prototype.__modules__;

        if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
          modules.push(mod);
        }
      }

      static use(module) {
        if (Array.isArray(module)) {
          module.forEach(m => Swiper.installModule(m));
          return Swiper;
        }

        Swiper.installModule(module);
        return Swiper;
      }

    }

    Object.keys(prototypes).forEach(prototypeGroup => {
      Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    Swiper.use([Resize, Observer]);

    /* eslint-disable consistent-return */
    function Mousewheel(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      const window = getWindow();
      extendParams({
        mousewheel: {
          enabled: false,
          releaseOnEdges: false,
          invert: false,
          forceToAxis: false,
          sensitivity: 1,
          eventsTarget: 'container',
          thresholdDelta: null,
          thresholdTime: null
        }
      });
      swiper.mousewheel = {
        enabled: false
      };
      let timeout;
      let lastScrollTime = now();
      let lastEventBeforeSnap;
      const recentWheelEvents = [];

      function normalize(e) {
        // Reasonable defaults
        const PIXEL_STEP = 10;
        const LINE_HEIGHT = 40;
        const PAGE_HEIGHT = 800;
        let sX = 0;
        let sY = 0; // spinX, spinY

        let pX = 0;
        let pY = 0; // pixelX, pixelY
        // Legacy

        if ('detail' in e) {
          sY = e.detail;
        }

        if ('wheelDelta' in e) {
          sY = -e.wheelDelta / 120;
        }

        if ('wheelDeltaY' in e) {
          sY = -e.wheelDeltaY / 120;
        }

        if ('wheelDeltaX' in e) {
          sX = -e.wheelDeltaX / 120;
        } // side scrolling on FF with DOMMouseScroll


        if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
          sX = sY;
          sY = 0;
        }

        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;

        if ('deltaY' in e) {
          pY = e.deltaY;
        }

        if ('deltaX' in e) {
          pX = e.deltaX;
        }

        if (e.shiftKey && !pX) {
          // if user scrolls with shift he wants horizontal scroll
          pX = pY;
          pY = 0;
        }

        if ((pX || pY) && e.deltaMode) {
          if (e.deltaMode === 1) {
            // delta in LINE units
            pX *= LINE_HEIGHT;
            pY *= LINE_HEIGHT;
          } else {
            // delta in PAGE units
            pX *= PAGE_HEIGHT;
            pY *= PAGE_HEIGHT;
          }
        } // Fall-back if spin cannot be determined


        if (pX && !sX) {
          sX = pX < 1 ? -1 : 1;
        }

        if (pY && !sY) {
          sY = pY < 1 ? -1 : 1;
        }

        return {
          spinX: sX,
          spinY: sY,
          pixelX: pX,
          pixelY: pY
        };
      }

      function handleMouseEnter() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = true;
      }

      function handleMouseLeave() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = false;
      }

      function animateSlider(newEvent) {
        if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
          // Prevent if delta of wheel scroll delta is below configured threshold
          return false;
        }

        if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
          // Prevent if time between scrolls is below configured threshold
          return false;
        } // If the movement is NOT big enough and
        // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
        //   Don't go any further (avoid insignificant scroll movement).


        if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
          // Return false as a default
          return true;
        } // If user is scrolling towards the end:
        //   If the slider hasn't hit the latest slide or
        //   if the slider is a loop and
        //   if the slider isn't moving right now:
        //     Go to next slide and
        //     emit a scroll event.
        // Else (the user is scrolling towards the beginning) and
        // if the slider hasn't hit the first slide or
        // if the slider is a loop and
        // if the slider isn't moving right now:
        //   Go to prev slide and
        //   emit a scroll event.


        if (newEvent.direction < 0) {
          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
            swiper.slideNext();
            emit('scroll', newEvent.raw);
          }
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
          swiper.slidePrev();
          emit('scroll', newEvent.raw);
        } // If you got here is because an animation has been triggered so store the current time


        lastScrollTime = new window.Date().getTime(); // Return false as a default

        return false;
      }

      function releaseScroll(newEvent) {
        const params = swiper.params.mousewheel;

        if (newEvent.direction < 0) {
          if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
            // Return true to animate scroll on edges
            return true;
          }
        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
          // Return true to animate scroll on edges
          return true;
        }

        return false;
      }

      function handle(event) {
        let e = event;
        let disableParentSwiper = true;
        if (!swiper.enabled) return;
        const params = swiper.params.mousewheel;

        if (swiper.params.cssMode) {
          e.preventDefault();
        }

        let target = swiper.$el;

        if (swiper.params.mousewheel.eventsTarget !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarget);
        }

        if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
        if (e.originalEvent) e = e.originalEvent; // jquery fix

        let delta = 0;
        const rtlFactor = swiper.rtlTranslate ? -1 : 1;
        const data = normalize(e);

        if (params.forceToAxis) {
          if (swiper.isHorizontal()) {
            if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
          } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
        } else {
          delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
        }

        if (delta === 0) return true;
        if (params.invert) delta = -delta; // Get the scroll positions

        let positions = swiper.getTranslate() + delta * params.sensitivity;
        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:
        //     the disableParentSwiper will be true.
        // When loop is false:
        //     if the scroll positions is not on edge,
        //     then the disableParentSwiper will be true.
        //     if the scroll on edge positions,
        //     then the disableParentSwiper will be false.

        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();

        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
          // Register the new event in a variable which stores the relevant data
          const newEvent = {
            time: now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta),
            raw: event
          }; // Keep the most recent events

          if (recentWheelEvents.length >= 2) {
            recentWheelEvents.shift(); // only store the last N events
          }

          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
          //   If direction has changed or
          //   if the scroll is quicker than the previous one:
          //     Animate the slider.
          // Else (this is the first time the wheel is moved):
          //     Animate the slider.

          if (prevEvent) {
            if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
              animateSlider(newEvent);
            }
          } else {
            animateSlider(newEvent);
          } // If it's time to release the scroll:
          //   Return now so you don't hit the preventDefault.


          if (releaseScroll(newEvent)) {
            return true;
          }
        } else {
          // Freemode or scrollContainer:
          // If we recently snapped after a momentum scroll, then ignore wheel events
          // to give time for the deceleration to finish. Stop ignoring after 500 msecs
          // or if it's a new scroll (larger delta or inverse sign as last event before
          // an end-of-momentum snap).
          const newEvent = {
            time: now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta)
          };
          const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;

          if (!ignoreWheelEvents) {
            lastEventBeforeSnap = undefined;

            if (swiper.params.loop) {
              swiper.loopFix();
            }

            let position = swiper.getTranslate() + delta * params.sensitivity;
            const wasBeginning = swiper.isBeginning;
            const wasEnd = swiper.isEnd;
            if (position >= swiper.minTranslate()) position = swiper.minTranslate();
            if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
            swiper.setTransition(0);
            swiper.setTranslate(position);
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();

            if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
              swiper.updateSlidesClasses();
            }

            if (swiper.params.freeMode.sticky) {
              // When wheel scrolling starts with sticky (aka snap) enabled, then detect
              // the end of a momentum scroll by storing recent (N=15?) wheel events.
              // 1. do all N events have decreasing or same (absolute value) delta?
              // 2. did all N events arrive in the last M (M=500?) msecs?
              // 3. does the earliest event have an (absolute value) delta that's
              //    at least P (P=1?) larger than the most recent event's delta?
              // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
              // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
              // Snap immediately and ignore remaining wheel events in this scroll.
              // See comment above for "remaining wheel events in this scroll" determination.
              // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
              clearTimeout(timeout);
              timeout = undefined;

              if (recentWheelEvents.length >= 15) {
                recentWheelEvents.shift(); // only store the last N events
              }

              const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
              const firstEvent = recentWheelEvents[0];
              recentWheelEvents.push(newEvent);

              if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                recentWheelEvents.splice(0);
              } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                // We're at the end of the deceleration of a momentum scroll, so there's no need
                // to wait for more events. Snap ASAP on the next tick.
                // Also, because there's some remaining momentum we'll bias the snap in the
                // direction of the ongoing scroll because it's better UX for the scroll to snap
                // in the same direction as the scroll instead of reversing to snap.  Therefore,
                // if it's already scrolled more than 20% in the current direction, keep going.
                const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                lastEventBeforeSnap = newEvent;
                recentWheelEvents.splice(0);
                timeout = nextTick(() => {
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 0); // no delay; move on next tick
              }

              if (!timeout) {
                // if we get here, then we haven't detected the end of a momentum scroll, so
                // we'll consider a scroll "complete" when there haven't been any wheel events
                // for 500ms.
                timeout = nextTick(() => {
                  const snapToThreshold = 0.5;
                  lastEventBeforeSnap = newEvent;
                  recentWheelEvents.splice(0);
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 500);
              }
            } // Emit event


            if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay

            if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions

            if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
          }
        }

        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        return false;
      }

      function events(method) {
        let target = swiper.$el;

        if (swiper.params.mousewheel.eventsTarget !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarget);
        }

        target[method]('mouseenter', handleMouseEnter);
        target[method]('mouseleave', handleMouseLeave);
        target[method]('wheel', handle);
      }

      function enable() {
        if (swiper.params.cssMode) {
          swiper.wrapperEl.removeEventListener('wheel', handle);
          return true;
        }

        if (swiper.mousewheel.enabled) return false;
        events('on');
        swiper.mousewheel.enabled = true;
        return true;
      }

      function disable() {
        if (swiper.params.cssMode) {
          swiper.wrapperEl.addEventListener(event, handle);
          return true;
        }

        if (!swiper.mousewheel.enabled) return false;
        events('off');
        swiper.mousewheel.enabled = false;
        return true;
      }

      on('init', () => {
        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
          disable();
        }

        if (swiper.params.mousewheel.enabled) enable();
      });
      on('destroy', () => {
        if (swiper.params.cssMode) {
          enable();
        }

        if (swiper.mousewheel.enabled) disable();
      });
      Object.assign(swiper.mousewheel, {
        enable,
        disable
      });
    }

    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
      const document = getDocument();

      if (swiper.params.createElements) {
        Object.keys(checkProps).forEach(key => {
          if (!params[key] && params.auto === true) {
            let element = swiper.$el.children(`.${checkProps[key]}`)[0];

            if (!element) {
              element = document.createElement('div');
              element.className = checkProps[key];
              swiper.$el.append(element);
            }

            params[key] = element;
            originalParams[key] = element;
          }
        });
      }

      return params;
    }

    function Navigation(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      extendParams({
        navigation: {
          nextEl: null,
          prevEl: null,
          hideOnClick: false,
          disabledClass: 'swiper-button-disabled',
          hiddenClass: 'swiper-button-hidden',
          lockClass: 'swiper-button-lock',
          navigationDisabledClass: 'swiper-navigation-disabled'
        }
      });
      swiper.navigation = {
        nextEl: null,
        $nextEl: null,
        prevEl: null,
        $prevEl: null
      };

      function getEl(el) {
        let $el;

        if (el) {
          $el = $(el);

          if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
            $el = swiper.$el.find(el);
          }
        }

        return $el;
      }

      function toggleEl($el, disabled) {
        const params = swiper.params.navigation;

        if ($el && $el.length > 0) {
          $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
          if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;

          if (swiper.params.watchOverflow && swiper.enabled) {
            $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          }
        }
      }

      function update() {
        // Update Navigation Buttons
        if (swiper.params.loop) return;
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
        toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
      }

      function onPrevClick(e) {
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slidePrev();
        emit('navigationPrev');
      }

      function onNextClick(e) {
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slideNext();
        emit('navigationNext');
      }

      function init() {
        const params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
          nextEl: 'swiper-button-next',
          prevEl: 'swiper-button-prev'
        });
        if (!(params.nextEl || params.prevEl)) return;
        const $nextEl = getEl(params.nextEl);
        const $prevEl = getEl(params.prevEl);

        if ($nextEl && $nextEl.length > 0) {
          $nextEl.on('click', onNextClick);
        }

        if ($prevEl && $prevEl.length > 0) {
          $prevEl.on('click', onPrevClick);
        }

        Object.assign(swiper.navigation, {
          $nextEl,
          nextEl: $nextEl && $nextEl[0],
          $prevEl,
          prevEl: $prevEl && $prevEl[0]
        });

        if (!swiper.enabled) {
          if ($nextEl) $nextEl.addClass(params.lockClass);
          if ($prevEl) $prevEl.addClass(params.lockClass);
        }
      }

      function destroy() {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;

        if ($nextEl && $nextEl.length) {
          $nextEl.off('click', onNextClick);
          $nextEl.removeClass(swiper.params.navigation.disabledClass);
        }

        if ($prevEl && $prevEl.length) {
          $prevEl.off('click', onPrevClick);
          $prevEl.removeClass(swiper.params.navigation.disabledClass);
        }
      }

      on('init', () => {
        if (swiper.params.navigation.enabled === false) {
          // eslint-disable-next-line
          disable();
        } else {
          init();
          update();
        }
      });
      on('toEdge fromEdge lock unlock', () => {
        update();
      });
      on('destroy', () => {
        destroy();
      });
      on('enable disable', () => {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;

        if ($nextEl) {
          $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }

        if ($prevEl) {
          $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }
      });
      on('click', (_s, e) => {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        const targetEl = e.target;

        if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
          if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
          let isHidden;

          if ($nextEl) {
            isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
          } else if ($prevEl) {
            isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
          }

          if (isHidden === true) {
            emit('navigationShow');
          } else {
            emit('navigationHide');
          }

          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }

          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      });

      const enable = () => {
        swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);
        init();
        update();
      };

      const disable = () => {
        swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);
        destroy();
      };

      Object.assign(swiper.navigation, {
        enable,
        disable,
        update,
        init,
        destroy
      });
    }

    function classesToSelector(classes) {
      if (classes === void 0) {
        classes = '';
      }

      return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
    }

    function Pagination(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      const pfx = 'swiper-pagination';
      extendParams({
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: 'bullets',
          // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: number => number,
          formatFractionTotal: number => number,
          bulletClass: `${pfx}-bullet`,
          bulletActiveClass: `${pfx}-bullet-active`,
          modifierClass: `${pfx}-`,
          currentClass: `${pfx}-current`,
          totalClass: `${pfx}-total`,
          hiddenClass: `${pfx}-hidden`,
          progressbarFillClass: `${pfx}-progressbar-fill`,
          progressbarOppositeClass: `${pfx}-progressbar-opposite`,
          clickableClass: `${pfx}-clickable`,
          lockClass: `${pfx}-lock`,
          horizontalClass: `${pfx}-horizontal`,
          verticalClass: `${pfx}-vertical`,
          paginationDisabledClass: `${pfx}-disabled`
        }
      });
      swiper.pagination = {
        el: null,
        $el: null,
        bullets: []
      };
      let bulletSize;
      let dynamicBulletIndex = 0;

      function isPaginationDisabled() {
        return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
      }

      function setSideBullets($bulletEl, position) {
        const {
          bulletActiveClass
        } = swiper.params.pagination;
        $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
      }

      function update() {
        // Render || Update Pagination bullets/items
        const rtl = swiper.rtl;
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const $el = swiper.pagination.$el; // Current/Total

        let current;
        const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        if (swiper.params.loop) {
          current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

          if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
            current -= slidesLength - swiper.loopedSlides * 2;
          }

          if (current > total - 1) current -= total;
          if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
        } else if (typeof swiper.snapIndex !== 'undefined') {
          current = swiper.snapIndex;
        } else {
          current = swiper.activeIndex || 0;
        } // Types


        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
          const bullets = swiper.pagination.bullets;
          let firstIndex;
          let lastIndex;
          let midIndex;

          if (params.dynamicBullets) {
            bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
            $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);

            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
              dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);

              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (dynamicBulletIndex < 0) {
                dynamicBulletIndex = 0;
              }
            }

            firstIndex = Math.max(current - dynamicBulletIndex, 0);
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }

          bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));

          if ($el.length > 1) {
            bullets.each(bullet => {
              const $bullet = $(bullet);
              const bulletIndex = $bullet.index();

              if (bulletIndex === current) {
                $bullet.addClass(params.bulletActiveClass);
              }

              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  $bullet.addClass(`${params.bulletActiveClass}-main`);
                }

                if (bulletIndex === firstIndex) {
                  setSideBullets($bullet, 'prev');
                }

                if (bulletIndex === lastIndex) {
                  setSideBullets($bullet, 'next');
                }
              }
            });
          } else {
            const $bullet = bullets.eq(current);
            const bulletIndex = $bullet.index();
            $bullet.addClass(params.bulletActiveClass);

            if (params.dynamicBullets) {
              const $firstDisplayedBullet = bullets.eq(firstIndex);
              const $lastDisplayedBullet = bullets.eq(lastIndex);

              for (let i = firstIndex; i <= lastIndex; i += 1) {
                bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
              }

              if (swiper.params.loop) {
                if (bulletIndex >= bullets.length) {
                  for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                    bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                  }

                  bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
                } else {
                  setSideBullets($firstDisplayedBullet, 'prev');
                  setSideBullets($lastDisplayedBullet, 'next');
                }
              } else {
                setSideBullets($firstDisplayedBullet, 'prev');
                setSideBullets($lastDisplayedBullet, 'next');
              }
            }
          }

          if (params.dynamicBullets) {
            const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
            const offsetProp = rtl ? 'right' : 'left';
            bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
          }
        }

        if (params.type === 'fraction') {
          $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
          $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }

        if (params.type === 'progressbar') {
          let progressbarDirection;

          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }

          const scale = (current + 1) / total;
          let scaleX = 1;
          let scaleY = 1;

          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }

          $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
        }

        if (params.type === 'custom' && params.renderCustom) {
          $el.html(params.renderCustom(swiper, current + 1, total));
          emit('paginationRender', $el[0]);
        } else {
          emit('paginationUpdate', $el[0]);
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      }

      function render() {
        // Render Container
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const $el = swiper.pagination.$el;
        let paginationHTML = '';

        if (params.type === 'bullets') {
          let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

          if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
            numberOfBullets = slidesLength;
          }

          for (let i = 0; i < numberOfBullets; i += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
            } else {
              paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
            }
          }

          $el.html(paginationHTML);
          swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }

        if (params.type === 'fraction') {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
          } else {
            paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
          }

          $el.html(paginationHTML);
        }

        if (params.type === 'progressbar') {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
          } else {
            paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
          }

          $el.html(paginationHTML);
        }

        if (params.type !== 'custom') {
          emit('paginationRender', swiper.pagination.$el[0]);
        }
      }

      function init() {
        swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
          el: 'swiper-pagination'
        });
        const params = swiper.params.pagination;
        if (!params.el) return;
        let $el = $(params.el);
        if ($el.length === 0) return;

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
          $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper

          if ($el.length > 1) {
            $el = $el.filter(el => {
              if ($(el).parents('.swiper')[0] !== swiper.el) return false;
              return true;
            });
          }
        }

        if (params.type === 'bullets' && params.clickable) {
          $el.addClass(params.clickableClass);
        }

        $el.addClass(params.modifierClass + params.type);
        $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);

        if (params.type === 'bullets' && params.dynamicBullets) {
          $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
          dynamicBulletIndex = 0;

          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }

        if (params.type === 'progressbar' && params.progressbarOpposite) {
          $el.addClass(params.progressbarOppositeClass);
        }

        if (params.clickable) {
          $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
            e.preventDefault();
            let index = $(this).index() * swiper.params.slidesPerGroup;
            if (swiper.params.loop) index += swiper.loopedSlides;
            swiper.slideTo(index);
          });
        }

        Object.assign(swiper.pagination, {
          $el,
          el: $el[0]
        });

        if (!swiper.enabled) {
          $el.addClass(params.lockClass);
        }
      }

      function destroy() {
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const $el = swiper.pagination.$el;
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

        if (params.clickable) {
          $el.off('click', classesToSelector(params.bulletClass));
        }
      }

      on('init', () => {
        if (swiper.params.pagination.enabled === false) {
          // eslint-disable-next-line
          disable();
        } else {
          init();
          render();
          update();
        }
      });
      on('activeIndexChange', () => {
        if (swiper.params.loop) {
          update();
        } else if (typeof swiper.snapIndex === 'undefined') {
          update();
        }
      });
      on('snapIndexChange', () => {
        if (!swiper.params.loop) {
          update();
        }
      });
      on('slidesLengthChange', () => {
        if (swiper.params.loop) {
          render();
          update();
        }
      });
      on('snapGridLengthChange', () => {
        if (!swiper.params.loop) {
          render();
          update();
        }
      });
      on('destroy', () => {
        destroy();
      });
      on('enable disable', () => {
        const {
          $el
        } = swiper.pagination;

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
        }
      });
      on('lock unlock', () => {
        update();
      });
      on('click', (_s, e) => {
        const targetEl = e.target;
        const {
          $el
        } = swiper.pagination;

        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
          if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
          const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);

          if (isHidden === true) {
            emit('paginationShow');
          } else {
            emit('paginationHide');
          }

          $el.toggleClass(swiper.params.pagination.hiddenClass);
        }
      });

      const enable = () => {
        swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);

        if (swiper.pagination.$el) {
          swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
        }

        init();
        render();
        update();
      };

      const disable = () => {
        swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);

        if (swiper.pagination.$el) {
          swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);
        }

        destroy();
      };

      Object.assign(swiper.pagination, {
        enable,
        disable,
        render,
        update,
        init,
        destroy
      });
    }

    function Scrollbar(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      const document = getDocument();
      let isTouched = false;
      let timeout = null;
      let dragTimeout = null;
      let dragStartPos;
      let dragSize;
      let trackSize;
      let divider;
      extendParams({
        scrollbar: {
          el: null,
          dragSize: 'auto',
          hide: false,
          draggable: false,
          snapOnRelease: true,
          lockClass: 'swiper-scrollbar-lock',
          dragClass: 'swiper-scrollbar-drag',
          scrollbarDisabledClass: 'swiper-scrollbar-disabled',
          horizontalClass: `swiper-scrollbar-horizontal`,
          verticalClass: `swiper-scrollbar-vertical`
        }
      });
      swiper.scrollbar = {
        el: null,
        dragEl: null,
        $el: null,
        $dragEl: null
      };

      function setTranslate() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const {
          scrollbar,
          rtlTranslate: rtl,
          progress
        } = swiper;
        const {
          $dragEl,
          $el
        } = scrollbar;
        const params = swiper.params.scrollbar;
        let newSize = dragSize;
        let newPos = (trackSize - dragSize) * progress;

        if (rtl) {
          newPos = -newPos;

          if (newPos > 0) {
            newSize = dragSize - newPos;
            newPos = 0;
          } else if (-newPos + dragSize > trackSize) {
            newSize = trackSize + newPos;
          }
        } else if (newPos < 0) {
          newSize = dragSize + newPos;
          newPos = 0;
        } else if (newPos + dragSize > trackSize) {
          newSize = trackSize - newPos;
        }

        if (swiper.isHorizontal()) {
          $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
          $dragEl[0].style.width = `${newSize}px`;
        } else {
          $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
          $dragEl[0].style.height = `${newSize}px`;
        }

        if (params.hide) {
          clearTimeout(timeout);
          $el[0].style.opacity = 1;
          timeout = setTimeout(() => {
            $el[0].style.opacity = 0;
            $el.transition(400);
          }, 1000);
        }
      }

      function setTransition(duration) {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.$dragEl.transition(duration);
      }

      function updateSize() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const {
          scrollbar
        } = swiper;
        const {
          $dragEl,
          $el
        } = scrollbar;
        $dragEl[0].style.width = '';
        $dragEl[0].style.height = '';
        trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));

        if (swiper.params.scrollbar.dragSize === 'auto') {
          dragSize = trackSize * divider;
        } else {
          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        }

        if (swiper.isHorizontal()) {
          $dragEl[0].style.width = `${dragSize}px`;
        } else {
          $dragEl[0].style.height = `${dragSize}px`;
        }

        if (divider >= 1) {
          $el[0].style.display = 'none';
        } else {
          $el[0].style.display = '';
        }

        if (swiper.params.scrollbar.hide) {
          $el[0].style.opacity = 0;
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
        }
      }

      function getPointerPosition(e) {
        if (swiper.isHorizontal()) {
          return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
        }

        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
      }

      function setDragPosition(e) {
        const {
          scrollbar,
          rtlTranslate: rtl
        } = swiper;
        const {
          $el
        } = scrollbar;
        let positionRatio;
        positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);

        if (rtl) {
          positionRatio = 1 - positionRatio;
        }

        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      function onDragStart(e) {
        const params = swiper.params.scrollbar;
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el,
          $dragEl
        } = scrollbar;
        isTouched = true;
        dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
        e.preventDefault();
        e.stopPropagation();
        $wrapperEl.transition(100);
        $dragEl.transition(100);
        setDragPosition(e);
        clearTimeout(dragTimeout);
        $el.transition(0);

        if (params.hide) {
          $el.css('opacity', 1);
        }

        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', 'none');
        }

        emit('scrollbarDragStart', e);
      }

      function onDragMove(e) {
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el,
          $dragEl
        } = scrollbar;
        if (!isTouched) return;
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        setDragPosition(e);
        $wrapperEl.transition(0);
        $el.transition(0);
        $dragEl.transition(0);
        emit('scrollbarDragMove', e);
      }

      function onDragEnd(e) {
        const params = swiper.params.scrollbar;
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el
        } = scrollbar;
        if (!isTouched) return;
        isTouched = false;

        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', '');
          $wrapperEl.transition('');
        }

        if (params.hide) {
          clearTimeout(dragTimeout);
          dragTimeout = nextTick(() => {
            $el.css('opacity', 0);
            $el.transition(400);
          }, 1000);
        }

        emit('scrollbarDragEnd', e);

        if (params.snapOnRelease) {
          swiper.slideToClosest();
        }
      }

      function events(method) {
        const {
          scrollbar,
          touchEventsTouch,
          touchEventsDesktop,
          params,
          support
        } = swiper;
        const $el = scrollbar.$el;
        if (!$el) return;
        const target = $el[0];
        const activeListener = support.passiveListener && params.passiveListeners ? {
          passive: false,
          capture: false
        } : false;
        const passiveListener = support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        if (!target) return;
        const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';

        if (!support.touch) {
          target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
          document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
          document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
        } else {
          target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
          target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
          target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
        }
      }

      function enableDraggable() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        events('on');
      }

      function disableDraggable() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        events('off');
      }

      function init() {
        const {
          scrollbar,
          $el: $swiperEl
        } = swiper;
        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
          el: 'swiper-scrollbar'
        });
        const params = swiper.params.scrollbar;
        if (!params.el) return;
        let $el = $(params.el);

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
          $el = $swiperEl.find(params.el);
        }

        $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);

        if ($dragEl.length === 0) {
          $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
          $el.append($dragEl);
        }

        Object.assign(scrollbar, {
          $el,
          el: $el[0],
          $dragEl,
          dragEl: $dragEl[0]
        });

        if (params.draggable) {
          enableDraggable();
        }

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      }

      function destroy() {
        const params = swiper.params.scrollbar;
        const $el = swiper.scrollbar.$el;

        if ($el) {
          $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        }

        disableDraggable();
      }

      on('init', () => {
        if (swiper.params.scrollbar.enabled === false) {
          // eslint-disable-next-line
          disable();
        } else {
          init();
          updateSize();
          setTranslate();
        }
      });
      on('update resize observerUpdate lock unlock', () => {
        updateSize();
      });
      on('setTranslate', () => {
        setTranslate();
      });
      on('setTransition', (_s, duration) => {
        setTransition(duration);
      });
      on('enable disable', () => {
        const {
          $el
        } = swiper.scrollbar;

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      });
      on('destroy', () => {
        destroy();
      });

      const enable = () => {
        swiper.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);

        if (swiper.scrollbar.$el) {
          swiper.scrollbar.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);
        }

        init();
        updateSize();
        setTranslate();
      };

      const disable = () => {
        swiper.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);

        if (swiper.scrollbar.$el) {
          swiper.scrollbar.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);
        }

        destroy();
      };

      Object.assign(swiper.scrollbar, {
        enable,
        disable,
        updateSize,
        setTranslate,
        init,
        destroy
      });
    }

    function Parallax(_ref) {
      let {
        swiper,
        extendParams,
        on
      } = _ref;
      extendParams({
        parallax: {
          enabled: false
        }
      });

      const setTransform = (el, progress) => {
        const {
          rtl
        } = swiper;
        const $el = $(el);
        const rtlFactor = rtl ? -1 : 1;
        const p = $el.attr('data-swiper-parallax') || '0';
        let x = $el.attr('data-swiper-parallax-x');
        let y = $el.attr('data-swiper-parallax-y');
        const scale = $el.attr('data-swiper-parallax-scale');
        const opacity = $el.attr('data-swiper-parallax-opacity');

        if (x || y) {
          x = x || '0';
          y = y || '0';
        } else if (swiper.isHorizontal()) {
          x = p;
          y = '0';
        } else {
          y = p;
          x = '0';
        }

        if (x.indexOf('%') >= 0) {
          x = `${parseInt(x, 10) * progress * rtlFactor}%`;
        } else {
          x = `${x * progress * rtlFactor}px`;
        }

        if (y.indexOf('%') >= 0) {
          y = `${parseInt(y, 10) * progress}%`;
        } else {
          y = `${y * progress}px`;
        }

        if (typeof opacity !== 'undefined' && opacity !== null) {
          const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
          $el[0].style.opacity = currentOpacity;
        }

        if (typeof scale === 'undefined' || scale === null) {
          $el.transform(`translate3d(${x}, ${y}, 0px)`);
        } else {
          const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
          $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
        }
      };

      const setTranslate = () => {
        const {
          $el,
          slides,
          progress,
          snapGrid
        } = swiper;
        $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
          setTransform(el, progress);
        });
        slides.each((slideEl, slideIndex) => {
          let slideProgress = slideEl.progress;

          if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
            slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
          }

          slideProgress = Math.min(Math.max(slideProgress, -1), 1);
          $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
            setTransform(el, slideProgress);
          });
        });
      };

      const setTransition = function (duration) {
        if (duration === void 0) {
          duration = swiper.params.speed;
        }

        const {
          $el
        } = swiper;
        $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(parallaxEl => {
          const $parallaxEl = $(parallaxEl);
          let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
          if (duration === 0) parallaxDuration = 0;
          $parallaxEl.transition(parallaxDuration);
        });
      };

      on('beforeInit', () => {
        if (!swiper.params.parallax.enabled) return;
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      });
      on('init', () => {
        if (!swiper.params.parallax.enabled) return;
        setTranslate();
      });
      on('setTranslate', () => {
        if (!swiper.params.parallax.enabled) return;
        setTranslate();
      });
      on('setTransition', (_swiper, duration) => {
        if (!swiper.params.parallax.enabled) return;
        setTransition(duration);
      });
    }

    /* eslint no-underscore-dangle: "off" */
    function Autoplay(_ref) {
      let {
        swiper,
        extendParams,
        on,
        emit
      } = _ref;
      let timeout;
      swiper.autoplay = {
        running: false,
        paused: false
      };
      extendParams({
        autoplay: {
          enabled: false,
          delay: 3000,
          waitForTransition: true,
          disableOnInteraction: true,
          stopOnLastSlide: false,
          reverseDirection: false,
          pauseOnMouseEnter: false
        }
      });

      function run() {
        if (!swiper.size) {
          swiper.autoplay.running = false;
          swiper.autoplay.paused = false;
          return;
        }

        const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
        let delay = swiper.params.autoplay.delay;

        if ($activeSlideEl.attr('data-swiper-autoplay')) {
          delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
        }

        clearTimeout(timeout);
        timeout = nextTick(() => {
          let autoplayResult;

          if (swiper.params.autoplay.reverseDirection) {
            if (swiper.params.loop) {
              swiper.loopFix();
              autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
              emit('autoplay');
            } else if (!swiper.isBeginning) {
              autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
              emit('autoplay');
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
              autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
              emit('autoplay');
            } else {
              stop();
            }
          } else if (swiper.params.loop) {
            swiper.loopFix();
            autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.isEnd) {
            autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
            emit('autoplay');
          } else {
            stop();
          }

          if (swiper.params.cssMode && swiper.autoplay.running) run();else if (autoplayResult === false) {
            run();
          }
        }, delay);
      }

      function start() {
        if (typeof timeout !== 'undefined') return false;
        if (swiper.autoplay.running) return false;
        swiper.autoplay.running = true;
        emit('autoplayStart');
        run();
        return true;
      }

      function stop() {
        if (!swiper.autoplay.running) return false;
        if (typeof timeout === 'undefined') return false;

        if (timeout) {
          clearTimeout(timeout);
          timeout = undefined;
        }

        swiper.autoplay.running = false;
        emit('autoplayStop');
        return true;
      }

      function pause(speed) {
        if (!swiper.autoplay.running) return;
        if (swiper.autoplay.paused) return;
        if (timeout) clearTimeout(timeout);
        swiper.autoplay.paused = true;

        if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
          swiper.autoplay.paused = false;
          run();
        } else {
          ['transitionend', 'webkitTransitionEnd'].forEach(event => {
            swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
          });
        }
      }

      function onVisibilityChange() {
        const document = getDocument();

        if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
          pause();
        }

        if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
          run();
          swiper.autoplay.paused = false;
        }
      }

      function onTransitionEnd(e) {
        if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
        if (e.target !== swiper.$wrapperEl[0]) return;
        ['transitionend', 'webkitTransitionEnd'].forEach(event => {
          swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
        });
        swiper.autoplay.paused = false;

        if (!swiper.autoplay.running) {
          stop();
        } else {
          run();
        }
      }

      function onMouseEnter() {
        if (swiper.params.autoplay.disableOnInteraction) {
          stop();
        } else {
          emit('autoplayPause');
          pause();
        }

        ['transitionend', 'webkitTransitionEnd'].forEach(event => {
          swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
        });
      }

      function onMouseLeave() {
        if (swiper.params.autoplay.disableOnInteraction) {
          return;
        }

        swiper.autoplay.paused = false;
        emit('autoplayResume');
        run();
      }

      function attachMouseEvents() {
        if (swiper.params.autoplay.pauseOnMouseEnter) {
          swiper.$el.on('mouseenter', onMouseEnter);
          swiper.$el.on('mouseleave', onMouseLeave);
        }
      }

      function detachMouseEvents() {
        swiper.$el.off('mouseenter', onMouseEnter);
        swiper.$el.off('mouseleave', onMouseLeave);
      }

      on('init', () => {
        if (swiper.params.autoplay.enabled) {
          start();
          const document = getDocument();
          document.addEventListener('visibilitychange', onVisibilityChange);
          attachMouseEvents();
        }
      });
      on('beforeTransitionStart', (_s, speed, internal) => {
        if (swiper.autoplay.running) {
          if (internal || !swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.pause(speed);
          } else {
            stop();
          }
        }
      });
      on('sliderFirstMove', () => {
        if (swiper.autoplay.running) {
          if (swiper.params.autoplay.disableOnInteraction) {
            stop();
          } else {
            pause();
          }
        }
      });
      on('touchEnd', () => {
        if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
          run();
        }
      });
      on('destroy', () => {
        detachMouseEvents();

        if (swiper.autoplay.running) {
          stop();
        }

        const document = getDocument();
        document.removeEventListener('visibilitychange', onVisibilityChange);
      });
      Object.assign(swiper.autoplay, {
        pause,
        run,
        start,
        stop
      });
    }

    function freeMode(_ref) {
      let {
        swiper,
        extendParams,
        emit,
        once
      } = _ref;
      extendParams({
        freeMode: {
          enabled: false,
          momentum: true,
          momentumRatio: 1,
          momentumBounce: true,
          momentumBounceRatio: 1,
          momentumVelocityRatio: 1,
          sticky: false,
          minimumVelocity: 0.02
        }
      });

      function onTouchStart() {
        const translate = swiper.getTranslate();
        swiper.setTranslate(translate);
        swiper.setTransition(0);
        swiper.touchEventsData.velocities.length = 0;
        swiper.freeMode.onTouchEnd({
          currentPos: swiper.rtl ? swiper.translate : -swiper.translate
        });
      }

      function onTouchMove() {
        const {
          touchEventsData: data,
          touches
        } = swiper; // Velocity

        if (data.velocities.length === 0) {
          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
            time: data.touchStartTime
          });
        }

        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
          time: now()
        });
      }

      function onTouchEnd(_ref2) {
        let {
          currentPos
        } = _ref2;
        const {
          params,
          $wrapperEl,
          rtlTranslate: rtl,
          snapGrid,
          touchEventsData: data
        } = swiper; // Time diff

        const touchEndTime = now();
        const timeDiff = touchEndTime - data.touchStartTime;

        if (currentPos < -swiper.minTranslate()) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (currentPos > -swiper.maxTranslate()) {
          if (swiper.slides.length < snapGrid.length) {
            swiper.slideTo(snapGrid.length - 1);
          } else {
            swiper.slideTo(swiper.slides.length - 1);
          }

          return;
        }

        if (params.freeMode.momentum) {
          if (data.velocities.length > 1) {
            const lastMoveEvent = data.velocities.pop();
            const velocityEvent = data.velocities.pop();
            const distance = lastMoveEvent.position - velocityEvent.position;
            const time = lastMoveEvent.time - velocityEvent.time;
            swiper.velocity = distance / time;
            swiper.velocity /= 2;

            if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
              swiper.velocity = 0;
            } // this implies that the user stopped moving a finger then released.
            // There would be no events with distance zero, so the last event is stale.


            if (time > 150 || now() - lastMoveEvent.time > 300) {
              swiper.velocity = 0;
            }
          } else {
            swiper.velocity = 0;
          }

          swiper.velocity *= params.freeMode.momentumVelocityRatio;
          data.velocities.length = 0;
          let momentumDuration = 1000 * params.freeMode.momentumRatio;
          const momentumDistance = swiper.velocity * momentumDuration;
          let newPosition = swiper.translate + momentumDistance;
          if (rtl) newPosition = -newPosition;
          let doBounce = false;
          let afterBouncePosition;
          const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
          let needsLoopFix;

          if (newPosition < swiper.maxTranslate()) {
            if (params.freeMode.momentumBounce) {
              if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                newPosition = swiper.maxTranslate() - bounceAmount;
              }

              afterBouncePosition = swiper.maxTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.maxTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (newPosition > swiper.minTranslate()) {
            if (params.freeMode.momentumBounce) {
              if (newPosition - swiper.minTranslate() > bounceAmount) {
                newPosition = swiper.minTranslate() + bounceAmount;
              }

              afterBouncePosition = swiper.minTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.minTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (params.freeMode.sticky) {
            let nextSlide;

            for (let j = 0; j < snapGrid.length; j += 1) {
              if (snapGrid[j] > -newPosition) {
                nextSlide = j;
                break;
              }
            }

            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
              newPosition = snapGrid[nextSlide];
            } else {
              newPosition = snapGrid[nextSlide - 1];
            }

            newPosition = -newPosition;
          }

          if (needsLoopFix) {
            once('transitionEnd', () => {
              swiper.loopFix();
            });
          } // Fix duration


          if (swiper.velocity !== 0) {
            if (rtl) {
              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
            } else {
              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
            }

            if (params.freeMode.sticky) {
              // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
              // event, then durations can be 20+ seconds to slide one (or zero!) slides.
              // It's easy to see this when simulating touch with mouse events. To fix this,
              // limit single-slide swipes to the default slide duration. This also has the
              // nice side effect of matching slide speed if the user stopped moving before
              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
              // For faster swipes, also apply limits (albeit higher ones).
              const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
              const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

              if (moveDistance < currentSlideSize) {
                momentumDuration = params.speed;
              } else if (moveDistance < 2 * currentSlideSize) {
                momentumDuration = params.speed * 1.5;
              } else {
                momentumDuration = params.speed * 2.5;
              }
            }
          } else if (params.freeMode.sticky) {
            swiper.slideToClosest();
            return;
          }

          if (params.freeMode.momentumBounce && doBounce) {
            swiper.updateProgress(afterBouncePosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            swiper.animating = true;
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
              emit('momentumBounce');
              swiper.setTransition(params.speed);
              setTimeout(() => {
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(() => {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }, 0);
            });
          } else if (swiper.velocity) {
            emit('_freeModeNoMomentumRelease');
            swiper.updateProgress(newPosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);

            if (!swiper.animating) {
              swiper.animating = true;
              $wrapperEl.transitionEnd(() => {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }
          } else {
            swiper.updateProgress(newPosition);
          }

          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        } else if (params.freeMode.sticky) {
          swiper.slideToClosest();
          return;
        } else if (params.freeMode) {
          emit('_freeModeNoMomentumRelease');
        }

        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }
      }

      Object.assign(swiper, {
        freeMode: {
          onTouchStart,
          onTouchMove,
          onTouchEnd
        }
      });
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var aos = createCommonjsModule(function (module, exports) {
    !function (e, t) {
       module.exports = t() ;
    }(commonjsGlobal, function () {
      return function (e) {
        function t(o) {
          if (n[o]) return n[o].exports;
          var i = n[o] = {
            exports: {},
            id: o,
            loaded: !1
          };
          return e[o].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports;
        }

        var n = {};
        return t.m = e, t.c = n, t.p = "dist/", t(0);
      }([function (e, t, n) {

        function o(e) {
          return e && e.__esModule ? e : {
            default: e
          };
        }

        var i = Object.assign || function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];

            for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
          }

          return e;
        },
            r = n(1),
            a = (o(r), n(6)),
            u = o(a),
            c = n(7),
            s = o(c),
            f = n(8),
            d = o(f),
            l = n(9),
            p = o(l),
            m = n(10),
            b = o(m),
            v = n(11),
            y = o(v),
            g = n(14),
            h = o(g),
            w = [],
            k = !1,
            x = {
          offset: 120,
          delay: 0,
          easing: "ease",
          duration: 400,
          disable: !1,
          once: !1,
          startEvent: "DOMContentLoaded",
          throttleDelay: 99,
          debounceDelay: 50,
          disableMutationObserver: !1
        },
            j = function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          if (e && (k = !0), k) return w = (0, y.default)(w, x), (0, b.default)(w, x.once), w;
        },
            O = function () {
          w = (0, h.default)(), j();
        },
            M = function () {
          w.forEach(function (e, t) {
            e.node.removeAttribute("data-aos"), e.node.removeAttribute("data-aos-easing"), e.node.removeAttribute("data-aos-duration"), e.node.removeAttribute("data-aos-delay");
          });
        },
            S = function (e) {
          return e === !0 || "mobile" === e && p.default.mobile() || "phone" === e && p.default.phone() || "tablet" === e && p.default.tablet() || "function" == typeof e && e() === !0;
        },
            _ = function (e) {
          x = i(x, e), w = (0, h.default)();
          var t = document.all && !window.atob;
          return S(x.disable) || t ? M() : (x.disableMutationObserver || d.default.isSupported() || (console.info('\n      aos: MutationObserver is not supported on this browser,\n      code mutations observing has been disabled.\n      You may have to call "refreshHard()" by yourself.\n    '), x.disableMutationObserver = !0), document.querySelector("body").setAttribute("data-aos-easing", x.easing), document.querySelector("body").setAttribute("data-aos-duration", x.duration), document.querySelector("body").setAttribute("data-aos-delay", x.delay), "DOMContentLoaded" === x.startEvent && ["complete", "interactive"].indexOf(document.readyState) > -1 ? j(!0) : "load" === x.startEvent ? window.addEventListener(x.startEvent, function () {
            j(!0);
          }) : document.addEventListener(x.startEvent, function () {
            j(!0);
          }), window.addEventListener("resize", (0, s.default)(j, x.debounceDelay, !0)), window.addEventListener("orientationchange", (0, s.default)(j, x.debounceDelay, !0)), window.addEventListener("scroll", (0, u.default)(function () {
            (0, b.default)(w, x.once);
          }, x.throttleDelay)), x.disableMutationObserver || d.default.ready("[data-aos]", O), w);
        };

        e.exports = {
          init: _,
          refresh: j,
          refreshHard: O
        };
      }, function (e, t) {},,,,, function (e, t) {
        (function (t) {

          function n(e, t, n) {
            function o(t) {
              var n = b,
                  o = v;
              return b = v = void 0, k = t, g = e.apply(o, n);
            }

            function r(e) {
              return k = e, h = setTimeout(f, t), M ? o(e) : g;
            }

            function a(e) {
              var n = e - w,
                  o = e - k,
                  i = t - n;
              return S ? j(i, y - o) : i;
            }

            function c(e) {
              var n = e - w,
                  o = e - k;
              return void 0 === w || n >= t || n < 0 || S && o >= y;
            }

            function f() {
              var e = O();
              return c(e) ? d(e) : void (h = setTimeout(f, a(e)));
            }

            function d(e) {
              return h = void 0, _ && b ? o(e) : (b = v = void 0, g);
            }

            function l() {
              void 0 !== h && clearTimeout(h), k = 0, b = w = v = h = void 0;
            }

            function p() {
              return void 0 === h ? g : d(O());
            }

            function m() {
              var e = O(),
                  n = c(e);

              if (b = arguments, v = this, w = e, n) {
                if (void 0 === h) return r(w);
                if (S) return h = setTimeout(f, t), o(w);
              }

              return void 0 === h && (h = setTimeout(f, t)), g;
            }

            var b,
                v,
                y,
                g,
                h,
                w,
                k = 0,
                M = !1,
                S = !1,
                _ = !0;

            if ("function" != typeof e) throw new TypeError(s);
            return t = u(t) || 0, i(n) && (M = !!n.leading, S = "maxWait" in n, y = S ? x(u(n.maxWait) || 0, t) : y, _ = "trailing" in n ? !!n.trailing : _), m.cancel = l, m.flush = p, m;
          }

          function o(e, t, o) {
            var r = !0,
                a = !0;
            if ("function" != typeof e) throw new TypeError(s);
            return i(o) && (r = "leading" in o ? !!o.leading : r, a = "trailing" in o ? !!o.trailing : a), n(e, t, {
              leading: r,
              maxWait: t,
              trailing: a
            });
          }

          function i(e) {
            var t = "undefined" == typeof e ? "undefined" : c(e);
            return !!e && ("object" == t || "function" == t);
          }

          function r(e) {
            return !!e && "object" == ("undefined" == typeof e ? "undefined" : c(e));
          }

          function a(e) {
            return "symbol" == ("undefined" == typeof e ? "undefined" : c(e)) || r(e) && k.call(e) == d;
          }

          function u(e) {
            if ("number" == typeof e) return e;
            if (a(e)) return f;

            if (i(e)) {
              var t = "function" == typeof e.valueOf ? e.valueOf() : e;
              e = i(t) ? t + "" : t;
            }

            if ("string" != typeof e) return 0 === e ? e : +e;
            e = e.replace(l, "");
            var n = m.test(e);
            return n || b.test(e) ? v(e.slice(2), n ? 2 : 8) : p.test(e) ? f : +e;
          }

          var c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e;
          } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
          },
              s = "Expected a function",
              f = NaN,
              d = "[object Symbol]",
              l = /^\s+|\s+$/g,
              p = /^[-+]0x[0-9a-f]+$/i,
              m = /^0b[01]+$/i,
              b = /^0o[0-7]+$/i,
              v = parseInt,
              y = "object" == ("undefined" == typeof t ? "undefined" : c(t)) && t && t.Object === Object && t,
              g = "object" == ("undefined" == typeof self ? "undefined" : c(self)) && self && self.Object === Object && self,
              h = y || g || Function("return this")(),
              w = Object.prototype,
              k = w.toString,
              x = Math.max,
              j = Math.min,
              O = function () {
            return h.Date.now();
          };

          e.exports = o;
        }).call(t, function () {
          return this;
        }());
      }, function (e, t) {
        (function (t) {

          function n(e, t, n) {
            function i(t) {
              var n = b,
                  o = v;
              return b = v = void 0, O = t, g = e.apply(o, n);
            }

            function r(e) {
              return O = e, h = setTimeout(f, t), M ? i(e) : g;
            }

            function u(e) {
              var n = e - w,
                  o = e - O,
                  i = t - n;
              return S ? x(i, y - o) : i;
            }

            function s(e) {
              var n = e - w,
                  o = e - O;
              return void 0 === w || n >= t || n < 0 || S && o >= y;
            }

            function f() {
              var e = j();
              return s(e) ? d(e) : void (h = setTimeout(f, u(e)));
            }

            function d(e) {
              return h = void 0, _ && b ? i(e) : (b = v = void 0, g);
            }

            function l() {
              void 0 !== h && clearTimeout(h), O = 0, b = w = v = h = void 0;
            }

            function p() {
              return void 0 === h ? g : d(j());
            }

            function m() {
              var e = j(),
                  n = s(e);

              if (b = arguments, v = this, w = e, n) {
                if (void 0 === h) return r(w);
                if (S) return h = setTimeout(f, t), i(w);
              }

              return void 0 === h && (h = setTimeout(f, t)), g;
            }

            var b,
                v,
                y,
                g,
                h,
                w,
                O = 0,
                M = !1,
                S = !1,
                _ = !0;

            if ("function" != typeof e) throw new TypeError(c);
            return t = a(t) || 0, o(n) && (M = !!n.leading, S = "maxWait" in n, y = S ? k(a(n.maxWait) || 0, t) : y, _ = "trailing" in n ? !!n.trailing : _), m.cancel = l, m.flush = p, m;
          }

          function o(e) {
            var t = "undefined" == typeof e ? "undefined" : u(e);
            return !!e && ("object" == t || "function" == t);
          }

          function i(e) {
            return !!e && "object" == ("undefined" == typeof e ? "undefined" : u(e));
          }

          function r(e) {
            return "symbol" == ("undefined" == typeof e ? "undefined" : u(e)) || i(e) && w.call(e) == f;
          }

          function a(e) {
            if ("number" == typeof e) return e;
            if (r(e)) return s;

            if (o(e)) {
              var t = "function" == typeof e.valueOf ? e.valueOf() : e;
              e = o(t) ? t + "" : t;
            }

            if ("string" != typeof e) return 0 === e ? e : +e;
            e = e.replace(d, "");
            var n = p.test(e);
            return n || m.test(e) ? b(e.slice(2), n ? 2 : 8) : l.test(e) ? s : +e;
          }

          var u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e;
          } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
          },
              c = "Expected a function",
              s = NaN,
              f = "[object Symbol]",
              d = /^\s+|\s+$/g,
              l = /^[-+]0x[0-9a-f]+$/i,
              p = /^0b[01]+$/i,
              m = /^0o[0-7]+$/i,
              b = parseInt,
              v = "object" == ("undefined" == typeof t ? "undefined" : u(t)) && t && t.Object === Object && t,
              y = "object" == ("undefined" == typeof self ? "undefined" : u(self)) && self && self.Object === Object && self,
              g = v || y || Function("return this")(),
              h = Object.prototype,
              w = h.toString,
              k = Math.max,
              x = Math.min,
              j = function () {
            return g.Date.now();
          };

          e.exports = n;
        }).call(t, function () {
          return this;
        }());
      }, function (e, t) {

        function n(e) {
          var t = void 0,
              o = void 0,
              i = void 0;

          for (t = 0; t < e.length; t += 1) {
            if (o = e[t], o.dataset && o.dataset.aos) return !0;
            if (i = o.children && n(o.children)) return !0;
          }

          return !1;
        }

        function o() {
          return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
        }

        function i() {
          return !!o();
        }

        function r(e, t) {
          var n = window.document,
              i = o(),
              r = new i(a);
          u = t, r.observe(n.documentElement, {
            childList: !0,
            subtree: !0,
            removedNodes: !0
          });
        }

        function a(e) {
          e && e.forEach(function (e) {
            var t = Array.prototype.slice.call(e.addedNodes),
                o = Array.prototype.slice.call(e.removedNodes),
                i = t.concat(o);
            if (n(i)) return u();
          });
        }

        Object.defineProperty(t, "__esModule", {
          value: !0
        });

        var u = function () {};

        t.default = {
          isSupported: i,
          ready: r
        };
      }, function (e, t) {

        function n(e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }

        function o() {
          return navigator.userAgent || navigator.vendor || window.opera || "";
        }

        Object.defineProperty(t, "__esModule", {
          value: !0
        });

        var i = function () {
          function e(e, t) {
            for (var n = 0; n < t.length; n++) {
              var o = t[n];
              o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
            }
          }

          return function (t, n, o) {
            return n && e(t.prototype, n), o && e(t, o), t;
          };
        }(),
            r = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
            a = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
            u = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i,
            c = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
            s = function () {
          function e() {
            n(this, e);
          }

          return i(e, [{
            key: "phone",
            value: function () {
              var e = o();
              return !(!r.test(e) && !a.test(e.substr(0, 4)));
            }
          }, {
            key: "mobile",
            value: function () {
              var e = o();
              return !(!u.test(e) && !c.test(e.substr(0, 4)));
            }
          }, {
            key: "tablet",
            value: function () {
              return this.mobile() && !this.phone();
            }
          }]), e;
        }();

        t.default = new s();
      }, function (e, t) {

        Object.defineProperty(t, "__esModule", {
          value: !0
        });

        var n = function (e, t, n) {
          var o = e.node.getAttribute("data-aos-once");
          t > e.position ? e.node.classList.add("aos-animate") : "undefined" != typeof o && ("false" === o || !n && "true" !== o) && e.node.classList.remove("aos-animate");
        },
            o = function (e, t) {
          var o = window.pageYOffset,
              i = window.innerHeight;
          e.forEach(function (e, r) {
            n(e, i + o, t);
          });
        };

        t.default = o;
      }, function (e, t, n) {

        function o(e) {
          return e && e.__esModule ? e : {
            default: e
          };
        }

        Object.defineProperty(t, "__esModule", {
          value: !0
        });

        var i = n(12),
            r = o(i),
            a = function (e, t) {
          return e.forEach(function (e, n) {
            e.node.classList.add("aos-init"), e.position = (0, r.default)(e.node, t.offset);
          }), e;
        };

        t.default = a;
      }, function (e, t, n) {

        function o(e) {
          return e && e.__esModule ? e : {
            default: e
          };
        }

        Object.defineProperty(t, "__esModule", {
          value: !0
        });

        var i = n(13),
            r = o(i),
            a = function (e, t) {
          var n = 0,
              o = 0,
              i = window.innerHeight,
              a = {
            offset: e.getAttribute("data-aos-offset"),
            anchor: e.getAttribute("data-aos-anchor"),
            anchorPlacement: e.getAttribute("data-aos-anchor-placement")
          };

          switch (a.offset && !isNaN(a.offset) && (o = parseInt(a.offset)), a.anchor && document.querySelectorAll(a.anchor) && (e = document.querySelectorAll(a.anchor)[0]), n = (0, r.default)(e).top, a.anchorPlacement) {
            case "top-bottom":
              break;

            case "center-bottom":
              n += e.offsetHeight / 2;
              break;

            case "bottom-bottom":
              n += e.offsetHeight;
              break;

            case "top-center":
              n += i / 2;
              break;

            case "bottom-center":
              n += i / 2 + e.offsetHeight;
              break;

            case "center-center":
              n += i / 2 + e.offsetHeight / 2;
              break;

            case "top-top":
              n += i;
              break;

            case "bottom-top":
              n += e.offsetHeight + i;
              break;

            case "center-top":
              n += e.offsetHeight / 2 + i;
          }

          return a.anchorPlacement || a.offset || isNaN(t) || (o = t), n + o;
        };

        t.default = a;
      }, function (e, t) {

        Object.defineProperty(t, "__esModule", {
          value: !0
        });

        var n = function (e) {
          for (var t = 0, n = 0; e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop);) t += e.offsetLeft - ("BODY" != e.tagName ? e.scrollLeft : 0), n += e.offsetTop - ("BODY" != e.tagName ? e.scrollTop : 0), e = e.offsetParent;

          return {
            top: n,
            left: t
          };
        };

        t.default = n;
      }, function (e, t) {

        Object.defineProperty(t, "__esModule", {
          value: !0
        });

        var n = function (e) {
          return e = e || document.querySelectorAll("[data-aos]"), Array.prototype.map.call(e, function (e) {
            return {
              node: e
            };
          });
        };

        t.default = n;
      }]);
    });
    });

    var AOS = unwrapExports(aos);
    var aos_1 = aos.AOS;

    function createFashionSlider(el) {
      if (document.querySelector('.swiper-fashion')) {
        const swiperEl = el.querySelector('.swiper-fashion');
        let navigationLocked = false;
        let transitionDisabled = false;
        let frameId;

        const disableTransitions = $el => {
          $el.addClass('fashion-slider-no-transition');
          transitionDisabled = true;
          cancelAnimationFrame(frameId);
          frameId = requestAnimationFrame(() => {
            $el.removeClass('fashion-slider-no-transition');
            transitionDisabled = false;
            navigationLocked = false;
          });
        };

        const initNavigation = swiper => {
          // Use lock to control the button locking time without using the button component that comes with it
          swiper.$el.find('.fashion-slider-button-next').on('click', () => {
            if (!navigationLocked) {
              swiper.slideNext();
            }
          });
          swiper.$el.find('.fashion-slider-button-prev').on('click', () => {
            if (!navigationLocked) {
              swiper.slidePrev();
            }
          });
        };

        const destroyNavigation = swiper => {
          swiper.$el.find('.fashion-slider-button-next, .fashion-slider-button-prev').off('click');
        };

        const fashionSlider = new Swiper(swiperEl, {
          modules: [Parallax, Pagination, Autoplay],
          speed: 1300,
          allowTouchMove: false,
          // no touch swiping
          parallax: true,
          // text parallax
          on: {
            transitionStart(swiper) {
              const {
                slides,
                previousIndex,
                activeIndex,
                $el
              } = swiper;
              if (!transitionDisabled) navigationLocked = true; // lock navigation buttons

              const $activeSlide = slides.eq(activeIndex);
              const $previousSlide = slides.eq(previousIndex);
              const $previousImageScale = $previousSlide.find('.fashion-slider-scale'); // image wrapper

              const $previousImage = $previousSlide.find('img'); // current image

              const $activeImage = $activeSlide.find('img'); // next image

              const direction = activeIndex - previousIndex;
              const bgColor = $activeSlide.attr('data-slide-bg-color');
              $el.css('background-color', bgColor); // background color animation

              $previousImageScale.transform('scale(0.6)');
              $previousImage.transition(1000).transform('scale(1.2)'); // image scaling parallax

              $previousSlide.find('.fashion-slider-title-text').transition(1000).css('color', 'rgba(255,255,255,0)') // text transparency animation
              .css('opacity', '0'); // text transparency animation

              $previousImage.transitionEnd(() => {
                $activeImage.transition(1300).transform('translate3d(0, 0, 0) scale(1.2)'); // image shift parallax

                $previousImage.transition(1300).transform(`translate3d(${60 * direction}%, 0, 0)  scale(1.2)`);
              });
            },

            transitionEnd(swiper) {
              const {
                slides,
                activeIndex,
                $el
              } = swiper;
              const $activeSlide = slides.eq(activeIndex);
              const $activeImage = $activeSlide.find('img');
              $activeSlide.find('.fashion-slider-scale').transform('scale(1)');
              $activeImage.transition(1000).transform('scale(1)');
              $activeSlide.find('.fashion-slider-title-text').transition(1000).css('color', 'rgba(255,255,255,1)').css('opacity', '1'); // text transparency animation

              $activeImage.transitionEnd(() => {
                navigationLocked = false;
              }); // First and last, disable button

              if (activeIndex === 0) {
                $el.find('.fashion-slider-button-prev').addClass('fashion-slider-button-disabled');
              } else {
                $el.find('.fashion-slider-button-prev').removeClass('fashion-slider-button-disabled');
              }

              if (activeIndex === slides.length - 1) {
                $el.find('.fashion-slider-button-next').addClass('fashion-slider-button-disabled');
              } else {
                $el.find('.fashion-slider-button-next').removeClass('fashion-slider-button-disabled');
              }
            },

            init(swiper) {
              // Set initial slide bg color
              const {
                slides,
                activeIndex,
                $el
              } = swiper; // disable initial transition

              disableTransitions($el); // set current bg color

              const bgColor = slides.eq(activeIndex).attr('data-slide-bg-color');
              $el.css('background-color', bgColor); // background color animation
              // trigger the transitionEnd event once during initialization

              swiper.emit('transitionEnd'); // init navigation

              initNavigation(swiper);
            },

            resize(swiper) {
              disableTransitions(swiper.$el);
            },

            destroy(swiper) {
              destroyNavigation(swiper);
            }

          },
          pagination: {
            el: ".fashion-pagination",
            type: 'bullets',
            clickable: true
          },
          autoplay: {
            delay: 2500,
            disableOnInteraction: false
          }
        });
        return fashionSlider;
      }
    }

    // @fancyapps/ui/Fancybox v4.0.31
    const t = t => "object" == typeof t && null !== t && t.constructor === Object && "[object Object]" === Object.prototype.toString.call(t),
          e = (...i) => {
      let s = !1;
      "boolean" == typeof i[0] && (s = i.shift());
      let o = i[0];
      if (!o || "object" != typeof o) throw new Error("extendee must be an object");
      const n = i.slice(1),
            a = n.length;

      for (let i = 0; i < a; i++) {
        const a = n[i];

        for (let i in a) if (a.hasOwnProperty(i)) {
          const n = a[i];

          if (s && (Array.isArray(n) || t(n))) {
            const t = Array.isArray(n) ? [] : {};
            o[i] = e(!0, o.hasOwnProperty(i) ? o[i] : t, n);
          } else o[i] = n;
        }
      }

      return o;
    },
          i = (t, e = 1e4) => (t = parseFloat(t) || 0, Math.round((t + Number.EPSILON) * e) / e),
          s = function (t) {
      return !!(t && "object" == typeof t && t instanceof Element && t !== document.body) && !t.__Panzoom && (function (t) {
        const e = getComputedStyle(t)["overflow-y"],
              i = getComputedStyle(t)["overflow-x"],
              s = ("scroll" === e || "auto" === e) && Math.abs(t.scrollHeight - t.clientHeight) > 1,
              o = ("scroll" === i || "auto" === i) && Math.abs(t.scrollWidth - t.clientWidth) > 1;
        return s || o;
      }(t) ? t : s(t.parentNode));
    },
          o = "undefined" != typeof window && window.ResizeObserver || class {
      constructor(t) {
        this.observables = [], this.boundCheck = this.check.bind(this), this.boundCheck(), this.callback = t;
      }

      observe(t) {
        if (this.observables.some(e => e.el === t)) return;
        const e = {
          el: t,
          size: {
            height: t.clientHeight,
            width: t.clientWidth
          }
        };
        this.observables.push(e);
      }

      unobserve(t) {
        this.observables = this.observables.filter(e => e.el !== t);
      }

      disconnect() {
        this.observables = [];
      }

      check() {
        const t = this.observables.filter(t => {
          const e = t.el.clientHeight,
                i = t.el.clientWidth;
          if (t.size.height !== e || t.size.width !== i) return t.size.height = e, t.size.width = i, !0;
        }).map(t => t.el);
        t.length > 0 && this.callback(t), window.requestAnimationFrame(this.boundCheck);
      }

    };

    class n {
      constructor(t) {
        this.id = self.Touch && t instanceof Touch ? t.identifier : -1, this.pageX = t.pageX, this.pageY = t.pageY, this.clientX = t.clientX, this.clientY = t.clientY;
      }

    }

    const a = (t, e) => e ? Math.sqrt((e.clientX - t.clientX) ** 2 + (e.clientY - t.clientY) ** 2) : 0,
          r = (t, e) => e ? {
      clientX: (t.clientX + e.clientX) / 2,
      clientY: (t.clientY + e.clientY) / 2
    } : t;

    class h {
      constructor(t, {
        start: e = () => !0,
        move: i = () => {},
        end: s = () => {}
      } = {}) {
        this._element = t, this.startPointers = [], this.currentPointers = [], this._pointerStart = t => {
          if (t.buttons > 0 && 0 !== t.button) return;
          const e = new n(t);
          this.currentPointers.some(t => t.id === e.id) || this._triggerPointerStart(e, t) && (window.addEventListener("mousemove", this._move), window.addEventListener("mouseup", this._pointerEnd));
        }, this._touchStart = t => {
          for (const e of Array.from(t.changedTouches || [])) this._triggerPointerStart(new n(e), t);
        }, this._move = t => {
          const e = this.currentPointers.slice(),
                i = (t => "changedTouches" in t)(t) ? Array.from(t.changedTouches).map(t => new n(t)) : [new n(t)];

          for (const t of i) {
            const e = this.currentPointers.findIndex(e => e.id === t.id);
            e < 0 || (this.currentPointers[e] = t);
          }

          this._moveCallback(e, this.currentPointers.slice(), t);
        }, this._triggerPointerEnd = (t, e) => {
          const i = this.currentPointers.findIndex(e => e.id === t.id);
          return !(i < 0) && (this.currentPointers.splice(i, 1), this.startPointers.splice(i, 1), this._endCallback(t, e), !0);
        }, this._pointerEnd = t => {
          t.buttons > 0 && 0 !== t.button || this._triggerPointerEnd(new n(t), t) && (window.removeEventListener("mousemove", this._move, {
            passive: !1
          }), window.removeEventListener("mouseup", this._pointerEnd, {
            passive: !1
          }));
        }, this._touchEnd = t => {
          for (const e of Array.from(t.changedTouches || [])) this._triggerPointerEnd(new n(e), t);
        }, this._startCallback = e, this._moveCallback = i, this._endCallback = s, this._element.addEventListener("mousedown", this._pointerStart, {
          passive: !1
        }), this._element.addEventListener("touchstart", this._touchStart, {
          passive: !1
        }), this._element.addEventListener("touchmove", this._move, {
          passive: !1
        }), this._element.addEventListener("touchend", this._touchEnd), this._element.addEventListener("touchcancel", this._touchEnd);
      }

      stop() {
        this._element.removeEventListener("mousedown", this._pointerStart, {
          passive: !1
        }), this._element.removeEventListener("touchstart", this._touchStart, {
          passive: !1
        }), this._element.removeEventListener("touchmove", this._move, {
          passive: !1
        }), this._element.removeEventListener("touchend", this._touchEnd), this._element.removeEventListener("touchcancel", this._touchEnd), window.removeEventListener("mousemove", this._move), window.removeEventListener("mouseup", this._pointerEnd);
      }

      _triggerPointerStart(t, e) {
        return !!this._startCallback(t, e) && (this.currentPointers.push(t), this.startPointers.push(t), !0);
      }

    }

    class l {
      constructor(t = {}) {
        this.options = e(!0, {}, t), this.plugins = [], this.events = {};

        for (const t of ["on", "once"]) for (const e of Object.entries(this.options[t] || {})) this[t](...e);
      }

      option(t, e, ...i) {
        t = String(t);
        let s = (o = t, n = this.options, o.split(".").reduce(function (t, e) {
          return t && t[e];
        }, n));
        var o, n;
        return "function" == typeof s && (s = s.call(this, this, ...i)), void 0 === s ? e : s;
      }

      localize(t, e = []) {
        return t = (t = String(t).replace(/\{\{(\w+).?(\w+)?\}\}/g, (t, i, s) => {
          let o = "";
          s ? o = this.option(`${i[0] + i.toLowerCase().substring(1)}.l10n.${s}`) : i && (o = this.option(`l10n.${i}`)), o || (o = t);

          for (let t = 0; t < e.length; t++) o = o.split(e[t][0]).join(e[t][1]);

          return o;
        })).replace(/\{\{(.*)\}\}/, (t, e) => e);
      }

      on(e, i) {
        if (t(e)) {
          for (const t of Object.entries(e)) this.on(...t);

          return this;
        }

        return String(e).split(" ").forEach(t => {
          const e = this.events[t] = this.events[t] || [];
          -1 == e.indexOf(i) && e.push(i);
        }), this;
      }

      once(e, i) {
        if (t(e)) {
          for (const t of Object.entries(e)) this.once(...t);

          return this;
        }

        return String(e).split(" ").forEach(t => {
          const e = (...s) => {
            this.off(t, e), i.call(this, this, ...s);
          };

          e._ = i, this.on(t, e);
        }), this;
      }

      off(e, i) {
        if (!t(e)) return e.split(" ").forEach(t => {
          const e = this.events[t];
          if (!e || !e.length) return this;
          let s = -1;

          for (let t = 0, o = e.length; t < o; t++) {
            const o = e[t];

            if (o && (o === i || o._ === i)) {
              s = t;
              break;
            }
          }

          -1 != s && e.splice(s, 1);
        }), this;

        for (const t of Object.entries(e)) this.off(...t);
      }

      trigger(t, ...e) {
        for (const i of [...(this.events[t] || [])].slice()) if (i && !1 === i.call(this, this, ...e)) return !1;

        for (const i of [...(this.events["*"] || [])].slice()) if (i && !1 === i.call(this, t, this, ...e)) return !1;

        return !0;
      }

      attachPlugins(t) {
        const i = {};

        for (const [s, o] of Object.entries(t || {})) !1 === this.options[s] || this.plugins[s] || (this.options[s] = e({}, o.defaults || {}, this.options[s]), i[s] = new o(this));

        for (const [t, e] of Object.entries(i)) e.attach(this);

        return this.plugins = Object.assign({}, this.plugins, i), this;
      }

      detachPlugins() {
        for (const t in this.plugins) {
          let e;
          (e = this.plugins[t]) && "function" == typeof e.detach && e.detach(this);
        }

        return this.plugins = {}, this;
      }

    }

    const c = {
      touch: !0,
      zoom: !0,
      pinchToZoom: !0,
      panOnlyZoomed: !1,
      lockAxis: !1,
      friction: .64,
      decelFriction: .88,
      zoomFriction: .74,
      bounceForce: .2,
      baseScale: 1,
      minScale: 1,
      maxScale: 2,
      step: .5,
      textSelection: !1,
      click: "toggleZoom",
      wheel: "zoom",
      wheelFactor: 42,
      wheelLimit: 5,
      draggableClass: "is-draggable",
      draggingClass: "is-dragging",
      ratio: 1
    };

    class d extends l {
      constructor(t, i = {}) {
        super(e(!0, {}, c, i)), this.state = "init", this.$container = t;

        for (const t of ["onLoad", "onWheel", "onClick"]) this[t] = this[t].bind(this);

        this.initLayout(), this.resetValues(), this.attachPlugins(d.Plugins), this.trigger("init"), this.updateMetrics(), this.attachEvents(), this.trigger("ready"), !1 === this.option("centerOnStart") ? this.state = "ready" : this.panTo({
          friction: 0
        }), t.__Panzoom = this;
      }

      initLayout() {
        const t = this.$container;
        if (!(t instanceof HTMLElement)) throw new Error("Panzoom: Container not found");
        const e = this.option("content") || t.querySelector(".panzoom__content");
        if (!e) throw new Error("Panzoom: Content not found");
        this.$content = e;
        let i = this.option("viewport") || t.querySelector(".panzoom__viewport");
        i || !1 === this.option("wrapInner") || (i = document.createElement("div"), i.classList.add("panzoom__viewport"), i.append(...t.childNodes), t.appendChild(i)), this.$viewport = i || e.parentNode;
      }

      resetValues() {
        this.updateRate = this.option("updateRate", /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ? 250 : 24), this.container = {
          width: 0,
          height: 0
        }, this.viewport = {
          width: 0,
          height: 0
        }, this.content = {
          origWidth: 0,
          origHeight: 0,
          width: 0,
          height: 0,
          x: this.option("x", 0),
          y: this.option("y", 0),
          scale: this.option("baseScale")
        }, this.transform = {
          x: 0,
          y: 0,
          scale: 1
        }, this.resetDragPosition();
      }

      onLoad(t) {
        this.updateMetrics(), this.panTo({
          scale: this.option("baseScale"),
          friction: 0
        }), this.trigger("load", t);
      }

      onClick(t) {
        if (t.defaultPrevented) return;
        if (document.activeElement && document.activeElement.closest("[contenteditable]")) return;
        if (this.option("textSelection") && window.getSelection().toString().length && (!t.target || !t.target.hasAttribute("data-fancybox-close"))) return void t.stopPropagation();
        const e = this.$content.getClientRects()[0];
        if ("ready" !== this.state && (this.dragPosition.midPoint || Math.abs(e.top - this.dragStart.rect.top) > 1 || Math.abs(e.left - this.dragStart.rect.left) > 1)) return t.preventDefault(), void t.stopPropagation();
        !1 !== this.trigger("click", t) && this.option("zoom") && "toggleZoom" === this.option("click") && (t.preventDefault(), t.stopPropagation(), this.zoomWithClick(t));
      }

      onWheel(t) {
        !1 !== this.trigger("wheel", t) && this.option("zoom") && this.option("wheel") && this.zoomWithWheel(t);
      }

      zoomWithWheel(t) {
        void 0 === this.changedDelta && (this.changedDelta = 0);
        const e = Math.max(-1, Math.min(1, -t.deltaY || -t.deltaX || t.wheelDelta || -t.detail)),
              i = this.content.scale;
        let s = i * (100 + e * this.option("wheelFactor")) / 100;
        if (e < 0 && Math.abs(i - this.option("minScale")) < .01 || e > 0 && Math.abs(i - this.option("maxScale")) < .01 ? (this.changedDelta += Math.abs(e), s = i) : (this.changedDelta = 0, s = Math.max(Math.min(s, this.option("maxScale")), this.option("minScale"))), this.changedDelta > this.option("wheelLimit")) return;
        if (t.preventDefault(), s === i) return;
        const o = this.$content.getBoundingClientRect(),
              n = t.clientX - o.left,
              a = t.clientY - o.top;
        this.zoomTo(s, {
          x: n,
          y: a
        });
      }

      zoomWithClick(t) {
        const e = this.$content.getClientRects()[0],
              i = t.clientX - e.left,
              s = t.clientY - e.top;
        this.toggleZoom({
          x: i,
          y: s
        });
      }

      attachEvents() {
        this.$content.addEventListener("load", this.onLoad), this.$container.addEventListener("wheel", this.onWheel, {
          passive: !1
        }), this.$container.addEventListener("click", this.onClick, {
          passive: !1
        }), this.initObserver();
        const t = new h(this.$container, {
          start: (e, i) => {
            if (!this.option("touch")) return !1;
            if (this.velocity.scale < 0) return !1;
            const o = i.composedPath()[0];

            if (!t.currentPointers.length) {
              if (-1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(o.nodeName)) return !1;
              if (this.option("textSelection") && ((t, e, i) => {
                const s = t.childNodes,
                      o = document.createRange();

                for (let t = 0; t < s.length; t++) {
                  const n = s[t];
                  if (n.nodeType !== Node.TEXT_NODE) continue;
                  o.selectNodeContents(n);
                  const a = o.getBoundingClientRect();
                  if (e >= a.left && i >= a.top && e <= a.right && i <= a.bottom) return n;
                }

                return !1;
              })(o, e.clientX, e.clientY)) return !1;
            }

            return !s(o) && !1 !== this.trigger("touchStart", i) && ("mousedown" === i.type && i.preventDefault(), this.state = "pointerdown", this.resetDragPosition(), this.dragPosition.midPoint = null, this.dragPosition.time = Date.now(), !0);
          },
          move: (e, i, s) => {
            if ("pointerdown" !== this.state) return;
            if (!1 === this.trigger("touchMove", s)) return void s.preventDefault();
            if (i.length < 2 && !0 === this.option("panOnlyZoomed") && this.content.width <= this.viewport.width && this.content.height <= this.viewport.height && this.transform.scale <= this.option("baseScale")) return;
            if (i.length > 1 && (!this.option("zoom") || !1 === this.option("pinchToZoom"))) return;
            const o = r(e[0], e[1]),
                  n = r(i[0], i[1]),
                  h = n.clientX - o.clientX,
                  l = n.clientY - o.clientY,
                  c = a(e[0], e[1]),
                  d = a(i[0], i[1]),
                  u = c && d ? d / c : 1;
            this.dragOffset.x += h, this.dragOffset.y += l, this.dragOffset.scale *= u, this.dragOffset.time = Date.now() - this.dragPosition.time;
            const f = 1 === this.dragStart.scale && this.option("lockAxis");

            if (f && !this.lockAxis) {
              if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6) return void s.preventDefault();
              const t = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI);
              this.lockAxis = t > 45 && t < 135 ? "y" : "x";
            }

            if ("xy" === f || "y" !== this.lockAxis) {
              if (s.preventDefault(), s.stopPropagation(), s.stopImmediatePropagation(), this.lockAxis && (this.dragOffset["x" === this.lockAxis ? "y" : "x"] = 0), this.$container.classList.add(this.option("draggingClass")), this.transform.scale === this.option("baseScale") && "y" === this.lockAxis || (this.dragPosition.x = this.dragStart.x + this.dragOffset.x), this.transform.scale === this.option("baseScale") && "x" === this.lockAxis || (this.dragPosition.y = this.dragStart.y + this.dragOffset.y), this.dragPosition.scale = this.dragStart.scale * this.dragOffset.scale, i.length > 1) {
                const e = r(t.startPointers[0], t.startPointers[1]),
                      i = e.clientX - this.dragStart.rect.x,
                      s = e.clientY - this.dragStart.rect.y,
                      {
                  deltaX: o,
                  deltaY: a
                } = this.getZoomDelta(this.content.scale * this.dragOffset.scale, i, s);
                this.dragPosition.x -= o, this.dragPosition.y -= a, this.dragPosition.midPoint = n;
              } else this.setDragResistance();

              this.transform = {
                x: this.dragPosition.x,
                y: this.dragPosition.y,
                scale: this.dragPosition.scale
              }, this.startAnimation();
            }
          },
          end: (e, i) => {
            if ("pointerdown" !== this.state) return;
            if (this._dragOffset = { ...this.dragOffset
            }, t.currentPointers.length) return void this.resetDragPosition();
            if (this.state = "decel", this.friction = this.option("decelFriction"), this.recalculateTransform(), this.$container.classList.remove(this.option("draggingClass")), !1 === this.trigger("touchEnd", i)) return;
            if ("decel" !== this.state) return;
            const s = this.option("minScale");
            if (this.transform.scale < s) return void this.zoomTo(s, {
              friction: .64
            });
            const o = this.option("maxScale");

            if (this.transform.scale - o > .01) {
              const t = this.dragPosition.midPoint || e,
                    i = this.$content.getClientRects()[0];
              this.zoomTo(o, {
                friction: .64,
                x: t.clientX - i.left,
                y: t.clientY - i.top
              });
            }
          }
        });
        this.pointerTracker = t;
      }

      initObserver() {
        this.resizeObserver || (this.resizeObserver = new o(() => {
          this.updateTimer || (this.updateTimer = setTimeout(() => {
            const t = this.$container.getBoundingClientRect();
            t.width && t.height ? ((Math.abs(t.width - this.container.width) > 1 || Math.abs(t.height - this.container.height) > 1) && (this.isAnimating() && this.endAnimation(!0), this.updateMetrics(), this.panTo({
              x: this.content.x,
              y: this.content.y,
              scale: this.option("baseScale"),
              friction: 0
            })), this.updateTimer = null) : this.updateTimer = null;
          }, this.updateRate));
        }), this.resizeObserver.observe(this.$container));
      }

      resetDragPosition() {
        this.lockAxis = null, this.friction = this.option("friction"), this.velocity = {
          x: 0,
          y: 0,
          scale: 0
        };
        const {
          x: t,
          y: e,
          scale: i
        } = this.content;
        this.dragStart = {
          rect: this.$content.getBoundingClientRect(),
          x: t,
          y: e,
          scale: i
        }, this.dragPosition = { ...this.dragPosition,
          x: t,
          y: e,
          scale: i
        }, this.dragOffset = {
          x: 0,
          y: 0,
          scale: 1,
          time: 0
        };
      }

      updateMetrics(t) {
        !0 !== t && this.trigger("beforeUpdate");
        const e = this.$container,
              s = this.$content,
              o = this.$viewport,
              n = s instanceof HTMLImageElement,
              a = this.option("zoom"),
              r = this.option("resizeParent", a);
        let h = this.option("width"),
            l = this.option("height"),
            c = h || (d = s, Math.max(parseFloat(d.naturalWidth || 0), parseFloat(d.width && d.width.baseVal && d.width.baseVal.value || 0), parseFloat(d.offsetWidth || 0), parseFloat(d.scrollWidth || 0)));
        var d;

        let u = l || (t => Math.max(parseFloat(t.naturalHeight || 0), parseFloat(t.height && t.height.baseVal && t.height.baseVal.value || 0), parseFloat(t.offsetHeight || 0), parseFloat(t.scrollHeight || 0)))(s);

        Object.assign(s.style, {
          width: h ? `${h}px` : "",
          height: l ? `${l}px` : "",
          maxWidth: "",
          maxHeight: ""
        }), r && Object.assign(o.style, {
          width: "",
          height: ""
        });
        const f = this.option("ratio");
        c = i(c * f), u = i(u * f), h = c, l = u;
        const g = s.getBoundingClientRect(),
              p = o.getBoundingClientRect(),
              m = o == e ? p : e.getBoundingClientRect();
        let y = Math.max(o.offsetWidth, i(p.width)),
            v = Math.max(o.offsetHeight, i(p.height)),
            b = window.getComputedStyle(o);

        if (y -= parseFloat(b.paddingLeft) + parseFloat(b.paddingRight), v -= parseFloat(b.paddingTop) + parseFloat(b.paddingBottom), this.viewport.width = y, this.viewport.height = v, a) {
          if (Math.abs(c - g.width) > .1 || Math.abs(u - g.height) > .1) {
            const t = ((t, e, i, s) => {
              const o = Math.min(i / t || 0, s / e);
              return {
                width: t * o || 0,
                height: e * o || 0
              };
            })(c, u, Math.min(c, g.width), Math.min(u, g.height));

            h = i(t.width), l = i(t.height);
          }

          Object.assign(s.style, {
            width: `${h}px`,
            height: `${l}px`,
            transform: ""
          });
        }

        if (r && (Object.assign(o.style, {
          width: `${h}px`,
          height: `${l}px`
        }), this.viewport = { ...this.viewport,
          width: h,
          height: l
        }), n && a && "function" != typeof this.options.maxScale) {
          const t = this.option("maxScale");

          this.options.maxScale = function () {
            return this.content.origWidth > 0 && this.content.fitWidth > 0 ? this.content.origWidth / this.content.fitWidth : t;
          };
        }

        this.content = { ...this.content,
          origWidth: c,
          origHeight: u,
          fitWidth: h,
          fitHeight: l,
          width: h,
          height: l,
          scale: 1,
          isZoomable: a
        }, this.container = {
          width: m.width,
          height: m.height
        }, !0 !== t && this.trigger("afterUpdate");
      }

      zoomIn(t) {
        this.zoomTo(this.content.scale + (t || this.option("step")));
      }

      zoomOut(t) {
        this.zoomTo(this.content.scale - (t || this.option("step")));
      }

      toggleZoom(t = {}) {
        const e = this.option("maxScale"),
              i = this.option("baseScale"),
              s = this.content.scale > i + .5 * (e - i) ? i : e;
        this.zoomTo(s, t);
      }

      zoomTo(t = this.option("baseScale"), {
        x: e = null,
        y: s = null
      } = {}) {
        t = Math.max(Math.min(t, this.option("maxScale")), this.option("minScale"));
        const o = i(this.content.scale / (this.content.width / this.content.fitWidth), 1e7);
        null === e && (e = this.content.width * o * .5), null === s && (s = this.content.height * o * .5);
        const {
          deltaX: n,
          deltaY: a
        } = this.getZoomDelta(t, e, s);
        e = this.content.x - n, s = this.content.y - a, this.panTo({
          x: e,
          y: s,
          scale: t,
          friction: this.option("zoomFriction")
        });
      }

      getZoomDelta(t, e = 0, i = 0) {
        const s = this.content.fitWidth * this.content.scale,
              o = this.content.fitHeight * this.content.scale,
              n = e > 0 && s ? e / s : 0,
              a = i > 0 && o ? i / o : 0;
        return {
          deltaX: (this.content.fitWidth * t - s) * n,
          deltaY: (this.content.fitHeight * t - o) * a
        };
      }

      panTo({
        x: t = this.content.x,
        y: e = this.content.y,
        scale: i,
        friction: s = this.option("friction"),
        ignoreBounds: o = !1
      } = {}) {
        if (i = i || this.content.scale || 1, !o) {
          const {
            boundX: s,
            boundY: o
          } = this.getBounds(i);
          s && (t = Math.max(Math.min(t, s.to), s.from)), o && (e = Math.max(Math.min(e, o.to), o.from));
        }

        this.friction = s, this.transform = { ...this.transform,
          x: t,
          y: e,
          scale: i
        }, s ? (this.state = "panning", this.velocity = {
          x: (1 / this.friction - 1) * (t - this.content.x),
          y: (1 / this.friction - 1) * (e - this.content.y),
          scale: (1 / this.friction - 1) * (i - this.content.scale)
        }, this.startAnimation()) : this.endAnimation();
      }

      startAnimation() {
        this.rAF ? cancelAnimationFrame(this.rAF) : this.trigger("startAnimation"), this.rAF = requestAnimationFrame(() => this.animate());
      }

      animate() {
        if (this.setEdgeForce(), this.setDragForce(), this.velocity.x *= this.friction, this.velocity.y *= this.friction, this.velocity.scale *= this.friction, this.content.x += this.velocity.x, this.content.y += this.velocity.y, this.content.scale += this.velocity.scale, this.isAnimating()) this.setTransform();else if ("pointerdown" !== this.state) return void this.endAnimation();
        this.rAF = requestAnimationFrame(() => this.animate());
      }

      getBounds(t) {
        let e = this.boundX,
            s = this.boundY;
        if (void 0 !== e && void 0 !== s) return {
          boundX: e,
          boundY: s
        };
        e = {
          from: 0,
          to: 0
        }, s = {
          from: 0,
          to: 0
        }, t = t || this.transform.scale;
        const o = this.content.fitWidth * t,
              n = this.content.fitHeight * t,
              a = this.viewport.width,
              r = this.viewport.height;

        if (o < a) {
          const t = i(.5 * (a - o));
          e.from = t, e.to = t;
        } else e.from = i(a - o);

        if (n < r) {
          const t = .5 * (r - n);
          s.from = t, s.to = t;
        } else s.from = i(r - n);

        return {
          boundX: e,
          boundY: s
        };
      }

      setEdgeForce() {
        if ("decel" !== this.state) return;
        const t = this.option("bounceForce"),
              {
          boundX: e,
          boundY: i
        } = this.getBounds(Math.max(this.transform.scale, this.content.scale));
        let s, o, n, a;

        if (e && (s = this.content.x < e.from, o = this.content.x > e.to), i && (n = this.content.y < i.from, a = this.content.y > i.to), s || o) {
          let i = ((s ? e.from : e.to) - this.content.x) * t;
          const o = this.content.x + (this.velocity.x + i) / this.friction;
          o >= e.from && o <= e.to && (i += this.velocity.x), this.velocity.x = i, this.recalculateTransform();
        }

        if (n || a) {
          let e = ((n ? i.from : i.to) - this.content.y) * t;
          const s = this.content.y + (e + this.velocity.y) / this.friction;
          s >= i.from && s <= i.to && (e += this.velocity.y), this.velocity.y = e, this.recalculateTransform();
        }
      }

      setDragResistance() {
        if ("pointerdown" !== this.state) return;
        const {
          boundX: t,
          boundY: e
        } = this.getBounds(this.dragPosition.scale);
        let i, s, o, n;

        if (t && (i = this.dragPosition.x < t.from, s = this.dragPosition.x > t.to), e && (o = this.dragPosition.y < e.from, n = this.dragPosition.y > e.to), (i || s) && (!i || !s)) {
          const e = i ? t.from : t.to,
                s = e - this.dragPosition.x;
          this.dragPosition.x = e - .3 * s;
        }

        if ((o || n) && (!o || !n)) {
          const t = o ? e.from : e.to,
                i = t - this.dragPosition.y;
          this.dragPosition.y = t - .3 * i;
        }
      }

      setDragForce() {
        "pointerdown" === this.state && (this.velocity.x = this.dragPosition.x - this.content.x, this.velocity.y = this.dragPosition.y - this.content.y, this.velocity.scale = this.dragPosition.scale - this.content.scale);
      }

      recalculateTransform() {
        this.transform.x = this.content.x + this.velocity.x / (1 / this.friction - 1), this.transform.y = this.content.y + this.velocity.y / (1 / this.friction - 1), this.transform.scale = this.content.scale + this.velocity.scale / (1 / this.friction - 1);
      }

      isAnimating() {
        return !(!this.friction || !(Math.abs(this.velocity.x) > .05 || Math.abs(this.velocity.y) > .05 || Math.abs(this.velocity.scale) > .05));
      }

      setTransform(t) {
        let e, s, o;

        if (t ? (e = i(this.transform.x), s = i(this.transform.y), o = this.transform.scale, this.content = { ...this.content,
          x: e,
          y: s,
          scale: o
        }) : (e = i(this.content.x), s = i(this.content.y), o = this.content.scale / (this.content.width / this.content.fitWidth), this.content = { ...this.content,
          x: e,
          y: s
        }), this.trigger("beforeTransform"), e = i(this.content.x), s = i(this.content.y), t && this.option("zoom")) {
          let t, n;
          t = i(this.content.fitWidth * o), n = i(this.content.fitHeight * o), this.content.width = t, this.content.height = n, this.transform = { ...this.transform,
            width: t,
            height: n,
            scale: o
          }, Object.assign(this.$content.style, {
            width: `${t}px`,
            height: `${n}px`,
            maxWidth: "none",
            maxHeight: "none",
            transform: `translate3d(${e}px, ${s}px, 0) scale(1)`
          });
        } else this.$content.style.transform = `translate3d(${e}px, ${s}px, 0) scale(${o})`;

        this.trigger("afterTransform");
      }

      endAnimation(t) {
        cancelAnimationFrame(this.rAF), this.rAF = null, this.velocity = {
          x: 0,
          y: 0,
          scale: 0
        }, this.setTransform(!0), this.state = "ready", this.handleCursor(), !0 !== t && this.trigger("endAnimation");
      }

      handleCursor() {
        const t = this.option("draggableClass");
        t && this.option("touch") && (1 == this.option("panOnlyZoomed") && this.content.width <= this.viewport.width && this.content.height <= this.viewport.height && this.transform.scale <= this.option("baseScale") ? this.$container.classList.remove(t) : this.$container.classList.add(t));
      }

      detachEvents() {
        this.$content.removeEventListener("load", this.onLoad), this.$container.removeEventListener("wheel", this.onWheel, {
          passive: !1
        }), this.$container.removeEventListener("click", this.onClick, {
          passive: !1
        }), this.pointerTracker && (this.pointerTracker.stop(), this.pointerTracker = null), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null);
      }

      destroy() {
        "destroy" !== this.state && (this.state = "destroy", clearTimeout(this.updateTimer), this.updateTimer = null, cancelAnimationFrame(this.rAF), this.rAF = null, this.detachEvents(), this.detachPlugins(), this.resetDragPosition());
      }

    }

    d.version = "4.0.31", d.Plugins = {};

    const u = (t, e) => {
      let i = 0;
      return function (...s) {
        const o = new Date().getTime();
        if (!(o - i < e)) return i = o, t(...s);
      };
    };

    class f {
      constructor(t) {
        this.$container = null, this.$prev = null, this.$next = null, this.carousel = t, this.onRefresh = this.onRefresh.bind(this);
      }

      option(t) {
        return this.carousel.option(`Navigation.${t}`);
      }

      createButton(t) {
        const e = document.createElement("button");
        e.setAttribute("title", this.carousel.localize(`{{${t.toUpperCase()}}}`));
        const i = this.option("classNames.button") + " " + this.option(`classNames.${t}`);
        return e.classList.add(...i.split(" ")), e.setAttribute("tabindex", "0"), e.innerHTML = this.carousel.localize(this.option(`${t}Tpl`)), e.addEventListener("click", e => {
          e.preventDefault(), e.stopPropagation(), this.carousel["slide" + ("next" === t ? "Next" : "Prev")]();
        }), e;
      }

      build() {
        this.$container || (this.$container = document.createElement("div"), this.$container.classList.add(...this.option("classNames.main").split(" ")), this.carousel.$container.appendChild(this.$container)), this.$next || (this.$next = this.createButton("next"), this.$container.appendChild(this.$next)), this.$prev || (this.$prev = this.createButton("prev"), this.$container.appendChild(this.$prev));
      }

      onRefresh() {
        const t = this.carousel.pages.length;
        t <= 1 || t > 1 && this.carousel.elemDimWidth < this.carousel.wrapDimWidth && !Number.isInteger(this.carousel.option("slidesPerPage")) ? this.cleanup() : (this.build(), this.$prev.removeAttribute("disabled"), this.$next.removeAttribute("disabled"), this.carousel.option("infiniteX", this.carousel.option("infinite")) || (this.carousel.page <= 0 && this.$prev.setAttribute("disabled", ""), this.carousel.page >= t - 1 && this.$next.setAttribute("disabled", "")));
      }

      cleanup() {
        this.$prev && this.$prev.remove(), this.$prev = null, this.$next && this.$next.remove(), this.$next = null, this.$container && this.$container.remove(), this.$container = null;
      }

      attach() {
        this.carousel.on("refresh change", this.onRefresh);
      }

      detach() {
        this.carousel.off("refresh change", this.onRefresh), this.cleanup();
      }

    }

    f.defaults = {
      prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>',
      nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>',
      classNames: {
        main: "carousel__nav",
        button: "carousel__button",
        next: "is-next",
        prev: "is-prev"
      }
    };

    class g {
      constructor(t) {
        this.carousel = t, this.selectedIndex = null, this.friction = 0, this.onNavReady = this.onNavReady.bind(this), this.onNavClick = this.onNavClick.bind(this), this.onNavCreateSlide = this.onNavCreateSlide.bind(this), this.onTargetChange = this.onTargetChange.bind(this);
      }

      addAsTargetFor(t) {
        this.target = this.carousel, this.nav = t, this.attachEvents();
      }

      addAsNavFor(t) {
        this.target = t, this.nav = this.carousel, this.attachEvents();
      }

      attachEvents() {
        this.nav.options.initialSlide = this.target.options.initialPage, this.nav.on("ready", this.onNavReady), this.nav.on("createSlide", this.onNavCreateSlide), this.nav.on("Panzoom.click", this.onNavClick), this.target.on("change", this.onTargetChange), this.target.on("Panzoom.afterUpdate", this.onTargetChange);
      }

      onNavReady() {
        this.onTargetChange(!0);
      }

      onNavClick(t, e, i) {
        const s = i.target.closest(".carousel__slide");
        if (!s) return;
        i.stopPropagation();
        const o = parseInt(s.dataset.index, 10),
              n = this.target.findPageForSlide(o);
        this.target.page !== n && this.target.slideTo(n, {
          friction: this.friction
        }), this.markSelectedSlide(o);
      }

      onNavCreateSlide(t, e) {
        e.index === this.selectedIndex && this.markSelectedSlide(e.index);
      }

      onTargetChange() {
        const t = this.target.pages[this.target.page].indexes[0],
              e = this.nav.findPageForSlide(t);
        this.nav.slideTo(e), this.markSelectedSlide(t);
      }

      markSelectedSlide(t) {
        this.selectedIndex = t, [...this.nav.slides].filter(t => t.$el && t.$el.classList.remove("is-nav-selected"));
        const e = this.nav.slides[t];
        e && e.$el && e.$el.classList.add("is-nav-selected");
      }

      attach(t) {
        const e = t.options.Sync;
        (e.target || e.nav) && (e.target ? this.addAsNavFor(e.target) : e.nav && this.addAsTargetFor(e.nav), this.friction = e.friction);
      }

      detach() {
        this.nav && (this.nav.off("ready", this.onNavReady), this.nav.off("Panzoom.click", this.onNavClick), this.nav.off("createSlide", this.onNavCreateSlide)), this.target && (this.target.off("Panzoom.afterUpdate", this.onTargetChange), this.target.off("change", this.onTargetChange));
      }

    }

    g.defaults = {
      friction: .92
    };
    const p = {
      Navigation: f,
      Dots: class {
        constructor(t) {
          this.carousel = t, this.$list = null, this.events = {
            change: this.onChange.bind(this),
            refresh: this.onRefresh.bind(this)
          };
        }

        buildList() {
          if (this.carousel.pages.length < this.carousel.option("Dots.minSlideCount")) return;
          const t = document.createElement("ol");
          return t.classList.add("carousel__dots"), t.addEventListener("click", t => {
            if (!("page" in t.target.dataset)) return;
            t.preventDefault(), t.stopPropagation();
            const e = parseInt(t.target.dataset.page, 10),
                  i = this.carousel;
            e !== i.page && (i.pages.length < 3 && i.option("infinite") ? i[0 == e ? "slidePrev" : "slideNext"]() : i.slideTo(e));
          }), this.$list = t, this.carousel.$container.appendChild(t), this.carousel.$container.classList.add("has-dots"), t;
        }

        removeList() {
          this.$list && (this.$list.parentNode.removeChild(this.$list), this.$list = null), this.carousel.$container.classList.remove("has-dots");
        }

        rebuildDots() {
          let t = this.$list;
          const e = !!t,
                i = this.carousel.pages.length;
          if (i < 2) return void (e && this.removeList());
          e || (t = this.buildList());
          const s = this.$list.children.length;
          if (s > i) for (let t = i; t < s; t++) this.$list.removeChild(this.$list.lastChild);else {
            for (let t = s; t < i; t++) {
              const e = document.createElement("li");
              e.classList.add("carousel__dot"), e.dataset.page = t, e.setAttribute("role", "button"), e.setAttribute("tabindex", "0"), e.setAttribute("title", this.carousel.localize("{{GOTO}}", [["%d", t + 1]])), e.addEventListener("keydown", t => {
                const i = t.code;
                let s;
                "Enter" === i || "NumpadEnter" === i ? s = e : "ArrowRight" === i ? s = e.nextSibling : "ArrowLeft" === i && (s = e.previousSibling), s && s.click();
              }), this.$list.appendChild(e);
            }

            this.setActiveDot();
          }
        }

        setActiveDot() {
          if (!this.$list) return;
          this.$list.childNodes.forEach(t => {
            t.classList.remove("is-selected");
          });
          const t = this.$list.childNodes[this.carousel.page];
          t && t.classList.add("is-selected");
        }

        onChange() {
          this.setActiveDot();
        }

        onRefresh() {
          this.rebuildDots();
        }

        attach() {
          this.carousel.on(this.events);
        }

        detach() {
          this.removeList(), this.carousel.off(this.events), this.carousel = null;
        }

      },
      Sync: g
    };
    const m = {
      slides: [],
      preload: 0,
      slidesPerPage: "auto",
      initialPage: null,
      initialSlide: null,
      friction: .92,
      center: !0,
      infinite: !0,
      fill: !0,
      dragFree: !1,
      prefix: "",
      classNames: {
        viewport: "carousel__viewport",
        track: "carousel__track",
        slide: "carousel__slide",
        slideSelected: "is-selected"
      },
      l10n: {
        NEXT: "Next slide",
        PREV: "Previous slide",
        GOTO: "Go to slide #%d"
      }
    };

    class y extends l {
      constructor(t, i = {}) {
        if (super(i = e(!0, {}, m, i)), this.state = "init", this.$container = t, !(this.$container instanceof HTMLElement)) throw new Error("No root element provided");
        this.slideNext = u(this.slideNext.bind(this), 250), this.slidePrev = u(this.slidePrev.bind(this), 250), this.init(), t.__Carousel = this;
      }

      init() {
        this.pages = [], this.page = this.pageIndex = null, this.prevPage = this.prevPageIndex = null, this.attachPlugins(y.Plugins), this.trigger("init"), this.initLayout(), this.initSlides(), this.updateMetrics(), this.$track && this.pages.length && (this.$track.style.transform = `translate3d(${-1 * this.pages[this.page].left}px, 0px, 0) scale(1)`), this.manageSlideVisiblity(), this.initPanzoom(), this.state = "ready", this.trigger("ready");
      }

      initLayout() {
        const t = this.option("prefix"),
              e = this.option("classNames");
        this.$viewport = this.option("viewport") || this.$container.querySelector(`.${t}${e.viewport}`), this.$viewport || (this.$viewport = document.createElement("div"), this.$viewport.classList.add(...(t + e.viewport).split(" ")), this.$viewport.append(...this.$container.childNodes), this.$container.appendChild(this.$viewport)), this.$track = this.option("track") || this.$container.querySelector(`.${t}${e.track}`), this.$track || (this.$track = document.createElement("div"), this.$track.classList.add(...(t + e.track).split(" ")), this.$track.append(...this.$viewport.childNodes), this.$viewport.appendChild(this.$track));
      }

      initSlides() {
        this.slides = [];
        this.$viewport.querySelectorAll(`.${this.option("prefix")}${this.option("classNames.slide")}`).forEach(t => {
          const e = {
            $el: t,
            isDom: !0
          };
          this.slides.push(e), this.trigger("createSlide", e, this.slides.length);
        }), Array.isArray(this.options.slides) && (this.slides = e(!0, [...this.slides], this.options.slides));
      }

      updateMetrics() {
        let t,
            e = 0,
            s = [];
        this.slides.forEach((i, o) => {
          const n = i.$el,
                a = i.isDom || !t ? this.getSlideMetrics(n) : t;
          i.index = o, i.width = a, i.left = e, t = a, e += a, s.push(o);
        });
        let o = Math.max(this.$track.offsetWidth, i(this.$track.getBoundingClientRect().width)),
            n = getComputedStyle(this.$track);
        o -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight), this.contentWidth = e, this.viewportWidth = o;
        const a = [],
              r = this.option("slidesPerPage");
        if (Number.isInteger(r) && e > o) for (let t = 0; t < this.slides.length; t += r) a.push({
          indexes: s.slice(t, t + r),
          slides: this.slides.slice(t, t + r)
        });else {
          let t = 0,
              e = 0;

          for (let i = 0; i < this.slides.length; i += 1) {
            let s = this.slides[i];
            (!a.length || e + s.width > o) && (a.push({
              indexes: [],
              slides: []
            }), t = a.length - 1, e = 0), e += s.width, a[t].indexes.push(i), a[t].slides.push(s);
          }
        }
        const h = this.option("center"),
              l = this.option("fill");
        a.forEach((t, i) => {
          t.index = i, t.width = t.slides.reduce((t, e) => t + e.width, 0), t.left = t.slides[0].left, h && (t.left += .5 * (o - t.width) * -1), l && !this.option("infiniteX", this.option("infinite")) && e > o && (t.left = Math.max(t.left, 0), t.left = Math.min(t.left, e - o));
        });
        const c = [];
        let d;
        a.forEach(t => {
          const e = { ...t
          };
          d && e.left === d.left ? (d.width += e.width, d.slides = [...d.slides, ...e.slides], d.indexes = [...d.indexes, ...e.indexes]) : (e.index = c.length, d = e, c.push(e));
        }), this.pages = c;
        let u = this.page;

        if (null === u) {
          const t = this.option("initialSlide");
          u = null !== t ? this.findPageForSlide(t) : parseInt(this.option("initialPage", 0), 10) || 0, c[u] || (u = c.length && u > c.length ? c[c.length - 1].index : 0), this.page = u, this.pageIndex = u;
        }

        this.updatePanzoom(), this.trigger("refresh");
      }

      getSlideMetrics(t) {
        if (!t) {
          const e = this.slides[0];
          (t = document.createElement("div")).dataset.isTestEl = 1, t.style.visibility = "hidden", t.classList.add(...(this.option("prefix") + this.option("classNames.slide")).split(" ")), e.customClass && t.classList.add(...e.customClass.split(" ")), this.$track.prepend(t);
        }

        let e = Math.max(t.offsetWidth, i(t.getBoundingClientRect().width));
        const s = t.currentStyle || window.getComputedStyle(t);
        return e = e + (parseFloat(s.marginLeft) || 0) + (parseFloat(s.marginRight) || 0), t.dataset.isTestEl && t.remove(), e;
      }

      findPageForSlide(t) {
        t = parseInt(t, 10) || 0;
        const e = this.pages.find(e => e.indexes.indexOf(t) > -1);
        return e ? e.index : null;
      }

      slideNext() {
        this.slideTo(this.pageIndex + 1);
      }

      slidePrev() {
        this.slideTo(this.pageIndex - 1);
      }

      slideTo(t, e = {}) {
        const {
          x: i = -1 * this.setPage(t, !0),
          y: s = 0,
          friction: o = this.option("friction")
        } = e;
        this.Panzoom.content.x === i && !this.Panzoom.velocity.x && o || (this.Panzoom.panTo({
          x: i,
          y: s,
          friction: o,
          ignoreBounds: !0
        }), "ready" === this.state && "ready" === this.Panzoom.state && this.trigger("settle"));
      }

      initPanzoom() {
        this.Panzoom && this.Panzoom.destroy();
        const t = e(!0, {}, {
          content: this.$track,
          wrapInner: !1,
          resizeParent: !1,
          zoom: !1,
          click: !1,
          lockAxis: "x",
          x: this.pages.length ? -1 * this.pages[this.page].left : 0,
          centerOnStart: !1,
          textSelection: () => this.option("textSelection", !1),
          panOnlyZoomed: function () {
            return this.content.width <= this.viewport.width;
          }
        }, this.option("Panzoom"));
        this.Panzoom = new d(this.$container, t), this.Panzoom.on({
          "*": (t, ...e) => this.trigger(`Panzoom.${t}`, ...e),
          afterUpdate: () => {
            this.updatePage();
          },
          beforeTransform: this.onBeforeTransform.bind(this),
          touchEnd: this.onTouchEnd.bind(this),
          endAnimation: () => {
            this.trigger("settle");
          }
        }), this.updateMetrics(), this.manageSlideVisiblity();
      }

      updatePanzoom() {
        this.Panzoom && (this.Panzoom.content = { ...this.Panzoom.content,
          fitWidth: this.contentWidth,
          origWidth: this.contentWidth,
          width: this.contentWidth
        }, this.pages.length > 1 && this.option("infiniteX", this.option("infinite")) ? this.Panzoom.boundX = null : this.pages.length && (this.Panzoom.boundX = {
          from: -1 * this.pages[this.pages.length - 1].left,
          to: -1 * this.pages[0].left
        }), this.option("infiniteY", this.option("infinite")) ? this.Panzoom.boundY = null : this.Panzoom.boundY = {
          from: 0,
          to: 0
        }, this.Panzoom.handleCursor());
      }

      manageSlideVisiblity() {
        const t = this.contentWidth,
              e = this.viewportWidth;
        let i = this.Panzoom ? -1 * this.Panzoom.content.x : this.pages.length ? this.pages[this.page].left : 0;
        const s = this.option("preload"),
              o = this.option("infiniteX", this.option("infinite")),
              n = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-left")),
              a = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-right"));
        this.slides.forEach(r => {
          let h,
              l,
              c = 0;
          h = i - n, l = i + e + a, h -= s * (e + n + a), l += s * (e + n + a);
          const d = r.left + r.width > h && r.left < l;
          h = i + t - n, l = i + t + e + a, h -= s * (e + n + a);
          const u = o && r.left + r.width > h && r.left < l;
          h = i - t - n, l = i - t + e + a, h -= s * (e + n + a);
          const f = o && r.left + r.width > h && r.left < l;
          u || d || f ? (this.createSlideEl(r), d && (c = 0), u && (c = -1), f && (c = 1), r.left + r.width > i && r.left <= i + e + a && (c = 0)) : this.removeSlideEl(r), r.hasDiff = c;
        });
        let r = 0,
            h = 0;
        this.slides.forEach((e, i) => {
          let s = 0;
          e.$el ? (i !== r || e.hasDiff ? s = h + e.hasDiff * t : h = 0, e.$el.style.left = Math.abs(s) > .1 ? `${h + e.hasDiff * t}px` : "", r++) : h += e.width;
        }), this.markSelectedSlides();
      }

      createSlideEl(t) {
        if (!t) return;

        if (t.$el) {
          let e = t.$el.dataset.index;

          if (!e || parseInt(e, 10) !== t.index) {
            let e;
            t.$el.dataset.index = t.index, t.$el.querySelectorAll("[data-lazy-srcset]").forEach(t => {
              t.srcset = t.dataset.lazySrcset;
            }), t.$el.querySelectorAll("[data-lazy-src]").forEach(t => {
              let e = t.dataset.lazySrc;
              t instanceof HTMLImageElement ? t.src = e : t.style.backgroundImage = `url('${e}')`;
            }), (e = t.$el.dataset.lazySrc) && (t.$el.style.backgroundImage = `url('${e}')`), t.state = "ready";
          }

          return;
        }

        const e = document.createElement("div");
        e.dataset.index = t.index, e.classList.add(...(this.option("prefix") + this.option("classNames.slide")).split(" ")), t.customClass && e.classList.add(...t.customClass.split(" ")), t.html && (e.innerHTML = t.html);
        const i = [];
        this.slides.forEach((t, e) => {
          t.$el && i.push(e);
        });
        const s = t.index;
        let o = null;

        if (i.length) {
          let t = i.reduce((t, e) => Math.abs(e - s) < Math.abs(t - s) ? e : t);
          o = this.slides[t];
        }

        return this.$track.insertBefore(e, o && o.$el ? o.index < t.index ? o.$el.nextSibling : o.$el : null), t.$el = e, this.trigger("createSlide", t, s), t;
      }

      removeSlideEl(t) {
        t.$el && !t.isDom && (this.trigger("removeSlide", t), t.$el.remove(), t.$el = null);
      }

      markSelectedSlides() {
        const t = this.option("classNames.slideSelected"),
              e = "aria-hidden";
        this.slides.forEach((i, s) => {
          const o = i.$el;
          if (!o) return;
          const n = this.pages[this.page];
          n && n.indexes && n.indexes.indexOf(s) > -1 ? (t && !o.classList.contains(t) && (o.classList.add(t), this.trigger("selectSlide", i)), o.removeAttribute(e)) : (t && o.classList.contains(t) && (o.classList.remove(t), this.trigger("unselectSlide", i)), o.setAttribute(e, !0));
        });
      }

      updatePage() {
        this.updateMetrics(), this.slideTo(this.page, {
          friction: 0
        });
      }

      onBeforeTransform() {
        this.option("infiniteX", this.option("infinite")) && this.manageInfiniteTrack(), this.manageSlideVisiblity();
      }

      manageInfiniteTrack() {
        const t = this.contentWidth,
              e = this.viewportWidth;
        if (!this.option("infiniteX", this.option("infinite")) || this.pages.length < 2 || t < e) return;
        const i = this.Panzoom;
        let s = !1;
        return i.content.x < -1 * (t - e) && (i.content.x += t, this.pageIndex = this.pageIndex - this.pages.length, s = !0), i.content.x > e && (i.content.x -= t, this.pageIndex = this.pageIndex + this.pages.length, s = !0), s && "pointerdown" === i.state && i.resetDragPosition(), s;
      }

      onTouchEnd(t, e) {
        const i = this.option("dragFree");
        if (!i && this.pages.length > 1 && t.dragOffset.time < 350 && Math.abs(t.dragOffset.y) < 1 && Math.abs(t.dragOffset.x) > 5) this[t.dragOffset.x < 0 ? "slideNext" : "slidePrev"]();else if (i) {
          const [, e] = this.getPageFromPosition(-1 * t.transform.x);
          this.setPage(e);
        } else this.slideToClosest();
      }

      slideToClosest(t = {}) {
        let [, e] = this.getPageFromPosition(-1 * this.Panzoom.content.x);
        this.slideTo(e, t);
      }

      getPageFromPosition(t) {
        const e = this.pages.length;
        this.option("center") && (t += .5 * this.viewportWidth);
        const i = Math.floor(t / this.contentWidth);
        t -= i * this.contentWidth;
        let s = this.slides.find(e => e.left <= t && e.left + e.width > t);

        if (s) {
          let t = this.findPageForSlide(s.index);
          return [t, t + i * e];
        }

        return [0, 0];
      }

      setPage(t, e) {
        let i = 0,
            s = parseInt(t, 10) || 0;
        const o = this.page,
              n = this.pageIndex,
              a = this.pages.length,
              r = this.contentWidth,
              h = this.viewportWidth;

        if (t = (s % a + a) % a, this.option("infiniteX", this.option("infinite")) && r > h) {
          const o = Math.floor(s / a) || 0,
                n = r;

          if (i = this.pages[t].left + o * n, !0 === e && a > 2) {
            let t = -1 * this.Panzoom.content.x;
            const e = i - n,
                  o = i + n,
                  r = Math.abs(t - i),
                  h = Math.abs(t - e),
                  l = Math.abs(t - o);
            l < r && l <= h ? (i = o, s += a) : h < r && h < l && (i = e, s -= a);
          }
        } else t = s = Math.max(0, Math.min(s, a - 1)), i = this.pages.length ? this.pages[t].left : 0;

        return this.page = t, this.pageIndex = s, null !== o && t !== o && (this.prevPage = o, this.prevPageIndex = n, this.trigger("change", t, o)), i;
      }

      destroy() {
        this.state = "destroy", this.slides.forEach(t => {
          this.removeSlideEl(t);
        }), this.slides = [], this.Panzoom.destroy(), this.detachPlugins();
      }

    }

    y.version = "4.0.31", y.Plugins = p;
    const v = !("undefined" == typeof window || !window.document || !window.document.createElement);
    let b = null;

    const x = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden])", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])'],
          w = t => {
      if (t && v) {
        null === b && document.createElement("div").focus({
          get preventScroll() {
            return b = !0, !1;
          }

        });

        try {
          if (t.setActive) t.setActive();else if (b) t.focus({
            preventScroll: !0
          });else {
            const e = window.pageXOffset || document.body.scrollTop,
                  i = window.pageYOffset || document.body.scrollLeft;
            t.focus(), document.body.scrollTo({
              top: e,
              left: i,
              behavior: "auto"
            });
          }
        } catch (t) {}
      }
    };

    const $$1 = {
      minSlideCount: 2,
      minScreenHeight: 500,
      autoStart: !0,
      key: "t",
      Carousel: {},
      tpl: '<div class="fancybox__thumb" style="background-image:url(\'{{src}}\')"></div>'
    };

    class C {
      constructor(t) {
        this.fancybox = t, this.$container = null, this.state = "init";

        for (const t of ["onPrepare", "onClosing", "onKeydown"]) this[t] = this[t].bind(this);

        this.events = {
          prepare: this.onPrepare,
          closing: this.onClosing,
          keydown: this.onKeydown
        };
      }

      onPrepare() {
        this.getSlides().length < this.fancybox.option("Thumbs.minSlideCount") ? this.state = "disabled" : !0 === this.fancybox.option("Thumbs.autoStart") && this.fancybox.Carousel.Panzoom.content.height >= this.fancybox.option("Thumbs.minScreenHeight") && this.build();
      }

      onClosing() {
        this.Carousel && this.Carousel.Panzoom.detachEvents();
      }

      onKeydown(t, e) {
        e === t.option("Thumbs.key") && this.toggle();
      }

      build() {
        if (this.$container) return;
        const t = document.createElement("div");
        t.classList.add("fancybox__thumbs"), this.fancybox.$carousel.parentNode.insertBefore(t, this.fancybox.$carousel.nextSibling), this.Carousel = new y(t, e(!0, {
          Dots: !1,
          Navigation: !1,
          Sync: {
            friction: 0
          },
          infinite: !1,
          center: !0,
          fill: !0,
          dragFree: !0,
          slidesPerPage: 1,
          preload: 1
        }, this.fancybox.option("Thumbs.Carousel"), {
          Sync: {
            target: this.fancybox.Carousel
          },
          slides: this.getSlides()
        })), this.Carousel.Panzoom.on("wheel", (t, e) => {
          e.preventDefault(), this.fancybox[e.deltaY < 0 ? "prev" : "next"]();
        }), this.$container = t, this.state = "visible";
      }

      getSlides() {
        const t = [];

        for (const e of this.fancybox.items) {
          const i = e.thumb;
          i && t.push({
            html: this.fancybox.option("Thumbs.tpl").replace(/\{\{src\}\}/gi, i),
            customClass: `has-thumb has-${e.type || "image"}`
          });
        }

        return t;
      }

      toggle() {
        "visible" === this.state ? this.hide() : "hidden" === this.state ? this.show() : this.build();
      }

      show() {
        "hidden" === this.state && (this.$container.style.display = "", this.Carousel.Panzoom.attachEvents(), this.state = "visible");
      }

      hide() {
        "visible" === this.state && (this.Carousel.Panzoom.detachEvents(), this.$container.style.display = "none", this.state = "hidden");
      }

      cleanup() {
        this.Carousel && (this.Carousel.destroy(), this.Carousel = null), this.$container && (this.$container.remove(), this.$container = null), this.state = "init";
      }

      attach() {
        this.fancybox.on(this.events);
      }

      detach() {
        this.fancybox.off(this.events), this.cleanup();
      }

    }

    C.defaults = $$1;

    const S = (t, e) => {
      const i = new URL(t),
            s = new URLSearchParams(i.search);
      let o = new URLSearchParams();

      for (const [t, i] of [...s, ...Object.entries(e)]) "t" === t ? o.set("start", parseInt(i)) : o.set(t, i);

      o = o.toString();
      let n = t.match(/#t=((.*)?\d+s)/);
      return n && (o += `#t=${n[1]}`), o;
    },
          E = {
      video: {
        autoplay: !0,
        ratio: 16 / 9
      },
      youtube: {
        autohide: 1,
        fs: 1,
        rel: 0,
        hd: 1,
        wmode: "transparent",
        enablejsapi: 1,
        html5: 1
      },
      vimeo: {
        hd: 1,
        show_title: 1,
        show_byline: 1,
        show_portrait: 0,
        fullscreen: 1
      },
      html5video: {
        tpl: '<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">\n  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos.</video>',
        format: ""
      }
    };

    class P {
      constructor(t) {
        this.fancybox = t;

        for (const t of ["onInit", "onReady", "onCreateSlide", "onRemoveSlide", "onSelectSlide", "onUnselectSlide", "onRefresh", "onMessage"]) this[t] = this[t].bind(this);

        this.events = {
          init: this.onInit,
          ready: this.onReady,
          "Carousel.createSlide": this.onCreateSlide,
          "Carousel.removeSlide": this.onRemoveSlide,
          "Carousel.selectSlide": this.onSelectSlide,
          "Carousel.unselectSlide": this.onUnselectSlide,
          "Carousel.refresh": this.onRefresh
        };
      }

      onInit() {
        for (const t of this.fancybox.items) this.processType(t);
      }

      processType(t) {
        if (t.html) return t.src = t.html, t.type = "html", void delete t.html;
        const i = t.src || "";
        let s = t.type || this.fancybox.options.type,
            o = null;

        if (!i || "string" == typeof i) {
          if (o = i.match(/(?:youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) {
            const e = S(i, this.fancybox.option("Html.youtube")),
                  n = encodeURIComponent(o[1]);
            t.videoId = n, t.src = `https://www.youtube-nocookie.com/embed/${n}?${e}`, t.thumb = t.thumb || `https://i.ytimg.com/vi/${n}/mqdefault.jpg`, t.vendor = "youtube", s = "video";
          } else if (o = i.match(/^.+vimeo.com\/(?:\/)?([\d]+)(.*)?/)) {
            const e = S(i, this.fancybox.option("Html.vimeo")),
                  n = encodeURIComponent(o[1]);
            t.videoId = n, t.src = `https://player.vimeo.com/video/${n}?${e}`, t.vendor = "vimeo", s = "video";
          } else (o = i.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (t.src = `//maps.google.${o[1]}/?ll=${(o[2] ? o[2] + "&z=" + Math.floor(o[3]) + (o[4] ? o[4].replace(/^\//, "&") : "") : o[4] + "").replace(/\?/, "&")}&output=${o[4] && o[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, s = "map") : (o = i.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (t.src = `//maps.google.${o[1]}/maps?q=${o[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, s = "map");

          s || ("#" === i.charAt(0) ? s = "inline" : (o = i.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (s = "html5video", t.format = t.format || "video/" + ("ogv" === o[1] ? "ogg" : o[1])) : i.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? s = "image" : i.match(/\.(pdf)((\?|#).*)?$/i) && (s = "pdf")), t.type = s || this.fancybox.option("defaultType", "image"), "html5video" !== s && "video" !== s || (t.video = e({}, this.fancybox.option("Html.video"), t.video), t._width && t._height ? t.ratio = parseFloat(t._width) / parseFloat(t._height) : t.ratio = t.ratio || t.video.ratio || E.video.ratio);
        }
      }

      onReady() {
        this.fancybox.Carousel.slides.forEach(t => {
          t.$el && (this.setContent(t), t.index === this.fancybox.getSlide().index && this.playVideo(t));
        });
      }

      onCreateSlide(t, e, i) {
        "ready" === this.fancybox.state && this.setContent(i);
      }

      loadInlineContent(t) {
        let e;
        if (t.src instanceof HTMLElement) e = t.src;else if ("string" == typeof t.src) {
          const i = t.src.split("#", 2),
                s = 2 === i.length && "" === i[0] ? i[1] : i[0];
          e = document.getElementById(s);
        }

        if (e) {
          if ("clone" === t.type || e.$placeHolder) {
            e = e.cloneNode(!0);
            let i = e.getAttribute("id");
            i = i ? `${i}--clone` : `clone-${this.fancybox.id}-${t.index}`, e.setAttribute("id", i);
          } else {
            const t = document.createElement("div");
            t.classList.add("fancybox-placeholder"), e.parentNode.insertBefore(t, e), e.$placeHolder = t;
          }

          this.fancybox.setContent(t, e);
        } else this.fancybox.setError(t, "{{ELEMENT_NOT_FOUND}}");
      }

      loadAjaxContent(t) {
        const e = this.fancybox,
              i = new XMLHttpRequest();
        e.showLoading(t), i.onreadystatechange = function () {
          i.readyState === XMLHttpRequest.DONE && "ready" === e.state && (e.hideLoading(t), 200 === i.status ? e.setContent(t, i.responseText) : e.setError(t, 404 === i.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}"));
        };
        const s = t.ajax || null;
        i.open(s ? "POST" : "GET", t.src), i.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), i.setRequestHeader("X-Requested-With", "XMLHttpRequest"), i.send(s), t.xhr = i;
      }

      loadIframeContent(t) {
        const e = this.fancybox,
              i = document.createElement("iframe");
        if (i.className = "fancybox__iframe", i.setAttribute("id", `fancybox__iframe_${e.id}_${t.index}`), i.setAttribute("allow", "autoplay; fullscreen"), i.setAttribute("scrolling", "auto"), t.$iframe = i, "iframe" !== t.type || !1 === t.preload) return i.setAttribute("src", t.src), this.fancybox.setContent(t, i), void this.resizeIframe(t);
        e.showLoading(t);
        const s = document.createElement("div");
        s.style.visibility = "hidden", this.fancybox.setContent(t, s), s.appendChild(i), i.onerror = () => {
          e.setError(t, "{{IFRAME_ERROR}}");
        }, i.onload = () => {
          e.hideLoading(t);
          let s = !1;
          i.isReady || (i.isReady = !0, s = !0), i.src.length && (i.parentNode.style.visibility = "", this.resizeIframe(t), s && e.revealContent(t));
        }, i.setAttribute("src", t.src);
      }

      setAspectRatio(t) {
        const e = t.$content,
              i = t.ratio;
        if (!e) return;
        let s = t._width,
            o = t._height;

        if (i || s && o) {
          Object.assign(e.style, {
            width: s && o ? "100%" : "",
            height: s && o ? "100%" : "",
            maxWidth: "",
            maxHeight: ""
          });
          let t = e.offsetWidth,
              n = e.offsetHeight;

          if (s = s || t, o = o || n, s > t || o > n) {
            let e = Math.min(t / s, n / o);
            s *= e, o *= e;
          }

          Math.abs(s / o - i) > .01 && (i < s / o ? s = o * i : o = s / i), Object.assign(e.style, {
            width: `${s}px`,
            height: `${o}px`
          });
        }
      }

      resizeIframe(t) {
        const e = t.$iframe;
        if (!e) return;
        let i = t._width || 0,
            s = t._height || 0;
        i && s && (t.autoSize = !1);
        const o = e.parentNode,
              n = o && o.style;
        if (!1 !== t.preload && !1 !== t.autoSize && n) try {
          const t = window.getComputedStyle(o),
                a = parseFloat(t.paddingLeft) + parseFloat(t.paddingRight),
                r = parseFloat(t.paddingTop) + parseFloat(t.paddingBottom),
                h = e.contentWindow.document,
                l = h.getElementsByTagName("html")[0],
                c = h.body;
          n.width = "", c.style.overflow = "hidden", i = i || l.scrollWidth + a, n.width = `${i}px`, c.style.overflow = "", n.flex = "0 0 auto", n.height = `${c.scrollHeight}px`, s = l.scrollHeight + r;
        } catch (t) {}

        if (i || s) {
          const t = {
            flex: "0 1 auto"
          };
          i && (t.width = `${i}px`), s && (t.height = `${s}px`), Object.assign(n, t);
        }
      }

      onRefresh(t, e) {
        e.slides.forEach(t => {
          t.$el && (t.$iframe && this.resizeIframe(t), t.ratio && this.setAspectRatio(t));
        });
      }

      setContent(t) {
        if (t && !t.isDom) {
          switch (t.type) {
            case "html":
              this.fancybox.setContent(t, t.src);
              break;

            case "html5video":
              this.fancybox.setContent(t, this.fancybox.option("Html.html5video.tpl").replace(/\{\{src\}\}/gi, t.src).replace("{{format}}", t.format || t.html5video && t.html5video.format || "").replace("{{poster}}", t.poster || t.thumb || ""));
              break;

            case "inline":
            case "clone":
              this.loadInlineContent(t);
              break;

            case "ajax":
              this.loadAjaxContent(t);
              break;

            case "pdf":
            case "video":
            case "map":
              t.preload = !1;

            case "iframe":
              this.loadIframeContent(t);
          }

          t.ratio && this.setAspectRatio(t);
        }
      }

      onSelectSlide(t, e, i) {
        "ready" === t.state && this.playVideo(i);
      }

      playVideo(t) {
        if ("html5video" === t.type && t.video.autoplay) try {
          const e = t.$el.querySelector("video");

          if (e) {
            const t = e.play();
            void 0 !== t && t.then(() => {}).catch(t => {
              e.muted = !0, e.play();
            });
          }
        } catch (t) {}
        if ("video" !== t.type || !t.$iframe || !t.$iframe.contentWindow) return;

        const e = () => {
          if ("done" === t.state && t.$iframe && t.$iframe.contentWindow) {
            let e;
            if (t.$iframe.isReady) return t.video && t.video.autoplay && (e = "youtube" == t.vendor ? {
              event: "command",
              func: "playVideo"
            } : {
              method: "play",
              value: "true"
            }), void (e && t.$iframe.contentWindow.postMessage(JSON.stringify(e), "*"));
            "youtube" === t.vendor && (e = {
              event: "listening",
              id: t.$iframe.getAttribute("id")
            }, t.$iframe.contentWindow.postMessage(JSON.stringify(e), "*"));
          }

          t.poller = setTimeout(e, 250);
        };

        e();
      }

      onUnselectSlide(t, e, i) {
        if ("html5video" === i.type) {
          try {
            i.$el.querySelector("video").pause();
          } catch (t) {}

          return;
        }

        let s = !1;
        "vimeo" == i.vendor ? s = {
          method: "pause",
          value: "true"
        } : "youtube" === i.vendor && (s = {
          event: "command",
          func: "pauseVideo"
        }), s && i.$iframe && i.$iframe.contentWindow && i.$iframe.contentWindow.postMessage(JSON.stringify(s), "*"), clearTimeout(i.poller);
      }

      onRemoveSlide(t, e, i) {
        i.xhr && (i.xhr.abort(), i.xhr = null), i.$iframe && (i.$iframe.onload = i.$iframe.onerror = null, i.$iframe.src = "//about:blank", i.$iframe = null);
        const s = i.$content;
        "inline" === i.type && s && (s.classList.remove("fancybox__content"), "none" !== s.style.display && (s.style.display = "none")), i.$closeButton && (i.$closeButton.remove(), i.$closeButton = null);
        const o = s && s.$placeHolder;
        o && (o.parentNode.insertBefore(s, o), o.remove(), s.$placeHolder = null);
      }

      onMessage(t) {
        try {
          let e = JSON.parse(t.data);

          if ("https://player.vimeo.com" === t.origin) {
            if ("ready" === e.event) for (let e of document.getElementsByClassName("fancybox__iframe")) e.contentWindow === t.source && (e.isReady = 1);
          } else "https://www.youtube-nocookie.com" === t.origin && "onReady" === e.event && (document.getElementById(e.id).isReady = 1);
        } catch (t) {}
      }

      attach() {
        this.fancybox.on(this.events), window.addEventListener("message", this.onMessage, !1);
      }

      detach() {
        this.fancybox.off(this.events), window.removeEventListener("message", this.onMessage, !1);
      }

    }

    P.defaults = E;

    class T {
      constructor(t) {
        this.fancybox = t;

        for (const t of ["onReady", "onClosing", "onDone", "onPageChange", "onCreateSlide", "onRemoveSlide", "onImageStatusChange"]) this[t] = this[t].bind(this);

        this.events = {
          ready: this.onReady,
          closing: this.onClosing,
          done: this.onDone,
          "Carousel.change": this.onPageChange,
          "Carousel.createSlide": this.onCreateSlide,
          "Carousel.removeSlide": this.onRemoveSlide
        };
      }

      onReady() {
        this.fancybox.Carousel.slides.forEach(t => {
          t.$el && this.setContent(t);
        });
      }

      onDone(t, e) {
        this.handleCursor(e);
      }

      onClosing(t) {
        clearTimeout(this.clickTimer), this.clickTimer = null, t.Carousel.slides.forEach(t => {
          t.$image && (t.state = "destroy"), t.Panzoom && t.Panzoom.detachEvents();
        }), "closing" === this.fancybox.state && this.canZoom(t.getSlide()) && this.zoomOut();
      }

      onCreateSlide(t, e, i) {
        "ready" === this.fancybox.state && this.setContent(i);
      }

      onRemoveSlide(t, e, i) {
        i.$image && (i.$el.classList.remove(t.option("Image.canZoomInClass")), i.$image.remove(), i.$image = null), i.Panzoom && (i.Panzoom.destroy(), i.Panzoom = null), i.$el && i.$el.dataset && delete i.$el.dataset.imageFit;
      }

      setContent(t) {
        if (t.isDom || t.html || t.type && "image" !== t.type) return;
        if (t.$image) return;
        t.type = "image", t.state = "loading";
        const e = document.createElement("div");
        e.style.visibility = "hidden";
        const i = document.createElement("img");
        i.addEventListener("load", e => {
          e.stopImmediatePropagation(), this.onImageStatusChange(t);
        }), i.addEventListener("error", () => {
          this.onImageStatusChange(t);
        }), i.src = t.src, i.alt = "", i.draggable = !1, i.classList.add("fancybox__image"), t.srcset && i.setAttribute("srcset", t.srcset), t.sizes && i.setAttribute("sizes", t.sizes), t.$image = i;
        const s = this.fancybox.option("Image.wrap");

        if (s) {
          const o = document.createElement("div");
          o.classList.add("string" == typeof s ? s : "fancybox__image-wrap"), o.appendChild(i), e.appendChild(o), t.$wrap = o;
        } else e.appendChild(i);

        t.$el.dataset.imageFit = this.fancybox.option("Image.fit"), this.fancybox.setContent(t, e), i.complete || i.error ? this.onImageStatusChange(t) : this.fancybox.showLoading(t);
      }

      onImageStatusChange(t) {
        const e = t.$image;
        e && "loading" === t.state && (e.complete && e.naturalWidth && e.naturalHeight ? (this.fancybox.hideLoading(t), "contain" === this.fancybox.option("Image.fit") && this.initSlidePanzoom(t), t.$el.addEventListener("wheel", e => this.onWheel(t, e), {
          passive: !1
        }), t.$content.addEventListener("click", e => this.onClick(t, e), {
          passive: !1
        }), this.revealContent(t)) : this.fancybox.setError(t, "{{IMAGE_ERROR}}"));
      }

      initSlidePanzoom(t) {
        t.Panzoom || (t.Panzoom = new d(t.$el, e(!0, this.fancybox.option("Image.Panzoom", {}), {
          viewport: t.$wrap,
          content: t.$image,
          width: t._width,
          height: t._height,
          wrapInner: !1,
          textSelection: !0,
          touch: this.fancybox.option("Image.touch"),
          panOnlyZoomed: !0,
          click: !1,
          wheel: !1
        })), t.Panzoom.on("startAnimation", () => {
          this.fancybox.trigger("Image.startAnimation", t);
        }), t.Panzoom.on("endAnimation", () => {
          "zoomIn" === t.state && this.fancybox.done(t), this.handleCursor(t), this.fancybox.trigger("Image.endAnimation", t);
        }), t.Panzoom.on("afterUpdate", () => {
          this.handleCursor(t), this.fancybox.trigger("Image.afterUpdate", t);
        }));
      }

      revealContent(t) {
        null === this.fancybox.Carousel.prevPage && t.index === this.fancybox.options.startIndex && this.canZoom(t) ? this.zoomIn() : this.fancybox.revealContent(t);
      }

      getZoomInfo(t) {
        const e = t.$thumb.getBoundingClientRect(),
              i = e.width,
              s = e.height,
              o = t.$content.getBoundingClientRect(),
              n = o.width,
              a = o.height,
              r = o.top - e.top,
              h = o.left - e.left;
        let l = this.fancybox.option("Image.zoomOpacity");
        return "auto" === l && (l = Math.abs(i / s - n / a) > .1), {
          top: r,
          left: h,
          scale: n && i ? i / n : 1,
          opacity: l
        };
      }

      canZoom(t) {
        const e = this.fancybox,
              i = e.$container;
        if (window.visualViewport && 1 !== window.visualViewport.scale) return !1;
        if (t.Panzoom && !t.Panzoom.content.width) return !1;
        if (!e.option("Image.zoom") || "contain" !== e.option("Image.fit")) return !1;
        const s = t.$thumb;
        if (!s || "loading" === t.state) return !1;
        i.classList.add("fancybox__no-click");
        const o = s.getBoundingClientRect();
        let n;

        if (this.fancybox.option("Image.ignoreCoveredThumbnail")) {
          const t = document.elementFromPoint(o.left + 1, o.top + 1) === s,
                e = document.elementFromPoint(o.right - 1, o.bottom - 1) === s;
          n = t && e;
        } else n = document.elementFromPoint(o.left + .5 * o.width, o.top + .5 * o.height) === s;

        return i.classList.remove("fancybox__no-click"), n;
      }

      zoomIn() {
        const t = this.fancybox,
              e = t.getSlide(),
              i = e.Panzoom,
              {
          top: s,
          left: o,
          scale: n,
          opacity: a
        } = this.getZoomInfo(e);
        t.trigger("reveal", e), i.panTo({
          x: -1 * o,
          y: -1 * s,
          scale: n,
          friction: 0,
          ignoreBounds: !0
        }), e.$content.style.visibility = "", e.state = "zoomIn", !0 === a && i.on("afterTransform", t => {
          "zoomIn" !== e.state && "zoomOut" !== e.state || (t.$content.style.opacity = Math.min(1, 1 - (1 - t.content.scale) / (1 - n)));
        }), i.panTo({
          x: 0,
          y: 0,
          scale: 1,
          friction: this.fancybox.option("Image.zoomFriction")
        });
      }

      zoomOut() {
        const t = this.fancybox,
              e = t.getSlide(),
              i = e.Panzoom;
        if (!i) return;
        e.state = "zoomOut", t.state = "customClosing", e.$caption && (e.$caption.style.visibility = "hidden");
        let s = this.fancybox.option("Image.zoomFriction");

        const o = t => {
          const {
            top: o,
            left: n,
            scale: a,
            opacity: r
          } = this.getZoomInfo(e);
          t || r || (s *= .82), i.panTo({
            x: -1 * n,
            y: -1 * o,
            scale: a,
            friction: s,
            ignoreBounds: !0
          }), s *= .98;
        };

        window.addEventListener("scroll", o), i.once("endAnimation", () => {
          window.removeEventListener("scroll", o), t.destroy();
        }), o();
      }

      handleCursor(t) {
        if ("image" !== t.type || !t.$el) return;
        const e = t.Panzoom,
              i = this.fancybox.option("Image.click", !1, t),
              s = this.fancybox.option("Image.touch"),
              o = t.$el.classList,
              n = this.fancybox.option("Image.canZoomInClass"),
              a = this.fancybox.option("Image.canZoomOutClass");

        if (o.remove(a), o.remove(n), e && "toggleZoom" === i) {
          e && 1 === e.content.scale && e.option("maxScale") - e.content.scale > .01 ? o.add(n) : e.content.scale > 1 && !s && o.add(a);
        } else "close" === i && o.add(a);
      }

      onWheel(t, e) {
        if ("ready" === this.fancybox.state && !1 !== this.fancybox.trigger("Image.wheel", e)) switch (this.fancybox.option("Image.wheel")) {
          case "zoom":
            "done" === t.state && t.Panzoom && t.Panzoom.zoomWithWheel(e);
            break;

          case "close":
            this.fancybox.close();
            break;

          case "slide":
            this.fancybox[e.deltaY < 0 ? "prev" : "next"]();
        }
      }

      onClick(t, e) {
        if ("ready" !== this.fancybox.state) return;
        const i = t.Panzoom;
        if (i && (i.dragPosition.midPoint || 0 !== i.dragOffset.x || 0 !== i.dragOffset.y || 1 !== i.dragOffset.scale)) return;
        if (this.fancybox.Carousel.Panzoom.lockAxis) return !1;

        const s = i => {
          switch (i) {
            case "toggleZoom":
              e.stopPropagation(), t.Panzoom && t.Panzoom.zoomWithClick(e);
              break;

            case "close":
              this.fancybox.close();
              break;

            case "next":
              e.stopPropagation(), this.fancybox.next();
          }
        },
              o = this.fancybox.option("Image.click"),
              n = this.fancybox.option("Image.doubleClick");

        n ? this.clickTimer ? (clearTimeout(this.clickTimer), this.clickTimer = null, s(n)) : this.clickTimer = setTimeout(() => {
          this.clickTimer = null, s(o);
        }, 300) : s(o);
      }

      onPageChange(t, e) {
        const i = t.getSlide();
        e.slides.forEach(t => {
          t.Panzoom && "done" === t.state && t.index !== i.index && t.Panzoom.panTo({
            x: 0,
            y: 0,
            scale: 1,
            friction: .8
          });
        });
      }

      attach() {
        this.fancybox.on(this.events);
      }

      detach() {
        this.fancybox.off(this.events);
      }

    }

    T.defaults = {
      canZoomInClass: "can-zoom_in",
      canZoomOutClass: "can-zoom_out",
      zoom: !0,
      zoomOpacity: "auto",
      zoomFriction: .82,
      ignoreCoveredThumbnail: !1,
      touch: !0,
      click: "toggleZoom",
      doubleClick: null,
      wheel: "zoom",
      fit: "contain",
      wrap: !1,
      Panzoom: {
        ratio: 1
      }
    };

    class L {
      constructor(t) {
        this.fancybox = t;

        for (const t of ["onChange", "onClosing"]) this[t] = this[t].bind(this);

        this.events = {
          initCarousel: this.onChange,
          "Carousel.change": this.onChange,
          closing: this.onClosing
        }, this.hasCreatedHistory = !1, this.origHash = "", this.timer = null;
      }

      onChange(t) {
        const e = t.Carousel;
        this.timer && clearTimeout(this.timer);
        const i = null === e.prevPage,
              s = t.getSlide(),
              o = new URL(document.URL).hash;
        let n = !1;
        if (s.slug) n = "#" + s.slug;else {
          const i = s.$trigger && s.$trigger.dataset,
                o = t.option("slug") || i && i.fancybox;
          o && o.length && "true" !== o && (n = "#" + o + (e.slides.length > 1 ? "-" + (s.index + 1) : ""));
        }
        i && (this.origHash = o !== n ? o : ""), n && o !== n && (this.timer = setTimeout(() => {
          try {
            window.history[i ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + n), i && (this.hasCreatedHistory = !0);
          } catch (t) {}
        }, 300));
      }

      onClosing() {
        if (this.timer && clearTimeout(this.timer), !0 !== this.hasSilentClose) try {
          return void window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (this.origHash || ""));
        } catch (t) {}
      }

      attach(t) {
        t.on(this.events);
      }

      detach(t) {
        t.off(this.events);
      }

      static startFromUrl() {
        const t = L.Fancybox;
        if (!t || t.getInstance() || !1 === t.defaults.Hash) return;
        const {
          hash: e,
          slug: i,
          index: s
        } = L.getParsedURL();
        if (!i) return;
        let o = document.querySelector(`[data-slug="${e}"]`);
        if (o && o.dispatchEvent(new CustomEvent("click", {
          bubbles: !0,
          cancelable: !0
        })), t.getInstance()) return;
        const n = document.querySelectorAll(`[data-fancybox="${i}"]`);
        n.length && (null === s && 1 === n.length ? o = n[0] : s && (o = n[s - 1]), o && o.dispatchEvent(new CustomEvent("click", {
          bubbles: !0,
          cancelable: !0
        })));
      }

      static onHashChange() {
        const {
          slug: t,
          index: e
        } = L.getParsedURL(),
              i = L.Fancybox,
              s = i && i.getInstance();

        if (s && s.plugins.Hash) {
          if (t) {
            const i = s.Carousel;
            if (t === s.option("slug")) return i.slideTo(e - 1);

            for (let e of i.slides) if (e.slug && e.slug === t) return i.slideTo(e.index);

            const o = s.getSlide(),
                  n = o.$trigger && o.$trigger.dataset;
            if (n && n.fancybox === t) return i.slideTo(e - 1);
          }

          s.plugins.Hash.hasSilentClose = !0, s.close();
        }

        L.startFromUrl();
      }

      static create(t) {
        function e() {
          window.addEventListener("hashchange", L.onHashChange, !1), L.startFromUrl();
        }

        L.Fancybox = t, v && window.requestAnimationFrame(() => {
          /complete|interactive|loaded/.test(document.readyState) ? e() : document.addEventListener("DOMContentLoaded", e);
        });
      }

      static destroy() {
        window.removeEventListener("hashchange", L.onHashChange, !1);
      }

      static getParsedURL() {
        const t = window.location.hash.substr(1),
              e = t.split("-"),
              i = e.length > 1 && /^\+?\d+$/.test(e[e.length - 1]) && parseInt(e.pop(-1), 10) || null;
        return {
          hash: t,
          slug: e.join("-"),
          index: i
        };
      }

    }

    const _ = {
      pageXOffset: 0,
      pageYOffset: 0,
      element: () => document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement,

      activate(t) {
        _.pageXOffset = window.pageXOffset, _.pageYOffset = window.pageYOffset, t.requestFullscreen ? t.requestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.msRequestFullscreen && t.msRequestFullscreen();
      },

      deactivate() {
        document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen();
      }

    };

    class A {
      constructor(t) {
        this.fancybox = t, this.active = !1, this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
      }

      isActive() {
        return this.active;
      }

      setTimer() {
        if (!this.active || this.timer) return;
        const t = this.fancybox.option("slideshow.delay", 3e3);
        this.timer = setTimeout(() => {
          this.timer = null, this.fancybox.option("infinite") || this.fancybox.getSlide().index !== this.fancybox.Carousel.slides.length - 1 ? this.fancybox.next() : this.fancybox.jumpTo(0, {
            friction: 0
          });
        }, t);
        let e = this.$progress;
        e || (e = document.createElement("div"), e.classList.add("fancybox__progress"), this.fancybox.$carousel.parentNode.insertBefore(e, this.fancybox.$carousel), this.$progress = e, e.offsetHeight), e.style.transitionDuration = `${t}ms`, e.style.transform = "scaleX(1)";
      }

      clearTimer() {
        clearTimeout(this.timer), this.timer = null, this.$progress && (this.$progress.style.transitionDuration = "", this.$progress.style.transform = "", this.$progress.offsetHeight);
      }

      activate() {
        this.active || (this.active = !0, this.fancybox.$container.classList.add("has-slideshow"), "done" === this.fancybox.getSlide().state && this.setTimer(), document.addEventListener("visibilitychange", this.handleVisibilityChange, !1));
      }

      handleVisibilityChange() {
        this.deactivate();
      }

      deactivate() {
        this.active = !1, this.clearTimer(), this.fancybox.$container.classList.remove("has-slideshow"), document.removeEventListener("visibilitychange", this.handleVisibilityChange, !1);
      }

      toggle() {
        this.active ? this.deactivate() : this.fancybox.Carousel.slides.length > 1 && this.activate();
      }

    }

    const z = {
      display: ["counter", "zoom", "slideshow", "fullscreen", "thumbs", "close"],
      autoEnable: !0,
      items: {
        counter: {
          position: "left",
          type: "div",
          class: "fancybox__counter",
          html: '<span data-fancybox-index=""></span>&nbsp;/&nbsp;<span data-fancybox-count=""></span>',
          attr: {
            tabindex: -1
          }
        },
        prev: {
          type: "button",
          class: "fancybox__button--prev",
          label: "PREV",
          html: '<svg viewBox="0 0 24 24"><path d="M15 4l-8 8 8 8"/></svg>',
          attr: {
            "data-fancybox-prev": ""
          }
        },
        next: {
          type: "button",
          class: "fancybox__button--next",
          label: "NEXT",
          html: '<svg viewBox="0 0 24 24"><path d="M8 4l8 8-8 8"/></svg>',
          attr: {
            "data-fancybox-next": ""
          }
        },
        fullscreen: {
          type: "button",
          class: "fancybox__button--fullscreen",
          label: "TOGGLE_FULLSCREEN",
          html: '<svg viewBox="0 0 24 24">\n                <g><path d="M3 8 V3h5"></path><path d="M21 8V3h-5"></path><path d="M8 21H3v-5"></path><path d="M16 21h5v-5"></path></g>\n                <g><path d="M7 2v5H2M17 2v5h5M2 17h5v5M22 17h-5v5"/></g>\n            </svg>',
          click: function (t) {
            t.preventDefault(), _.element() ? _.deactivate() : _.activate(this.fancybox.$container);
          }
        },
        slideshow: {
          type: "button",
          class: "fancybox__button--slideshow",
          label: "TOGGLE_SLIDESHOW",
          html: '<svg viewBox="0 0 24 24">\n                <g><path d="M6 4v16"/><path d="M20 12L6 20"/><path d="M20 12L6 4"/></g>\n                <g><path d="M7 4v15M17 4v15"/></g>\n            </svg>',
          click: function (t) {
            t.preventDefault(), this.Slideshow.toggle();
          }
        },
        zoom: {
          type: "button",
          class: "fancybox__button--zoom",
          label: "TOGGLE_ZOOM",
          html: '<svg viewBox="0 0 24 24"><circle cx="10" cy="10" r="7"></circle><path d="M16 16 L21 21"></svg>',
          click: function (t) {
            t.preventDefault();
            const e = this.fancybox.getSlide().Panzoom;
            e && e.toggleZoom();
          }
        },
        download: {
          type: "link",
          label: "DOWNLOAD",
          class: "fancybox__button--download",
          html: '<svg viewBox="0 0 24 24"><path d="M12 15V3m0 12l-4-4m4 4l4-4M2 17l.62 2.48A2 2 0 004.56 21h14.88a2 2 0 001.94-1.51L22 17"/></svg>',
          click: function (t) {
            t.stopPropagation();
          }
        },
        thumbs: {
          type: "button",
          label: "TOGGLE_THUMBS",
          class: "fancybox__button--thumbs",
          html: '<svg viewBox="0 0 24 24"><circle cx="4" cy="4" r="1" /><circle cx="12" cy="4" r="1" transform="rotate(90 12 4)"/><circle cx="20" cy="4" r="1" transform="rotate(90 20 4)"/><circle cx="4" cy="12" r="1" transform="rotate(90 4 12)"/><circle cx="12" cy="12" r="1" transform="rotate(90 12 12)"/><circle cx="20" cy="12" r="1" transform="rotate(90 20 12)"/><circle cx="4" cy="20" r="1" transform="rotate(90 4 20)"/><circle cx="12" cy="20" r="1" transform="rotate(90 12 20)"/><circle cx="20" cy="20" r="1" transform="rotate(90 20 20)"/></svg>',
          click: function (t) {
            t.stopPropagation();
            const e = this.fancybox.plugins.Thumbs;
            e && e.toggle();
          }
        },
        close: {
          type: "button",
          label: "CLOSE",
          class: "fancybox__button--close",
          html: '<svg viewBox="0 0 24 24"><path d="M20 20L4 4m16 0L4 20"></path></svg>',
          attr: {
            "data-fancybox-close": "",
            tabindex: 0
          }
        }
      }
    };

    class k {
      constructor(t) {
        this.fancybox = t, this.$container = null, this.state = "init";

        for (const t of ["onInit", "onPrepare", "onDone", "onKeydown", "onClosing", "onChange", "onSettle", "onRefresh"]) this[t] = this[t].bind(this);

        this.events = {
          init: this.onInit,
          prepare: this.onPrepare,
          done: this.onDone,
          keydown: this.onKeydown,
          closing: this.onClosing,
          "Carousel.change": this.onChange,
          "Carousel.settle": this.onSettle,
          "Carousel.Panzoom.touchStart": () => this.onRefresh(),
          "Image.startAnimation": (t, e) => this.onRefresh(e),
          "Image.afterUpdate": (t, e) => this.onRefresh(e)
        };
      }

      onInit() {
        if (this.fancybox.option("Toolbar.autoEnable")) {
          let t = !1;

          for (const e of this.fancybox.items) if ("image" === e.type) {
            t = !0;
            break;
          }

          if (!t) return void (this.state = "disabled");
        }

        for (const e of this.fancybox.option("Toolbar.display")) {
          if ("close" === (t(e) ? e.id : e)) {
            this.fancybox.options.closeButton = !1;
            break;
          }
        }
      }

      onPrepare() {
        const t = this.fancybox;
        if ("init" === this.state && (this.build(), this.update(), this.Slideshow = new A(t), !t.Carousel.prevPage && (t.option("slideshow.autoStart") && this.Slideshow.activate(), t.option("fullscreen.autoStart") && !_.element()))) try {
          _.activate(t.$container);
        } catch (t) {}
      }

      onFsChange() {
        window.scrollTo(_.pageXOffset, _.pageYOffset);
      }

      onSettle() {
        const t = this.fancybox,
              e = this.Slideshow;
        e && e.isActive() && (t.getSlide().index !== t.Carousel.slides.length - 1 || t.option("infinite") ? "done" === t.getSlide().state && e.setTimer() : e.deactivate());
      }

      onChange() {
        this.update(), this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer();
      }

      onDone(t, e) {
        const i = this.Slideshow;
        e.index === t.getSlide().index && (this.update(), i && i.isActive() && (t.option("infinite") || e.index !== t.Carousel.slides.length - 1 ? i.setTimer() : i.deactivate()));
      }

      onRefresh(t) {
        t && t.index !== this.fancybox.getSlide().index || (this.update(), !this.Slideshow || !this.Slideshow.isActive() || t && "done" !== t.state || this.Slideshow.deactivate());
      }

      onKeydown(t, e, i) {
        " " === e && this.Slideshow && (this.Slideshow.toggle(), i.preventDefault());
      }

      onClosing() {
        this.Slideshow && this.Slideshow.deactivate(), document.removeEventListener("fullscreenchange", this.onFsChange);
      }

      createElement(t) {
        let e;
        "div" === t.type ? e = document.createElement("div") : (e = document.createElement("link" === t.type ? "a" : "button"), e.classList.add("carousel__button")), e.innerHTML = t.html, e.setAttribute("tabindex", t.tabindex || 0), t.class && e.classList.add(...t.class.split(" "));

        for (const i in t.attr) e.setAttribute(i, t.attr[i]);

        t.label && e.setAttribute("title", this.fancybox.localize(`{{${t.label}}}`)), t.click && e.addEventListener("click", t.click.bind(this)), "prev" === t.id && e.setAttribute("data-fancybox-prev", ""), "next" === t.id && e.setAttribute("data-fancybox-next", "");
        const i = e.querySelector("svg");
        return i && (i.setAttribute("role", "img"), i.setAttribute("tabindex", "-1"), i.setAttribute("xmlns", "http://www.w3.org/2000/svg")), e;
      }

      build() {
        this.cleanup();
        const i = this.fancybox.option("Toolbar.items"),
              s = [{
          position: "left",
          items: []
        }, {
          position: "center",
          items: []
        }, {
          position: "right",
          items: []
        }],
              o = this.fancybox.plugins.Thumbs;

        for (const n of this.fancybox.option("Toolbar.display")) {
          let a, r;
          if (t(n) ? (a = n.id, r = e({}, i[a], n)) : (a = n, r = i[a]), ["counter", "next", "prev", "slideshow"].includes(a) && this.fancybox.items.length < 2) continue;

          if ("fullscreen" === a) {
            if (!document.fullscreenEnabled || window.fullScreen) continue;
            document.addEventListener("fullscreenchange", this.onFsChange);
          }

          if ("thumbs" === a && (!o || "disabled" === o.state)) continue;
          if (!r) continue;
          let h = r.position || "right",
              l = s.find(t => t.position === h);
          l && l.items.push(r);
        }

        const n = document.createElement("div");
        n.classList.add("fancybox__toolbar");

        for (const t of s) if (t.items.length) {
          const e = document.createElement("div");
          e.classList.add("fancybox__toolbar__items"), e.classList.add(`fancybox__toolbar__items--${t.position}`);

          for (const i of t.items) e.appendChild(this.createElement(i));

          n.appendChild(e);
        }

        this.fancybox.$carousel.parentNode.insertBefore(n, this.fancybox.$carousel), this.$container = n;
      }

      update() {
        const t = this.fancybox.getSlide(),
              e = t.index,
              i = this.fancybox.items.length,
              s = t.downloadSrc || ("image" !== t.type || t.error ? null : t.src);

        for (const t of this.fancybox.$container.querySelectorAll("a.fancybox__button--download")) s ? (t.removeAttribute("disabled"), t.removeAttribute("tabindex"), t.setAttribute("href", s), t.setAttribute("download", s), t.setAttribute("target", "_blank")) : (t.setAttribute("disabled", ""), t.setAttribute("tabindex", -1), t.removeAttribute("href"), t.removeAttribute("download"));

        const o = t.Panzoom,
              n = o && o.option("maxScale") > o.option("baseScale");

        for (const t of this.fancybox.$container.querySelectorAll(".fancybox__button--zoom")) n ? t.removeAttribute("disabled") : t.setAttribute("disabled", "");

        for (const e of this.fancybox.$container.querySelectorAll("[data-fancybox-index]")) e.innerHTML = t.index + 1;

        for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-count]")) t.innerHTML = i;

        if (!this.fancybox.option("infinite")) {
          for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-prev]")) 0 === e ? t.setAttribute("disabled", "") : t.removeAttribute("disabled");

          for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-next]")) e === i - 1 ? t.setAttribute("disabled", "") : t.removeAttribute("disabled");
        }
      }

      cleanup() {
        this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer(), this.$container && this.$container.remove(), this.$container = null;
      }

      attach() {
        this.fancybox.on(this.events);
      }

      detach() {
        this.fancybox.off(this.events), this.cleanup();
      }

    }

    k.defaults = z;
    const O = {
      ScrollLock: class {
        constructor(t) {
          this.fancybox = t, this.viewport = null, this.pendingUpdate = null;

          for (const t of ["onReady", "onResize", "onTouchstart", "onTouchmove"]) this[t] = this[t].bind(this);
        }

        onReady() {
          const t = window.visualViewport;
          t && (this.viewport = t, this.startY = 0, t.addEventListener("resize", this.onResize), this.updateViewport()), window.addEventListener("touchstart", this.onTouchstart, {
            passive: !1
          }), window.addEventListener("touchmove", this.onTouchmove, {
            passive: !1
          }), window.addEventListener("wheel", this.onWheel, {
            passive: !1
          });
        }

        onResize() {
          this.updateViewport();
        }

        updateViewport() {
          const t = this.fancybox,
                e = this.viewport,
                i = e.scale || 1,
                s = t.$container;
          if (!s) return;
          let o = "",
              n = "",
              a = "";
          i - 1 > .1 && (o = e.width * i + "px", n = e.height * i + "px", a = `translate3d(${e.offsetLeft}px, ${e.offsetTop}px, 0) scale(${1 / i})`), s.style.width = o, s.style.height = n, s.style.transform = a;
        }

        onTouchstart(t) {
          this.startY = t.touches ? t.touches[0].screenY : t.screenY;
        }

        onTouchmove(t) {
          const e = this.startY,
                i = window.innerWidth / window.document.documentElement.clientWidth;
          if (!t.cancelable) return;
          if (t.touches.length > 1 || 1 !== i) return;
          const o = s(t.composedPath()[0]);
          if (!o) return void t.preventDefault();
          const n = window.getComputedStyle(o),
                a = parseInt(n.getPropertyValue("height"), 10),
                r = t.touches ? t.touches[0].screenY : t.screenY,
                h = e <= r && 0 === o.scrollTop,
                l = e >= r && o.scrollHeight - o.scrollTop === a;
          (h || l) && t.preventDefault();
        }

        onWheel(t) {
          s(t.composedPath()[0]) || t.preventDefault();
        }

        cleanup() {
          this.pendingUpdate && (cancelAnimationFrame(this.pendingUpdate), this.pendingUpdate = null);
          const t = this.viewport;
          t && (t.removeEventListener("resize", this.onResize), this.viewport = null), window.removeEventListener("touchstart", this.onTouchstart, !1), window.removeEventListener("touchmove", this.onTouchmove, !1), window.removeEventListener("wheel", this.onWheel, {
            passive: !1
          });
        }

        attach() {
          this.fancybox.on("initLayout", this.onReady);
        }

        detach() {
          this.fancybox.off("initLayout", this.onReady), this.cleanup();
        }

      },
      Thumbs: C,
      Html: P,
      Toolbar: k,
      Image: T,
      Hash: L
    };
    const M = {
      startIndex: 0,
      preload: 1,
      infinite: !0,
      showClass: "fancybox-zoomInUp",
      hideClass: "fancybox-fadeOut",
      animated: !0,
      hideScrollbar: !0,
      parentEl: null,
      mainClass: null,
      autoFocus: !0,
      trapFocus: !0,
      placeFocusBack: !0,
      click: "close",
      closeButton: "inside",
      dragToClose: !0,
      keyboard: {
        Escape: "close",
        Delete: "close",
        Backspace: "close",
        PageUp: "next",
        PageDown: "prev",
        ArrowUp: "next",
        ArrowDown: "prev",
        ArrowRight: "next",
        ArrowLeft: "prev"
      },
      template: {
        closeButton: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg>',
        spinner: '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="25 25 50 50" tabindex="-1"><circle cx="50" cy="50" r="20"/></svg>',
        main: null
      },
      l10n: {
        CLOSE: "Close",
        NEXT: "Next",
        PREV: "Previous",
        MODAL: "You can close this modal content with the ESC key",
        ERROR: "Something Went Wrong, Please Try Again Later",
        IMAGE_ERROR: "Image Not Found",
        ELEMENT_NOT_FOUND: "HTML Element Not Found",
        AJAX_NOT_FOUND: "Error Loading AJAX : Not Found",
        AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden",
        IFRAME_ERROR: "Error Loading Page",
        TOGGLE_ZOOM: "Toggle zoom level",
        TOGGLE_THUMBS: "Toggle thumbnails",
        TOGGLE_SLIDESHOW: "Toggle slideshow",
        TOGGLE_FULLSCREEN: "Toggle full-screen mode",
        DOWNLOAD: "Download"
      }
    },
          I = new Map();
    let F = 0;

    class R extends l {
      constructor(t, i = {}) {
        t = t.map(t => (t.width && (t._width = t.width), t.height && (t._height = t.height), t)), super(e(!0, {}, M, i)), this.bindHandlers(), this.state = "init", this.setItems(t), this.attachPlugins(R.Plugins), this.trigger("init"), !0 === this.option("hideScrollbar") && this.hideScrollbar(), this.initLayout(), this.initCarousel(), this.attachEvents(), I.set(this.id, this), this.trigger("prepare"), this.state = "ready", this.trigger("ready"), this.$container.setAttribute("aria-hidden", "false"), this.option("trapFocus") && this.focus();
      }

      option(t, ...e) {
        const i = this.getSlide();
        let s = i ? i[t] : void 0;
        return void 0 !== s ? ("function" == typeof s && (s = s.call(this, this, ...e)), s) : super.option(t, ...e);
      }

      bindHandlers() {
        for (const t of ["onMousedown", "onKeydown", "onClick", "onFocus", "onCreateSlide", "onSettle", "onTouchMove", "onTouchEnd", "onTransform"]) this[t] = this[t].bind(this);
      }

      attachEvents() {
        document.addEventListener("mousedown", this.onMousedown), document.addEventListener("keydown", this.onKeydown, !0), this.option("trapFocus") && document.addEventListener("focus", this.onFocus, !0), this.$container.addEventListener("click", this.onClick);
      }

      detachEvents() {
        document.removeEventListener("mousedown", this.onMousedown), document.removeEventListener("keydown", this.onKeydown, !0), document.removeEventListener("focus", this.onFocus, !0), this.$container.removeEventListener("click", this.onClick);
      }

      initLayout() {
        this.$root = this.option("parentEl") || document.body;
        let t = this.option("template.main");
        t && (this.$root.insertAdjacentHTML("beforeend", this.localize(t)), this.$container = this.$root.querySelector(".fancybox__container")), this.$container || (this.$container = document.createElement("div"), this.$root.appendChild(this.$container)), this.$container.onscroll = () => (this.$container.scrollLeft = 0, !1), Object.entries({
          class: "fancybox__container",
          role: "dialog",
          tabIndex: "-1",
          "aria-modal": "true",
          "aria-hidden": "true",
          "aria-label": this.localize("{{MODAL}}")
        }).forEach(t => this.$container.setAttribute(...t)), this.option("animated") && this.$container.classList.add("is-animated"), this.$backdrop = this.$container.querySelector(".fancybox__backdrop"), this.$backdrop || (this.$backdrop = document.createElement("div"), this.$backdrop.classList.add("fancybox__backdrop"), this.$container.appendChild(this.$backdrop)), this.$carousel = this.$container.querySelector(".fancybox__carousel"), this.$carousel || (this.$carousel = document.createElement("div"), this.$carousel.classList.add("fancybox__carousel"), this.$container.appendChild(this.$carousel)), this.$container.Fancybox = this, this.id = this.$container.getAttribute("id"), this.id || (this.id = this.options.id || ++F, this.$container.setAttribute("id", "fancybox-" + this.id));
        const e = this.option("mainClass");
        return e && this.$container.classList.add(...e.split(" ")), document.documentElement.classList.add("with-fancybox"), this.trigger("initLayout"), this;
      }

      setItems(t) {
        const e = [];

        for (const i of t) {
          const t = i.$trigger;

          if (t) {
            const e = t.dataset || {};
            i.src = e.src || t.getAttribute("href") || i.src, i.type = e.type || i.type, !i.src && t instanceof HTMLImageElement && (i.src = t.currentSrc || i.$trigger.src);
          }

          let s = i.$thumb;

          if (!s) {
            let t = i.$trigger && i.$trigger.origTarget;
            t && (s = t instanceof HTMLImageElement ? t : t.querySelector("img:not([aria-hidden])")), !s && i.$trigger && (s = i.$trigger instanceof HTMLImageElement ? i.$trigger : i.$trigger.querySelector("img:not([aria-hidden])"));
          }

          i.$thumb = s || null;
          let o = i.thumb;
          !o && s && (o = s.currentSrc || s.src, !o && s.dataset && (o = s.dataset.lazySrc || s.dataset.src)), o || "image" !== i.type || (o = i.src), i.thumb = o || null, i.caption = i.caption || "", e.push(i);
        }

        this.items = e;
      }

      initCarousel() {
        return this.Carousel = new y(this.$carousel, e(!0, {}, {
          prefix: "",
          classNames: {
            viewport: "fancybox__viewport",
            track: "fancybox__track",
            slide: "fancybox__slide"
          },
          textSelection: !0,
          preload: this.option("preload"),
          friction: .88,
          slides: this.items,
          initialPage: this.options.startIndex,
          slidesPerPage: 1,
          infiniteX: this.option("infinite"),
          infiniteY: !0,
          l10n: this.option("l10n"),
          Dots: !1,
          Navigation: {
            classNames: {
              main: "fancybox__nav",
              button: "carousel__button",
              next: "is-next",
              prev: "is-prev"
            }
          },
          Panzoom: {
            textSelection: !0,
            panOnlyZoomed: () => this.Carousel && this.Carousel.pages && this.Carousel.pages.length < 2 && !this.option("dragToClose"),
            lockAxis: () => {
              if (this.Carousel) {
                let t = "x";
                return this.option("dragToClose") && (t += "y"), t;
              }
            }
          },
          on: {
            "*": (t, ...e) => this.trigger(`Carousel.${t}`, ...e),
            init: t => this.Carousel = t,
            createSlide: this.onCreateSlide,
            settle: this.onSettle
          }
        }, this.option("Carousel"))), this.option("dragToClose") && this.Carousel.Panzoom.on({
          touchMove: this.onTouchMove,
          afterTransform: this.onTransform,
          touchEnd: this.onTouchEnd
        }), this.trigger("initCarousel"), this;
      }

      onCreateSlide(t, e) {
        let i = e.caption || "";

        if ("function" == typeof this.options.caption && (i = this.options.caption.call(this, this, this.Carousel, e)), "string" == typeof i && i.length) {
          const t = document.createElement("div"),
                s = `fancybox__caption_${this.id}_${e.index}`;
          t.className = "fancybox__caption", t.innerHTML = i, t.setAttribute("id", s), e.$caption = e.$el.appendChild(t), e.$el.classList.add("has-caption"), e.$el.setAttribute("aria-labelledby", s);
        }
      }

      onSettle() {
        this.option("autoFocus") && this.focus();
      }

      onFocus(t) {
        this.isTopmost() && this.focus(t);
      }

      onClick(t) {
        if (t.defaultPrevented) return;
        let e = t.composedPath()[0];
        if (e.matches("[data-fancybox-close]")) return t.preventDefault(), void R.close(!1, t);
        if (e.matches("[data-fancybox-next]")) return t.preventDefault(), void R.next();
        if (e.matches("[data-fancybox-prev]")) return t.preventDefault(), void R.prev();
        const i = document.activeElement;

        if (i) {
          if (i.closest("[contenteditable]")) return;
          e.matches(x) || i.blur();
        }

        if (e.closest(".fancybox__content")) return;
        if (getSelection().toString().length) return;
        if (!1 === this.trigger("click", t)) return;

        switch (this.option("click")) {
          case "close":
            this.close();
            break;

          case "next":
            this.next();
        }
      }

      onTouchMove() {
        const t = this.getSlide().Panzoom;
        return !t || 1 === t.content.scale;
      }

      onTouchEnd(t) {
        const e = t.dragOffset.y;
        Math.abs(e) >= 150 || Math.abs(e) >= 35 && t.dragOffset.time < 350 ? (this.option("hideClass") && (this.getSlide().hideClass = "fancybox-throwOut" + (t.content.y < 0 ? "Up" : "Down")), this.close()) : "y" === t.lockAxis && t.panTo({
          y: 0
        });
      }

      onTransform(t) {
        if (this.$backdrop) {
          const e = Math.abs(t.content.y),
                i = e < 1 ? "" : Math.max(.33, Math.min(1, 1 - e / t.content.fitHeight * 1.5));
          this.$container.style.setProperty("--fancybox-ts", i ? "0s" : ""), this.$container.style.setProperty("--fancybox-opacity", i);
        }
      }

      onMousedown() {
        "ready" === this.state && document.body.classList.add("is-using-mouse");
      }

      onKeydown(t) {
        if (!this.isTopmost()) return;
        document.body.classList.remove("is-using-mouse");
        const e = t.key,
              i = this.option("keyboard");
        if (!i || t.ctrlKey || t.altKey || t.shiftKey) return;
        const s = t.composedPath()[0],
              o = document.activeElement && document.activeElement.classList,
              n = o && o.contains("carousel__button");

        if ("Escape" !== e && !n) {
          if (t.target.isContentEditable || -1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(s.nodeName)) return;
        }

        if (!1 === this.trigger("keydown", e, t)) return;
        const a = i[e];
        "function" == typeof this[a] && this[a]();
      }

      getSlide() {
        const t = this.Carousel;
        if (!t) return null;
        const e = null === t.page ? t.option("initialPage") : t.page,
              i = t.pages || [];
        return i.length && i[e] ? i[e].slides[0] : null;
      }

      focus(t) {
        if (R.ignoreFocusChange) return;
        if (["init", "closing", "customClosing", "destroy"].indexOf(this.state) > -1) return;
        const e = this.$container,
              i = this.getSlide(),
              s = "done" === i.state ? i.$el : null;
        if (s && s.contains(document.activeElement)) return;
        t && t.preventDefault(), R.ignoreFocusChange = !0;
        const o = Array.from(e.querySelectorAll(x));
        let n,
            a = [];

        for (let t of o) {
          const e = t.offsetParent,
                i = s && s.contains(t),
                o = !this.Carousel.$viewport.contains(t);
          e && (i || o) ? (a.push(t), void 0 !== t.dataset.origTabindex && (t.tabIndex = t.dataset.origTabindex, t.removeAttribute("data-orig-tabindex")), (t.hasAttribute("autoFocus") || !n && i && !t.classList.contains("carousel__button")) && (n = t)) : (t.dataset.origTabindex = void 0 === t.dataset.origTabindex ? t.getAttribute("tabindex") : t.dataset.origTabindex, t.tabIndex = -1);
        }

        t ? a.indexOf(t.target) > -1 ? this.lastFocus = t.target : this.lastFocus === e ? w(a[a.length - 1]) : w(e) : this.option("autoFocus") && n ? w(n) : a.indexOf(document.activeElement) < 0 && w(e), this.lastFocus = document.activeElement, R.ignoreFocusChange = !1;
      }

      hideScrollbar() {
        if (!v) return;
        const t = window.innerWidth - document.documentElement.getBoundingClientRect().width,
              e = "fancybox-style-noscroll";
        let i = document.getElementById(e);
        i || t > 0 && (i = document.createElement("style"), i.id = e, i.type = "text/css", i.innerHTML = `.compensate-for-scrollbar {padding-right: ${t}px;}`, document.getElementsByTagName("head")[0].appendChild(i), document.body.classList.add("compensate-for-scrollbar"));
      }

      revealScrollbar() {
        document.body.classList.remove("compensate-for-scrollbar");
        const t = document.getElementById("fancybox-style-noscroll");
        t && t.remove();
      }

      clearContent(t) {
        this.Carousel.trigger("removeSlide", t), t.$content && (t.$content.remove(), t.$content = null), t.$closeButton && (t.$closeButton.remove(), t.$closeButton = null), t._className && t.$el.classList.remove(t._className);
      }

      setContent(t, e, i = {}) {
        let s;
        const o = t.$el;
        if (e instanceof HTMLElement) ["img", "iframe", "video", "audio"].indexOf(e.nodeName.toLowerCase()) > -1 ? (s = document.createElement("div"), s.appendChild(e)) : s = e;else {
          const t = document.createRange().createContextualFragment(e);
          s = document.createElement("div"), s.appendChild(t);
        }
        if (t.filter && !t.error && (s = s.querySelector(t.filter)), s instanceof Element) return t._className = `has-${i.suffix || t.type || "unknown"}`, o.classList.add(t._className), s.classList.add("fancybox__content"), "none" !== s.style.display && "none" !== getComputedStyle(s).getPropertyValue("display") || (s.style.display = t.display || this.option("defaultDisplay") || "flex"), t.id && s.setAttribute("id", t.id), t.$content = s, o.prepend(s), this.manageCloseButton(t), "loading" !== t.state && this.revealContent(t), s;
        this.setError(t, "{{ELEMENT_NOT_FOUND}}");
      }

      manageCloseButton(t) {
        const e = void 0 === t.closeButton ? this.option("closeButton") : t.closeButton;
        if (!e || "top" === e && this.$closeButton) return;
        const i = document.createElement("button");
        i.classList.add("carousel__button", "is-close"), i.setAttribute("title", this.options.l10n.CLOSE), i.innerHTML = this.option("template.closeButton"), i.addEventListener("click", t => this.close(t)), "inside" === e ? (t.$closeButton && t.$closeButton.remove(), t.$closeButton = t.$content.appendChild(i)) : this.$closeButton = this.$container.insertBefore(i, this.$container.firstChild);
      }

      revealContent(t) {
        this.trigger("reveal", t), t.$content.style.visibility = "";
        let e = !1;
        t.error || "loading" === t.state || null !== this.Carousel.prevPage || t.index !== this.options.startIndex || (e = void 0 === t.showClass ? this.option("showClass") : t.showClass), e ? (t.state = "animating", this.animateCSS(t.$content, e, () => {
          this.done(t);
        })) : this.done(t);
      }

      animateCSS(t, e, i) {
        if (t && t.dispatchEvent(new CustomEvent("animationend", {
          bubbles: !0,
          cancelable: !0
        })), !t || !e) return void ("function" == typeof i && i());

        const s = function (o) {
          o.currentTarget === this && (t.removeEventListener("animationend", s), i && i(), t.classList.remove(e));
        };

        t.addEventListener("animationend", s), t.classList.add(e);
      }

      done(t) {
        t.state = "done", this.trigger("done", t);
        const e = this.getSlide();
        e && t.index === e.index && this.option("autoFocus") && this.focus();
      }

      setError(t, e) {
        t.error = e, this.hideLoading(t), this.clearContent(t);
        const i = document.createElement("div");
        i.classList.add("fancybox-error"), i.innerHTML = this.localize(e || "<p>{{ERROR}}</p>"), this.setContent(t, i, {
          suffix: "error"
        });
      }

      showLoading(t) {
        t.state = "loading", t.$el.classList.add("is-loading");
        let e = t.$el.querySelector(".fancybox__spinner");
        e || (e = document.createElement("div"), e.classList.add("fancybox__spinner"), e.innerHTML = this.option("template.spinner"), e.addEventListener("click", () => {
          this.Carousel.Panzoom.velocity || this.close();
        }), t.$el.prepend(e));
      }

      hideLoading(t) {
        const e = t.$el && t.$el.querySelector(".fancybox__spinner");
        e && (e.remove(), t.$el.classList.remove("is-loading")), "loading" === t.state && (this.trigger("load", t), t.state = "ready");
      }

      next() {
        const t = this.Carousel;
        t && t.pages.length > 1 && t.slideNext();
      }

      prev() {
        const t = this.Carousel;
        t && t.pages.length > 1 && t.slidePrev();
      }

      jumpTo(...t) {
        this.Carousel && this.Carousel.slideTo(...t);
      }

      isClosing() {
        return ["closing", "customClosing", "destroy"].includes(this.state);
      }

      isTopmost() {
        return R.getInstance().id == this.id;
      }

      close(t) {
        if (t && t.preventDefault(), this.isClosing()) return;
        if (!1 === this.trigger("shouldClose", t)) return;
        if (this.state = "closing", this.Carousel.Panzoom.destroy(), this.detachEvents(), this.trigger("closing", t), "destroy" === this.state) return;
        this.$container.setAttribute("aria-hidden", "true"), this.$container.classList.add("is-closing");
        const e = this.getSlide();

        if (this.Carousel.slides.forEach(t => {
          t.$content && t.index !== e.index && this.Carousel.trigger("removeSlide", t);
        }), "closing" === this.state) {
          const t = void 0 === e.hideClass ? this.option("hideClass") : e.hideClass;
          this.animateCSS(e.$content, t, () => {
            this.destroy();
          }, !0);
        }
      }

      destroy() {
        if ("destroy" === this.state) return;
        this.state = "destroy", this.trigger("destroy");
        const t = this.option("placeFocusBack") ? this.option("triggerTarget", this.getSlide().$trigger) : null;
        this.Carousel.destroy(), this.detachPlugins(), this.Carousel = null, this.options = {}, this.events = {}, this.$container.remove(), this.$container = this.$backdrop = this.$carousel = null, t && w(t), I.delete(this.id);
        const e = R.getInstance();
        e ? e.focus() : (document.documentElement.classList.remove("with-fancybox"), document.body.classList.remove("is-using-mouse"), this.revealScrollbar());
      }

      static show(t, e = {}) {
        return new R(t, e);
      }

      static fromEvent(t, e = {}) {
        if (t.defaultPrevented) return;
        if (t.button && 0 !== t.button) return;
        if (t.ctrlKey || t.metaKey || t.shiftKey) return;
        const i = t.composedPath()[0];
        let s,
            o,
            n,
            a = i;

        if ((a.matches("[data-fancybox-trigger]") || (a = a.closest("[data-fancybox-trigger]"))) && (e.triggerTarget = a, s = a && a.dataset && a.dataset.fancyboxTrigger), s) {
          const t = document.querySelectorAll(`[data-fancybox="${s}"]`),
                e = parseInt(a.dataset.fancyboxIndex, 10) || 0;
          a = t.length ? t[e] : a;
        }

        Array.from(R.openers.keys()).reverse().some(e => {
          n = a || i;
          let s = !1;

          try {
            n instanceof Element && ("string" == typeof e || e instanceof String) && (s = n.matches(e) || (n = n.closest(e)));
          } catch (t) {}

          return !!s && (t.preventDefault(), o = e, !0);
        });
        let r = !1;

        if (o) {
          e.event = t, e.target = n, n.origTarget = i, r = R.fromOpener(o, e);
          const s = R.getInstance();
          s && "ready" === s.state && t.detail && document.body.classList.add("is-using-mouse");
        }

        return r;
      }

      static fromOpener(t, i = {}) {
        let s = [],
            o = i.startIndex || 0,
            n = i.target || null;
        const a = void 0 !== (i = e({}, i, R.openers.get(t))).groupAll && i.groupAll,
              r = void 0 === i.groupAttr ? "data-fancybox" : i.groupAttr,
              h = r && n ? n.getAttribute(`${r}`) : "";

        if (!n || h || a) {
          const e = i.root || (n ? n.getRootNode() : document.body);
          s = [].slice.call(e.querySelectorAll(t));
        }

        if (n && !a && (s = h ? s.filter(t => t.getAttribute(`${r}`) === h) : [n]), !s.length) return !1;
        const l = R.getInstance();
        return !(l && s.indexOf(l.options.$trigger) > -1) && (o = n ? s.indexOf(n) : o, s = s.map(function (t) {
          const e = ["false", "0", "no", "null", "undefined"],
                i = ["true", "1", "yes"],
                s = Object.assign({}, t.dataset),
                o = {};

          for (let [t, n] of Object.entries(s)) if ("fancybox" !== t) if ("width" === t || "height" === t) o[`_${t}`] = n;else if ("string" == typeof n || n instanceof String) {
            if (e.indexOf(n) > -1) o[t] = !1;else if (i.indexOf(o[t]) > -1) o[t] = !0;else try {
              o[t] = JSON.parse(n);
            } catch (e) {
              o[t] = n;
            }
          } else o[t] = n;

          return t instanceof Element && (o.$trigger = t), o;
        }), new R(s, e({}, i, {
          startIndex: o,
          $trigger: n
        })));
      }

      static bind(t, e = {}) {
        function i() {
          document.body.addEventListener("click", R.fromEvent, !1);
        }

        v && (R.openers.size || (/complete|interactive|loaded/.test(document.readyState) ? i() : document.addEventListener("DOMContentLoaded", i)), R.openers.set(t, e));
      }

      static unbind(t) {
        R.openers.delete(t), R.openers.size || R.destroy();
      }

      static destroy() {
        let t;

        for (; t = R.getInstance();) t.destroy();

        R.openers = new Map(), document.body.removeEventListener("click", R.fromEvent, !1);
      }

      static getInstance(t) {
        if (t) return I.get(t);
        return Array.from(I.values()).reverse().find(t => !t.isClosing() && t) || null;
      }

      static close(t = !0, e) {
        if (t) for (const t of I.values()) t.close(e);else {
          const t = R.getInstance();
          t && t.close(e);
        }
      }

      static next() {
        const t = R.getInstance();
        t && t.next();
      }

      static prev() {
        const t = R.getInstance();
        t && t.prev();
      }

    }

    R.version = "4.0.31", R.defaults = M, R.openers = new Map(), R.Plugins = O, R.bind("[data-fancybox]");

    for (const [t, e] of Object.entries(R.Plugins || {})) "function" == typeof e.create && e.create(R);

    var wpcf7Elm = document.querySelector('.wpcf7');

    if (wpcf7Elm) {
      wpcf7Elm.addEventListener('wpcf7mailsent', function (event) {
         close();
      }, false);
      wpcf7Elm.addEventListener('wpcf7submit', function (event) {
        console.log('submitted');
        console.log(event.detail.apiResponse.message);
        R.show([{
          src: event.detail.apiResponse.message,
          type: "html"
        }]);
      }, false);
    }

    var nouislider = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       factory(exports) ;
    })(commonjsGlobal, function (exports) {

      exports.PipsMode = void 0;

      (function (PipsMode) {
        PipsMode["Range"] = "range";
        PipsMode["Steps"] = "steps";
        PipsMode["Positions"] = "positions";
        PipsMode["Count"] = "count";
        PipsMode["Values"] = "values";
      })(exports.PipsMode || (exports.PipsMode = {}));

      exports.PipsType = void 0;

      (function (PipsType) {
        PipsType[PipsType["None"] = -1] = "None";
        PipsType[PipsType["NoValue"] = 0] = "NoValue";
        PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
        PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
      })(exports.PipsType || (exports.PipsType = {})); //region Helper Methods


      function isValidFormatter(entry) {
        return isValidPartialFormatter(entry) && typeof entry.from === "function";
      }

      function isValidPartialFormatter(entry) {
        // partial formatters only need a to function and not a from function
        return typeof entry === "object" && typeof entry.to === "function";
      }

      function removeElement(el) {
        el.parentElement.removeChild(el);
      }

      function isSet(value) {
        return value !== null && value !== undefined;
      } // Bindable version


      function preventDefault(e) {
        e.preventDefault();
      } // Removes duplicates from an array.


      function unique(array) {
        return array.filter(function (a) {
          return !this[a] ? this[a] = true : false;
        }, {});
      } // Round a value to the closest 'to'.


      function closest(value, to) {
        return Math.round(value / to) * to;
      } // Current position of an element relative to the document.


      function offset(elem, orientation) {
        var rect = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var docElem = doc.documentElement;
        var pageOffset = getPageOffset(doc); // getBoundingClientRect contains left scroll in Chrome on Android.
        // I haven't found a feature detection that proves this. Worst case
        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.

        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
          pageOffset.x = 0;
        }

        return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
      } // Checks whether a value is numerical.


      function isNumeric(a) {
        return typeof a === "number" && !isNaN(a) && isFinite(a);
      } // Sets a class and removes it after [duration] ms.


      function addClassFor(element, className, duration) {
        if (duration > 0) {
          addClass(element, className);
          setTimeout(function () {
            removeClass(element, className);
          }, duration);
        }
      } // Limits a value to 0 - 100


      function limit(a) {
        return Math.max(Math.min(a, 100), 0);
      } // Wraps a variable as an array, if it isn't one yet.
      // Note that an input array is returned by reference!


      function asArray(a) {
        return Array.isArray(a) ? a : [a];
      } // Counts decimals


      function countDecimals(numStr) {
        numStr = String(numStr);
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
      } // http://youmightnotneedjquery.com/#add_class


      function addClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.add(className);
        } else {
          el.className += " " + className;
        }
      } // http://youmightnotneedjquery.com/#remove_class


      function removeClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.remove(className);
        } else {
          el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
        }
      } // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/


      function hasClass(el, className) {
        return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
      } // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes


      function getPageOffset(doc) {
        var supportPageOffset = window.pageXOffset !== undefined;
        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
        var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
        var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
        return {
          x: x,
          y: y
        };
      } // we provide a function to compute constants instead
      // of accessing window.* as soon as the module needs it
      // so that we do not compute anything if not needed


      function getActions() {
        // Determine the events to bind. IE11 implements pointerEvents without
        // a prefix, which breaks compatibility with the IE10 implementation.
        return window.navigator.pointerEnabled ? {
          start: "pointerdown",
          move: "pointermove",
          end: "pointerup"
        } : window.navigator.msPointerEnabled ? {
          start: "MSPointerDown",
          move: "MSPointerMove",
          end: "MSPointerUp"
        } : {
          start: "mousedown touchstart",
          move: "mousemove touchmove",
          end: "mouseup touchend"
        };
      } // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
      // Issue #785


      function getSupportsPassive() {
        var supportsPassive = false;
        /* eslint-disable */

        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function () {
              supportsPassive = true;
            }
          }); // @ts-ignore

          window.addEventListener("test", null, opts);
        } catch (e) {}
        /* eslint-enable */


        return supportsPassive;
      }

      function getSupportsTouchActionNone() {
        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
      } //endregion
      //region Range Calculation
      // Determine the size of a sub-range in relation to a full range.


      function subRangeRatio(pa, pb) {
        return 100 / (pb - pa);
      } // (percentage) How many percent is this value of this range?


      function fromPercentage(range, value, startRange) {
        return value * 100 / (range[startRange + 1] - range[startRange]);
      } // (percentage) Where is this value on this range?


      function toPercentage(range, value) {
        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
      } // (value) How much is this percentage on this range?


      function isPercentage(range, value) {
        return value * (range[1] - range[0]) / 100 + range[0];
      }

      function getJ(value, arr) {
        var j = 1;

        while (value >= arr[j]) {
          j += 1;
        }

        return j;
      } // (percentage) Input a value, find where, on a scale of 0-100, it applies.


      function toStepping(xVal, xPct, value) {
        if (value >= xVal.slice(-1)[0]) {
          return 100;
        }

        var j = getJ(value, xVal);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];
        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
      } // (value) Input a percentage, find where it is on the specified range.


      function fromStepping(xVal, xPct, value) {
        // There is no range group that fits 100
        if (value >= 100) {
          return xVal.slice(-1)[0];
        }

        var j = getJ(value, xPct);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];
        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
      } // (percentage) Get the step that applies at a certain value.


      function getStep(xPct, xSteps, snap, value) {
        if (value === 100) {
          return value;
        }

        var j = getJ(value, xPct);
        var a = xPct[j - 1];
        var b = xPct[j]; // If 'snap' is set, steps are used as fixed points on the slider.

        if (snap) {
          // Find the closest position, a or b.
          if (value - a > (b - a) / 2) {
            return b;
          }

          return a;
        }

        if (!xSteps[j - 1]) {
          return value;
        }

        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
      } //endregion
      //region Spectrum


      var Spectrum =
      /** @class */
      function () {
        function Spectrum(entry, snap, singleStep) {
          this.xPct = [];
          this.xVal = [];
          this.xSteps = [];
          this.xNumSteps = [];
          this.xHighestCompleteStep = [];
          this.xSteps = [singleStep || false];
          this.xNumSteps = [false];
          this.snap = snap;
          var index;
          var ordered = []; // Map the object keys to an array.

          Object.keys(entry).forEach(function (index) {
            ordered.push([asArray(entry[index]), index]);
          }); // Sort all entries by value (numeric sort).

          ordered.sort(function (a, b) {
            return a[0][0] - b[0][0];
          }); // Convert all entries to subranges.

          for (index = 0; index < ordered.length; index++) {
            this.handleEntryPoint(ordered[index][1], ordered[index][0]);
          } // Store the actual step values.
          // xSteps is sorted in the same order as xPct and xVal.


          this.xNumSteps = this.xSteps.slice(0); // Convert all numeric steps to the percentage of the subrange they represent.

          for (index = 0; index < this.xNumSteps.length; index++) {
            this.handleStepPoint(index, this.xNumSteps[index]);
          }
        }

        Spectrum.prototype.getDistance = function (value) {
          var distances = [];

          for (var index = 0; index < this.xNumSteps.length - 1; index++) {
            distances[index] = fromPercentage(this.xVal, value, index);
          }

          return distances;
        }; // Calculate the percentual distance over the whole scale of ranges.
        // direction: 0 = backwards / 1 = forwards


        Spectrum.prototype.getAbsoluteDistance = function (value, distances, direction) {
          var xPct_index = 0; // Calculate range where to start calculation

          if (value < this.xPct[this.xPct.length - 1]) {
            while (value > this.xPct[xPct_index + 1]) {
              xPct_index++;
            }
          } else if (value === this.xPct[this.xPct.length - 1]) {
            xPct_index = this.xPct.length - 2;
          } // If looking backwards and the value is exactly at a range separator then look one range further


          if (!direction && value === this.xPct[xPct_index + 1]) {
            xPct_index++;
          }

          if (distances === null) {
            distances = [];
          }

          var start_factor;
          var rest_factor = 1;
          var rest_rel_distance = distances[xPct_index];
          var range_pct = 0;
          var rel_range_distance = 0;
          var abs_distance_counter = 0;
          var range_counter = 0; // Calculate what part of the start range the value is

          if (direction) {
            start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
          } else {
            start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
          } // Do until the complete distance across ranges is calculated


          while (rest_rel_distance > 0) {
            // Calculate the percentage of total range
            range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter]; // Detect if the margin, padding or limit is larger then the current range and calculate

            if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
              // If larger then take the percentual distance of the whole range
              rel_range_distance = range_pct * start_factor; // Rest factor of relative percentual distance still to be calculated

              rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter]; // Set start factor to 1 as for next range it does not apply.

              start_factor = 1;
            } else {
              // If smaller or equal then take the percentual distance of the calculate percentual part of that range
              rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor; // No rest left as the rest fits in current range

              rest_factor = 0;
            }

            if (direction) {
              abs_distance_counter = abs_distance_counter - rel_range_distance; // Limit range to first range when distance becomes outside of minimum range

              if (this.xPct.length + range_counter >= 1) {
                range_counter--;
              }
            } else {
              abs_distance_counter = abs_distance_counter + rel_range_distance; // Limit range to last range when distance becomes outside of maximum range

              if (this.xPct.length - range_counter >= 1) {
                range_counter++;
              }
            } // Rest of relative percentual distance still to be calculated


            rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
          }

          return value + abs_distance_counter;
        };

        Spectrum.prototype.toStepping = function (value) {
          value = toStepping(this.xVal, this.xPct, value);
          return value;
        };

        Spectrum.prototype.fromStepping = function (value) {
          return fromStepping(this.xVal, this.xPct, value);
        };

        Spectrum.prototype.getStep = function (value) {
          value = getStep(this.xPct, this.xSteps, this.snap, value);
          return value;
        };

        Spectrum.prototype.getDefaultStep = function (value, isDown, size) {
          var j = getJ(value, this.xPct); // When at the top or stepping down, look at the previous sub-range

          if (value === 100 || isDown && value === this.xPct[j - 1]) {
            j = Math.max(j - 1, 1);
          }

          return (this.xVal[j] - this.xVal[j - 1]) / size;
        };

        Spectrum.prototype.getNearbySteps = function (value) {
          var j = getJ(value, this.xPct);
          return {
            stepBefore: {
              startValue: this.xVal[j - 2],
              step: this.xNumSteps[j - 2],
              highestStep: this.xHighestCompleteStep[j - 2]
            },
            thisStep: {
              startValue: this.xVal[j - 1],
              step: this.xNumSteps[j - 1],
              highestStep: this.xHighestCompleteStep[j - 1]
            },
            stepAfter: {
              startValue: this.xVal[j],
              step: this.xNumSteps[j],
              highestStep: this.xHighestCompleteStep[j]
            }
          };
        };

        Spectrum.prototype.countStepDecimals = function () {
          var stepDecimals = this.xNumSteps.map(countDecimals);
          return Math.max.apply(null, stepDecimals);
        };

        Spectrum.prototype.hasNoSize = function () {
          return this.xVal[0] === this.xVal[this.xVal.length - 1];
        }; // Outside testing


        Spectrum.prototype.convert = function (value) {
          return this.getStep(this.toStepping(value));
        };

        Spectrum.prototype.handleEntryPoint = function (index, value) {
          var percentage; // Covert min/max syntax to 0 and 100.

          if (index === "min") {
            percentage = 0;
          } else if (index === "max") {
            percentage = 100;
          } else {
            percentage = parseFloat(index);
          } // Check for correct input.


          if (!isNumeric(percentage) || !isNumeric(value[0])) {
            throw new Error("noUiSlider: 'range' value isn't numeric.");
          } // Store values.


          this.xPct.push(percentage);
          this.xVal.push(value[0]);
          var value1 = Number(value[1]); // NaN will evaluate to false too, but to keep
          // logging clear, set step explicitly. Make sure
          // not to override the 'step' setting with false.

          if (!percentage) {
            if (!isNaN(value1)) {
              this.xSteps[0] = value1;
            }
          } else {
            this.xSteps.push(isNaN(value1) ? false : value1);
          }

          this.xHighestCompleteStep.push(0);
        };

        Spectrum.prototype.handleStepPoint = function (i, n) {
          // Ignore 'false' stepping.
          if (!n) {
            return;
          } // Step over zero-length ranges (#948);


          if (this.xVal[i] === this.xVal[i + 1]) {
            this.xSteps[i] = this.xHighestCompleteStep[i] = this.xVal[i];
            return;
          } // Factor to range ratio


          this.xSteps[i] = fromPercentage([this.xVal[i], this.xVal[i + 1]], n, 0) / subRangeRatio(this.xPct[i], this.xPct[i + 1]);
          var totalSteps = (this.xVal[i + 1] - this.xVal[i]) / this.xNumSteps[i];
          var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
          var step = this.xVal[i] + this.xNumSteps[i] * highestStep;
          this.xHighestCompleteStep[i] = step;
        };

        return Spectrum;
      }(); //endregion
      //region Options

      /*	Every input option is tested and parsed. This will prevent
          endless validation in internal methods. These tests are
          structured with an item for every option available. An
          option can be marked as required by setting the 'r' flag.
          The testing function is provided with three arguments:
              - The provided value for the option;
              - A reference to the options object;
              - The name for the option;
           The testing function returns false when an error is detected,
          or true when everything is OK. It can also modify the option
          object, to make sure all values can be correctly looped elsewhere. */
      //region Defaults


      var defaultFormatter = {
        to: function (value) {
          return value === undefined ? "" : value.toFixed(2);
        },
        from: Number
      };
      var cssClasses = {
        target: "target",
        base: "base",
        origin: "origin",
        handle: "handle",
        handleLower: "handle-lower",
        handleUpper: "handle-upper",
        touchArea: "touch-area",
        horizontal: "horizontal",
        vertical: "vertical",
        background: "background",
        connect: "connect",
        connects: "connects",
        ltr: "ltr",
        rtl: "rtl",
        textDirectionLtr: "txt-dir-ltr",
        textDirectionRtl: "txt-dir-rtl",
        draggable: "draggable",
        drag: "state-drag",
        tap: "state-tap",
        active: "active",
        tooltip: "tooltip",
        pips: "pips",
        pipsHorizontal: "pips-horizontal",
        pipsVertical: "pips-vertical",
        marker: "marker",
        markerHorizontal: "marker-horizontal",
        markerVertical: "marker-vertical",
        markerNormal: "marker-normal",
        markerLarge: "marker-large",
        markerSub: "marker-sub",
        value: "value",
        valueHorizontal: "value-horizontal",
        valueVertical: "value-vertical",
        valueNormal: "value-normal",
        valueLarge: "value-large",
        valueSub: "value-sub"
      }; // Namespaces of internal event listeners

      var INTERNAL_EVENT_NS = {
        tooltips: ".__tooltips",
        aria: ".__aria"
      }; //endregion

      function testStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'step' is not numeric.");
        } // The step option can still be used to set stepping
        // for linear sliders. Overwritten if set in 'range'.


        parsed.singleStep = entry;
      }

      function testKeyboardPageMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
        }

        parsed.keyboardPageMultiplier = entry;
      }

      function testKeyboardMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
        }

        parsed.keyboardMultiplier = entry;
      }

      function testKeyboardDefaultStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
        }

        parsed.keyboardDefaultStep = entry;
      }

      function testRange(parsed, entry) {
        // Filter incorrect input.
        if (typeof entry !== "object" || Array.isArray(entry)) {
          throw new Error("noUiSlider: 'range' is not an object.");
        } // Catch missing start or end.


        if (entry.min === undefined || entry.max === undefined) {
          throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
        }

        parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
      }

      function testStart(parsed, entry) {
        entry = asArray(entry); // Validate input. Values aren't tested, as the public .val method
        // will always provide a valid location.

        if (!Array.isArray(entry) || !entry.length) {
          throw new Error("noUiSlider: 'start' option is incorrect.");
        } // Store the number of handles.


        parsed.handles = entry.length; // When the slider is initialized, the .val method will
        // be called with the start options.

        parsed.start = entry;
      }

      function testSnap(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'snap' option must be a boolean.");
        } // Enforce 100% stepping within subranges.


        parsed.snap = entry;
      }

      function testAnimate(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'animate' option must be a boolean.");
        } // Enforce 100% stepping within subranges.


        parsed.animate = entry;
      }

      function testAnimationDuration(parsed, entry) {
        if (typeof entry !== "number") {
          throw new Error("noUiSlider: 'animationDuration' option must be a number.");
        }

        parsed.animationDuration = entry;
      }

      function testConnect(parsed, entry) {
        var connect = [false];
        var i; // Map legacy options

        if (entry === "lower") {
          entry = [true, false];
        } else if (entry === "upper") {
          entry = [false, true];
        } // Handle boolean options


        if (entry === true || entry === false) {
          for (i = 1; i < parsed.handles; i++) {
            connect.push(entry);
          }

          connect.push(false);
        } // Reject invalid input
        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
          throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        } else {
          connect = entry;
        }

        parsed.connect = connect;
      }

      function testOrientation(parsed, entry) {
        // Set orientation to an a numerical value for easy
        // array selection.
        switch (entry) {
          case "horizontal":
            parsed.ort = 0;
            break;

          case "vertical":
            parsed.ort = 1;
            break;

          default:
            throw new Error("noUiSlider: 'orientation' option is invalid.");
        }
      }

      function testMargin(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'margin' option must be numeric.");
        } // Issue #582


        if (entry === 0) {
          return;
        }

        parsed.margin = parsed.spectrum.getDistance(entry);
      }

      function testLimit(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'limit' option must be numeric.");
        }

        parsed.limit = parsed.spectrum.getDistance(entry);

        if (!parsed.limit || parsed.handles < 2) {
          throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
        }
      }

      function testPadding(parsed, entry) {
        var index;

        if (!isNumeric(entry) && !Array.isArray(entry)) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }

        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }

        if (entry === 0) {
          return;
        }

        if (!Array.isArray(entry)) {
          entry = [entry, entry];
        } // 'getDistance' returns false for invalid values.


        parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];

        for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) {
          // last "range" can't contain step size as it is purely an endpoint.
          if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) {
            throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
          }
        }

        var totalPadding = entry[0] + entry[1];
        var firstValue = parsed.spectrum.xVal[0];
        var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];

        if (totalPadding / (lastValue - firstValue) > 1) {
          throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
        }
      }

      function testDirection(parsed, entry) {
        // Set direction as a numerical value for easy parsing.
        // Invert connection for RTL sliders, so that the proper
        // handles get the connect/background classes.
        switch (entry) {
          case "ltr":
            parsed.dir = 0;
            break;

          case "rtl":
            parsed.dir = 1;
            break;

          default:
            throw new Error("noUiSlider: 'direction' option was not recognized.");
        }
      }

      function testBehaviour(parsed, entry) {
        // Make sure the input is a string.
        if (typeof entry !== "string") {
          throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
        } // Check if the string contains any keywords.
        // None are required.


        var tap = entry.indexOf("tap") >= 0;
        var drag = entry.indexOf("drag") >= 0;
        var fixed = entry.indexOf("fixed") >= 0;
        var snap = entry.indexOf("snap") >= 0;
        var hover = entry.indexOf("hover") >= 0;
        var unconstrained = entry.indexOf("unconstrained") >= 0;
        var dragAll = entry.indexOf("drag-all") >= 0;
        var smoothSteps = entry.indexOf("smooth-steps") >= 0;

        if (fixed) {
          if (parsed.handles !== 2) {
            throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
          } // Use margin to enforce fixed state


          testMargin(parsed, parsed.start[1] - parsed.start[0]);
        }

        if (unconstrained && (parsed.margin || parsed.limit)) {
          throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
        }

        parsed.events = {
          tap: tap || snap,
          drag: drag,
          dragAll: dragAll,
          smoothSteps: smoothSteps,
          fixed: fixed,
          snap: snap,
          hover: hover,
          unconstrained: unconstrained
        };
      }

      function testTooltips(parsed, entry) {
        if (entry === false) {
          return;
        }

        if (entry === true || isValidPartialFormatter(entry)) {
          parsed.tooltips = [];

          for (var i = 0; i < parsed.handles; i++) {
            parsed.tooltips.push(entry);
          }
        } else {
          entry = asArray(entry);

          if (entry.length !== parsed.handles) {
            throw new Error("noUiSlider: must pass a formatter for all handles.");
          }

          entry.forEach(function (formatter) {
            if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
              throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
            }
          });
          parsed.tooltips = entry;
        }
      }

      function testHandleAttributes(parsed, entry) {
        if (entry.length !== parsed.handles) {
          throw new Error("noUiSlider: must pass a attributes for all handles.");
        }

        parsed.handleAttributes = entry;
      }

      function testAriaFormat(parsed, entry) {
        if (!isValidPartialFormatter(entry)) {
          throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
        }

        parsed.ariaFormat = entry;
      }

      function testFormat(parsed, entry) {
        if (!isValidFormatter(entry)) {
          throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
        }

        parsed.format = entry;
      }

      function testKeyboardSupport(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
        }

        parsed.keyboardSupport = entry;
      }

      function testDocumentElement(parsed, entry) {
        // This is an advanced option. Passed values are used without validation.
        parsed.documentElement = entry;
      }

      function testCssPrefix(parsed, entry) {
        if (typeof entry !== "string" && entry !== false) {
          throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
        }

        parsed.cssPrefix = entry;
      }

      function testCssClasses(parsed, entry) {
        if (typeof entry !== "object") {
          throw new Error("noUiSlider: 'cssClasses' must be an object.");
        }

        if (typeof parsed.cssPrefix === "string") {
          parsed.cssClasses = {};
          Object.keys(entry).forEach(function (key) {
            parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
          });
        } else {
          parsed.cssClasses = entry;
        }
      } // Test all developer settings and parse to assumption-safe values.


      function testOptions(options) {
        // To prove a fix for #537, freeze options here.
        // If the object is modified, an error will be thrown.
        // Object.freeze(options);
        var parsed = {
          margin: null,
          limit: null,
          padding: null,
          animate: true,
          animationDuration: 300,
          ariaFormat: defaultFormatter,
          format: defaultFormatter
        }; // Tests are executed in the order they are presented here.

        var tests = {
          step: {
            r: false,
            t: testStep
          },
          keyboardPageMultiplier: {
            r: false,
            t: testKeyboardPageMultiplier
          },
          keyboardMultiplier: {
            r: false,
            t: testKeyboardMultiplier
          },
          keyboardDefaultStep: {
            r: false,
            t: testKeyboardDefaultStep
          },
          start: {
            r: true,
            t: testStart
          },
          connect: {
            r: true,
            t: testConnect
          },
          direction: {
            r: true,
            t: testDirection
          },
          snap: {
            r: false,
            t: testSnap
          },
          animate: {
            r: false,
            t: testAnimate
          },
          animationDuration: {
            r: false,
            t: testAnimationDuration
          },
          range: {
            r: true,
            t: testRange
          },
          orientation: {
            r: false,
            t: testOrientation
          },
          margin: {
            r: false,
            t: testMargin
          },
          limit: {
            r: false,
            t: testLimit
          },
          padding: {
            r: false,
            t: testPadding
          },
          behaviour: {
            r: true,
            t: testBehaviour
          },
          ariaFormat: {
            r: false,
            t: testAriaFormat
          },
          format: {
            r: false,
            t: testFormat
          },
          tooltips: {
            r: false,
            t: testTooltips
          },
          keyboardSupport: {
            r: true,
            t: testKeyboardSupport
          },
          documentElement: {
            r: false,
            t: testDocumentElement
          },
          cssPrefix: {
            r: true,
            t: testCssPrefix
          },
          cssClasses: {
            r: true,
            t: testCssClasses
          },
          handleAttributes: {
            r: false,
            t: testHandleAttributes
          }
        };
        var defaults = {
          connect: false,
          direction: "ltr",
          behaviour: "tap",
          orientation: "horizontal",
          keyboardSupport: true,
          cssPrefix: "noUi-",
          cssClasses: cssClasses,
          keyboardPageMultiplier: 5,
          keyboardMultiplier: 1,
          keyboardDefaultStep: 10
        }; // AriaFormat defaults to regular format, if any.

        if (options.format && !options.ariaFormat) {
          options.ariaFormat = options.format;
        } // Run all options through a testing mechanism to ensure correct
        // input. It should be noted that options might get modified to
        // be handled properly. E.g. wrapping integers in arrays.


        Object.keys(tests).forEach(function (name) {
          // If the option isn't set, but it is required, throw an error.
          if (!isSet(options[name]) && defaults[name] === undefined) {
            if (tests[name].r) {
              throw new Error("noUiSlider: '" + name + "' is required.");
            }

            return;
          }

          tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
        }); // Forward pips options

        parsed.pips = options.pips; // All recent browsers accept unprefixed transform.
        // We need -ms- for IE9 and -webkit- for older Android;
        // Assume use of -webkit- if unprefixed and -ms- are not supported.
        // https://caniuse.com/#feat=transforms2d

        var d = document.createElement("div");
        var msPrefix = d.style.msTransform !== undefined;
        var noPrefix = d.style.transform !== undefined;
        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform"; // Pips don't move, so we can place them using left/top.

        var styles = [["left", "top"], ["right", "bottom"]];
        parsed.style = styles[parsed.dir][parsed.ort];
        return parsed;
      } //endregion


      function scope(target, options, originalOptions) {
        var actions = getActions();
        var supportsTouchActionNone = getSupportsTouchActionNone();
        var supportsPassive = supportsTouchActionNone && getSupportsPassive(); // All variables local to 'scope' are prefixed with 'scope_'
        // Slider DOM Nodes

        var scope_Target = target;
        var scope_Base;
        var scope_Handles;
        var scope_Connects;
        var scope_Pips;
        var scope_Tooltips; // Slider state values

        var scope_Spectrum = options.spectrum;
        var scope_Values = [];
        var scope_Locations = [];
        var scope_HandleNumbers = [];
        var scope_ActiveHandlesCount = 0;
        var scope_Events = {}; // Document Nodes

        var scope_Document = target.ownerDocument;
        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
        var scope_Body = scope_Document.body; // For horizontal sliders in standard ltr documents,
        // make .noUi-origin overflow to the left so the document doesn't scroll.

        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100; // Creates a node, adds it to target, returns the new node.

        function addNodeTo(addTarget, className) {
          var div = scope_Document.createElement("div");

          if (className) {
            addClass(div, className);
          }

          addTarget.appendChild(div);
          return div;
        } // Append a origin to the base


        function addOrigin(base, handleNumber) {
          var origin = addNodeTo(base, options.cssClasses.origin);
          var handle = addNodeTo(origin, options.cssClasses.handle);
          addNodeTo(handle, options.cssClasses.touchArea);
          handle.setAttribute("data-handle", String(handleNumber));

          if (options.keyboardSupport) {
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
            // 0 = focusable and reachable
            handle.setAttribute("tabindex", "0");
            handle.addEventListener("keydown", function (event) {
              return eventKeydown(event, handleNumber);
            });
          }

          if (options.handleAttributes !== undefined) {
            var attributes_1 = options.handleAttributes[handleNumber];
            Object.keys(attributes_1).forEach(function (attribute) {
              handle.setAttribute(attribute, attributes_1[attribute]);
            });
          }

          handle.setAttribute("role", "slider");
          handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");

          if (handleNumber === 0) {
            addClass(handle, options.cssClasses.handleLower);
          } else if (handleNumber === options.handles - 1) {
            addClass(handle, options.cssClasses.handleUpper);
          }

          return origin;
        } // Insert nodes for connect elements


        function addConnect(base, add) {
          if (!add) {
            return false;
          }

          return addNodeTo(base, options.cssClasses.connect);
        } // Add handles to the slider base.


        function addElements(connectOptions, base) {
          var connectBase = addNodeTo(base, options.cssClasses.connects);
          scope_Handles = [];
          scope_Connects = [];
          scope_Connects.push(addConnect(connectBase, connectOptions[0])); // [::::O====O====O====]
          // connectOptions = [0, 1, 1, 1]

          for (var i = 0; i < options.handles; i++) {
            // Keep a list of all added handles.
            scope_Handles.push(addOrigin(base, i));
            scope_HandleNumbers[i] = i;
            scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
          }
        } // Initialize a single slider.


        function addSlider(addTarget) {
          // Apply classes and data to the target.
          addClass(addTarget, options.cssClasses.target);

          if (options.dir === 0) {
            addClass(addTarget, options.cssClasses.ltr);
          } else {
            addClass(addTarget, options.cssClasses.rtl);
          }

          if (options.ort === 0) {
            addClass(addTarget, options.cssClasses.horizontal);
          } else {
            addClass(addTarget, options.cssClasses.vertical);
          }

          var textDirection = getComputedStyle(addTarget).direction;

          if (textDirection === "rtl") {
            addClass(addTarget, options.cssClasses.textDirectionRtl);
          } else {
            addClass(addTarget, options.cssClasses.textDirectionLtr);
          }

          return addNodeTo(addTarget, options.cssClasses.base);
        }

        function addTooltip(handle, handleNumber) {
          if (!options.tooltips || !options.tooltips[handleNumber]) {
            return false;
          }

          return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
        }

        function isSliderDisabled() {
          return scope_Target.hasAttribute("disabled");
        } // Disable the slider dragging if any handle is disabled


        function isHandleDisabled(handleNumber) {
          var handleOrigin = scope_Handles[handleNumber];
          return handleOrigin.hasAttribute("disabled");
        }

        function removeTooltips() {
          if (scope_Tooltips) {
            removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
            scope_Tooltips.forEach(function (tooltip) {
              if (tooltip) {
                removeElement(tooltip);
              }
            });
            scope_Tooltips = null;
          }
        } // The tooltips option is a shorthand for using the 'update' event.


        function tooltips() {
          removeTooltips(); // Tooltips are added with options.tooltips in original order.

          scope_Tooltips = scope_Handles.map(addTooltip);
          bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function (values, handleNumber, unencoded) {
            if (!scope_Tooltips || !options.tooltips) {
              return;
            }

            if (scope_Tooltips[handleNumber] === false) {
              return;
            }

            var formattedValue = values[handleNumber];

            if (options.tooltips[handleNumber] !== true) {
              formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
            }

            scope_Tooltips[handleNumber].innerHTML = formattedValue;
          });
        }

        function aria() {
          removeEvent("update" + INTERNAL_EVENT_NS.aria);
          bindEvent("update" + INTERNAL_EVENT_NS.aria, function (values, handleNumber, unencoded, tap, positions) {
            // Update Aria Values for all handles, as a change in one changes min and max values for the next.
            scope_HandleNumbers.forEach(function (index) {
              var handle = scope_Handles[index];
              var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);
              var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);
              var now = positions[index]; // Formatted value for display

              var text = String(options.ariaFormat.to(unencoded[index])); // Map to slider range values

              min = scope_Spectrum.fromStepping(min).toFixed(1);
              max = scope_Spectrum.fromStepping(max).toFixed(1);
              now = scope_Spectrum.fromStepping(now).toFixed(1);
              handle.children[0].setAttribute("aria-valuemin", min);
              handle.children[0].setAttribute("aria-valuemax", max);
              handle.children[0].setAttribute("aria-valuenow", now);
              handle.children[0].setAttribute("aria-valuetext", text);
            });
          });
        }

        function getGroup(pips) {
          // Use the range.
          if (pips.mode === exports.PipsMode.Range || pips.mode === exports.PipsMode.Steps) {
            return scope_Spectrum.xVal;
          }

          if (pips.mode === exports.PipsMode.Count) {
            if (pips.values < 2) {
              throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
            } // Divide 0 - 100 in 'count' parts.


            var interval = pips.values - 1;
            var spread = 100 / interval;
            var values = []; // List these parts and have them handled as 'positions'.

            while (interval--) {
              values[interval] = interval * spread;
            }

            values.push(100);
            return mapToRange(values, pips.stepped);
          }

          if (pips.mode === exports.PipsMode.Positions) {
            // Map all percentages to on-range values.
            return mapToRange(pips.values, pips.stepped);
          }

          if (pips.mode === exports.PipsMode.Values) {
            // If the value must be stepped, it needs to be converted to a percentage first.
            if (pips.stepped) {
              return pips.values.map(function (value) {
                // Convert to percentage, apply step, return to value.
                return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
              });
            } // Otherwise, we can simply use the values.


            return pips.values;
          }

          return []; // pips.mode = never
        }

        function mapToRange(values, stepped) {
          return values.map(function (value) {
            return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
          });
        }

        function generateSpread(pips) {
          function safeIncrement(value, increment) {
            // Avoid floating point variance by dropping the smallest decimal places.
            return Number((value + increment).toFixed(7));
          }

          var group = getGroup(pips);
          var indexes = {};
          var firstInRange = scope_Spectrum.xVal[0];
          var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
          var ignoreFirst = false;
          var ignoreLast = false;
          var prevPct = 0; // Create a copy of the group, sort it and filter away all duplicates.

          group = unique(group.slice().sort(function (a, b) {
            return a - b;
          })); // Make sure the range starts with the first element.

          if (group[0] !== firstInRange) {
            group.unshift(firstInRange);
            ignoreFirst = true;
          } // Likewise for the last one.


          if (group[group.length - 1] !== lastInRange) {
            group.push(lastInRange);
            ignoreLast = true;
          }

          group.forEach(function (current, index) {
            // Get the current step and the lower + upper positions.
            var step;
            var i;
            var q;
            var low = current;
            var high = group[index + 1];
            var newPct;
            var pctDifference;
            var pctPos;
            var type;
            var steps;
            var realSteps;
            var stepSize;
            var isSteps = pips.mode === exports.PipsMode.Steps; // When using 'steps' mode, use the provided steps.
            // Otherwise, we'll step on to the next subrange.

            if (isSteps) {
              step = scope_Spectrum.xNumSteps[index];
            } // Default to a 'full' step.


            if (!step) {
              step = high - low;
            } // If high is undefined we are at the last subrange. Make sure it iterates once (#1088)


            if (high === undefined) {
              high = low;
            } // Make sure step isn't 0, which would cause an infinite loop (#654)


            step = Math.max(step, 0.0000001); // Find all steps in the subrange.

            for (i = low; i <= high; i = safeIncrement(i, step)) {
              // Get the percentage value for the current step,
              // calculate the size for the subrange.
              newPct = scope_Spectrum.toStepping(i);
              pctDifference = newPct - prevPct;
              steps = pctDifference / (pips.density || 1);
              realSteps = Math.round(steps); // This ratio represents the amount of percentage-space a point indicates.
              // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.
              // Round the percentage offset to an even number, then divide by two
              // to spread the offset on both sides of the range.

              stepSize = pctDifference / realSteps; // Divide all points evenly, adding the correct number to this subrange.
              // Run up to <= so that 100% gets a point, event if ignoreLast is set.

              for (q = 1; q <= realSteps; q += 1) {
                // The ratio between the rounded value and the actual size might be ~1% off.
                // Correct the percentage offset by the number of points
                // per subrange. density = 1 will result in 100 points on the
                // full range, 2 for 50, 4 for 25, etc.
                pctPos = prevPct + q * stepSize;
                indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
              } // Determine the point type.


              type = group.indexOf(i) > -1 ? exports.PipsType.LargeValue : isSteps ? exports.PipsType.SmallValue : exports.PipsType.NoValue; // Enforce the 'ignoreFirst' option by overwriting the type for 0.

              if (!index && ignoreFirst && i !== high) {
                type = 0;
              }

              if (!(i === high && ignoreLast)) {
                // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.
                indexes[newPct.toFixed(5)] = [i, type];
              } // Update the percentage count.


              prevPct = newPct;
            }
          });
          return indexes;
        }

        function addMarking(spread, filterFunc, formatter) {
          var _a, _b;

          var element = scope_Document.createElement("div");
          var valueSizeClasses = (_a = {}, _a[exports.PipsType.None] = "", _a[exports.PipsType.NoValue] = options.cssClasses.valueNormal, _a[exports.PipsType.LargeValue] = options.cssClasses.valueLarge, _a[exports.PipsType.SmallValue] = options.cssClasses.valueSub, _a);
          var markerSizeClasses = (_b = {}, _b[exports.PipsType.None] = "", _b[exports.PipsType.NoValue] = options.cssClasses.markerNormal, _b[exports.PipsType.LargeValue] = options.cssClasses.markerLarge, _b[exports.PipsType.SmallValue] = options.cssClasses.markerSub, _b);
          var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
          var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
          addClass(element, options.cssClasses.pips);
          addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);

          function getClasses(type, source) {
            var a = source === options.cssClasses.value;
            var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
            var sizeClasses = a ? valueSizeClasses : markerSizeClasses;
            return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
          }

          function addSpread(offset, value, type) {
            // Apply the filter function, if it is set.
            type = filterFunc ? filterFunc(value, type) : type;

            if (type === exports.PipsType.None) {
              return;
            } // Add a marker for every point


            var node = addNodeTo(element, false);
            node.className = getClasses(type, options.cssClasses.marker);
            node.style[options.style] = offset + "%"; // Values are only appended for points marked '1' or '2'.

            if (type > exports.PipsType.NoValue) {
              node = addNodeTo(element, false);
              node.className = getClasses(type, options.cssClasses.value);
              node.setAttribute("data-value", String(value));
              node.style[options.style] = offset + "%";
              node.innerHTML = String(formatter.to(value));
            }
          } // Append all points.


          Object.keys(spread).forEach(function (offset) {
            addSpread(offset, spread[offset][0], spread[offset][1]);
          });
          return element;
        }

        function removePips() {
          if (scope_Pips) {
            removeElement(scope_Pips);
            scope_Pips = null;
          }
        }

        function pips(pips) {
          // Fix #669
          removePips();
          var spread = generateSpread(pips);
          var filter = pips.filter;
          var format = pips.format || {
            to: function (value) {
              return String(Math.round(value));
            }
          };
          scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));
          return scope_Pips;
        } // Shorthand for base dimensions.


        function baseSize() {
          var rect = scope_Base.getBoundingClientRect();
          var alt = "offset" + ["Width", "Height"][options.ort];
          return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
        } // Handler for attaching events trough a proxy.


        function attachEvent(events, element, callback, data) {
          // This function can be used to 'filter' events to the slider.
          // element is a node, not a nodeList
          var method = function (event) {
            var e = fixEvent(event, data.pageOffset, data.target || element); // fixEvent returns false if this event has a different target
            // when handling (multi-) touch events;

            if (!e) {
              return false;
            } // doNotReject is passed by all end events to make sure released touches
            // are not rejected, leaving the slider "stuck" to the cursor;


            if (isSliderDisabled() && !data.doNotReject) {
              return false;
            } // Stop if an active 'tap' transition is taking place.


            if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
              return false;
            } // Ignore right or middle clicks on start #454


            if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {
              return false;
            } // Ignore right or middle clicks on start #454


            if (data.hover && e.buttons) {
              return false;
            } // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.
            // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support
            // touch-action: manipulation, but that allows panning, which breaks
            // sliders after zooming/on non-responsive pages.
            // See: https://bugs.webkit.org/show_bug.cgi?id=133112


            if (!supportsPassive) {
              e.preventDefault();
            }

            e.calcPoint = e.points[options.ort]; // Call the event handler with the event [ and additional data ].

            callback(e, data);
            return;
          };

          var methods = []; // Bind a closure on the target for every event type.

          events.split(" ").forEach(function (eventName) {
            element.addEventListener(eventName, method, supportsPassive ? {
              passive: true
            } : false);
            methods.push([eventName, method]);
          });
          return methods;
        } // Provide a clean event with standardized offset values.


        function fixEvent(e, pageOffset, eventTarget) {
          // Filter the event to register the type, which can be
          // touch, mouse or pointer. Offset changes need to be
          // made on an event specific basis.
          var touch = e.type.indexOf("touch") === 0;
          var mouse = e.type.indexOf("mouse") === 0;
          var pointer = e.type.indexOf("pointer") === 0;
          var x = 0;
          var y = 0; // IE10 implemented pointer events with a prefix;

          if (e.type.indexOf("MSPointer") === 0) {
            pointer = true;
          } // Erroneous events seem to be passed in occasionally on iOS/iPadOS after user finishes interacting with
          // the slider. They appear to be of type MouseEvent, yet they don't have usual properties set. Ignore
          // events that have no touches or buttons associated with them. (#1057, #1079, #1095)


          if (e.type === "mousedown" && !e.buttons && !e.touches) {
            return false;
          } // The only thing one handle should be concerned about is the touches that originated on top of it.


          if (touch) {
            // Returns true if a touch originated on the target.
            var isTouchOnTarget = function (checkTouch) {
              var target = checkTouch.target;
              return target === eventTarget || eventTarget.contains(target) || e.composed && e.composedPath().shift() === eventTarget;
            }; // In the case of touchstart events, we need to make sure there is still no more than one
            // touch on the target so we look amongst all touches.


            if (e.type === "touchstart") {
              var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget); // Do not support more than one touch per handle.

              if (targetTouches.length > 1) {
                return false;
              }

              x = targetTouches[0].pageX;
              y = targetTouches[0].pageY;
            } else {
              // In the other cases, find on changedTouches is enough.
              var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget); // Cancel if the target touch has not moved.

              if (!targetTouch) {
                return false;
              }

              x = targetTouch.pageX;
              y = targetTouch.pageY;
            }
          }

          pageOffset = pageOffset || getPageOffset(scope_Document);

          if (mouse || pointer) {
            x = e.clientX + pageOffset.x;
            y = e.clientY + pageOffset.y;
          }

          e.pageOffset = pageOffset;
          e.points = [x, y];
          e.cursor = mouse || pointer; // Fix #435

          return e;
        } // Translate a coordinate in the document to a percentage on the slider


        function calcPointToPercentage(calcPoint) {
          var location = calcPoint - offset(scope_Base, options.ort);
          var proposal = location * 100 / baseSize(); // Clamp proposal between 0% and 100%
          // Out-of-bound coordinates may occur when .noUi-base pseudo-elements
          // are used (e.g. contained handles feature)

          proposal = limit(proposal);
          return options.dir ? 100 - proposal : proposal;
        } // Find handle closest to a certain percentage on the slider


        function getClosestHandle(clickedPosition) {
          var smallestDifference = 100;
          var handleNumber = false;
          scope_Handles.forEach(function (handle, index) {
            // Disabled handles are ignored
            if (isHandleDisabled(index)) {
              return;
            }

            var handlePosition = scope_Locations[index];
            var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition); // Initial state

            var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100; // Difference with this handle is smaller than the previously checked handle

            var isCloser = differenceWithThisHandle < smallestDifference;
            var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;

            if (isCloser || isCloserAfter || clickAtEdge) {
              handleNumber = index;
              smallestDifference = differenceWithThisHandle;
            }
          });
          return handleNumber;
        } // Fire 'end' when a mouse or pen leaves the document.


        function documentLeave(event, data) {
          if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
            eventEnd(event, data);
          }
        } // Handle movement on document for handle and range drag.


        function eventMove(event, data) {
          // Fix #498
          // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).
          // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero
          // IE9 has .buttons and .which zero on mousemove.
          // Firefox breaks the spec MDN defines.
          if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
            return eventEnd(event, data);
          } // Check if we are moving up or down


          var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint); // Convert the movement into a percentage of the slider width/height

          var proposal = movement * 100 / data.baseSize;
          moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
        } // Unbind move events on document, call callbacks.


        function eventEnd(event, data) {
          // The handle is no longer active, so remove the class.
          if (data.handle) {
            removeClass(data.handle, options.cssClasses.active);
            scope_ActiveHandlesCount -= 1;
          } // Unbind the move and end events, which are added on 'start'.


          data.listeners.forEach(function (c) {
            scope_DocumentElement.removeEventListener(c[0], c[1]);
          });

          if (scope_ActiveHandlesCount === 0) {
            // Remove dragging class.
            removeClass(scope_Target, options.cssClasses.drag);
            setZindex(); // Remove cursor styles and text-selection events bound to the body.

            if (event.cursor) {
              scope_Body.style.cursor = "";
              scope_Body.removeEventListener("selectstart", preventDefault);
            }
          }

          if (options.events.smoothSteps) {
            data.handleNumbers.forEach(function (handleNumber) {
              setHandle(handleNumber, scope_Locations[handleNumber], true, true, false, false);
            });
            data.handleNumbers.forEach(function (handleNumber) {
              fireEvent("update", handleNumber);
            });
          }

          data.handleNumbers.forEach(function (handleNumber) {
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);
            fireEvent("end", handleNumber);
          });
        } // Bind move events on document.


        function eventStart(event, data) {
          // Ignore event if any handle is disabled
          if (data.handleNumbers.some(isHandleDisabled)) {
            return;
          }

          var handle;

          if (data.handleNumbers.length === 1) {
            var handleOrigin = scope_Handles[data.handleNumbers[0]];
            handle = handleOrigin.children[0];
            scope_ActiveHandlesCount += 1; // Mark the handle as 'active' so it can be styled.

            addClass(handle, options.cssClasses.active);
          } // A drag should never propagate up to the 'tap' event.


          event.stopPropagation(); // Record the event listeners.

          var listeners = []; // Attach the move and end events.

          var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
            // The event target has changed so we need to propagate the original one so that we keep
            // relying on it to extract target touches.
            target: event.target,
            handle: handle,
            connect: data.connect,
            listeners: listeners,
            startCalcPoint: event.calcPoint,
            baseSize: baseSize(),
            pageOffset: event.pageOffset,
            handleNumbers: data.handleNumbers,
            buttonsProperty: event.buttons,
            locations: scope_Locations.slice()
          });
          var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
            target: event.target,
            handle: handle,
            listeners: listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          });
          var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
            target: event.target,
            handle: handle,
            listeners: listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          }); // We want to make sure we pushed the listeners in the listener list rather than creating
          // a new one as it has already been passed to the event handlers.

          listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent)); // Text selection isn't an issue on touch devices,
          // so adding cursor styles can be skipped.

          if (event.cursor) {
            // Prevent the 'I' cursor and extend the range-drag cursor.
            scope_Body.style.cursor = getComputedStyle(event.target).cursor; // Mark the target with a dragging state.

            if (scope_Handles.length > 1) {
              addClass(scope_Target, options.cssClasses.drag);
            } // Prevent text selection when dragging the handles.
            // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,
            // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,
            // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.
            // The 'cursor' flag is false.
            // See: http://caniuse.com/#search=selectstart


            scope_Body.addEventListener("selectstart", preventDefault, false);
          }

          data.handleNumbers.forEach(function (handleNumber) {
            fireEvent("start", handleNumber);
          });
        } // Move closest handle to tapped location.


        function eventTap(event) {
          // The tap event shouldn't propagate up
          event.stopPropagation();
          var proposal = calcPointToPercentage(event.calcPoint);
          var handleNumber = getClosestHandle(proposal); // Tackle the case that all handles are 'disabled'.

          if (handleNumber === false) {
            return;
          } // Flag the slider as it is now in a transitional state.
          // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.


          if (!options.events.snap) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          }

          setHandle(handleNumber, proposal, true, true);
          setZindex();
          fireEvent("slide", handleNumber, true);
          fireEvent("update", handleNumber, true);

          if (!options.events.snap) {
            fireEvent("change", handleNumber, true);
            fireEvent("set", handleNumber, true);
          } else {
            eventStart(event, {
              handleNumbers: [handleNumber]
            });
          }
        } // Fires a 'hover' event for a hovered mouse/pen position.


        function eventHover(event) {
          var proposal = calcPointToPercentage(event.calcPoint);
          var to = scope_Spectrum.getStep(proposal);
          var value = scope_Spectrum.fromStepping(to);
          Object.keys(scope_Events).forEach(function (targetEvent) {
            if ("hover" === targetEvent.split(".")[0]) {
              scope_Events[targetEvent].forEach(function (callback) {
                callback.call(scope_Self, value);
              });
            }
          });
        } // Handles keydown on focused handles
        // Don't move the document when pressing arrow keys on focused handles


        function eventKeydown(event, handleNumber) {
          if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
            return false;
          }

          var horizontalKeys = ["Left", "Right"];
          var verticalKeys = ["Down", "Up"];
          var largeStepKeys = ["PageDown", "PageUp"];
          var edgeKeys = ["Home", "End"];

          if (options.dir && !options.ort) {
            // On an right-to-left slider, the left and right keys act inverted
            horizontalKeys.reverse();
          } else if (options.ort && !options.dir) {
            // On a top-to-bottom slider, the up and down keys act inverted
            verticalKeys.reverse();
            largeStepKeys.reverse();
          } // Strip "Arrow" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key


          var key = event.key.replace("Arrow", "");
          var isLargeDown = key === largeStepKeys[0];
          var isLargeUp = key === largeStepKeys[1];
          var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
          var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
          var isMin = key === edgeKeys[0];
          var isMax = key === edgeKeys[1];

          if (!isDown && !isUp && !isMin && !isMax) {
            return true;
          }

          event.preventDefault();
          var to;

          if (isUp || isDown) {
            var direction = isDown ? 0 : 1;
            var steps = getNextStepsForHandle(handleNumber);
            var step = steps[direction]; // At the edge of a slider, do nothing

            if (step === null) {
              return false;
            } // No step set, use the default of 10% of the sub-range


            if (step === false) {
              step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
            }

            if (isLargeUp || isLargeDown) {
              step *= options.keyboardPageMultiplier;
            } else {
              step *= options.keyboardMultiplier;
            } // Step over zero-length ranges (#948);


            step = Math.max(step, 0.0000001); // Decrement for down steps

            step = (isDown ? -1 : 1) * step;
            to = scope_Values[handleNumber] + step;
          } else if (isMax) {
            // End key
            to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
          } else {
            // Home key
            to = options.spectrum.xVal[0];
          }

          setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
          fireEvent("slide", handleNumber);
          fireEvent("update", handleNumber);
          fireEvent("change", handleNumber);
          fireEvent("set", handleNumber);
          return false;
        } // Attach events to several slider parts.


        function bindSliderEvents(behaviour) {
          // Attach the standard drag event to the handles.
          if (!behaviour.fixed) {
            scope_Handles.forEach(function (handle, index) {
              // These events are only bound to the visual handle
              // element, not the 'real' origin element.
              attachEvent(actions.start, handle.children[0], eventStart, {
                handleNumbers: [index]
              });
            });
          } // Attach the tap event to the slider base.


          if (behaviour.tap) {
            attachEvent(actions.start, scope_Base, eventTap, {});
          } // Fire hover events


          if (behaviour.hover) {
            attachEvent(actions.move, scope_Base, eventHover, {
              hover: true
            });
          } // Make the range draggable.


          if (behaviour.drag) {
            scope_Connects.forEach(function (connect, index) {
              if (connect === false || index === 0 || index === scope_Connects.length - 1) {
                return;
              }

              var handleBefore = scope_Handles[index - 1];
              var handleAfter = scope_Handles[index];
              var eventHolders = [connect];
              var handlesToDrag = [handleBefore, handleAfter];
              var handleNumbersToDrag = [index - 1, index];
              addClass(connect, options.cssClasses.draggable); // When the range is fixed, the entire range can
              // be dragged by the handles. The handle in the first
              // origin will propagate the start event upward,
              // but it needs to be bound manually on the other.

              if (behaviour.fixed) {
                eventHolders.push(handleBefore.children[0]);
                eventHolders.push(handleAfter.children[0]);
              }

              if (behaviour.dragAll) {
                handlesToDrag = scope_Handles;
                handleNumbersToDrag = scope_HandleNumbers;
              }

              eventHolders.forEach(function (eventHolder) {
                attachEvent(actions.start, eventHolder, eventStart, {
                  handles: handlesToDrag,
                  handleNumbers: handleNumbersToDrag,
                  connect: connect
                });
              });
            });
          }
        } // Attach an event to this slider, possibly including a namespace


        function bindEvent(namespacedEvent, callback) {
          scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
          scope_Events[namespacedEvent].push(callback); // If the event bound is 'update,' fire it immediately for all handles.

          if (namespacedEvent.split(".")[0] === "update") {
            scope_Handles.forEach(function (a, index) {
              fireEvent("update", index);
            });
          }
        }

        function isInternalNamespace(namespace) {
          return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
        } // Undo attachment of event


        function removeEvent(namespacedEvent) {
          var event = namespacedEvent && namespacedEvent.split(".")[0];
          var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
          Object.keys(scope_Events).forEach(function (bind) {
            var tEvent = bind.split(".")[0];
            var tNamespace = bind.substring(tEvent.length);

            if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
              // only delete protected internal event if intentional
              if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                delete scope_Events[bind];
              }
            }
          });
        } // External event handling


        function fireEvent(eventName, handleNumber, tap) {
          Object.keys(scope_Events).forEach(function (targetEvent) {
            var eventType = targetEvent.split(".")[0];

            if (eventName === eventType) {
              scope_Events[targetEvent].forEach(function (callback) {
                callback.call( // Use the slider public API as the scope ('this')
                scope_Self, // Return values as array, so arg_1[arg_2] is always valid.
                scope_Values.map(options.format.to), // Handle index, 0 or 1
                handleNumber, // Un-formatted slider values
                scope_Values.slice(), // Event is fired by tap, true or false
                tap || false, // Left offset of the handle, in relation to the slider
                scope_Locations.slice(), // add the slider public API to an accessible parameter when this is unavailable
                scope_Self);
              });
            }
          });
        } // Split out the handle positioning logic so the Move event can use it, too


        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue, smoothSteps) {
          var distance; // For sliders with multiple handles, limit movement to the other handle.
          // Apply the margin option by adding it to the handle positions.

          if (scope_Handles.length > 1 && !options.events.unconstrained) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
              to = Math.max(to, distance);
            }

            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
              to = Math.min(to, distance);
            }
          } // The limit option has the opposite effect, limiting handles to a
          // maximum distance from another. Limit must be > 0, as otherwise
          // handles would be unmovable.


          if (scope_Handles.length > 1 && options.limit) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
              to = Math.min(to, distance);
            }

            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
              to = Math.max(to, distance);
            }
          } // The padding option keeps the handles a certain distance from the
          // edges of the slider. Padding must be > 0.


          if (options.padding) {
            if (handleNumber === 0) {
              distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
              to = Math.max(to, distance);
            }

            if (handleNumber === scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
              to = Math.min(to, distance);
            }
          }

          if (!smoothSteps) {
            to = scope_Spectrum.getStep(to);
          } // Limit percentage to the 0 - 100 range


          to = limit(to); // Return false if handle can't move

          if (to === reference[handleNumber] && !getValue) {
            return false;
          }

          return to;
        } // Uses slider orientation to create CSS rules. a = base value;


        function inRuleOrder(v, a) {
          var o = options.ort;
          return (o ? a : v) + ", " + (o ? v : a);
        } // Moves handle(s) by a percentage
        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])


        function moveHandles(upward, proposal, locations, handleNumbers, connect) {
          var proposals = locations.slice(); // Store first handle now, so we still have it in case handleNumbers is reversed

          var firstHandle = handleNumbers[0];
          var smoothSteps = options.events.smoothSteps;
          var b = [!upward, upward];
          var f = [upward, !upward]; // Copy handleNumbers so we don't change the dataset

          handleNumbers = handleNumbers.slice(); // Check to see which handle is 'leading'.
          // If that one can't move the second can't either.

          if (upward) {
            handleNumbers.reverse();
          } // Step 1: get the maximum percentage that any of the handles can move


          if (handleNumbers.length > 1) {
            handleNumbers.forEach(function (handleNumber, o) {
              var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false, smoothSteps); // Stop if one of the handles can't move.

              if (to === false) {
                proposal = 0;
              } else {
                proposal = to - proposals[handleNumber];
                proposals[handleNumber] = to;
              }
            });
          } // If using one handle, check backward AND forward
          else {
            b = f = [true];
          }

          var state = false; // Step 2: Try to set the handles with the found percentage

          handleNumbers.forEach(function (handleNumber, o) {
            state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o], false, smoothSteps) || state;
          }); // Step 3: If a handle moved, fire events

          if (state) {
            handleNumbers.forEach(function (handleNumber) {
              fireEvent("update", handleNumber);
              fireEvent("slide", handleNumber);
            }); // If target is a connect, then fire drag event

            if (connect != undefined) {
              fireEvent("drag", firstHandle);
            }
          }
        } // Takes a base value and an offset. This offset is used for the connect bar size.
        // In the initial design for this feature, the origin element was 1% wide.
        // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature
        // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223


        function transformDirection(a, b) {
          return options.dir ? 100 - a - b : a;
        } // Updates scope_Locations and scope_Values, updates visual state


        function updateHandlePosition(handleNumber, to) {
          // Update locations.
          scope_Locations[handleNumber] = to; // Convert the value to the slider stepping/range.

          scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
          var translation = transformDirection(to, 0) - scope_DirOffset;
          var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
          scope_Handles[handleNumber].style[options.transformRule] = translateRule;
          updateConnect(handleNumber);
          updateConnect(handleNumber + 1);
        } // Handles before the slider middle are stacked later = higher,
        // Handles after the middle later is lower
        // [[7] [8] .......... | .......... [5] [4]


        function setZindex() {
          scope_HandleNumbers.forEach(function (handleNumber) {
            var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
            var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
            scope_Handles[handleNumber].style.zIndex = String(zIndex);
          });
        } // Test suggested values and apply margin, step.
        // if exactInput is true, don't run checkHandlePosition, then the handle can be placed in between steps (#436)


        function setHandle(handleNumber, to, lookBackward, lookForward, exactInput, smoothSteps) {
          if (!exactInput) {
            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false, smoothSteps);
          }

          if (to === false) {
            return false;
          }

          updateHandlePosition(handleNumber, to);
          return true;
        } // Updates style attribute for connect nodes


        function updateConnect(index) {
          // Skip connects set to false
          if (!scope_Connects[index]) {
            return;
          }

          var l = 0;
          var h = 100;

          if (index !== 0) {
            l = scope_Locations[index - 1];
          }

          if (index !== scope_Connects.length - 1) {
            h = scope_Locations[index];
          } // We use two rules:
          // 'translate' to change the left/top offset;
          // 'scale' to change the width of the element;
          // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)


          var connectWidth = h - l;
          var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
          var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
          scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;
        } // Parses value passed to .set method. Returns current value if not parse-able.


        function resolveToValue(to, handleNumber) {
          // Setting with null indicates an 'ignore'.
          // Inputting 'false' is invalid.
          if (to === null || to === false || to === undefined) {
            return scope_Locations[handleNumber];
          } // If a formatted number was passed, attempt to decode it.


          if (typeof to === "number") {
            to = String(to);
          }

          to = options.format.from(to);

          if (to !== false) {
            to = scope_Spectrum.toStepping(to);
          } // If parsing the number failed, use the current value.


          if (to === false || isNaN(to)) {
            return scope_Locations[handleNumber];
          }

          return to;
        } // Set the slider value.


        function valueSet(input, fireSetEvent, exactInput) {
          var values = asArray(input);
          var isInit = scope_Locations[0] === undefined; // Event fires by default

          fireSetEvent = fireSetEvent === undefined ? true : fireSetEvent; // Animation is optional.
          // Make sure the initial values were set before using animated placement.

          if (options.animate && !isInit) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          } // First pass, without lookAhead but with lookBackward. Values are set from left to right.


          scope_HandleNumbers.forEach(function (handleNumber) {
            setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);
          });
          var i = scope_HandleNumbers.length === 1 ? 0 : 1; // Spread handles evenly across the slider if the range has no size (min=max)

          if (isInit && scope_Spectrum.hasNoSize()) {
            exactInput = true;
            scope_Locations[0] = 0;

            if (scope_HandleNumbers.length > 1) {
              var space_1 = 100 / (scope_HandleNumbers.length - 1);
              scope_HandleNumbers.forEach(function (handleNumber) {
                scope_Locations[handleNumber] = handleNumber * space_1;
              });
            }
          } // Secondary passes. Now that all base values are set, apply constraints.
          // Iterate all handles to ensure constraints are applied for the entire slider (Issue #1009)


          for (; i < scope_HandleNumbers.length; ++i) {
            scope_HandleNumbers.forEach(function (handleNumber) {
              setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
            });
          }

          setZindex();
          scope_HandleNumbers.forEach(function (handleNumber) {
            fireEvent("update", handleNumber); // Fire the event only for handles that received a new value, as per #579

            if (values[handleNumber] !== null && fireSetEvent) {
              fireEvent("set", handleNumber);
            }
          });
        } // Reset slider to initial values


        function valueReset(fireSetEvent) {
          valueSet(options.start, fireSetEvent);
        } // Set value for a single handle


        function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
          // Ensure numeric input
          handleNumber = Number(handleNumber);

          if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
            throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
          } // Look both backward and forward, since we don't want this handle to "push" other handles (#960);
          // The exactInput argument can be used to ignore slider stepping (#436)


          setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
          fireEvent("update", handleNumber);

          if (fireSetEvent) {
            fireEvent("set", handleNumber);
          }
        } // Get the slider value.


        function valueGet(unencoded) {
          if (unencoded === void 0) {
            unencoded = false;
          }

          if (unencoded) {
            // return a copy of the raw values
            return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
          }

          var values = scope_Values.map(options.format.to); // If only one handle is used, return a single value.

          if (values.length === 1) {
            return values[0];
          }

          return values;
        } // Removes classes from the root and empties it.


        function destroy() {
          // remove protected internal listeners
          removeEvent(INTERNAL_EVENT_NS.aria);
          removeEvent(INTERNAL_EVENT_NS.tooltips);
          Object.keys(options.cssClasses).forEach(function (key) {
            removeClass(scope_Target, options.cssClasses[key]);
          });

          while (scope_Target.firstChild) {
            scope_Target.removeChild(scope_Target.firstChild);
          }

          delete scope_Target.noUiSlider;
        }

        function getNextStepsForHandle(handleNumber) {
          var location = scope_Locations[handleNumber];
          var nearbySteps = scope_Spectrum.getNearbySteps(location);
          var value = scope_Values[handleNumber];
          var increment = nearbySteps.thisStep.step;
          var decrement = null; // If snapped, directly use defined step value

          if (options.snap) {
            return [value - nearbySteps.stepBefore.startValue || null, nearbySteps.stepAfter.startValue - value || null];
          } // If the next value in this step moves into the next step,
          // the increment is the start of the next step - the current value


          if (increment !== false) {
            if (value + increment > nearbySteps.stepAfter.startValue) {
              increment = nearbySteps.stepAfter.startValue - value;
            }
          } // If the value is beyond the starting point


          if (value > nearbySteps.thisStep.startValue) {
            decrement = nearbySteps.thisStep.step;
          } else if (nearbySteps.stepBefore.step === false) {
            decrement = false;
          } // If a handle is at the start of a step, it always steps back into the previous step first
          else {
            decrement = value - nearbySteps.stepBefore.highestStep;
          } // Now, if at the slider edges, there is no in/decrement


          if (location === 100) {
            increment = null;
          } else if (location === 0) {
            decrement = null;
          } // As per #391, the comparison for the decrement step can have some rounding issues.


          var stepDecimals = scope_Spectrum.countStepDecimals(); // Round per #391

          if (increment !== null && increment !== false) {
            increment = Number(increment.toFixed(stepDecimals));
          }

          if (decrement !== null && decrement !== false) {
            decrement = Number(decrement.toFixed(stepDecimals));
          }

          return [decrement, increment];
        } // Get the current step size for the slider.


        function getNextSteps() {
          return scope_HandleNumbers.map(getNextStepsForHandle);
        } // Updatable: margin, limit, padding, step, range, animate, snap


        function updateOptions(optionsToUpdate, fireSetEvent) {
          // Spectrum is created using the range, snap, direction and step options.
          // 'snap' and 'step' can be updated.
          // If 'snap' and 'step' are not passed, they should remain unchanged.
          var v = valueGet();
          var updateAble = ["margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips"]; // Only change options that we're actually passed to update.

          updateAble.forEach(function (name) {
            // Check for undefined. null removes the value.
            if (optionsToUpdate[name] !== undefined) {
              originalOptions[name] = optionsToUpdate[name];
            }
          });
          var newOptions = testOptions(originalOptions); // Load new options into the slider state

          updateAble.forEach(function (name) {
            if (optionsToUpdate[name] !== undefined) {
              options[name] = newOptions[name];
            }
          });
          scope_Spectrum = newOptions.spectrum; // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)

          options.margin = newOptions.margin;
          options.limit = newOptions.limit;
          options.padding = newOptions.padding; // Update pips, removes existing.

          if (options.pips) {
            pips(options.pips);
          } else {
            removePips();
          } // Update tooltips, removes existing.


          if (options.tooltips) {
            tooltips();
          } else {
            removeTooltips();
          } // Invalidate the current positioning so valueSet forces an update.


          scope_Locations = [];
          valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);
        } // Initialization steps


        function setupSlider() {
          // Create the base element, initialize HTML and set classes.
          // Add handles and connect elements.
          scope_Base = addSlider(scope_Target);
          addElements(options.connect, scope_Base); // Attach user events.

          bindSliderEvents(options.events); // Use the public value method to set the start values.

          valueSet(options.start);

          if (options.pips) {
            pips(options.pips);
          }

          if (options.tooltips) {
            tooltips();
          }

          aria();
        }

        setupSlider();
        var scope_Self = {
          destroy: destroy,
          steps: getNextSteps,
          on: bindEvent,
          off: removeEvent,
          get: valueGet,
          set: valueSet,
          setHandle: valueSetHandle,
          reset: valueReset,
          // Exposed for unit testing, don't use this in your application.
          __moveHandles: function (upward, proposal, handleNumbers) {
            moveHandles(upward, proposal, scope_Locations, handleNumbers);
          },
          options: originalOptions,
          updateOptions: updateOptions,
          target: scope_Target,
          removePips: removePips,
          removeTooltips: removeTooltips,
          getPositions: function () {
            return scope_Locations.slice();
          },
          getTooltips: function () {
            return scope_Tooltips;
          },
          getOrigins: function () {
            return scope_Handles;
          },
          pips: pips // Issue #594

        };
        return scope_Self;
      } // Run the standard initializer


      function initialize(target, originalOptions) {
        if (!target || !target.nodeName) {
          throw new Error("noUiSlider: create requires a single element, got: " + target);
        } // Throw an error if the slider was already initialized.


        if (target.noUiSlider) {
          throw new Error("noUiSlider: Slider was already initialized.");
        } // Test the options and create the slider environment;


        var options = testOptions(originalOptions);
        var api = scope(target, options, originalOptions);
        target.noUiSlider = api;
        return api;
      }

      var nouislider = {
        // Exposed for unit testing, don't use this in your application.
        __spectrum: Spectrum,
        // A reference to the default classes, allows global changes.
        // Use the cssClasses option for changes to one slider.
        cssClasses: cssClasses,
        create: initialize
      };
      exports.create = initialize;
      exports.cssClasses = cssClasses;
      exports["default"] = nouislider;
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
    });
    });

    var noUiSlider = unwrapExports(nouislider);

    /**
     * import main Fashion Slider function
     */

    /*end of inludes*/

    document.addEventListener("DOMContentLoaded", ready);

    function ready() {
      /**
       * Fashion Slider element
       */
      const sliderEl = document.querySelector('.fashion-slider');
      /**
       * Init Fashion Slider
       *
       * argument: pass .fashion-slider element
       */

      createFashionSlider(sliderEl); // =======================

      let burgerBtns = [...document.querySelectorAll(".burger")];
      let body = document.querySelector("body");
      let html = document.querySelector("html");

      for (const burgerBtn of burgerBtns) {
        burgerBtn.addEventListener("click", function () {
          body.classList.toggle("active");
          html.classList.toggle("active");
        });
      }

      if (document.querySelector('.prise-slider')) {
        let sliderPrise = new Swiper(".prise-slider", {
          modules: [Navigation, Autoplay],
          watchOverflow: true,
          speed: 800,
          observer: true,
          observeParents: true,
          observeSlideChildren: true,
          grabCursor: true,
          navigation: {
            nextEl: ".plans-navigation .button-next",
            prevEl: ".plans-navigation .button-prev"
          },
          autoplay: {
            delay: 2500,
            disableOnInteraction: false
          },
          on: {
            init() {
              this.el.addEventListener('mouseenter', () => {
                this.autoplay.stop();
              });
              this.el.addEventListener('mouseleave', () => {
                this.autoplay.start();
              });
            }

          },
          breakpoints: {
            320: {
              slidesPerView: 1.35,
              spaceBetween: 15,
              centeredSlides: true,
              loop: true
            },
            639: {
              slidesPerView: 1,
              spaceBetween: 15,
              centeredSlides: true,
              loop: true
            },
            768: {
              slidesPerView: 1,
              spaceBetween: 30,
              centeredSlides: false,
              loop: true
            },
            1024: {
              slidesPerView: 2,
              spaceBetween: 30,
              centeredSlides: false,
              loop: false
            },
            1280: {
              slidesPerView: 3,
              spaceBetween: 30
            }
          }
        });
      }

      if (document.querySelector('.reviews-slider')) {
        let sliderReview = new Swiper(".reviews-slider", {
          modules: [Navigation, Autoplay],
          watchOverflow: true,
          speed: 800,
          observer: true,
          observeParents: true,
          observeSlideChildren: true,
          grabCursor: true,
          navigation: {
            nextEl: ".reviews-navigation .button-next",
            prevEl: ".reviews-navigation .button-prev"
          },
          autoplay: {
            delay: 2500,
            disableOnInteraction: false
          },
          on: {
            init() {
              this.el.addEventListener('mouseenter', () => {
                this.autoplay.stop();
              });
              this.el.addEventListener('mouseleave', () => {
                this.autoplay.start();
              });
            }

          },
          breakpoints: {
            320: {
              slidesPerView: 1.35,
              spaceBetween: 15,
              centeredSlides: true,
              loop: true
            },
            639: {
              slidesPerView: 2,
              spaceBetween: 15,
              centeredSlides: false,
              loop: true
            },
            1024: {
              slidesPerView: 3,
              spaceBetween: 30,
              centeredSlides: false,
              loop: false
            },
            1280: {
              slidesPerView: 3,
              spaceBetween: 60
            }
          }
        });
      }

      if (document.querySelector('.page-swiper')) {
        let pageSwiper = new Swiper(".page-swiper", {
          modules: [Pagination, Scrollbar, freeMode, Mousewheel],
          wrapperClass: "page__wrapper",
          slideClass: "page__screen",
          direction: 'vertical',
          slidesPerView: 'auto',
          mousewheel: {
            sensitiviti: 1
          },
          init: false,
          watchOverflow: true,
          speed: 800,
          observer: true,
          observeParents: true,
          observeSlideChildren: true,
          on: {
            init: function () {
              setScrollType();
              screenContentPagging();
              hideToTopBtn();
            },
            resize: function () {
              setScrollType();
              screenContentPagging();
              setWidthPage();
            },
            afterInit: function () {
              hideToTopBtn();
            }
          },
          scrollbar: {
            el: '.page__scroll',
            dragClass: 'page__drag-scroll',
            draggable: true
          }
        });
        pageSwiper.init();

        function setScrollType() {
          let wrapper = document.querySelector('.page__wrapper');
          let page = document.querySelector('main.page');

          if (wrapper.classList.contains('_free')) {
            wrapper.classList.remove('_free');
            page.classList.remove('_free');
            pageSwiper.params.freeMode.enabled = false;
          }

          for (let index = 0; index < pageSwiper.slides.length; index++) {
            const pageSlide = pageSwiper.slides[index];
            const pageSlideContent = pageSlide.querySelector('.screen__content');

            if (pageSlideContent) {
              const pageSlideContentHeight = pageSlideContent.offsetHeight;

              if (pageSlideContentHeight > window.innerHeight) {
                console.log(pageSlideContentHeight);
                console.log(pageSlideContent);
                wrapper.classList.add('_free');
                page.classList.add('_free');
                pageSwiper.params.freeMode.enabled = true;
                break;
              }
            }

            if (window.innerWidth > 1920 || window.innerHeight <= 767) {
              wrapper.classList.add('_free');
              page.classList.add('_free');
              pageSwiper.params.freeMode.enabled = true;
            }
          }
        }

        function setWidthPage() {
          let windowWidth = window.innerWidth;

          if (windowWidth < 1280) {
            pageSwiper.destroy();
          } else {
            pageSwiper.init();
          }
        }

        function screenContentPagging() {
          let wrapper = document.querySelector('.page__wrapper');
          let header = document.querySelector('header');
          let screenContents = document.querySelectorAll('.screen__content');
          let headerHeight = header.clientHeight;

          for (const screenContent of screenContents) {
            if (!wrapper.classList.contains('_free')) {
              screenContent.style.paddingTop = headerHeight + 'px';
            } else {
              screenContent.style.paddingTop = '0px';
            }
          }
        }

        let toTopPage = document.querySelector('.to-top-page');

        if (toTopPage) {
          toTopPage.addEventListener('click', e => {
            pageSwiper.slideTo(0, 800);

            if (window.innerWidth < 1279) {
              let body = 'body';
              scrollToBlock(e, body);
            }
          });
        }

        pageSwiper.on('slideChange', function () {
          hideToTopBtn();
        });
        window.addEventListener('scroll', e => {
          hideToTopBtn();
        });

        function hideToTopBtn() {
          let activeIndexSlide = pageSwiper.activeIndex;

          if (activeIndexSlide === 0) {
            let toTopPage = document.querySelector('.to-top-page');
            toTopPage.style.display = 'none';
          } else {
            toTopPage.style.display = 'flex';
          }
        }
      } // scroll rio


      let toTopPage = document.querySelector('.to-top-page');

      if (toTopPage && !document.querySelector('.page-swiper')) {
        toTopPage.addEventListener('click', e => {
          let body = 'body';
          scrollToBlock(e, body);
        });
      }

      function scrollToBlock(e, id) {
        e.preventDefault();
        document.getElementById(id).scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });
      } // scroll rio end


      var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);

      if (isIOS) {
        let videos = document.querySelectorAll('.video');
        videos.forEach(e => {
          var canvasVideo = new CanvasVideoPlayer({
            videoSelector: '#' + e.getAttribute('id') + ' .video__video',
            canvasSelector: '#' + e.getAttribute('id') + ' .video__canvas',
            timelineSelector: false,
            autoplay: true,
            makeLoop: true,
            pauseOnClick: false,
            audio: false
          });
        });
      } else {
        // Use HTML5 video
        document.querySelectorAll('.video__canvas')[0].style.display = 'none';
      } // screnn process


      let workItems = document.querySelectorAll('.work-items .item');
      let pageScreenProcess = document.querySelector('.page__screen--process');
      let deley = 200;

      if (pageScreenProcess) {
        function animScrenProcess() {
          workItems.forEach(item => {
            item.style.transitionDelay = deley + 'ms';
            deley += 100;

            if (window.innerWidth < 1024) {
              item.style.transitionDelay = 0 + 'ms';
            }
          });
        }

        animScrenProcess();
        window.addEventListener('resize', () => {
          if (window.innerWidth < 1024) {
            let workItems = document.querySelectorAll('.work-items .item');
            workItems.forEach(item => {
              item.style.transitionDelay = 0 + 'ms';
            });
            deley = 200;
          }
        });
        window.addEventListener('scroll', () => {
          if (window.pageYOffset + 100 >= offset(pageScreenProcess)) {
            pageScreenProcess.classList.add('active-anim');
          } else {
            pageScreenProcess.classList.remove('active-anim');
          }
        });

        function offset(el) {
          var rect = el.getBoundingClientRect(),
              scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          return rect.top + scrollTop;
        }
      } // checkbox input


      let inputCheckbox = document.querySelectorAll('[type="checkbox"]');

      for (let i = 0; i < inputCheckbox.length; i++) {
        const element = inputCheckbox[i];
        addClassToLabel(element);
        element.addEventListener('change', e => {
          let targetElement = e.target;
          addClassToLabel(targetElement);
        });
      }

      function addClassToLabel(input) {
        let parentLabel = input.closest('label');

        if (input.checked === true) {
          parentLabel.classList.add('checked');
        } else {
          parentLabel.classList.remove('checked');
        }
      } // checkbox input end
      // required input


      let inputRequired = document.querySelectorAll('.wpcf7-validates-as-required');

      for (let i = 0; i < inputRequired.length; i++) {
        const element = inputRequired[i];
        let parentFieldset = element.closest('fieldset');

        if (parentFieldset) {
          parentFieldset.classList.add('required');
        }
      } // required input end
      // range input


      var pipsRange = document.querySelectorAll('#pips-range');

      if (pipsRange) {
        pipsRange.forEach(rangeElement => {
          var range = {
            'min': [1, 1],
            '11.11%': [2, 1],
            '22.22%': [3, 1],
            '33.33%': [4, 1],
            '44.44%': [5, 1],
            '55.55%': [6, 1],
            '66.66%': [7, 1],
            '77.77%': [8, 1],
            '88.88%': [9, 1],
            'max': [10, 1]
          };
          noUiSlider.create(rangeElement, {
            range: range,
            start: 0,
            connect: 'lower',
            step: 1,
            pips: {
              mode: 'range',
              density: 'none'
            }
          });
          rangeElement.noUiSlider.on('update', function (values, handle) {
            let pipsRangeFieldset = rangeElement.closest('fieldset');
            let pipsRangeInput = pipsRangeFieldset.querySelector('#pips-range-input');
            pipsRangeInput.value = Math.round(values[handle]);
          });
        });
      } // range input end


      AOS.init();


      const spollersArray = document.querySelectorAll('[data-spollers]');

      if (spollersArray.length > 0) {
        // Получение обычных слойлеров
        const spollersRegular = Array.from(spollersArray).filter(function (item, index, self) {
          return !item.dataset.spollers.split(",")[0];
        }); // Инициализация обычных слойлеров

        if (spollersRegular.length > 0) {
          initSpollers(spollersRegular);
        } // Получение слойлеров с медиа запросами


        const spollersMedia = Array.from(spollersArray).filter(function (item, index, self) {
          return item.dataset.spollers.split(",")[0];
        }); // Инициализация слойлеров с медиа запросами

        if (spollersMedia.length > 0) {
          const breakpointsArray = [];
          spollersMedia.forEach(item => {
            const params = item.dataset.spollers;
            const breakpoint = {};
            const paramsArray = params.split(",");
            breakpoint.value = paramsArray[0];
            breakpoint.type = paramsArray[1] ? paramsArray[1].trim() : "max";
            breakpoint.item = item;
            breakpointsArray.push(breakpoint);
          }); // Получаем уникальные брейкпоинты

          let mediaQueries = breakpointsArray.map(function (item) {
            return '(' + item.type + "-width: " + item.value + "px)," + item.value + ',' + item.type;
          });
          mediaQueries = mediaQueries.filter(function (item, index, self) {
            return self.indexOf(item) === index;
          }); // Работаем с каждым брейкпоинтом

          mediaQueries.forEach(breakpoint => {
            const paramsArray = breakpoint.split(",");
            const mediaBreakpoint = paramsArray[1];
            const mediaType = paramsArray[2];
            const matchMedia = window.matchMedia(paramsArray[0]); // Объекты с нужными условиями

            const spollersArray = breakpointsArray.filter(function (item) {
              if (item.value === mediaBreakpoint && item.type === mediaType) {
                return true;
              }
            }); // Событие

            matchMedia.addListener(function () {
              initSpollers(spollersArray, matchMedia);
            });
            initSpollers(spollersArray, matchMedia);
          });
        } // Инициализация


        function initSpollers(spollersArray, matchMedia = false) {
          spollersArray.forEach(spollersBlock => {
            spollersBlock = matchMedia ? spollersBlock.item : spollersBlock;

            if (matchMedia.matches || !matchMedia) {
              spollersBlock.classList.add('_init');
              initSpollerBody(spollersBlock);
              spollersBlock.addEventListener("click", setSpollerAction);
            } else {
              spollersBlock.classList.remove('_init');
              initSpollerBody(spollersBlock, false);
              spollersBlock.removeEventListener("click", setSpollerAction);
            }
          });
        } // Работа с контентом


        function initSpollerBody(spollersBlock, hideSpollerBody = true) {
          const spollerTitles = spollersBlock.querySelectorAll('[data-spoller]');

          if (spollerTitles.length > 0) {
            spollerTitles.forEach(spollerTitle => {
              if (hideSpollerBody) {
                spollerTitle.removeAttribute('tabindex');

                if (!spollerTitle.classList.contains('_active')) {
                  spollerTitle.nextElementSibling.hidden = true;
                }
              } else {
                spollerTitle.setAttribute('tabindex', '-1');
                spollerTitle.nextElementSibling.hidden = false;
              }
            });
          }
        }

        function setSpollerAction(e) {
          const el = e.target;

          if (el.hasAttribute('data-spoller') || el.closest('[data-spoller]')) {
            const spollerTitle = el.hasAttribute('data-spoller') ? el : el.closest('[data-spoller]');
            const spollersBlock = spollerTitle.closest('[data-spollers]');
            const oneSpoller = spollersBlock.hasAttribute('data-one-spoller') ? true : false;

            if (!spollersBlock.querySelectorAll('._slide').length) {
              if (oneSpoller && !spollerTitle.classList.contains('_active')) {
                hideSpollersBody(spollersBlock);
              }

              spollerTitle.classList.toggle('_active');

              _slideToggle(spollerTitle.nextElementSibling, 500);
            }

            e.preventDefault();
          }
        }

        function hideSpollersBody(spollersBlock) {
          const spollerActiveTitle = spollersBlock.querySelector('[data-spoller]._active');

          if (spollerActiveTitle) {
            spollerActiveTitle.classList.remove('_active');

            _slideUp(spollerActiveTitle.nextElementSibling, 500);
          }
        }
      } //========================================================================================================================================================
      //SlideToggle


      let _slideUp = (target, duration = 500) => {
        if (!target.classList.contains('_slide')) {
          target.classList.add('_slide');
          target.style.transitionProperty = 'height, margin, padding';
          target.style.transitionDuration = duration + 'ms';
          target.style.height = target.offsetHeight + 'px';
          target.offsetHeight;
          target.style.overflow = 'hidden';
          target.style.height = 0;
          target.style.paddingTop = 0;
          target.style.paddingBottom = 0;
          target.style.marginTop = 0;
          target.style.marginBottom = 0;
          window.setTimeout(() => {
            target.hidden = true;
            target.style.removeProperty('height');
            target.style.removeProperty('padding-top');
            target.style.removeProperty('padding-bottom');
            target.style.removeProperty('margin-top');
            target.style.removeProperty('margin-bottom');
            target.style.removeProperty('overflow');
            target.style.removeProperty('transition-duration');
            target.style.removeProperty('transition-property');
            target.classList.remove('_slide');
          }, duration);
        }
      };

      let _slideDown = (target, duration = 500) => {
        if (!target.classList.contains('_slide')) {
          target.classList.add('_slide');

          if (target.hidden) {
            target.hidden = false;
          }

          let height = target.offsetHeight;
          target.style.overflow = 'hidden';
          target.style.height = 0;
          target.style.paddingTop = 0;
          target.style.paddingBottom = 0;
          target.style.marginTop = 0;
          target.style.marginBottom = 0;
          target.offsetHeight;
          target.style.transitionProperty = "height, margin, padding";
          target.style.transitionDuration = duration + 'ms';
          target.style.height = height + 'px';
          target.style.removeProperty('padding-top');
          target.style.removeProperty('padding-bottom');
          target.style.removeProperty('margin-top');
          target.style.removeProperty('margin-bottom');
          window.setTimeout(() => {
            target.style.removeProperty('height');
            target.style.removeProperty('overflow');
            target.style.removeProperty('transition-duration');
            target.style.removeProperty('transition-property');
            target.classList.remove('_slide');
          }, duration);
        }
      };

      let _slideToggle = (target, duration = 500) => {
        if (target.hidden) {
          return _slideDown(target, duration);
        } else {
          return _slideUp(target, duration);
        }
      }; //========================================================================================================================================================

      /*
      Для родителя слойлеров пишем атрибут data-spollers
      Для заголовков слойлеров пишем атрибут data-spoller
      Если нужно включать\выключать работу спойлеров на разных размерах экранов
      пишем параметры ширины и типа брейкпоинта.
      Например:
      data-spollers="992,max" - спойлеры будут работать только на экранах меньше или равно 992px
      data-spollers="768,min" - спойлеры будут работать только на экранах больше или равно 768px
      
      Если нужно что бы в блоке открывался болько один слойлер добавляем атрибут data-one-spoller
      */

    }

})));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJtYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnbWFpbicsIGZhY3RvcnkpIDpcbiAgICBmYWN0b3J5KCk7XG59KChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIFNTUiBXaW5kb3cgNC4wLjJcbiAgICAgKiBCZXR0ZXIgaGFuZGxpbmcgZm9yIHdpbmRvdyBvYmplY3QgaW4gU1NSIGVudmlyb25tZW50XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vbGltaXRzNHdlYi9zc3Itd2luZG93XG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgMjAyMSwgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICAgICAqXG4gICAgICogUmVsZWFzZWQgb246IERlY2VtYmVyIDEzLCAyMDIxXG4gICAgICovXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAnY29uc3RydWN0b3InIGluIG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0ID0ge30sIHNyYyA9IHt9KSB7XG4gICAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHRhcmdldFtrZXldID0gc3JjW2tleV07ZWxzZSBpZiAoaXNPYmplY3Qoc3JjW2tleV0pICYmIGlzT2JqZWN0KHRhcmdldFtrZXldKSAmJiBPYmplY3Qua2V5cyhzcmNba2V5XSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGV4dGVuZCh0YXJnZXRba2V5XSwgc3JjW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBzc3JEb2N1bWVudCA9IHtcbiAgICAgIGJvZHk6IHt9LFxuXG4gICAgICBhZGRFdmVudExpc3RlbmVyKCkge30sXG5cbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7fSxcblxuICAgICAgYWN0aXZlRWxlbWVudDoge1xuICAgICAgICBibHVyKCkge30sXG5cbiAgICAgICAgbm9kZU5hbWU6ICcnXG4gICAgICB9LFxuXG4gICAgICBxdWVyeVNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIHF1ZXJ5U2VsZWN0b3JBbGwoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG5cbiAgICAgIGdldEVsZW1lbnRCeUlkKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZUV2ZW50KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluaXRFdmVudCgpIHt9XG5cbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgIHN0eWxlOiB7fSxcblxuICAgICAgICAgIHNldEF0dHJpYnV0ZSgpIHt9LFxuXG4gICAgICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICBjcmVhdGVFbGVtZW50TlMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0sXG5cbiAgICAgIGltcG9ydE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcblxuICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgaGFzaDogJycsXG4gICAgICAgIGhvc3Q6ICcnLFxuICAgICAgICBob3N0bmFtZTogJycsXG4gICAgICAgIGhyZWY6ICcnLFxuICAgICAgICBvcmlnaW46ICcnLFxuICAgICAgICBwYXRobmFtZTogJycsXG4gICAgICAgIHByb3RvY29sOiAnJyxcbiAgICAgICAgc2VhcmNoOiAnJ1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHt9O1xuICAgICAgZXh0ZW5kKGRvYywgc3NyRG9jdW1lbnQpO1xuICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG5cbiAgICBjb25zdCBzc3JXaW5kb3cgPSB7XG4gICAgICBkb2N1bWVudDogc3NyRG9jdW1lbnQsXG4gICAgICBuYXZpZ2F0b3I6IHtcbiAgICAgICAgdXNlckFnZW50OiAnJ1xuICAgICAgfSxcbiAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgIGhhc2g6ICcnLFxuICAgICAgICBob3N0OiAnJyxcbiAgICAgICAgaG9zdG5hbWU6ICcnLFxuICAgICAgICBocmVmOiAnJyxcbiAgICAgICAgb3JpZ2luOiAnJyxcbiAgICAgICAgcGF0aG5hbWU6ICcnLFxuICAgICAgICBwcm90b2NvbDogJycsXG4gICAgICAgIHNlYXJjaDogJydcbiAgICAgIH0sXG4gICAgICBoaXN0b3J5OiB7XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgpIHt9LFxuXG4gICAgICAgIHB1c2hTdGF0ZSgpIHt9LFxuXG4gICAgICAgIGdvKCkge30sXG5cbiAgICAgICAgYmFjaygpIHt9XG5cbiAgICAgIH0sXG4gICAgICBDdXN0b21FdmVudDogZnVuY3Rpb24gQ3VzdG9tRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcigpIHt9LFxuXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKCkge30sXG5cbiAgICAgIGdldENvbXB1dGVkU3R5bGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZ2V0UHJvcGVydHlWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIEltYWdlKCkge30sXG5cbiAgICAgIERhdGUoKSB7fSxcblxuICAgICAgc2NyZWVuOiB7fSxcblxuICAgICAgc2V0VGltZW91dCgpIHt9LFxuXG4gICAgICBjbGVhclRpbWVvdXQoKSB7fSxcblxuICAgICAgbWF0Y2hNZWRpYSgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSxcblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgICAgfSxcblxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93KCkge1xuICAgICAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fTtcbiAgICAgIGV4dGVuZCh3aW4sIHNzcldpbmRvdyk7XG4gICAgICByZXR1cm4gd2luO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvbTcgNC4wLjRcbiAgICAgKiBNaW5pbWFsaXN0aWMgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBET00gbWFuaXB1bGF0aW9uLCB3aXRoIGEgalF1ZXJ5LWNvbXBhdGlibGUgQVBJXG4gICAgICogaHR0cHM6Ly9mcmFtZXdvcms3LmlvL2RvY3MvZG9tNy5odG1sXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgMjAyMiwgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICAgICAqXG4gICAgICogUmVsZWFzZWQgb246IEphbnVhcnkgMTEsIDIwMjJcbiAgICAgKi9cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4gICAgZnVuY3Rpb24gbWFrZVJlYWN0aXZlKG9iaikge1xuICAgICAgY29uc3QgcHJvdG8gPSBvYmouX19wcm90b19fO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ19fcHJvdG9fXycsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICBwcm90by5fX3Byb3RvX18gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGFzcyBEb203IGV4dGVuZHMgQXJyYXkge1xuICAgICAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzdXBlcihpdGVtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VwZXIoLi4uKGl0ZW1zIHx8IFtdKSk7XG4gICAgICAgICAgbWFrZVJlYWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheUZsYXQoYXJyID0gW10pIHtcbiAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgYXJyLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgICAgICByZXMucHVzaCguLi5hcnJheUZsYXQoZWwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMucHVzaChlbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnIsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGFyciwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFycmF5VW5pcXVlKGFycikge1xuICAgICAgY29uc3QgdW5pcXVlQXJyYXkgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHVuaXF1ZUFycmF5LmluZGV4T2YoYXJyW2ldKSA9PT0gLTEpIHVuaXF1ZUFycmF5LnB1c2goYXJyW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuaXF1ZUFycmF5O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcXNhKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gW3NlbGVjdG9yXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgY29uc3QgcmVzID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYS5wdXNoKHJlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgbGV0IGFyciA9IFtdO1xuXG4gICAgICBpZiAoIWNvbnRleHQgJiYgc2VsZWN0b3IgaW5zdGFuY2VvZiBEb203KSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IERvbTcoYXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgaHRtbCA9IHNlbGVjdG9yLnRyaW0oKTtcblxuICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8JykgPj0gMCAmJiBodG1sLmluZGV4T2YoJz4nKSA+PSAwKSB7XG4gICAgICAgICAgbGV0IHRvQ3JlYXRlID0gJ2Rpdic7XG4gICAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPGxpJykgPT09IDApIHRvQ3JlYXRlID0gJ3VsJztcbiAgICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8dHInKSA9PT0gMCkgdG9DcmVhdGUgPSAndGJvZHknO1xuICAgICAgICAgIGlmIChodG1sLmluZGV4T2YoJzx0ZCcpID09PSAwIHx8IGh0bWwuaW5kZXhPZignPHRoJykgPT09IDApIHRvQ3JlYXRlID0gJ3RyJztcbiAgICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8dGJvZHknKSA9PT0gMCkgdG9DcmVhdGUgPSAndGFibGUnO1xuICAgICAgICAgIGlmIChodG1sLmluZGV4T2YoJzxvcHRpb24nKSA9PT0gMCkgdG9DcmVhdGUgPSAnc2VsZWN0JztcbiAgICAgICAgICBjb25zdCB0ZW1wUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0b0NyZWF0ZSk7XG4gICAgICAgICAgdGVtcFBhcmVudC5pbm5lckhUTUwgPSBodG1sO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wUGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHRlbXBQYXJlbnQuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyciA9IHFzYShzZWxlY3Rvci50cmltKCksIGNvbnRleHQgfHwgZG9jdW1lbnQpO1xuICAgICAgICB9IC8vIGFyciA9IHFzYShzZWxlY3RvciwgZG9jdW1lbnQpO1xuXG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLm5vZGVUeXBlIHx8IHNlbGVjdG9yID09PSB3aW5kb3cgfHwgc2VsZWN0b3IgPT09IGRvY3VtZW50KSB7XG4gICAgICAgIGFyci5wdXNoKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RvcikpIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgRG9tNykgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgICBhcnIgPSBzZWxlY3RvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEb203KGFycmF5VW5pcXVlKGFycikpO1xuICAgIH1cblxuICAgICQuZm4gPSBEb203LnByb3RvdHlwZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICBmdW5jdGlvbiBhZGRDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gYXJyYXlGbGF0KGNsYXNzZXMubWFwKGMgPT4gYy5zcGxpdCgnICcpKSk7XG4gICAgICB0aGlzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gYXJyYXlGbGF0KGNsYXNzZXMubWFwKGMgPT4gYy5zcGxpdCgnICcpKSk7XG4gICAgICB0aGlzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVDbGFzcyguLi5jbGFzc2VzKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gYXJyYXlGbGF0KGNsYXNzZXMubWFwKGMgPT4gYy5zcGxpdCgnICcpKSk7XG4gICAgICB0aGlzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBjbGFzc05hbWVzLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3MoLi4uY2xhc3Nlcykge1xuICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IGFycmF5RmxhdChjbGFzc2VzLm1hcChjID0+IGMuc3BsaXQoJyAnKSkpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHRoaXMsIGVsID0+IHtcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXMuZmlsdGVyKGNsYXNzTmFtZSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkubGVuZ3RoID4gMDtcbiAgICAgIH0pLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0cihhdHRycywgdmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gR2V0IGF0dHJcbiAgICAgICAgaWYgKHRoaXNbMF0pIHJldHVybiB0aGlzWzBdLmdldEF0dHJpYnV0ZShhdHRycyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IC8vIFNldCBhdHRyc1xuXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIC8vIFN0cmluZ1xuICAgICAgICAgIHRoaXNbaV0uc2V0QXR0cmlidXRlKGF0dHJzLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgICAgZm9yIChjb25zdCBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICAgICAgdGhpc1tpXVthdHRyTmFtZV0gPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgICB0aGlzW2ldLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0cnNbYXR0ck5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQXR0cihhdHRyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdGhpc1tpXS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0aGlzW2ldLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbihkdXJhdGlvbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRoaXNbaV0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uICE9PSAnc3RyaW5nJyA/IGAke2R1cmF0aW9ufW1zYCA6IGR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbiguLi5hcmdzKSB7XG4gICAgICBsZXQgW2V2ZW50VHlwZSwgdGFyZ2V0U2VsZWN0b3IsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBbZXZlbnRUeXBlLCBsaXN0ZW5lciwgY2FwdHVyZV0gPSBhcmdzO1xuICAgICAgICB0YXJnZXRTZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYXB0dXJlKSBjYXB0dXJlID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUxpdmVFdmVudChlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBldmVudERhdGEgPSBlLnRhcmdldC5kb203RXZlbnREYXRhIHx8IFtdO1xuXG4gICAgICAgIGlmIChldmVudERhdGEuaW5kZXhPZihlKSA8IDApIHtcbiAgICAgICAgICBldmVudERhdGEudW5zaGlmdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkKHRhcmdldCkuaXModGFyZ2V0U2VsZWN0b3IpKSBsaXN0ZW5lci5hcHBseSh0YXJnZXQsIGV2ZW50RGF0YSk7ZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50cyA9ICQodGFyZ2V0KS5wYXJlbnRzKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcGFyZW50cy5sZW5ndGg7IGsgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCQocGFyZW50c1trXSkuaXModGFyZ2V0U2VsZWN0b3IpKSBsaXN0ZW5lci5hcHBseShwYXJlbnRzW2tdLCBldmVudERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFdmVudChlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGUgJiYgZS50YXJnZXQgPyBlLnRhcmdldC5kb203RXZlbnREYXRhIHx8IFtdIDogW107XG5cbiAgICAgICAgaWYgKGV2ZW50RGF0YS5pbmRleE9mKGUpIDwgMCkge1xuICAgICAgICAgIGV2ZW50RGF0YS51bnNoaWZ0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgZXZlbnREYXRhKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXZlbnRzID0gZXZlbnRUeXBlLnNwbGl0KCcgJyk7XG4gICAgICBsZXQgajtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpc1tpXTtcblxuICAgICAgICBpZiAoIXRhcmdldFNlbGVjdG9yKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGV2ZW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbal07XG4gICAgICAgICAgICBpZiAoIWVsLmRvbTdMaXN0ZW5lcnMpIGVsLmRvbTdMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICghZWwuZG9tN0xpc3RlbmVyc1tldmVudF0pIGVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICBlbC5kb203TGlzdGVuZXJzW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICAgIHByb3h5TGlzdGVuZXI6IGhhbmRsZUV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZUV2ZW50LCBjYXB0dXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTGl2ZSBldmVudHNcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZXZlbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tqXTtcbiAgICAgICAgICAgIGlmICghZWwuZG9tN0xpdmVMaXN0ZW5lcnMpIGVsLmRvbTdMaXZlTGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICBpZiAoIWVsLmRvbTdMaXZlTGlzdGVuZXJzW2V2ZW50XSkgZWwuZG9tN0xpdmVMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICBlbC5kb203TGl2ZUxpc3RlbmVyc1tldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICBwcm94eUxpc3RlbmVyOiBoYW5kbGVMaXZlRXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlTGl2ZUV2ZW50LCBjYXB0dXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2ZmKC4uLmFyZ3MpIHtcbiAgICAgIGxldCBbZXZlbnRUeXBlLCB0YXJnZXRTZWxlY3RvciwgbGlzdGVuZXIsIGNhcHR1cmVdID0gYXJncztcblxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIFtldmVudFR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG4gICAgICAgIHRhcmdldFNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNhcHR1cmUpIGNhcHR1cmUgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGV2ZW50VHlwZS5zcGxpdCgnICcpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpXTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBlbCA9IHRoaXNbal07XG4gICAgICAgICAgbGV0IGhhbmRsZXJzO1xuXG4gICAgICAgICAgaWYgKCF0YXJnZXRTZWxlY3RvciAmJiBlbC5kb203TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBoYW5kbGVycyA9IGVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0U2VsZWN0b3IgJiYgZWwuZG9tN0xpdmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzID0gZWwuZG9tN0xpdmVMaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBoYW5kbGVycy5sZW5ndGggLSAxOyBrID49IDA7IGsgLT0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNba107XG5cbiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGhhbmRsZXIubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlci5wcm94eUxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXIgJiYgaGFuZGxlci5saXN0ZW5lciAmJiBoYW5kbGVyLmxpc3RlbmVyLmRvbTdwcm94eSAmJiBoYW5kbGVyLmxpc3RlbmVyLmRvbTdwcm94eSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLnByb3h5TGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLnByb3h5TGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgZXZlbnRzID0gYXJnc1swXS5zcGxpdCgnICcpO1xuICAgICAgY29uc3QgZXZlbnREYXRhID0gYXJnc1sxXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSB0aGlzW2pdO1xuXG4gICAgICAgICAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCkge1xuICAgICAgICAgICAgY29uc3QgZXZ0ID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChldmVudCwge1xuICAgICAgICAgICAgICBkZXRhaWw6IGV2ZW50RGF0YSxcbiAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbC5kb203RXZlbnREYXRhID0gYXJncy5maWx0ZXIoKGRhdGEsIGRhdGFJbmRleCkgPT4gZGF0YUluZGV4ID4gMCk7XG4gICAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgICAgICBlbC5kb203RXZlbnREYXRhID0gW107XG4gICAgICAgICAgICBkZWxldGUgZWwuZG9tN0V2ZW50RGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZChjYWxsYmFjaykge1xuICAgICAgY29uc3QgZG9tID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gZmlyZUNhbGxCYWNrKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZSk7XG4gICAgICAgIGRvbS5vZmYoJ3RyYW5zaXRpb25lbmQnLCBmaXJlQ2FsbEJhY2spO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgZG9tLm9uKCd0cmFuc2l0aW9uZW5kJywgZmlyZUNhbGxCYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3V0ZXJXaWR0aChpbmNsdWRlTWFyZ2lucykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoaW5jbHVkZU1hcmdpbnMpIHtcbiAgICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLnN0eWxlcygpO1xuICAgICAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldFdpZHRoICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JykpICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWxlZnQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3V0ZXJIZWlnaHQoaW5jbHVkZU1hcmdpbnMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluY2x1ZGVNYXJnaW5zKSB7XG4gICAgICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5zdHlsZXMoKTtcbiAgICAgICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykpICsgcGFyc2VGbG9hdChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWJvdHRvbScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXNbMF07XG4gICAgICAgIGNvbnN0IGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgY29uc3QgY2xpZW50VG9wID0gZWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gICAgICAgIGNvbnN0IGNsaWVudExlZnQgPSBlbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBlbCA9PT0gd2luZG93ID8gd2luZG93LnNjcm9sbFkgOiBlbC5zY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IHNjcm9sbExlZnQgPSBlbCA9PT0gd2luZG93ID8gd2luZG93LnNjcm9sbFggOiBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcCxcbiAgICAgICAgICBsZWZ0OiBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgaWYgKHRoaXNbMF0pIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLCBudWxsKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjc3MocHJvcHMsIHZhbHVlKSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgIGxldCBpO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3BzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIC5jc3MoJ3dpZHRoJylcbiAgICAgICAgICBpZiAodGhpc1swXSkgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXNbMF0sIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIC5jc3MoeyB3aWR0aDogJzEwMHB4JyB9KVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgdGhpc1tpXS5zdHlsZVtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gLmNzcygnd2lkdGgnLCAnMTAwcHgnKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXNbaV0uc3R5bGVbcHJvcHNdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xuICAgICAgICBjYWxsYmFjay5hcHBseShlbCwgW2VsLCBpbmRleF0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFycmF5RmlsdGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiAkKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHRtbChodG1sKSB7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5pbm5lckhUTUwgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdGhpc1tpXS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXh0KHRleHQpIHtcbiAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdLnRleHRDb250ZW50LnRyaW0oKSA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0aGlzW2ldLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXMoc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3QgZWwgPSB0aGlzWzBdO1xuICAgICAgbGV0IGNvbXBhcmVXaXRoO1xuICAgICAgbGV0IGk7XG4gICAgICBpZiAoIWVsIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGVsLm1hdGNoZXMpIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIGlmIChlbC5tc01hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgY29tcGFyZVdpdGggPSAkKHNlbGVjdG9yKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcGFyZVdpdGgubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZVdpdGhbaV0gPT09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdG9yID09PSBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZWwgPT09IGRvY3VtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0b3IgPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gZWwgPT09IHdpbmRvdztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdG9yLm5vZGVUeXBlIHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgRG9tNykge1xuICAgICAgICBjb21wYXJlV2l0aCA9IHNlbGVjdG9yLm5vZGVUeXBlID8gW3NlbGVjdG9yXSA6IHNlbGVjdG9yO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wYXJlV2l0aC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChjb21wYXJlV2l0aFtpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZXgoKSB7XG4gICAgICBsZXQgY2hpbGQgPSB0aGlzWzBdO1xuICAgICAgbGV0IGk7XG5cbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBpID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgd2hpbGUgKChjaGlsZCA9IGNoaWxkLnByZXZpb3VzU2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxKGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHRoaXM7XG4gICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gJChbXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgY29uc3QgcmV0dXJuSW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICAgICAgaWYgKHJldHVybkluZGV4IDwgMCkgcmV0dXJuICQoW10pO1xuICAgICAgICByZXR1cm4gJChbdGhpc1tyZXR1cm5JbmRleF1dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoW3RoaXNbaW5kZXhdXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kKC4uLmVscykge1xuICAgICAgbGV0IG5ld0NoaWxkO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGVscy5sZW5ndGg7IGsgKz0gMSkge1xuICAgICAgICBuZXdDaGlsZCA9IGVsc1trXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBuZXdDaGlsZDtcblxuICAgICAgICAgICAgd2hpbGUgKHRlbXBEaXYuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICB0aGlzW2ldLmFwcGVuZENoaWxkKHRlbXBEaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZCBpbnN0YW5jZW9mIERvbTcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmV3Q2hpbGQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgdGhpc1tpXS5hcHBlbmRDaGlsZChuZXdDaGlsZFtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbaV0uYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwZW5kKG5ld0NoaWxkKSB7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IG5ld0NoaWxkO1xuXG4gICAgICAgICAgZm9yIChqID0gdGVtcERpdi5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICB0aGlzW2ldLmluc2VydEJlZm9yZSh0ZW1wRGl2LmNoaWxkTm9kZXNbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tNykge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuZXdDaGlsZC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdGhpc1tpXS5pbnNlcnRCZWZvcmUobmV3Q2hpbGRbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbaV0uaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCB0aGlzW2ldLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHQoc2VsZWN0b3IpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nICYmICQodGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuICQoW3RoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICQoW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKSByZXR1cm4gJChbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgcmV0dXJuICQoW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChbXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dEFsbChzZWxlY3Rvcikge1xuICAgICAgY29uc3QgbmV4dEVscyA9IFtdO1xuICAgICAgbGV0IGVsID0gdGhpc1swXTtcbiAgICAgIGlmICghZWwpIHJldHVybiAkKFtdKTtcblxuICAgICAgd2hpbGUgKGVsLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgICBjb25zdCBuZXh0ID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKCQobmV4dCkuaXMoc2VsZWN0b3IpKSBuZXh0RWxzLnB1c2gobmV4dCk7XG4gICAgICAgIH0gZWxzZSBuZXh0RWxzLnB1c2gobmV4dCk7XG5cbiAgICAgICAgZWwgPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChuZXh0RWxzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmV2KHNlbGVjdG9yKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpc1swXTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZyAmJiAkKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuICQoW2VsLnByZXZpb3VzRWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJChbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykgcmV0dXJuICQoW2VsLnByZXZpb3VzRWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgcmV0dXJuICQoW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChbXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJldkFsbChzZWxlY3Rvcikge1xuICAgICAgY29uc3QgcHJldkVscyA9IFtdO1xuICAgICAgbGV0IGVsID0gdGhpc1swXTtcbiAgICAgIGlmICghZWwpIHJldHVybiAkKFtdKTtcblxuICAgICAgd2hpbGUgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoJChwcmV2KS5pcyhzZWxlY3RvcikpIHByZXZFbHMucHVzaChwcmV2KTtcbiAgICAgICAgfSBlbHNlIHByZXZFbHMucHVzaChwcmV2KTtcblxuICAgICAgICBlbCA9IHByZXY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkKHByZXZFbHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudChzZWxlY3Rvcikge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpc1tpXS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzW2ldLnBhcmVudE5vZGUpLmlzKHNlbGVjdG9yKSkgcGFyZW50cy5wdXNoKHRoaXNbaV0ucGFyZW50Tm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaCh0aGlzW2ldLnBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChwYXJlbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzW2ldLnBhcmVudE5vZGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoJChwYXJlbnQpLmlzKHNlbGVjdG9yKSkgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkKHBhcmVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcbiAgICAgIGxldCBjbG9zZXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gJChbXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2xvc2VzdC5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgY2xvc2VzdCA9IGNsb3Nlc3QucGFyZW50cyhzZWxlY3RvcikuZXEoMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9zZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IGZvdW5kRWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gdGhpc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgZm91bmRFbGVtZW50cy5wdXNoKGZvdW5kW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChmb3VuZEVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXNbaV0uY2hpbGRyZW47XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCAkKGNoaWxkTm9kZXNbal0pLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZE5vZGVzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpc1tpXS5wYXJlbnROb2RlKSB0aGlzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IE1ldGhvZHMgPSB7XG4gICAgICBhZGRDbGFzcyxcbiAgICAgIHJlbW92ZUNsYXNzLFxuICAgICAgaGFzQ2xhc3MsXG4gICAgICB0b2dnbGVDbGFzcyxcbiAgICAgIGF0dHIsXG4gICAgICByZW1vdmVBdHRyLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG9uLFxuICAgICAgb2ZmLFxuICAgICAgdHJpZ2dlcixcbiAgICAgIHRyYW5zaXRpb25FbmQsXG4gICAgICBvdXRlcldpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQsXG4gICAgICBzdHlsZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBjc3MsXG4gICAgICBlYWNoLFxuICAgICAgaHRtbCxcbiAgICAgIHRleHQsXG4gICAgICBpcyxcbiAgICAgIGluZGV4LFxuICAgICAgZXEsXG4gICAgICBhcHBlbmQsXG4gICAgICBwcmVwZW5kLFxuICAgICAgbmV4dCxcbiAgICAgIG5leHRBbGwsXG4gICAgICBwcmV2LFxuICAgICAgcHJldkFsbCxcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudHMsXG4gICAgICBjbG9zZXN0LFxuICAgICAgZmluZCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZmlsdGVyLFxuICAgICAgcmVtb3ZlXG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhNZXRob2RzKS5mb3JFYWNoKG1ldGhvZE5hbWUgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCQuZm4sIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgdmFsdWU6IE1ldGhvZHNbbWV0aG9kTmFtZV0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZVByb3BzKG9iaikge1xuICAgICAgY29uc3Qgb2JqZWN0ID0gb2JqO1xuICAgICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2JqZWN0W2tleV0gPSBudWxsO1xuICAgICAgICB9IGNhdGNoIChlKSB7Ly8gbm8gZ2V0dGVyIGZvciBvYmplY3RcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVsZXRlIG9iamVjdFtrZXldO1xuICAgICAgICB9IGNhdGNoIChlKSB7Ly8gc29tZXRoaW5nIGdvdCB3cm9uZ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0VGljayhjYWxsYmFjaywgZGVsYXkpIHtcbiAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGF5ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3coKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlJDEoZWwpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgbGV0IHN0eWxlO1xuXG4gICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3R5bGUgJiYgZWwuY3VycmVudFN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2xhdGUoZWwsIGF4aXMpIHtcbiAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHtcbiAgICAgICAgYXhpcyA9ICd4JztcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBsZXQgbWF0cml4O1xuICAgICAgbGV0IGN1clRyYW5zZm9ybTtcbiAgICAgIGxldCB0cmFuc2Zvcm1NYXRyaXg7XG4gICAgICBjb25zdCBjdXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUkMShlbCk7XG5cbiAgICAgIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSB7XG4gICAgICAgIGN1clRyYW5zZm9ybSA9IGN1clN0eWxlLnRyYW5zZm9ybSB8fCBjdXJTdHlsZS53ZWJraXRUcmFuc2Zvcm07XG5cbiAgICAgICAgaWYgKGN1clRyYW5zZm9ybS5zcGxpdCgnLCcpLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICBjdXJUcmFuc2Zvcm0gPSBjdXJUcmFuc2Zvcm0uc3BsaXQoJywgJykubWFwKGEgPT4gYS5yZXBsYWNlKCcsJywgJy4nKSkuam9pbignLCAnKTtcbiAgICAgICAgfSAvLyBTb21lIG9sZCB2ZXJzaW9ucyBvZiBXZWJraXQgY2hva2Ugd2hlbiAnbm9uZScgaXMgcGFzc2VkOyBwYXNzXG4gICAgICAgIC8vIGVtcHR5IHN0cmluZyBpbnN0ZWFkIGluIHRoaXMgY2FzZVxuXG5cbiAgICAgICAgdHJhbnNmb3JtTWF0cml4ID0gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoY3VyVHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IGN1clRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1NYXRyaXggPSBjdXJTdHlsZS5Nb3pUcmFuc2Zvcm0gfHwgY3VyU3R5bGUuT1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5Nc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5tc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNmb3JtJykucmVwbGFjZSgndHJhbnNsYXRlKCcsICdtYXRyaXgoMSwgMCwgMCwgMSwnKTtcbiAgICAgICAgbWF0cml4ID0gdHJhbnNmb3JtTWF0cml4LnRvU3RyaW5nKCkuc3BsaXQoJywnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgICAvLyBMYXRlc3QgQ2hyb21lIGFuZCB3ZWJraXRzIEZpeFxuICAgICAgICBpZiAod2luZG93LldlYktpdENTU01hdHJpeCkgY3VyVHJhbnNmb3JtID0gdHJhbnNmb3JtTWF0cml4Lm00MTsgLy8gQ3JhenkgSUUxMCBNYXRyaXhcbiAgICAgICAgZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMTYpIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzEyXSk7IC8vIE5vcm1hbCBCcm93c2Vyc1xuICAgICAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzRdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgICAvLyBMYXRlc3QgQ2hyb21lIGFuZCB3ZWJraXRzIEZpeFxuICAgICAgICBpZiAod2luZG93LldlYktpdENTU01hdHJpeCkgY3VyVHJhbnNmb3JtID0gdHJhbnNmb3JtTWF0cml4Lm00MjsgLy8gQ3JhenkgSUUxMCBNYXRyaXhcbiAgICAgICAgZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMTYpIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzEzXSk7IC8vIE5vcm1hbCBCcm93c2Vyc1xuICAgICAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1clRyYW5zZm9ybSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0JDEobykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBvICE9PSBudWxsICYmIG8uY29uc3RydWN0b3IgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKSA9PT0gJ09iamVjdCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlICYmIChub2RlLm5vZGVUeXBlID09PSAxIHx8IG5vZGUubm9kZVR5cGUgPT09IDExKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQkMSgpIHtcbiAgICAgIGNvbnN0IHRvID0gT2JqZWN0KGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gICAgICBjb25zdCBub0V4dGVuZCA9IFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddO1xuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBuZXh0U291cmNlID0gaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGlmIChuZXh0U291cmNlICE9PSB1bmRlZmluZWQgJiYgbmV4dFNvdXJjZSAhPT0gbnVsbCAmJiAhaXNOb2RlKG5leHRTb3VyY2UpKSB7XG4gICAgICAgICAgY29uc3Qga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKS5maWx0ZXIoa2V5ID0+IG5vRXh0ZW5kLmluZGV4T2Yoa2V5KSA8IDApO1xuXG4gICAgICAgICAgZm9yIChsZXQgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG5cbiAgICAgICAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICAgIGlmIChpc09iamVjdCQxKHRvW25leHRLZXldKSAmJiBpc09iamVjdCQxKG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTb3VyY2VbbmV4dEtleV0uX19zd2lwZXJfXykge1xuICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHRlbmQkMSh0b1tuZXh0S2V5XSwgbmV4dFNvdXJjZVtuZXh0S2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc09iamVjdCQxKHRvW25leHRLZXldKSAmJiBpc09iamVjdCQxKG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSB7fTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0U291cmNlW25leHRLZXldLl9fc3dpcGVyX18pIHtcbiAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXh0ZW5kJDEodG9bbmV4dEtleV0sIG5leHRTb3VyY2VbbmV4dEtleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldENTU1Byb3BlcnR5KGVsLCB2YXJOYW1lLCB2YXJWYWx1ZSkge1xuICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFyVmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFuaW1hdGVDU1NNb2RlU2Nyb2xsKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIHNpZGVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gLXN3aXBlci50cmFuc2xhdGU7XG4gICAgICBsZXQgc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgIGxldCB0aW1lO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICdub25lJztcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShzd2lwZXIuY3NzTW9kZUZyYW1lSUQpO1xuICAgICAgY29uc3QgZGlyID0gdGFyZ2V0UG9zaXRpb24gPiBzdGFydFBvc2l0aW9uID8gJ25leHQnIDogJ3ByZXYnO1xuXG4gICAgICBjb25zdCBpc091dE9mQm91bmQgPSAoY3VycmVudCwgdGFyZ2V0KSA9PiB7XG4gICAgICAgIHJldHVybiBkaXIgPT09ICduZXh0JyAmJiBjdXJyZW50ID49IHRhcmdldCB8fCBkaXIgPT09ICdwcmV2JyAmJiBjdXJyZW50IDw9IHRhcmdldDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICAgIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnRUaW1lID0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5tYXgoTWF0aC5taW4oKHRpbWUgLSBzdGFydFRpbWUpIC8gZHVyYXRpb24sIDEpLCAwKTtcbiAgICAgICAgY29uc3QgZWFzZVByb2dyZXNzID0gMC41IC0gTWF0aC5jb3MocHJvZ3Jlc3MgKiBNYXRoLlBJKSAvIDI7XG4gICAgICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uICsgZWFzZVByb2dyZXNzICogKHRhcmdldFBvc2l0aW9uIC0gc3RhcnRQb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGlzT3V0T2ZCb3VuZChjdXJyZW50UG9zaXRpb24sIHRhcmdldFBvc2l0aW9uKSkge1xuICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zY3JvbGxUbyh7XG4gICAgICAgICAgW3NpZGVdOiBjdXJyZW50UG9zaXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzT3V0T2ZCb3VuZChjdXJyZW50UG9zaXRpb24sIHRhcmdldFBvc2l0aW9uKSkge1xuICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gJyc7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgW3NpZGVdOiBjdXJyZW50UG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShzd2lwZXIuY3NzTW9kZUZyYW1lSUQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci5jc3NNb2RlRnJhbWVJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICB9O1xuXG4gICAgICBhbmltYXRlKCk7XG4gICAgfVxuXG4gICAgbGV0IHN1cHBvcnQ7XG5cbiAgICBmdW5jdGlvbiBjYWxjU3VwcG9ydCgpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc21vb3RoU2Nyb2xsOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgJ3Njcm9sbEJlaGF2aW9yJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHRvdWNoOiAhISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCksXG4gICAgICAgIHBhc3NpdmVMaXN0ZW5lcjogZnVuY3Rpb24gY2hlY2tQYXNzaXZlTGlzdGVuZXIoKSB7XG4gICAgICAgICAgbGV0IHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVMaXN0ZW5lcicsIG51bGwsIG9wdHMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBObyBzdXBwb3J0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbiAgICAgICAgfSgpLFxuICAgICAgICBnZXN0dXJlczogZnVuY3Rpb24gY2hlY2tHZXN0dXJlcygpIHtcbiAgICAgICAgICByZXR1cm4gJ29uZ2VzdHVyZXN0YXJ0JyBpbiB3aW5kb3c7XG4gICAgICAgIH0oKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0KCkge1xuICAgICAgaWYgKCFzdXBwb3J0KSB7XG4gICAgICAgIHN1cHBvcnQgPSBjYWxjU3VwcG9ydCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3VwcG9ydDtcbiAgICB9XG5cbiAgICBsZXQgZGV2aWNlQ2FjaGVkO1xuXG4gICAgZnVuY3Rpb24gY2FsY0RldmljZShfdGVtcCkge1xuICAgICAgbGV0IHtcbiAgICAgICAgdXNlckFnZW50XG4gICAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgICBjb25zdCBzdXBwb3J0ID0gZ2V0U3VwcG9ydCgpO1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBjb25zdCBwbGF0Zm9ybSA9IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm07XG4gICAgICBjb25zdCB1YSA9IHVzZXJBZ2VudCB8fCB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgIGNvbnN0IGRldmljZSA9IHtcbiAgICAgICAgaW9zOiBmYWxzZSxcbiAgICAgICAgYW5kcm9pZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb25zdCBzY3JlZW5XaWR0aCA9IHdpbmRvdy5zY3JlZW4ud2lkdGg7XG4gICAgICBjb25zdCBzY3JlZW5IZWlnaHQgPSB3aW5kb3cuc2NyZWVuLmhlaWdodDtcbiAgICAgIGNvbnN0IGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgbGV0IGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pO1xuICAgICAgY29uc3QgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gICAgICBjb25zdCBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcc09TfGlPUylcXHMoW1xcZF9dKykvKTtcbiAgICAgIGNvbnN0IHdpbmRvd3MgPSBwbGF0Zm9ybSA9PT0gJ1dpbjMyJztcbiAgICAgIGxldCBtYWNvcyA9IHBsYXRmb3JtID09PSAnTWFjSW50ZWwnOyAvLyBpUGFkT3MgMTMgZml4XG5cbiAgICAgIGNvbnN0IGlQYWRTY3JlZW5zID0gWycxMDI0eDEzNjYnLCAnMTM2NngxMDI0JywgJzgzNHgxMTk0JywgJzExOTR4ODM0JywgJzgzNHgxMTEyJywgJzExMTJ4ODM0JywgJzc2OHgxMDI0JywgJzEwMjR4NzY4JywgJzgyMHgxMTgwJywgJzExODB4ODIwJywgJzgxMHgxMDgwJywgJzEwODB4ODEwJ107XG5cbiAgICAgIGlmICghaXBhZCAmJiBtYWNvcyAmJiBzdXBwb3J0LnRvdWNoICYmIGlQYWRTY3JlZW5zLmluZGV4T2YoYCR7c2NyZWVuV2lkdGh9eCR7c2NyZWVuSGVpZ2h0fWApID49IDApIHtcbiAgICAgICAgaXBhZCA9IHVhLm1hdGNoKC8oVmVyc2lvbilcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgaWYgKCFpcGFkKSBpcGFkID0gWzAsIDEsICcxM18wXzAnXTtcbiAgICAgICAgbWFjb3MgPSBmYWxzZTtcbiAgICAgIH0gLy8gQW5kcm9pZFxuXG5cbiAgICAgIGlmIChhbmRyb2lkICYmICF3aW5kb3dzKSB7XG4gICAgICAgIGRldmljZS5vcyA9ICdhbmRyb2lkJztcbiAgICAgICAgZGV2aWNlLmFuZHJvaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXBhZCB8fCBpcGhvbmUgfHwgaXBvZCkge1xuICAgICAgICBkZXZpY2Uub3MgPSAnaW9zJztcbiAgICAgICAgZGV2aWNlLmlvcyA9IHRydWU7XG4gICAgICB9IC8vIEV4cG9ydCBvYmplY3RcblxuXG4gICAgICByZXR1cm4gZGV2aWNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERldmljZShvdmVycmlkZXMpIHtcbiAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkge1xuICAgICAgICBvdmVycmlkZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZXZpY2VDYWNoZWQpIHtcbiAgICAgICAgZGV2aWNlQ2FjaGVkID0gY2FsY0RldmljZShvdmVycmlkZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGV2aWNlQ2FjaGVkO1xuICAgIH1cblxuICAgIGxldCBicm93c2VyO1xuXG4gICAgZnVuY3Rpb24gY2FsY0Jyb3dzZXIoKSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcblxuICAgICAgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgICAgIGNvbnN0IHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHVhLmluZGV4T2YoJ3NhZmFyaScpID49IDAgJiYgdWEuaW5kZXhPZignY2hyb21lJykgPCAwICYmIHVhLmluZGV4T2YoJ2FuZHJvaWQnKSA8IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzU2FmYXJpOiBpc1NhZmFyaSgpLFxuICAgICAgICBpc1dlYlZpZXc6IC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QnJvd3NlcigpIHtcbiAgICAgIGlmICghYnJvd3Nlcikge1xuICAgICAgICBicm93c2VyID0gY2FsY0Jyb3dzZXIoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVzaXplKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgb24sXG4gICAgICAgIGVtaXRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBsZXQgb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgbGV0IGFuaW1hdGlvbkZyYW1lID0gbnVsbDtcblxuICAgICAgY29uc3QgcmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgICAgIGVtaXQoJ2JlZm9yZVJlc2l6ZScpO1xuICAgICAgICBlbWl0KCdyZXNpemUnKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNyZWF0ZU9ic2VydmVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICAgICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodFxuICAgICAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgICAgIGxldCBuZXdXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgbGV0IG5ld0hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChfcmVmMiA9PiB7XG4gICAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgICAgY29udGVudEJveFNpemUsXG4gICAgICAgICAgICAgICAgY29udGVudFJlY3QsXG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQgIT09IHN3aXBlci5lbCkgcmV0dXJuO1xuICAgICAgICAgICAgICBuZXdXaWR0aCA9IGNvbnRlbnRSZWN0ID8gY29udGVudFJlY3Qud2lkdGggOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmlubGluZVNpemU7XG4gICAgICAgICAgICAgIG5ld0hlaWdodCA9IGNvbnRlbnRSZWN0ID8gY29udGVudFJlY3QuaGVpZ2h0IDogKGNvbnRlbnRCb3hTaXplWzBdIHx8IGNvbnRlbnRCb3hTaXplKS5ibG9ja1NpemU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG5ld1dpZHRoICE9PSB3aWR0aCB8fCBuZXdIZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgICByZXNpemVIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHN3aXBlci5lbCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZW1vdmVPYnNlcnZlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYnNlcnZlciAmJiBvYnNlcnZlci51bm9ic2VydmUgJiYgc3dpcGVyLmVsKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKHN3aXBlci5lbCk7XG4gICAgICAgICAgb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5pbml0aWFsaXplZCkgcmV0dXJuO1xuICAgICAgICBlbWl0KCdvcmllbnRhdGlvbmNoYW5nZScpO1xuICAgICAgfTtcblxuICAgICAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnJlc2l6ZU9ic2VydmVyICYmIHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICByZW1vdmVPYnNlcnZlcigpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBPYnNlcnZlcihfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICBzd2lwZXIsXG4gICAgICAgIGV4dGVuZFBhcmFtcyxcbiAgICAgICAgb24sXG4gICAgICAgIGVtaXRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3Qgb2JzZXJ2ZXJzID0gW107XG4gICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcblxuICAgICAgY29uc3QgYXR0YWNoID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgT2JzZXJ2ZXJGdW5jID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYmtpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE9ic2VydmVyRnVuYyhtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgIC8vIFRoZSBvYnNlcnZlclVwZGF0ZSBldmVudCBzaG91bGQgb25seSBiZSB0cmlnZ2VyZWRcbiAgICAgICAgICAvLyBvbmNlIGRlc3BpdGUgdGhlIG51bWJlciBvZiBtdXRhdGlvbnMuICBBZGRpdGlvbmFsXG4gICAgICAgICAgLy8gdHJpZ2dlcnMgYXJlIHJlZHVuZGFudCBhbmQgYXJlIHZlcnkgY29zdGx5XG4gICAgICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGVtaXQoJ29ic2VydmVyVXBkYXRlJywgbXV0YXRpb25zWzBdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvYnNlcnZlclVwZGF0ZSA9IGZ1bmN0aW9uIG9ic2VydmVyVXBkYXRlKCkge1xuICAgICAgICAgICAgZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvYnNlcnZlclVwZGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KG9ic2VydmVyVXBkYXRlLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgICAgICBjaGlsZExpc3Q6IHR5cGVvZiBvcHRpb25zLmNoaWxkTGlzdCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5jaGlsZExpc3QsXG4gICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHlwZW9mIG9wdGlvbnMuY2hhcmFjdGVyRGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5jaGFyYWN0ZXJEYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMub2JzZXJ2ZXIpIHJldHVybjtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5vYnNlcnZlUGFyZW50cykge1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclBhcmVudHMgPSBzd2lwZXIuJGVsLnBhcmVudHMoKTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVyUGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYXR0YWNoKGNvbnRhaW5lclBhcmVudHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBPYnNlcnZlIGNvbnRhaW5lclxuXG5cbiAgICAgICAgYXR0YWNoKHN3aXBlci4kZWxbMF0sIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHN3aXBlci5wYXJhbXMub2JzZXJ2ZVNsaWRlQ2hpbGRyZW5cbiAgICAgICAgfSk7IC8vIE9ic2VydmUgd3JhcHBlclxuXG4gICAgICAgIGF0dGFjaChzd2lwZXIuJHdyYXBwZXJFbFswXSwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xuICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9ic2VydmVycy5zcGxpY2UoMCwgb2JzZXJ2ZXJzLmxlbmd0aCk7XG4gICAgICB9O1xuXG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBvYnNlcnZlcjogZmFsc2UsXG4gICAgICAgIG9ic2VydmVQYXJlbnRzOiBmYWxzZSxcbiAgICAgICAgb2JzZXJ2ZVNsaWRlQ2hpbGRyZW46IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIG9uKCdpbml0JywgaW5pdCk7XG4gICAgICBvbignZGVzdHJveScsIGRlc3Ryb3kpO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG4gICAgdmFyIGV2ZW50c0VtaXR0ZXIgPSB7XG4gICAgICBvbihldmVudHMsIGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcHJpb3JpdHkgPyAndW5zaGlmdCcgOiAncHVzaCc7XG4gICAgICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdKSBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF1bbWV0aG9kXShoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfSxcblxuICAgICAgb25jZShldmVudHMsIGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcblxuICAgICAgICBmdW5jdGlvbiBvbmNlSGFuZGxlcigpIHtcbiAgICAgICAgICBzZWxmLm9mZihldmVudHMsIG9uY2VIYW5kbGVyKTtcblxuICAgICAgICAgIGlmIChvbmNlSGFuZGxlci5fX2VtaXR0ZXJQcm94eSkge1xuICAgICAgICAgICAgZGVsZXRlIG9uY2VIYW5kbGVyLl9fZW1pdHRlclByb3h5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgb25jZUhhbmRsZXIuX19lbWl0dGVyUHJveHkgPSBoYW5kbGVyO1xuICAgICAgICByZXR1cm4gc2VsZi5vbihldmVudHMsIG9uY2VIYW5kbGVyLCBwcmlvcml0eSk7XG4gICAgICB9LFxuXG4gICAgICBvbkFueShoYW5kbGVyLCBwcmlvcml0eSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycyB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGY7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHByaW9yaXR5ID8gJ3Vuc2hpZnQnIDogJ3B1c2gnO1xuXG4gICAgICAgIGlmIChzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpIDwgMCkge1xuICAgICAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzW21ldGhvZF0oaGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH0sXG5cbiAgICAgIG9mZkFueShoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKCFzZWxmLmV2ZW50c0FueUxpc3RlbmVycykgcmV0dXJuIHNlbGY7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH0sXG5cbiAgICAgIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICAgICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKChldmVudEhhbmRsZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXIgPT09IGhhbmRsZXIgfHwgZXZlbnRIYW5kbGVyLl9fZW1pdHRlclByb3h5ICYmIGV2ZW50SGFuZGxlci5fX2VtaXR0ZXJQcm94eSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH0sXG5cbiAgICAgIGVtaXQoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycykgcmV0dXJuIHNlbGY7XG4gICAgICAgIGxldCBldmVudHM7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgY29udGV4dDtcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICBldmVudHMgPSBhcmdzWzBdO1xuICAgICAgICAgIGRhdGEgPSBhcmdzLnNsaWNlKDEsIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgICBjb250ZXh0ID0gc2VsZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudHMgPSBhcmdzWzBdLmV2ZW50cztcbiAgICAgICAgICBkYXRhID0gYXJnc1swXS5kYXRhO1xuICAgICAgICAgIGNvbnRleHQgPSBhcmdzWzBdLmNvbnRleHQgfHwgc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudW5zaGlmdChjb250ZXh0KTtcbiAgICAgICAgY29uc3QgZXZlbnRzQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoJyAnKTtcbiAgICAgICAgZXZlbnRzQXJyYXkuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzICYmIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuZm9yRWFjaChldmVudEhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgICBldmVudEhhbmRsZXIuYXBwbHkoY29udGV4dCwgW2V2ZW50LCAuLi5kYXRhXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5ldmVudHNMaXN0ZW5lcnMgJiYgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uZm9yRWFjaChldmVudEhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgICBldmVudEhhbmRsZXIuYXBwbHkoY29udGV4dCwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTaXplKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGxldCB3aWR0aDtcbiAgICAgIGxldCBoZWlnaHQ7XG4gICAgICBjb25zdCAkZWwgPSBzd2lwZXIuJGVsO1xuXG4gICAgICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMud2lkdGggIT09ICd1bmRlZmluZWQnICYmIHN3aXBlci5wYXJhbXMud2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgd2lkdGggPSBzd2lwZXIucGFyYW1zLndpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSAkZWxbMF0uY2xpZW50V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc3dpcGVyLnBhcmFtcy5oZWlnaHQgIT09ICd1bmRlZmluZWQnICYmIHN3aXBlci5wYXJhbXMuaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIGhlaWdodCA9IHN3aXBlci5wYXJhbXMuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gJGVsWzBdLmNsaWVudEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpZHRoID09PSAwICYmIHN3aXBlci5pc0hvcml6b250YWwoKSB8fCBoZWlnaHQgPT09IDAgJiYgc3dpcGVyLmlzVmVydGljYWwoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFN1YnRyYWN0IHBhZGRpbmdzXG5cblxuICAgICAgd2lkdGggPSB3aWR0aCAtIHBhcnNlSW50KCRlbC5jc3MoJ3BhZGRpbmctbGVmdCcpIHx8IDAsIDEwKSAtIHBhcnNlSW50KCRlbC5jc3MoJ3BhZGRpbmctcmlnaHQnKSB8fCAwLCAxMCk7XG4gICAgICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLXRvcCcpIHx8IDAsIDEwKSAtIHBhcnNlSW50KCRlbC5jc3MoJ3BhZGRpbmctYm90dG9tJykgfHwgMCwgMTApO1xuICAgICAgaWYgKE51bWJlci5pc05hTih3aWR0aCkpIHdpZHRoID0gMDtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oaGVpZ2h0KSkgaGVpZ2h0ID0gMDtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHNpemU6IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHdpZHRoIDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTbGlkZXMoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBnZXREaXJlY3Rpb25MYWJlbChwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgICAgICB9IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAnd2lkdGgnOiAnaGVpZ2h0JyxcbiAgICAgICAgICAnbWFyZ2luLXRvcCc6ICdtYXJnaW4tbGVmdCcsXG4gICAgICAgICAgJ21hcmdpbi1ib3R0b20gJzogJ21hcmdpbi1yaWdodCcsXG4gICAgICAgICAgJ21hcmdpbi1sZWZ0JzogJ21hcmdpbi10b3AnLFxuICAgICAgICAgICdtYXJnaW4tcmlnaHQnOiAnbWFyZ2luLWJvdHRvbScsXG4gICAgICAgICAgJ3BhZGRpbmctbGVmdCc6ICdwYWRkaW5nLXRvcCcsXG4gICAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAncGFkZGluZy1ib3R0b20nLFxuICAgICAgICAgICdtYXJnaW5SaWdodCc6ICdtYXJnaW5Cb3R0b20nXG4gICAgICAgIH1bcHJvcGVydHldO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKG5vZGUsIGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG5vZGUuZ2V0UHJvcGVydHlWYWx1ZShnZXREaXJlY3Rpb25MYWJlbChsYWJlbCkpIHx8IDApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xuICAgICAgY29uc3Qge1xuICAgICAgICAkd3JhcHBlckVsLFxuICAgICAgICBzaXplOiBzd2lwZXJTaXplLFxuICAgICAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICAgICAgd3JvbmdSVExcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgICAgY29uc3QgcHJldmlvdXNTbGlkZXNMZW5ndGggPSBpc1ZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG4gICAgICBjb25zdCBzbGlkZXMgPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9YCk7XG4gICAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBpc1ZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc2xpZGVzLmxlbmd0aDtcbiAgICAgIGxldCBzbmFwR3JpZCA9IFtdO1xuICAgICAgY29uc3Qgc2xpZGVzR3JpZCA9IFtdO1xuICAgICAgY29uc3Qgc2xpZGVzU2l6ZXNHcmlkID0gW107XG4gICAgICBsZXQgb2Zmc2V0QmVmb3JlID0gcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZTtcblxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXRCZWZvcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2Zmc2V0QmVmb3JlID0gcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZS5jYWxsKHN3aXBlcik7XG4gICAgICB9XG5cbiAgICAgIGxldCBvZmZzZXRBZnRlciA9IHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlcjtcblxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXRBZnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvZmZzZXRBZnRlciA9IHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlci5jYWxsKHN3aXBlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByZXZpb3VzU25hcEdyaWRMZW5ndGggPSBzd2lwZXIuc25hcEdyaWQubGVuZ3RoO1xuICAgICAgY29uc3QgcHJldmlvdXNTbGlkZXNHcmlkTGVuZ3RoID0gc3dpcGVyLnNsaWRlc0dyaWQubGVuZ3RoO1xuICAgICAgbGV0IHNwYWNlQmV0d2VlbiA9IHBhcmFtcy5zcGFjZUJldHdlZW47XG4gICAgICBsZXQgc2xpZGVQb3NpdGlvbiA9IC1vZmZzZXRCZWZvcmU7XG4gICAgICBsZXQgcHJldlNsaWRlU2l6ZSA9IDA7XG4gICAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgICBpZiAodHlwZW9mIHN3aXBlclNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzcGFjZUJldHdlZW4gPT09ICdzdHJpbmcnICYmIHNwYWNlQmV0d2Vlbi5pbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbi5yZXBsYWNlKCclJywgJycpKSAvIDEwMCAqIHN3aXBlclNpemU7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci52aXJ0dWFsU2l6ZSA9IC1zcGFjZUJldHdlZW47IC8vIHJlc2V0IG1hcmdpbnNcblxuICAgICAgaWYgKHJ0bCkgc2xpZGVzLmNzcyh7XG4gICAgICAgIG1hcmdpbkxlZnQ6ICcnLFxuICAgICAgICBtYXJnaW5Cb3R0b206ICcnLFxuICAgICAgICBtYXJnaW5Ub3A6ICcnXG4gICAgICB9KTtlbHNlIHNsaWRlcy5jc3Moe1xuICAgICAgICBtYXJnaW5SaWdodDogJycsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogJycsXG4gICAgICAgIG1hcmdpblRvcDogJydcbiAgICAgIH0pOyAvLyByZXNldCBjc3NNb2RlIG9mZnNldHNcblxuICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICBzZXRDU1NQcm9wZXJ0eShzd2lwZXIud3JhcHBlckVsLCAnLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWJlZm9yZScsICcnKTtcbiAgICAgICAgc2V0Q1NTUHJvcGVydHkoc3dpcGVyLndyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcicsICcnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ3JpZEVuYWJsZWQgPSBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMSAmJiBzd2lwZXIuZ3JpZDtcblxuICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgIHN3aXBlci5ncmlkLmluaXRTbGlkZXMoc2xpZGVzTGVuZ3RoKTtcbiAgICAgIH0gLy8gQ2FsYyBzbGlkZXNcblxuXG4gICAgICBsZXQgc2xpZGVTaXplO1xuICAgICAgY29uc3Qgc2hvdWxkUmVzZXRTbGlkZVNpemUgPSBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5icmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhwYXJhbXMuYnJlYWtwb2ludHMpLmZpbHRlcihrZXkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhcmFtcy5icmVha3BvaW50c1trZXldLnNsaWRlc1BlclZpZXcgIT09ICd1bmRlZmluZWQnO1xuICAgICAgfSkubGVuZ3RoID4gMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzbGlkZVNpemUgPSAwO1xuICAgICAgICBjb25zdCBzbGlkZSA9IHNsaWRlcy5lcShpKTtcblxuICAgICAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgICAgICBzd2lwZXIuZ3JpZC51cGRhdGVTbGlkZShpLCBzbGlkZSwgc2xpZGVzTGVuZ3RoLCBnZXREaXJlY3Rpb25MYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2xpZGUuY3NzKCdkaXNwbGF5JykgPT09ICdub25lJykgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJykge1xuICAgICAgICAgIGlmIChzaG91bGRSZXNldFNsaWRlU2l6ZSkge1xuICAgICAgICAgICAgc2xpZGVzW2ldLnN0eWxlW2dldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IGBgO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHNsaWRlU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZVswXSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IHNsaWRlWzBdLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50V2ViS2l0VHJhbnNmb3JtID0gc2xpZGVbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHNsaWRlWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICdub25lJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudFdlYktpdFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgc2xpZGVbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSB7XG4gICAgICAgICAgICBzbGlkZVNpemUgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBzbGlkZS5vdXRlcldpZHRoKHRydWUpIDogc2xpZGUub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnd2lkdGgnKTtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdMZWZ0ID0gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShzbGlkZVN0eWxlcywgJ3BhZGRpbmctbGVmdCcpO1xuICAgICAgICAgICAgY29uc3QgcGFkZGluZ1JpZ2h0ID0gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShzbGlkZVN0eWxlcywgJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnbWFyZ2luLWxlZnQnKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpblJpZ2h0ID0gZ2V0RGlyZWN0aW9uUHJvcGVydHlWYWx1ZShzbGlkZVN0eWxlcywgJ21hcmdpbi1yaWdodCcpO1xuICAgICAgICAgICAgY29uc3QgYm94U2l6aW5nID0gc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnYm94LXNpemluZycpO1xuXG4gICAgICAgICAgICBpZiAoYm94U2l6aW5nICYmIGJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XG4gICAgICAgICAgICAgIHNsaWRlU2l6ZSA9IHdpZHRoICsgbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG9mZnNldFdpZHRoXG4gICAgICAgICAgICAgIH0gPSBzbGlkZVswXTtcbiAgICAgICAgICAgICAgc2xpZGVTaXplID0gd2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodCArIChvZmZzZXRXaWR0aCAtIGNsaWVudFdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgc2xpZGVbMF0uc3R5bGUudHJhbnNmb3JtID0gY3VycmVudFRyYW5zZm9ybTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudFdlYktpdFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgc2xpZGVbMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gY3VycmVudFdlYktpdFRyYW5zZm9ybTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVTaXplID0gTWF0aC5mbG9vcihzbGlkZVNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNsaWRlU2l6ZSA9IChzd2lwZXJTaXplIC0gKHBhcmFtcy5zbGlkZXNQZXJWaWV3IC0gMSkgKiBzcGFjZUJldHdlZW4pIC8gcGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gICAgICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcblxuICAgICAgICAgIGlmIChzbGlkZXNbaV0pIHtcbiAgICAgICAgICAgIHNsaWRlc1tpXS5zdHlsZVtnZXREaXJlY3Rpb25MYWJlbCgnd2lkdGgnKV0gPSBgJHtzbGlkZVNpemV9cHhgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbGlkZXNbaV0pIHtcbiAgICAgICAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplID0gc2xpZGVTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgc2xpZGVzU2l6ZXNHcmlkLnB1c2goc2xpZGVTaXplKTtcblxuICAgICAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gKyBzbGlkZVNpemUgLyAyICsgcHJldlNsaWRlU2l6ZSAvIDIgKyBzcGFjZUJldHdlZW47XG4gICAgICAgICAgaWYgKHByZXZTbGlkZVNpemUgPT09IDAgJiYgaSAhPT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSBzd2lwZXJTaXplIC8gMiAtIHNwYWNlQmV0d2VlbjtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSBzd2lwZXJTaXplIC8gMiAtIHNwYWNlQmV0d2VlbjtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoc2xpZGVQb3NpdGlvbikgPCAxIC8gMTAwMCkgc2xpZGVQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xuICAgICAgICAgIGlmIChpbmRleCAlIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMCkgc25hcEdyaWQucHVzaChzbGlkZVBvc2l0aW9uKTtcbiAgICAgICAgICBzbGlkZXNHcmlkLnB1c2goc2xpZGVQb3NpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xuICAgICAgICAgIGlmICgoaW5kZXggLSBNYXRoLm1pbihzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgaW5kZXgpKSAlIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDApIHNuYXBHcmlkLnB1c2goc2xpZGVQb3NpdGlvbik7XG4gICAgICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgICAgIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uICsgc2xpZGVTaXplICsgc3BhY2VCZXR3ZWVuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLnZpcnR1YWxTaXplICs9IHNsaWRlU2l6ZSArIHNwYWNlQmV0d2VlbjtcbiAgICAgICAgcHJldlNsaWRlU2l6ZSA9IHNsaWRlU2l6ZTtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLnZpcnR1YWxTaXplID0gTWF0aC5tYXgoc3dpcGVyLnZpcnR1YWxTaXplLCBzd2lwZXJTaXplKSArIG9mZnNldEFmdGVyO1xuXG4gICAgICBpZiAocnRsICYmIHdyb25nUlRMICYmIChwYXJhbXMuZWZmZWN0ID09PSAnc2xpZGUnIHx8IHBhcmFtcy5lZmZlY3QgPT09ICdjb3ZlcmZsb3cnKSkge1xuICAgICAgICAkd3JhcHBlckVsLmNzcyh7XG4gICAgICAgICAgd2lkdGg6IGAke3N3aXBlci52aXJ0dWFsU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW59cHhgXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnNldFdyYXBwZXJTaXplKSB7XG4gICAgICAgICR3cmFwcGVyRWwuY3NzKHtcbiAgICAgICAgICBbZ2V0RGlyZWN0aW9uTGFiZWwoJ3dpZHRoJyldOiBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVufXB4YFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgIHN3aXBlci5ncmlkLnVwZGF0ZVdyYXBwZXJTaXplKHNsaWRlU2l6ZSwgc25hcEdyaWQsIGdldERpcmVjdGlvbkxhYmVsKTtcbiAgICAgIH0gLy8gUmVtb3ZlIGxhc3QgZ3JpZCBlbGVtZW50cyBkZXBlbmRpbmcgb24gd2lkdGhcblxuXG4gICAgICBpZiAoIXBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICBjb25zdCBuZXdTbGlkZXNHcmlkID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFwR3JpZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGxldCBzbGlkZXNHcmlkSXRlbSA9IHNuYXBHcmlkW2ldO1xuICAgICAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZXNHcmlkSXRlbSA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZEl0ZW0pO1xuXG4gICAgICAgICAgaWYgKHNuYXBHcmlkW2ldIDw9IHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIHtcbiAgICAgICAgICAgIG5ld1NsaWRlc0dyaWQucHVzaChzbGlkZXNHcmlkSXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc25hcEdyaWQgPSBuZXdTbGlkZXNHcmlkO1xuXG4gICAgICAgIGlmIChNYXRoLmZsb29yKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIC0gTWF0aC5mbG9vcihzbmFwR3JpZFtzbmFwR3JpZC5sZW5ndGggLSAxXSkgPiAxKSB7XG4gICAgICAgICAgc25hcEdyaWQucHVzaChzd2lwZXIudmlydHVhbFNpemUgLSBzd2lwZXJTaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc25hcEdyaWQubGVuZ3RoID09PSAwKSBzbmFwR3JpZCA9IFswXTtcblxuICAgICAgaWYgKHBhcmFtcy5zcGFjZUJldHdlZW4gIT09IDApIHtcbiAgICAgICAgY29uc3Qga2V5ID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpICYmIHJ0bCA/ICdtYXJnaW5MZWZ0JyA6IGdldERpcmVjdGlvbkxhYmVsKCdtYXJnaW5SaWdodCcpO1xuICAgICAgICBzbGlkZXMuZmlsdGVyKChfLCBzbGlkZUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCFwYXJhbXMuY3NzTW9kZSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICBpZiAoc2xpZGVJbmRleCA9PT0gc2xpZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSkuY3NzKHtcbiAgICAgICAgICBba2V5XTogYCR7c3BhY2VCZXR3ZWVufXB4YFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXNCb3VuZHMpIHtcbiAgICAgICAgbGV0IGFsbFNsaWRlc1NpemUgPSAwO1xuICAgICAgICBzbGlkZXNTaXplc0dyaWQuZm9yRWFjaChzbGlkZVNpemVWYWx1ZSA9PiB7XG4gICAgICAgICAgYWxsU2xpZGVzU2l6ZSArPSBzbGlkZVNpemVWYWx1ZSArIChwYXJhbXMuc3BhY2VCZXR3ZWVuID8gcGFyYW1zLnNwYWNlQmV0d2VlbiA6IDApO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsU2xpZGVzU2l6ZSAtPSBwYXJhbXMuc3BhY2VCZXR3ZWVuO1xuICAgICAgICBjb25zdCBtYXhTbmFwID0gYWxsU2xpZGVzU2l6ZSAtIHN3aXBlclNpemU7XG4gICAgICAgIHNuYXBHcmlkID0gc25hcEdyaWQubWFwKHNuYXAgPT4ge1xuICAgICAgICAgIGlmIChzbmFwIDwgMCkgcmV0dXJuIC1vZmZzZXRCZWZvcmU7XG4gICAgICAgICAgaWYgKHNuYXAgPiBtYXhTbmFwKSByZXR1cm4gbWF4U25hcCArIG9mZnNldEFmdGVyO1xuICAgICAgICAgIHJldHVybiBzbmFwO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5jZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMpIHtcbiAgICAgICAgbGV0IGFsbFNsaWRlc1NpemUgPSAwO1xuICAgICAgICBzbGlkZXNTaXplc0dyaWQuZm9yRWFjaChzbGlkZVNpemVWYWx1ZSA9PiB7XG4gICAgICAgICAgYWxsU2xpZGVzU2l6ZSArPSBzbGlkZVNpemVWYWx1ZSArIChwYXJhbXMuc3BhY2VCZXR3ZWVuID8gcGFyYW1zLnNwYWNlQmV0d2VlbiA6IDApO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsU2xpZGVzU2l6ZSAtPSBwYXJhbXMuc3BhY2VCZXR3ZWVuO1xuXG4gICAgICAgIGlmIChhbGxTbGlkZXNTaXplIDwgc3dpcGVyU2l6ZSkge1xuICAgICAgICAgIGNvbnN0IGFsbFNsaWRlc09mZnNldCA9IChzd2lwZXJTaXplIC0gYWxsU2xpZGVzU2l6ZSkgLyAyO1xuICAgICAgICAgIHNuYXBHcmlkLmZvckVhY2goKHNuYXAsIHNuYXBJbmRleCkgPT4ge1xuICAgICAgICAgICAgc25hcEdyaWRbc25hcEluZGV4XSA9IHNuYXAgLSBhbGxTbGlkZXNPZmZzZXQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2xpZGVzR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgICAgICAgIHNsaWRlc0dyaWRbc25hcEluZGV4XSA9IHNuYXAgKyBhbGxTbGlkZXNPZmZzZXQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgc2xpZGVzLFxuICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgc2xpZGVzR3JpZCxcbiAgICAgICAgc2xpZGVzU2l6ZXNHcmlkXG4gICAgICB9KTtcblxuICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuY3NzTW9kZSAmJiAhcGFyYW1zLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XG4gICAgICAgIHNldENTU1Byb3BlcnR5KHN3aXBlci53cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYmVmb3JlJywgYCR7LXNuYXBHcmlkWzBdfXB4YCk7XG4gICAgICAgIHNldENTU1Byb3BlcnR5KHN3aXBlci53cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYWZ0ZXInLCBgJHtzd2lwZXIuc2l6ZSAvIDIgLSBzbGlkZXNTaXplc0dyaWRbc2xpZGVzU2l6ZXNHcmlkLmxlbmd0aCAtIDFdIC8gMn1weGApO1xuICAgICAgICBjb25zdCBhZGRUb1NuYXBHcmlkID0gLXN3aXBlci5zbmFwR3JpZFswXTtcbiAgICAgICAgY29uc3QgYWRkVG9TbGlkZXNHcmlkID0gLXN3aXBlci5zbGlkZXNHcmlkWzBdO1xuICAgICAgICBzd2lwZXIuc25hcEdyaWQgPSBzd2lwZXIuc25hcEdyaWQubWFwKHYgPT4gdiArIGFkZFRvU25hcEdyaWQpO1xuICAgICAgICBzd2lwZXIuc2xpZGVzR3JpZCA9IHN3aXBlci5zbGlkZXNHcmlkLm1hcCh2ID0+IHYgKyBhZGRUb1NsaWRlc0dyaWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2xpZGVzTGVuZ3RoICE9PSBwcmV2aW91c1NsaWRlc0xlbmd0aCkge1xuICAgICAgICBzd2lwZXIuZW1pdCgnc2xpZGVzTGVuZ3RoQ2hhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzbmFwR3JpZC5sZW5ndGggIT09IHByZXZpb3VzU25hcEdyaWRMZW5ndGgpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdykgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3NuYXBHcmlkTGVuZ3RoQ2hhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzbGlkZXNHcmlkLmxlbmd0aCAhPT0gcHJldmlvdXNTbGlkZXNHcmlkTGVuZ3RoKSB7XG4gICAgICAgIHN3aXBlci5lbWl0KCdzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcykge1xuICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzT2Zmc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNWaXJ0dWFsICYmICFwYXJhbXMuY3NzTW9kZSAmJiAocGFyYW1zLmVmZmVjdCA9PT0gJ3NsaWRlJyB8fCBwYXJhbXMuZWZmZWN0ID09PSAnZmFkZScpKSB7XG4gICAgICAgIGNvbnN0IGJhY2tGYWNlSGlkZGVuQ2xhc3MgPSBgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31iYWNrZmFjZS1oaWRkZW5gO1xuICAgICAgICBjb25zdCBoYXNDbGFzc0JhY2tmYWNlQ2xhc3NBZGRlZCA9IHN3aXBlci4kZWwuaGFzQ2xhc3MoYmFja0ZhY2VIaWRkZW5DbGFzcyk7XG5cbiAgICAgICAgaWYgKHNsaWRlc0xlbmd0aCA8PSBwYXJhbXMubWF4QmFja2ZhY2VIaWRkZW5TbGlkZXMpIHtcbiAgICAgICAgICBpZiAoIWhhc0NsYXNzQmFja2ZhY2VDbGFzc0FkZGVkKSBzd2lwZXIuJGVsLmFkZENsYXNzKGJhY2tGYWNlSGlkZGVuQ2xhc3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0NsYXNzQmFja2ZhY2VDbGFzc0FkZGVkKSB7XG4gICAgICAgICAgc3dpcGVyLiRlbC5yZW1vdmVDbGFzcyhiYWNrRmFjZUhpZGRlbkNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUF1dG9IZWlnaHQoc3BlZWQpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBhY3RpdmVTbGlkZXMgPSBbXTtcbiAgICAgIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgICAgbGV0IG5ld0hlaWdodCA9IDA7XG4gICAgICBsZXQgaTtcblxuICAgICAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xuICAgICAgfSBlbHNlIGlmIChzcGVlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzd2lwZXIucGFyYW1zLnNwZWVkKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ2V0U2xpZGVCeUluZGV4ID0gaW5kZXggPT4ge1xuICAgICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZXMuZmlsdGVyKGVsID0+IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApID09PSBpbmRleClbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3dpcGVyLnNsaWRlcy5lcShpbmRleClbMF07XG4gICAgICB9OyAvLyBGaW5kIHNsaWRlcyBjdXJyZW50bHkgaW4gdmlld1xuXG5cbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgIT09ICdhdXRvJyAmJiBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgKHN3aXBlci52aXNpYmxlU2xpZGVzIHx8ICQoW10pKS5lYWNoKHNsaWRlID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZVNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTWF0aC5jZWlsKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyk7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggKyBpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGggJiYgIWlzVmlydHVhbCkgYnJlYWs7XG4gICAgICAgICAgICBhY3RpdmVTbGlkZXMucHVzaChnZXRTbGlkZUJ5SW5kZXgoaW5kZXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZVNsaWRlcy5wdXNoKGdldFNsaWRlQnlJbmRleChzd2lwZXIuYWN0aXZlSW5kZXgpKTtcbiAgICAgIH0gLy8gRmluZCBuZXcgaGVpZ2h0IGZyb20gaGlnaGVzdCBzbGlkZSBpbiB2aWV3XG5cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZVNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIGFjdGl2ZVNsaWRlc1tpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBhY3RpdmVTbGlkZXNbaV0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIG5ld0hlaWdodCA9IGhlaWdodCA+IG5ld0hlaWdodCA/IGhlaWdodCA6IG5ld0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBVcGRhdGUgSGVpZ2h0XG5cblxuICAgICAgaWYgKG5ld0hlaWdodCB8fCBuZXdIZWlnaHQgPT09IDApIHN3aXBlci4kd3JhcHBlckVsLmNzcygnaGVpZ2h0JywgYCR7bmV3SGVpZ2h0fXB4YCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2xpZGVzT2Zmc2V0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHNsaWRlcyA9IHN3aXBlci5zbGlkZXM7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHNsaWRlc1tpXS5zd2lwZXJTbGlkZU9mZnNldCA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHNsaWRlc1tpXS5vZmZzZXRMZWZ0IDogc2xpZGVzW2ldLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTbGlkZXNQcm9ncmVzcyh0cmFuc2xhdGUpIHtcbiAgICAgIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICB0cmFuc2xhdGUgPSB0aGlzICYmIHRoaXMudHJhbnNsYXRlIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbGlkZXMsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgICAgICBzbmFwR3JpZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmIChzbGlkZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIHNsaWRlc1swXS5zd2lwZXJTbGlkZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHN3aXBlci51cGRhdGVTbGlkZXNPZmZzZXQoKTtcbiAgICAgIGxldCBvZmZzZXRDZW50ZXIgPSAtdHJhbnNsYXRlO1xuICAgICAgaWYgKHJ0bCkgb2Zmc2V0Q2VudGVyID0gdHJhbnNsYXRlOyAvLyBWaXNpYmxlIFNsaWRlc1xuXG4gICAgICBzbGlkZXMucmVtb3ZlQ2xhc3MocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcbiAgICAgIHN3aXBlci52aXNpYmxlU2xpZGVzSW5kZXhlcyA9IFtdO1xuICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgc2xpZGUgPSBzbGlkZXNbaV07XG4gICAgICAgIGxldCBzbGlkZU9mZnNldCA9IHNsaWRlLnN3aXBlclNsaWRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgICAgICBzbGlkZU9mZnNldCAtPSBzbGlkZXNbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzbGlkZVByb2dyZXNzID0gKG9mZnNldENlbnRlciArIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBzd2lwZXIubWluVHJhbnNsYXRlKCkgOiAwKSAtIHNsaWRlT2Zmc2V0KSAvIChzbGlkZS5zd2lwZXJTbGlkZVNpemUgKyBwYXJhbXMuc3BhY2VCZXR3ZWVuKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTbGlkZVByb2dyZXNzID0gKG9mZnNldENlbnRlciAtIHNuYXBHcmlkWzBdICsgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5taW5UcmFuc2xhdGUoKSA6IDApIC0gc2xpZGVPZmZzZXQpIC8gKHNsaWRlLnN3aXBlclNsaWRlU2l6ZSArIHBhcmFtcy5zcGFjZUJldHdlZW4pO1xuICAgICAgICBjb25zdCBzbGlkZUJlZm9yZSA9IC0ob2Zmc2V0Q2VudGVyIC0gc2xpZGVPZmZzZXQpO1xuICAgICAgICBjb25zdCBzbGlkZUFmdGVyID0gc2xpZGVCZWZvcmUgKyBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW2ldO1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBzbGlkZUJlZm9yZSA+PSAwICYmIHNsaWRlQmVmb3JlIDwgc3dpcGVyLnNpemUgLSAxIHx8IHNsaWRlQWZ0ZXIgPiAxICYmIHNsaWRlQWZ0ZXIgPD0gc3dpcGVyLnNpemUgfHwgc2xpZGVCZWZvcmUgPD0gMCAmJiBzbGlkZUFmdGVyID49IHN3aXBlci5zaXplO1xuXG4gICAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgICBzd2lwZXIudmlzaWJsZVNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAgICAgICBzd2lwZXIudmlzaWJsZVNsaWRlc0luZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICBzbGlkZXMuZXEoaSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNsaWRlLnByb2dyZXNzID0gcnRsID8gLXNsaWRlUHJvZ3Jlc3MgOiBzbGlkZVByb2dyZXNzO1xuICAgICAgICBzbGlkZS5vcmlnaW5hbFByb2dyZXNzID0gcnRsID8gLW9yaWdpbmFsU2xpZGVQcm9ncmVzcyA6IG9yaWdpbmFsU2xpZGVQcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXMgPSAkKHN3aXBlci52aXNpYmxlU2xpZGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcyh0cmFuc2xhdGUpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgdHJhbnNsYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IC0xIDogMTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgdHJhbnNsYXRlID0gc3dpcGVyICYmIHN3aXBlci50cmFuc2xhdGUgJiYgc3dpcGVyLnRyYW5zbGF0ZSAqIG11bHRpcGxpZXIgfHwgMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgbGV0IHtcbiAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgIGlzQmVnaW5uaW5nLFxuICAgICAgICBpc0VuZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGNvbnN0IHdhc0JlZ2lubmluZyA9IGlzQmVnaW5uaW5nO1xuICAgICAgY29uc3Qgd2FzRW5kID0gaXNFbmQ7XG5cbiAgICAgIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgICAgICBwcm9ncmVzcyA9IDA7XG4gICAgICAgIGlzQmVnaW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgaXNFbmQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSAodHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xuICAgICAgICBpc0JlZ2lubmluZyA9IHByb2dyZXNzIDw9IDA7XG4gICAgICAgIGlzRW5kID0gcHJvZ3Jlc3MgPj0gMTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgIGlzQmVnaW5uaW5nLFxuICAgICAgICBpc0VuZFxuICAgICAgfSk7XG4gICAgICBpZiAocGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfHwgcGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmIHBhcmFtcy5hdXRvSGVpZ2h0KSBzd2lwZXIudXBkYXRlU2xpZGVzUHJvZ3Jlc3ModHJhbnNsYXRlKTtcblxuICAgICAgaWYgKGlzQmVnaW5uaW5nICYmICF3YXNCZWdpbm5pbmcpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3JlYWNoQmVnaW5uaW5nIHRvRWRnZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFbmQgJiYgIXdhc0VuZCkge1xuICAgICAgICBzd2lwZXIuZW1pdCgncmVhY2hFbmQgdG9FZGdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3YXNCZWdpbm5pbmcgJiYgIWlzQmVnaW5uaW5nIHx8IHdhc0VuZCAmJiAhaXNFbmQpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ2Zyb21FZGdlJyk7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KCdwcm9ncmVzcycsIHByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTbGlkZXNDbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2xpZGVzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICByZWFsSW5kZXhcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgICAgc2xpZGVzLnJlbW92ZUNsYXNzKGAke3BhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzfSAke3BhcmFtcy5zbGlkZU5leHRDbGFzc30gJHtwYXJhbXMuc2xpZGVQcmV2Q2xhc3N9ICR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3N9ICR7cGFyYW1zLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzfSAke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzc31gKTtcbiAgICAgIGxldCBhY3RpdmVTbGlkZTtcblxuICAgICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgICBhY3RpdmVTbGlkZSA9IHN3aXBlci4kd3JhcHBlckVsLmZpbmQoYC4ke3BhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7YWN0aXZlSW5kZXh9XCJdYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVTbGlkZSA9IHNsaWRlcy5lcShhY3RpdmVJbmRleCk7XG4gICAgICB9IC8vIEFjdGl2ZSBjbGFzc2VzXG5cblxuICAgICAgYWN0aXZlU2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MpO1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgLy8gRHVwbGljYXRlIHRvIGFsbCBsb29wZWQgc2xpZGVzXG4gICAgICAgIGlmIChhY3RpdmVTbGlkZS5oYXNDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc306bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl1gKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyZWFsSW5kZXh9XCJdYCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9IC8vIE5leHQgU2xpZGVcblxuXG4gICAgICBsZXQgbmV4dFNsaWRlID0gYWN0aXZlU2xpZGUubmV4dEFsbChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCkuZXEoMCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcblxuICAgICAgaWYgKHBhcmFtcy5sb29wICYmIG5leHRTbGlkZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbmV4dFNsaWRlID0gc2xpZGVzLmVxKDApO1xuICAgICAgICBuZXh0U2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcbiAgICAgIH0gLy8gUHJldiBTbGlkZVxuXG5cbiAgICAgIGxldCBwcmV2U2xpZGUgPSBhY3RpdmVTbGlkZS5wcmV2QWxsKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKS5lcSgwKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVQcmV2Q2xhc3MpO1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3AgJiYgcHJldlNsaWRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwcmV2U2xpZGUgPSBzbGlkZXMuZXEoLTEpO1xuICAgICAgICBwcmV2U2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlUHJldkNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgIC8vIER1cGxpY2F0ZSB0byBhbGwgbG9vcGVkIHNsaWRlc1xuICAgICAgICBpZiAobmV4dFNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgICAgICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7bmV4dFNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyl9XCJdYCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke25leHRTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVwiXWApLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZU5leHRDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgICAgICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cHJldlNsaWRlLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyl9XCJdYCkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlUHJldkNsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3ByZXZTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVwiXWApLmFkZENsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXRTbGlkZXNDbGFzc2VzKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQWN0aXZlSW5kZXgobmV3QWN0aXZlSW5kZXgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB0cmFuc2xhdGUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbGlkZXNHcmlkLFxuICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBhY3RpdmVJbmRleDogcHJldmlvdXNJbmRleCxcbiAgICAgICAgcmVhbEluZGV4OiBwcmV2aW91c1JlYWxJbmRleCxcbiAgICAgICAgc25hcEluZGV4OiBwcmV2aW91c1NuYXBJbmRleFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGxldCBhY3RpdmVJbmRleCA9IG5ld0FjdGl2ZUluZGV4O1xuICAgICAgbGV0IHNuYXBJbmRleDtcblxuICAgICAgaWYgKHR5cGVvZiBhY3RpdmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzbGlkZXNHcmlkW2kgKyAxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSAmJiB0cmFuc2xhdGUgPCBzbGlkZXNHcmlkW2kgKyAxXSAtIChzbGlkZXNHcmlkW2kgKyAxXSAtIHNsaWRlc0dyaWRbaV0pIC8gMikge1xuICAgICAgICAgICAgICBhY3RpdmVJbmRleCA9IGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldICYmIHRyYW5zbGF0ZSA8IHNsaWRlc0dyaWRbaSArIDFdKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZUluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSkge1xuICAgICAgICAgICAgYWN0aXZlSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBOb3JtYWxpemUgc2xpZGVJbmRleFxuXG5cbiAgICAgICAgaWYgKHBhcmFtcy5ub3JtYWxpemVTbGlkZUluZGV4KSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZUluZGV4IDwgMCB8fCB0eXBlb2YgYWN0aXZlSW5kZXggPT09ICd1bmRlZmluZWQnKSBhY3RpdmVJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKSA+PSAwKSB7XG4gICAgICAgIHNuYXBJbmRleCA9IHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNraXAgPSBNYXRoLm1pbihwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBhY3RpdmVJbmRleCk7XG4gICAgICAgIHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChhY3RpdmVJbmRleCAtIHNraXApIC8gcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNuYXBJbmRleCA+PSBzbmFwR3JpZC5sZW5ndGgpIHNuYXBJbmRleCA9IHNuYXBHcmlkLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICBpZiAoc25hcEluZGV4ICE9PSBwcmV2aW91c1NuYXBJbmRleCkge1xuICAgICAgICAgIHN3aXBlci5zbmFwSW5kZXggPSBzbmFwSW5kZXg7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ3NuYXBJbmRleENoYW5nZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBHZXQgcmVhbCBpbmRleFxuXG5cbiAgICAgIGNvbnN0IHJlYWxJbmRleCA9IHBhcnNlSW50KHN3aXBlci5zbGlkZXMuZXEoYWN0aXZlSW5kZXgpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgfHwgYWN0aXZlSW5kZXgsIDEwKTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgICAgIHNuYXBJbmRleCxcbiAgICAgICAgcmVhbEluZGV4LFxuICAgICAgICBwcmV2aW91c0luZGV4LFxuICAgICAgICBhY3RpdmVJbmRleFxuICAgICAgfSk7XG4gICAgICBzd2lwZXIuZW1pdCgnYWN0aXZlSW5kZXhDaGFuZ2UnKTtcbiAgICAgIHN3aXBlci5lbWl0KCdzbmFwSW5kZXhDaGFuZ2UnKTtcblxuICAgICAgaWYgKHByZXZpb3VzUmVhbEluZGV4ICE9PSByZWFsSW5kZXgpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3JlYWxJbmRleENoYW5nZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGVyLmluaXRpYWxpemVkIHx8IHN3aXBlci5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0KSB7XG4gICAgICAgIHN3aXBlci5lbWl0KCdzbGlkZUNoYW5nZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNsaWNrZWRTbGlkZShlKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgICAgIGNvbnN0IHNsaWRlID0gJChlKS5jbG9zZXN0KGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKVswXTtcbiAgICAgIGxldCBzbGlkZUZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgc2xpZGVJbmRleDtcblxuICAgICAgaWYgKHNsaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChzd2lwZXIuc2xpZGVzW2ldID09PSBzbGlkZSkge1xuICAgICAgICAgICAgc2xpZGVGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBzbGlkZUluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2xpZGUgJiYgc2xpZGVGb3VuZCkge1xuICAgICAgICBzd2lwZXIuY2xpY2tlZFNsaWRlID0gc2xpZGU7XG5cbiAgICAgICAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgICAgICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHBhcnNlSW50KCQoc2xpZGUpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gc2xpZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLmNsaWNrZWRTbGlkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnNsaWRlVG9DbGlja2VkU2xpZGUgJiYgc3dpcGVyLmNsaWNrZWRJbmRleCAhPT0gdW5kZWZpbmVkICYmIHN3aXBlci5jbGlja2VkSW5kZXggIT09IHN3aXBlci5hY3RpdmVJbmRleCkge1xuICAgICAgICBzd2lwZXIuc2xpZGVUb0NsaWNrZWRTbGlkZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICB1cGRhdGVTaXplLFxuICAgICAgdXBkYXRlU2xpZGVzLFxuICAgICAgdXBkYXRlQXV0b0hlaWdodCxcbiAgICAgIHVwZGF0ZVNsaWRlc09mZnNldCxcbiAgICAgIHVwZGF0ZVNsaWRlc1Byb2dyZXNzLFxuICAgICAgdXBkYXRlUHJvZ3Jlc3MsXG4gICAgICB1cGRhdGVTbGlkZXNDbGFzc2VzLFxuICAgICAgdXBkYXRlQWN0aXZlSW5kZXgsXG4gICAgICB1cGRhdGVDbGlja2VkU2xpZGVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0U3dpcGVyVHJhbnNsYXRlKGF4aXMpIHtcbiAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHtcbiAgICAgICAgYXhpcyA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyAneCcgOiAneSc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgJHdyYXBwZXJFbFxuICAgICAgfSA9IHN3aXBlcjtcblxuICAgICAgaWYgKHBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlKSB7XG4gICAgICAgIHJldHVybiBydGwgPyAtdHJhbnNsYXRlIDogdHJhbnNsYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGN1cnJlbnRUcmFuc2xhdGUgPSBnZXRUcmFuc2xhdGUoJHdyYXBwZXJFbFswXSwgYXhpcyk7XG4gICAgICBpZiAocnRsKSBjdXJyZW50VHJhbnNsYXRlID0gLWN1cnJlbnRUcmFuc2xhdGU7XG4gICAgICByZXR1cm4gY3VycmVudFRyYW5zbGF0ZSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZSh0cmFuc2xhdGUsIGJ5Q29udHJvbGxlcikge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgJHdyYXBwZXJFbCxcbiAgICAgICAgd3JhcHBlckVsLFxuICAgICAgICBwcm9ncmVzc1xuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGxldCB4ID0gMDtcbiAgICAgIGxldCB5ID0gMDtcbiAgICAgIGNvbnN0IHogPSAwO1xuXG4gICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHggPSBydGwgPyAtdHJhbnNsYXRlIDogdHJhbnNsYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHRyYW5zbGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHtcbiAgICAgICAgeCA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgIHkgPSBNYXRoLmZsb29yKHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgd3JhcHBlckVsW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IC14IDogLXk7XG4gICAgICB9IGVsc2UgaWYgKCFwYXJhbXMudmlydHVhbFRyYW5zbGF0ZSkge1xuICAgICAgICAkd3JhcHBlckVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsICR7en1weClgKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLnByZXZpb3VzVHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICAgIHN3aXBlci50cmFuc2xhdGUgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB4IDogeTsgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byB1cGRhdGUgcHJvZ3Jlc3NcblxuICAgICAgbGV0IG5ld1Byb2dyZXNzO1xuICAgICAgY29uc3QgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG5cbiAgICAgIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgICAgICBuZXdQcm9ncmVzcyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdQcm9ncmVzcyA9ICh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIC8gdHJhbnNsYXRlc0RpZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdQcm9ncmVzcyAhPT0gcHJvZ3Jlc3MpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHRyYW5zbGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KCdzZXRUcmFuc2xhdGUnLCBzd2lwZXIudHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1pblRyYW5zbGF0ZSgpIHtcbiAgICAgIHJldHVybiAtdGhpcy5zbmFwR3JpZFswXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXhUcmFuc2xhdGUoKSB7XG4gICAgICByZXR1cm4gLXRoaXMuc25hcEdyaWRbdGhpcy5zbmFwR3JpZC5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVUbyh0cmFuc2xhdGUsIHNwZWVkLCBydW5DYWxsYmFja3MsIHRyYW5zbGF0ZUJvdW5kcywgaW50ZXJuYWwpIHtcbiAgICAgIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICB0cmFuc2xhdGUgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlZWQgPT09IHZvaWQgMCkge1xuICAgICAgICBzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkO1xuICAgICAgfVxuXG4gICAgICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICAgICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zbGF0ZUJvdW5kcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRyYW5zbGF0ZUJvdW5kcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgd3JhcHBlckVsXG4gICAgICB9ID0gc3dpcGVyO1xuXG4gICAgICBpZiAoc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWluVHJhbnNsYXRlID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgY29uc3QgbWF4VHJhbnNsYXRlID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICAgICAgbGV0IG5ld1RyYW5zbGF0ZTtcbiAgICAgIGlmICh0cmFuc2xhdGVCb3VuZHMgJiYgdHJhbnNsYXRlID4gbWluVHJhbnNsYXRlKSBuZXdUcmFuc2xhdGUgPSBtaW5UcmFuc2xhdGU7ZWxzZSBpZiAodHJhbnNsYXRlQm91bmRzICYmIHRyYW5zbGF0ZSA8IG1heFRyYW5zbGF0ZSkgbmV3VHJhbnNsYXRlID0gbWF4VHJhbnNsYXRlO2Vsc2UgbmV3VHJhbnNsYXRlID0gdHJhbnNsYXRlOyAvLyBVcGRhdGUgcHJvZ3Jlc3NcblxuICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKG5ld1RyYW5zbGF0ZSk7XG5cbiAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICBjb25zdCBpc0ggPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XG5cbiAgICAgICAgaWYgKHNwZWVkID09PSAwKSB7XG4gICAgICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IC1uZXdUcmFuc2xhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzd2lwZXIuc3VwcG9ydC5zbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgICAgIGFuaW1hdGVDU1NNb2RlU2Nyb2xsKHtcbiAgICAgICAgICAgICAgc3dpcGVyLFxuICAgICAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogLW5ld1RyYW5zbGF0ZSxcbiAgICAgICAgICAgICAgc2lkZTogaXNIID8gJ2xlZnQnIDogJ3RvcCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgICAgICAgIFtpc0ggPyAnbGVmdCcgOiAndG9wJ106IC1uZXdUcmFuc2xhdGUsXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcblxuICAgICAgICBpZiAocnVuQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIHNwZWVkLCBpbnRlcm5hbCk7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25FbmQnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1RyYW5zbGF0ZSk7XG5cbiAgICAgICAgaWYgKHJ1bkNhbGxiYWNrcykge1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uU3RhcnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSB7XG4gICAgICAgICAgICBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gdHJhbnNpdGlvbkVuZChlKSB7XG4gICAgICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgICBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgZGVsZXRlIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQ7XG5cbiAgICAgICAgICAgICAgaWYgKHJ1bkNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uRW5kJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgZ2V0VHJhbnNsYXRlOiBnZXRTd2lwZXJUcmFuc2xhdGUsXG4gICAgICBzZXRUcmFuc2xhdGUsXG4gICAgICBtaW5UcmFuc2xhdGUsXG4gICAgICBtYXhUcmFuc2xhdGUsXG4gICAgICB0cmFuc2xhdGVUb1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIHN3aXBlci4kd3JhcHBlckVsLnRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNpdGlvbicsIGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25FbWl0KF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgcnVuQ2FsbGJhY2tzLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHN0ZXBcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgcHJldmlvdXNJbmRleFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGxldCBkaXIgPSBkaXJlY3Rpb247XG5cbiAgICAgIGlmICghZGlyKSB7XG4gICAgICAgIGlmIChhY3RpdmVJbmRleCA+IHByZXZpb3VzSW5kZXgpIGRpciA9ICduZXh0JztlbHNlIGlmIChhY3RpdmVJbmRleCA8IHByZXZpb3VzSW5kZXgpIGRpciA9ICdwcmV2JztlbHNlIGRpciA9ICdyZXNldCc7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KGB0cmFuc2l0aW9uJHtzdGVwfWApO1xuXG4gICAgICBpZiAocnVuQ2FsbGJhY2tzICYmIGFjdGl2ZUluZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIGlmIChkaXIgPT09ICdyZXNldCcpIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdChgc2xpZGVSZXNldFRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmVtaXQoYHNsaWRlQ2hhbmdlVHJhbnNpdGlvbiR7c3RlcH1gKTtcblxuICAgICAgICBpZiAoZGlyID09PSAnbmV4dCcpIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdChgc2xpZGVOZXh0VHJhbnNpdGlvbiR7c3RlcH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdChgc2xpZGVQcmV2VHJhbnNpdGlvbiR7c3RlcH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtc1xuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuXG4gICAgICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbkVtaXQoe1xuICAgICAgICBzd2lwZXIsXG4gICAgICAgIHJ1bkNhbGxiYWNrcyxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBzdGVwOiAnU3RhcnQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kJDEocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pIHtcbiAgICAgIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgICAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBzd2lwZXIuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHJldHVybjtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuICAgICAgdHJhbnNpdGlvbkVtaXQoe1xuICAgICAgICBzd2lwZXIsXG4gICAgICAgIHJ1bkNhbGxiYWNrcyxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBzdGVwOiAnRW5kJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb24kMSA9IHtcbiAgICAgIHNldFRyYW5zaXRpb24sXG4gICAgICB0cmFuc2l0aW9uU3RhcnQsXG4gICAgICB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kJDFcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2xpZGVUbyhpbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwsIGluaXRpYWwpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWVkID09PSB2b2lkIDApIHtcbiAgICAgICAgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInICYmIHR5cGVvZiBpbmRleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2luZGV4JyBhcmd1bWVudCBjYW5ub3QgaGF2ZSB0eXBlIG90aGVyIHRoYW4gJ251bWJlcicgb3IgJ3N0cmluZycuIFske3R5cGVvZiBpbmRleH1dIGdpdmVuLmApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBpbmRleGAgYXJndW1lbnQgY29udmVydGVkIGZyb20gYHN0cmluZ2AgdG8gYG51bWJlcmAuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpbmRleEFzTnVtYmVyID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYGluZGV4YCBhcmd1bWVudCBpcyBhIHZhbGlkIGBudW1iZXJgXG4gICAgICAgICAqIGFmdGVyIGJlaW5nIGNvbnZlcnRlZCBmcm9tIHRoZSBgc3RyaW5nYCB0eXBlLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICAgICAgY29uc3QgaXNWYWxpZE51bWJlciA9IGlzRmluaXRlKGluZGV4QXNOdW1iZXIpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZE51bWJlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHBhc3NlZC1pbiAnaW5kZXgnIChzdHJpbmcpIGNvdWxkbid0IGJlIGNvbnZlcnRlZCB0byAnbnVtYmVyJy4gWyR7aW5kZXh9XSBnaXZlbi5gKTtcbiAgICAgICAgfSAvLyBLbm93aW5nIHRoYXQgdGhlIGNvbnZlcnRlZCBgaW5kZXhgIGlzIGEgdmFsaWQgbnVtYmVyLFxuICAgICAgICAvLyB3ZSBjYW4gdXBkYXRlIHRoZSBvcmlnaW5hbCBhcmd1bWVudCdzIHZhbHVlLlxuXG5cbiAgICAgICAgaW5kZXggPSBpbmRleEFzTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgbGV0IHNsaWRlSW5kZXggPSBpbmRleDtcbiAgICAgIGlmIChzbGlkZUluZGV4IDwgMCkgc2xpZGVJbmRleCA9IDA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgc25hcEdyaWQsXG4gICAgICAgIHNsaWRlc0dyaWQsXG4gICAgICAgIHByZXZpb3VzSW5kZXgsXG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICAgICAgd3JhcHBlckVsLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9ID0gc3dpcGVyO1xuXG4gICAgICBpZiAoc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uIHx8ICFlbmFibGVkICYmICFpbnRlcm5hbCAmJiAhaW5pdGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNraXAgPSBNYXRoLm1pbihzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgc2xpZGVJbmRleCk7XG4gICAgICBsZXQgc25hcEluZGV4ID0gc2tpcCArIE1hdGguZmxvb3IoKHNsaWRlSW5kZXggLSBza2lwKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgaWYgKHNuYXBJbmRleCA+PSBzbmFwR3JpZC5sZW5ndGgpIHNuYXBJbmRleCA9IHNuYXBHcmlkLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmICgoYWN0aXZlSW5kZXggfHwgcGFyYW1zLmluaXRpYWxTbGlkZSB8fCAwKSA9PT0gKHByZXZpb3VzSW5kZXggfHwgMCkgJiYgcnVuQ2FsbGJhY2tzKSB7XG4gICAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVTbGlkZUNoYW5nZVN0YXJ0Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IC1zbmFwR3JpZFtzbmFwSW5kZXhdOyAvLyBVcGRhdGUgcHJvZ3Jlc3NcblxuICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHRyYW5zbGF0ZSk7IC8vIE5vcm1hbGl6ZSBzbGlkZUluZGV4XG5cbiAgICAgIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkVHJhbnNsYXRlID0gLU1hdGguZmxvb3IodHJhbnNsYXRlICogMTAwKTtcbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkR3JpZCA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZFtpXSAqIDEwMCk7XG4gICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEdyaWROZXh0ID0gTWF0aC5mbG9vcihzbGlkZXNHcmlkW2kgKyAxXSAqIDEwMCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNsaWRlc0dyaWRbaSArIDFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRUcmFuc2xhdGUgPj0gbm9ybWFsaXplZEdyaWQgJiYgbm9ybWFsaXplZFRyYW5zbGF0ZSA8IG5vcm1hbGl6ZWRHcmlkTmV4dCAtIChub3JtYWxpemVkR3JpZE5leHQgLSBub3JtYWxpemVkR3JpZCkgLyAyKSB7XG4gICAgICAgICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHcmlkICYmIG5vcm1hbGl6ZWRUcmFuc2xhdGUgPCBub3JtYWxpemVkR3JpZE5leHQpIHtcbiAgICAgICAgICAgICAgc2xpZGVJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZFRyYW5zbGF0ZSA+PSBub3JtYWxpemVkR3JpZCkge1xuICAgICAgICAgICAgc2xpZGVJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIERpcmVjdGlvbnMgbG9ja3NcblxuXG4gICAgICBpZiAoc3dpcGVyLmluaXRpYWxpemVkICYmIHNsaWRlSW5kZXggIT09IGFjdGl2ZUluZGV4KSB7XG4gICAgICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmIHRyYW5zbGF0ZSA8IHN3aXBlci50cmFuc2xhdGUgJiYgdHJhbnNsYXRlIDwgc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgdHJhbnNsYXRlID4gc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPiBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgICAgICBpZiAoKGFjdGl2ZUluZGV4IHx8IDApICE9PSBzbGlkZUluZGV4KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGRpcmVjdGlvbjtcbiAgICAgIGlmIChzbGlkZUluZGV4ID4gYWN0aXZlSW5kZXgpIGRpcmVjdGlvbiA9ICduZXh0JztlbHNlIGlmIChzbGlkZUluZGV4IDwgYWN0aXZlSW5kZXgpIGRpcmVjdGlvbiA9ICdwcmV2JztlbHNlIGRpcmVjdGlvbiA9ICdyZXNldCc7IC8vIFVwZGF0ZSBJbmRleFxuXG4gICAgICBpZiAocnRsICYmIC10cmFuc2xhdGUgPT09IHN3aXBlci50cmFuc2xhdGUgfHwgIXJ0bCAmJiB0cmFuc2xhdGUgPT09IHN3aXBlci50cmFuc2xhdGUpIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpOyAvLyBVcGRhdGUgSGVpZ2h0XG5cbiAgICAgICAgaWYgKHBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZUF1dG9IZWlnaHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5lZmZlY3QgIT09ICdzbGlkZScpIHtcbiAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAncmVzZXQnKSB7XG4gICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgY29uc3QgaXNIID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICBjb25zdCB0ID0gcnRsID8gdHJhbnNsYXRlIDogLXRyYW5zbGF0ZTtcblxuICAgICAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcblxuICAgICAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSAnbm9uZSc7XG4gICAgICAgICAgICBzd2lwZXIuX2ltbWVkaWF0ZVZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdyYXBwZXJFbFtpc0ggPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10gPSB0O1xuXG4gICAgICAgICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICcnO1xuICAgICAgICAgICAgICBzd2lwZXIuX3N3aXBlckltbWVkaWF0ZVZpcnR1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXN3aXBlci5zdXBwb3J0LnNtb290aFNjcm9sbCkge1xuICAgICAgICAgICAgYW5pbWF0ZUNTU01vZGVTY3JvbGwoe1xuICAgICAgICAgICAgICBzd2lwZXIsXG4gICAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uOiB0LFxuICAgICAgICAgICAgICBzaWRlOiBpc0ggPyAnbGVmdCcgOiAndG9wJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgW2lzSCA/ICdsZWZ0JyA6ICd0b3AnXTogdCxcbiAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHNwZWVkKTtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleChzbGlkZUluZGV4KTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcbiAgICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuXG4gICAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkge1xuICAgICAgICAgIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoZSkge1xuICAgICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgICAgIGRlbGV0ZSBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQ7XG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2xpZGVUb0xvb3AoaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgICAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBpbmRleGAgYXJndW1lbnQgY29udmVydGVkIGZyb20gYHN0cmluZ2AgdG8gYG51bWJlcmAuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpbmRleEFzTnVtYmVyID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYGluZGV4YCBhcmd1bWVudCBpcyBhIHZhbGlkIGBudW1iZXJgXG4gICAgICAgICAqIGFmdGVyIGJlaW5nIGNvbnZlcnRlZCBmcm9tIHRoZSBgc3RyaW5nYCB0eXBlLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICAgICAgY29uc3QgaXNWYWxpZE51bWJlciA9IGlzRmluaXRlKGluZGV4QXNOdW1iZXIpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZE51bWJlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHBhc3NlZC1pbiAnaW5kZXgnIChzdHJpbmcpIGNvdWxkbid0IGJlIGNvbnZlcnRlZCB0byAnbnVtYmVyJy4gWyR7aW5kZXh9XSBnaXZlbi5gKTtcbiAgICAgICAgfSAvLyBLbm93aW5nIHRoYXQgdGhlIGNvbnZlcnRlZCBgaW5kZXhgIGlzIGEgdmFsaWQgbnVtYmVyLFxuICAgICAgICAvLyB3ZSBjYW4gdXBkYXRlIHRoZSBvcmlnaW5hbCBhcmd1bWVudCdzIHZhbHVlLlxuXG5cbiAgICAgICAgaW5kZXggPSBpbmRleEFzTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgbGV0IG5ld0luZGV4ID0gaW5kZXg7XG5cbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgbmV3SW5kZXggKz0gc3dpcGVyLmxvb3BlZFNsaWRlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKG5ld0luZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gICAgfVxuXG4gICAgLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG4gICAgZnVuY3Rpb24gc2xpZGVOZXh0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gICAgICBpZiAoc3BlZWQgPT09IHZvaWQgMCkge1xuICAgICAgICBzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkO1xuICAgICAgfVxuXG4gICAgICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICAgICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYW5pbWF0aW5nLFxuICAgICAgICBlbmFibGVkLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBpZiAoIWVuYWJsZWQpIHJldHVybiBzd2lwZXI7XG4gICAgICBsZXQgcGVyR3JvdXAgPSBwYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG5cbiAgICAgIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXBBdXRvKSB7XG4gICAgICAgIHBlckdyb3VwID0gTWF0aC5tYXgoc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCdjdXJyZW50JywgdHJ1ZSksIDEpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmNyZW1lbnQgPSBzd2lwZXIuYWN0aXZlSW5kZXggPCBwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwID8gMSA6IHBlckdyb3VwO1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgaWYgKGFuaW1hdGluZyAmJiBwYXJhbXMubG9vcFByZXZlbnRzU2xpZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgICAgICAgc3dpcGVyLl9jbGllbnRMZWZ0ID0gc3dpcGVyLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5yZXdpbmQgJiYgc3dpcGVyLmlzRW5kKSB7XG4gICAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbygwLCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBpbmNyZW1lbnQsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbiAgICBmdW5jdGlvbiBzbGlkZVByZXYoc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpIHtcbiAgICAgIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgICAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGFuaW1hdGluZyxcbiAgICAgICAgc25hcEdyaWQsXG4gICAgICAgIHNsaWRlc0dyaWQsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZSxcbiAgICAgICAgZW5hYmxlZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIHN3aXBlcjtcblxuICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgIGlmIChhbmltYXRpbmcgJiYgcGFyYW1zLmxvb3BQcmV2ZW50c1NsaWRlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN3aXBlci5sb29wRml4KCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gICAgICAgIHN3aXBlci5fY2xpZW50TGVmdCA9IHN3aXBlci4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcblxuICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKHZhbCkge1xuICAgICAgICBpZiAodmFsIDwgMCkgcmV0dXJuIC1NYXRoLmZsb29yKE1hdGguYWJzKHZhbCkpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWwpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub3JtYWxpemVkVHJhbnNsYXRlID0gbm9ybWFsaXplKHRyYW5zbGF0ZSk7XG4gICAgICBjb25zdCBub3JtYWxpemVkU25hcEdyaWQgPSBzbmFwR3JpZC5tYXAodmFsID0+IG5vcm1hbGl6ZSh2YWwpKTtcbiAgICAgIGxldCBwcmV2U25hcCA9IHNuYXBHcmlkW25vcm1hbGl6ZWRTbmFwR3JpZC5pbmRleE9mKG5vcm1hbGl6ZWRUcmFuc2xhdGUpIC0gMV07XG5cbiAgICAgIGlmICh0eXBlb2YgcHJldlNuYXAgPT09ICd1bmRlZmluZWQnICYmIHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIGxldCBwcmV2U25hcEluZGV4O1xuICAgICAgICBzbmFwR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAobm9ybWFsaXplZFRyYW5zbGF0ZSA+PSBzbmFwKSB7XG4gICAgICAgICAgICAvLyBwcmV2U25hcCA9IHNuYXA7XG4gICAgICAgICAgICBwcmV2U25hcEluZGV4ID0gc25hcEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmV2U25hcEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHByZXZTbmFwID0gc25hcEdyaWRbcHJldlNuYXBJbmRleCA+IDAgPyBwcmV2U25hcEluZGV4IC0gMSA6IHByZXZTbmFwSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBwcmV2SW5kZXggPSAwO1xuXG4gICAgICBpZiAodHlwZW9mIHByZXZTbmFwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcmV2SW5kZXggPSBzbGlkZXNHcmlkLmluZGV4T2YocHJldlNuYXApO1xuICAgICAgICBpZiAocHJldkluZGV4IDwgMCkgcHJldkluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4IC0gMTtcblxuICAgICAgICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDEgJiYgcGFyYW1zLnNsaWRlc1Blckdyb3VwQXV0bykge1xuICAgICAgICAgIHByZXZJbmRleCA9IHByZXZJbmRleCAtIHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygncHJldmlvdXMnLCB0cnVlKSArIDE7XG4gICAgICAgICAgcHJldkluZGV4ID0gTWF0aC5tYXgocHJldkluZGV4LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnJld2luZCAmJiBzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gc3dpcGVyLnBhcmFtcy52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHN3aXBlci52aXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCAtIDEgOiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbyhsYXN0SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHByZXZJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICAgIH1cblxuICAgIC8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuICAgIGZ1bmN0aW9uIHNsaWRlUmVzZXQoc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpIHtcbiAgICAgIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgICAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICAgIH1cblxuICAgIC8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuICAgIGZ1bmN0aW9uIHNsaWRlVG9DbG9zZXN0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsLCB0aHJlc2hvbGQpIHtcbiAgICAgIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgICAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyZXNob2xkID0gMC41O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgbGV0IGluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICAgICAgY29uc3Qgc2tpcCA9IE1hdGgubWluKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBpbmRleCk7XG4gICAgICBjb25zdCBzbmFwSW5kZXggPSBza2lwICsgTWF0aC5mbG9vcigoaW5kZXggLSBza2lwKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcblxuICAgICAgaWYgKHRyYW5zbGF0ZSA+PSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XSkge1xuICAgICAgICAvLyBUaGUgY3VycmVudCB0cmFuc2xhdGUgaXMgb24gb3IgYWZ0ZXIgdGhlIGN1cnJlbnQgc25hcCBpbmRleCwgc28gdGhlIGNob2ljZVxuICAgICAgICAvLyBpcyBiZXR3ZWVuIHRoZSBjdXJyZW50IGluZGV4IGFuZCB0aGUgb25lIGFmdGVyIGl0LlxuICAgICAgICBjb25zdCBjdXJyZW50U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXhdO1xuICAgICAgICBjb25zdCBuZXh0U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXggKyAxXTtcblxuICAgICAgICBpZiAodHJhbnNsYXRlIC0gY3VycmVudFNuYXAgPiAobmV4dFNuYXAgLSBjdXJyZW50U25hcCkgKiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBpbmRleCArPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgY3VycmVudCB0cmFuc2xhdGUgaXMgYmVmb3JlIHRoZSBjdXJyZW50IHNuYXAgaW5kZXgsIHNvIHRoZSBjaG9pY2VcbiAgICAgICAgLy8gaXMgYmV0d2VlbiB0aGUgY3VycmVudCBpbmRleCBhbmQgdGhlIG9uZSBiZWZvcmUgaXQuXG4gICAgICAgIGNvbnN0IHByZXZTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleCAtIDFdO1xuICAgICAgICBjb25zdCBjdXJyZW50U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXhdO1xuXG4gICAgICAgIGlmICh0cmFuc2xhdGUgLSBwcmV2U25hcCA8PSAoY3VycmVudFNuYXAgLSBwcmV2U25hcCkgKiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBpbmRleCAtPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoaW5kZXgsIDApO1xuICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgc3dpcGVyLnNsaWRlc0dyaWQubGVuZ3RoIC0gMSk7XG4gICAgICByZXR1cm4gc3dpcGVyLnNsaWRlVG8oaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbGlkZVRvQ2xpY2tlZFNsaWRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAkd3JhcHBlckVsXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgY29uc3Qgc2xpZGVzUGVyVmlldyA9IHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgPyBzd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoKSA6IHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgbGV0IHNsaWRlVG9JbmRleCA9IHN3aXBlci5jbGlja2VkSW5kZXg7XG4gICAgICBsZXQgcmVhbEluZGV4O1xuXG4gICAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgICAgaWYgKHN3aXBlci5hbmltYXRpbmcpIHJldHVybjtcbiAgICAgICAgcmVhbEluZGV4ID0gcGFyc2VJbnQoJChzd2lwZXIuY2xpY2tlZFNsaWRlKS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgIGlmIChzbGlkZVRvSW5kZXggPCBzd2lwZXIubG9vcGVkU2xpZGVzIC0gc2xpZGVzUGVyVmlldyAvIDIgfHwgc2xpZGVUb0luZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGggLSBzd2lwZXIubG9vcGVkU2xpZGVzICsgc2xpZGVzUGVyVmlldyAvIDIpIHtcbiAgICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICAgICAgICBzbGlkZVRvSW5kZXggPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl06bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlgKS5lcSgwKS5pbmRleCgpO1xuICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNsaWRlVG9JbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc2xpZGVzUGVyVmlldykge1xuICAgICAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICAgICAgc2xpZGVUb0luZGV4ID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyZWFsSW5kZXh9XCJdOm5vdCguJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pYCkuZXEoMCkuaW5kZXgoKTtcbiAgICAgICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsaWRlID0ge1xuICAgICAgc2xpZGVUbyxcbiAgICAgIHNsaWRlVG9Mb29wLFxuICAgICAgc2xpZGVOZXh0LFxuICAgICAgc2xpZGVQcmV2LFxuICAgICAgc2xpZGVSZXNldCxcbiAgICAgIHNsaWRlVG9DbG9zZXN0LFxuICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb29wQ3JlYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAkd3JhcHBlckVsXG4gICAgICB9ID0gc3dpcGVyOyAvLyBSZW1vdmUgZHVwbGljYXRlZCBzbGlkZXNcblxuICAgICAgY29uc3QgJHNlbGVjdG9yID0gJHdyYXBwZXJFbC5jaGlsZHJlbigpLmxlbmd0aCA+IDAgPyAkKCR3cmFwcGVyRWwuY2hpbGRyZW4oKVswXS5wYXJlbnROb2RlKSA6ICR3cmFwcGVyRWw7XG4gICAgICAkc2VsZWN0b3IuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfS4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfWApLnJlbW92ZSgpO1xuICAgICAgbGV0IHNsaWRlcyA9ICRzZWxlY3Rvci5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YCk7XG5cbiAgICAgIGlmIChwYXJhbXMubG9vcEZpbGxHcm91cFdpdGhCbGFuaykge1xuICAgICAgICBjb25zdCBibGFua1NsaWRlc051bSA9IHBhcmFtcy5zbGlkZXNQZXJHcm91cCAtIHNsaWRlcy5sZW5ndGggJSBwYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG5cbiAgICAgICAgaWYgKGJsYW5rU2xpZGVzTnVtICE9PSBwYXJhbXMuc2xpZGVzUGVyR3JvdXApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsYW5rU2xpZGVzTnVtOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsYW5rTm9kZSA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpLmFkZENsYXNzKGAke3BhcmFtcy5zbGlkZUNsYXNzfSAke3BhcmFtcy5zbGlkZUJsYW5rQ2xhc3N9YCk7XG4gICAgICAgICAgICAkc2VsZWN0b3IuYXBwZW5kKGJsYW5rTm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2xpZGVzID0gJHNlbGVjdG9yLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiAhcGFyYW1zLmxvb3BlZFNsaWRlcykgcGFyYW1zLmxvb3BlZFNsaWRlcyA9IHNsaWRlcy5sZW5ndGg7XG4gICAgICBzd2lwZXIubG9vcGVkU2xpZGVzID0gTWF0aC5jZWlsKHBhcnNlRmxvYXQocGFyYW1zLmxvb3BlZFNsaWRlcyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldywgMTApKTtcbiAgICAgIHN3aXBlci5sb29wZWRTbGlkZXMgKz0gcGFyYW1zLmxvb3BBZGRpdGlvbmFsU2xpZGVzO1xuXG4gICAgICBpZiAoc3dpcGVyLmxvb3BlZFNsaWRlcyA+IHNsaWRlcy5sZW5ndGggJiYgc3dpcGVyLnBhcmFtcy5sb29wZWRTbGlkZXNMaW1pdCkge1xuICAgICAgICBzd2lwZXIubG9vcGVkU2xpZGVzID0gc2xpZGVzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJlcGVuZFNsaWRlcyA9IFtdO1xuICAgICAgY29uc3QgYXBwZW5kU2xpZGVzID0gW107XG4gICAgICBzbGlkZXMuZWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICAgICQoZWwpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JywgaW5kZXgpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLmxvb3BlZFNsaWRlczsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaSAtIE1hdGguZmxvb3IoaSAvIHNsaWRlcy5sZW5ndGgpICogc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgYXBwZW5kU2xpZGVzLnB1c2goc2xpZGVzLmVxKGluZGV4KVswXSk7XG4gICAgICAgIHByZXBlbmRTbGlkZXMudW5zaGlmdChzbGlkZXMuZXEoc2xpZGVzLmxlbmd0aCAtIGluZGV4IC0gMSlbMF0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFwcGVuZFNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAkc2VsZWN0b3IuYXBwZW5kKCQoYXBwZW5kU2xpZGVzW2ldLmNsb25lTm9kZSh0cnVlKSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IHByZXBlbmRTbGlkZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgJHNlbGVjdG9yLnByZXBlbmQoJChwcmVwZW5kU2xpZGVzW2ldLmNsb25lTm9kZSh0cnVlKSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29wRml4KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVMb29wRml4Jyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICBzbGlkZXMsXG4gICAgICAgIGxvb3BlZFNsaWRlcyxcbiAgICAgICAgYWxsb3dTbGlkZVByZXYsXG4gICAgICAgIGFsbG93U2xpZGVOZXh0LFxuICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgcnRsVHJhbnNsYXRlOiBydGxcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBsZXQgbmV3SW5kZXg7XG4gICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSB0cnVlO1xuICAgICAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHNuYXBUcmFuc2xhdGUgPSAtc25hcEdyaWRbYWN0aXZlSW5kZXhdO1xuICAgICAgY29uc3QgZGlmZiA9IHNuYXBUcmFuc2xhdGUgLSBzd2lwZXIuZ2V0VHJhbnNsYXRlKCk7IC8vIEZpeCBGb3IgTmVnYXRpdmUgT3ZlcnNsaWRpbmdcblxuICAgICAgaWYgKGFjdGl2ZUluZGV4IDwgbG9vcGVkU2xpZGVzKSB7XG4gICAgICAgIG5ld0luZGV4ID0gc2xpZGVzLmxlbmd0aCAtIGxvb3BlZFNsaWRlcyAqIDMgKyBhY3RpdmVJbmRleDtcbiAgICAgICAgbmV3SW5kZXggKz0gbG9vcGVkU2xpZGVzO1xuICAgICAgICBjb25zdCBzbGlkZUNoYW5nZWQgPSBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIGlmIChzbGlkZUNoYW5nZWQgJiYgZGlmZiAhPT0gMCkge1xuICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoKHJ0bCA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZSkgLSBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhY3RpdmVJbmRleCA+PSBzbGlkZXMubGVuZ3RoIC0gbG9vcGVkU2xpZGVzKSB7XG4gICAgICAgIC8vIEZpeCBGb3IgUG9zaXRpdmUgT3ZlcnNsaWRpbmdcbiAgICAgICAgbmV3SW5kZXggPSAtc2xpZGVzLmxlbmd0aCArIGFjdGl2ZUluZGV4ICsgbG9vcGVkU2xpZGVzO1xuICAgICAgICBuZXdJbmRleCArPSBsb29wZWRTbGlkZXM7XG4gICAgICAgIGNvbnN0IHNsaWRlQ2hhbmdlZCA9IHN3aXBlci5zbGlkZVRvKG5ld0luZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNsaWRlQ2hhbmdlZCAmJiBkaWZmICE9PSAwKSB7XG4gICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZSgocnRsID8gLXN3aXBlci50cmFuc2xhdGUgOiBzd2lwZXIudHJhbnNsYXRlKSAtIGRpZmYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xuICAgICAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gYWxsb3dTbGlkZU5leHQ7XG4gICAgICBzd2lwZXIuZW1pdCgnbG9vcEZpeCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BEZXN0cm95KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgJHdyYXBwZXJFbCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBzbGlkZXNcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30sLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlQmxhbmtDbGFzc31gKS5yZW1vdmUoKTtcbiAgICAgIHNsaWRlcy5yZW1vdmVBdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xuICAgIH1cblxuICAgIHZhciBsb29wID0ge1xuICAgICAgbG9vcENyZWF0ZSxcbiAgICAgIGxvb3BGaXgsXG4gICAgICBsb29wRGVzdHJveVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRHcmFiQ3Vyc29yKG1vdmluZykge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIuc3VwcG9ydC50b3VjaCB8fCAhc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoIHx8IHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSByZXR1cm47XG4gICAgICBjb25zdCBlbCA9IHN3aXBlci5wYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICdjb250YWluZXInID8gc3dpcGVyLmVsIDogc3dpcGVyLndyYXBwZXJFbDtcbiAgICAgIGVsLnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcbiAgICAgIGVsLnN0eWxlLmN1cnNvciA9IG1vdmluZyA/ICdncmFiYmluZycgOiAnZ3JhYic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5zZXRHcmFiQ3Vyc29yKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcblxuICAgICAgaWYgKHN3aXBlci5zdXBwb3J0LnRvdWNoIHx8IHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyW3N3aXBlci5wYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICdjb250YWluZXInID8gJ2VsJyA6ICd3cmFwcGVyRWwnXS5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICB9XG5cbiAgICB2YXIgZ3JhYkN1cnNvciA9IHtcbiAgICAgIHNldEdyYWJDdXJzb3IsXG4gICAgICB1bnNldEdyYWJDdXJzb3JcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnQoc2VsZWN0b3IsIGJhc2UpIHtcbiAgICAgIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgYmFzZSA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF9fY2xvc2VzdEZyb20oZWwpIHtcbiAgICAgICAgaWYgKCFlbCB8fCBlbCA9PT0gZ2V0RG9jdW1lbnQoKSB8fCBlbCA9PT0gZ2V0V2luZG93KCkpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZWwuYXNzaWduZWRTbG90KSBlbCA9IGVsLmFzc2lnbmVkU2xvdDtcbiAgICAgICAgY29uc3QgZm91bmQgPSBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcblxuICAgICAgICBpZiAoIWZvdW5kICYmICFlbC5nZXRSb290Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kIHx8IF9fY2xvc2VzdEZyb20oZWwuZ2V0Um9vdE5vZGUoKS5ob3N0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9fY2xvc2VzdEZyb20oYmFzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBjb25zdCBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB0b3VjaGVzLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG5cbiAgICAgIGlmIChzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLmNzc01vZGUgJiYgcGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGUgPSBldmVudDtcbiAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICBsZXQgJHRhcmdldEVsID0gJChlLnRhcmdldCk7XG5cbiAgICAgIGlmIChwYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICd3cmFwcGVyJykge1xuICAgICAgICBpZiAoISR0YXJnZXRFbC5jbG9zZXN0KHN3aXBlci53cmFwcGVyRWwpLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmlzVG91Y2hFdmVudCA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnO1xuICAgICAgaWYgKCFkYXRhLmlzVG91Y2hFdmVudCAmJiAnd2hpY2gnIGluIGUgJiYgZS53aGljaCA9PT0gMykgcmV0dXJuO1xuICAgICAgaWYgKCFkYXRhLmlzVG91Y2hFdmVudCAmJiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uID4gMCkgcmV0dXJuO1xuICAgICAgaWYgKGRhdGEuaXNUb3VjaGVkICYmIGRhdGEuaXNNb3ZlZCkgcmV0dXJuOyAvLyBjaGFuZ2UgdGFyZ2V0IGVsIGZvciBzaGFkb3cgcm9vdCBjb21wb25lbnRcblxuICAgICAgY29uc3Qgc3dpcGluZ0NsYXNzSGFzVmFsdWUgPSAhIXBhcmFtcy5ub1N3aXBpbmdDbGFzcyAmJiBwYXJhbXMubm9Td2lwaW5nQ2xhc3MgIT09ICcnO1xuXG4gICAgICBpZiAoc3dpcGluZ0NsYXNzSGFzVmFsdWUgJiYgZS50YXJnZXQgJiYgZS50YXJnZXQuc2hhZG93Um9vdCAmJiBldmVudC5wYXRoICYmIGV2ZW50LnBhdGhbMF0pIHtcbiAgICAgICAgJHRhcmdldEVsID0gJChldmVudC5wYXRoWzBdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9Td2lwaW5nU2VsZWN0b3IgPSBwYXJhbXMubm9Td2lwaW5nU2VsZWN0b3IgPyBwYXJhbXMubm9Td2lwaW5nU2VsZWN0b3IgOiBgLiR7cGFyYW1zLm5vU3dpcGluZ0NsYXNzfWA7XG4gICAgICBjb25zdCBpc1RhcmdldFNoYWRvdyA9ICEhKGUudGFyZ2V0ICYmIGUudGFyZ2V0LnNoYWRvd1Jvb3QpOyAvLyB1c2UgY2xvc2VzdEVsZW1lbnQgZm9yIHNoYWRvdyByb290IGVsZW1lbnQgdG8gZ2V0IHRoZSBhY3R1YWwgY2xvc2VzdCBmb3IgbmVzdGVkIHNoYWRvdyByb290IGVsZW1lbnRcblxuICAgICAgaWYgKHBhcmFtcy5ub1N3aXBpbmcgJiYgKGlzVGFyZ2V0U2hhZG93ID8gY2xvc2VzdEVsZW1lbnQobm9Td2lwaW5nU2VsZWN0b3IsICR0YXJnZXRFbFswXSkgOiAkdGFyZ2V0RWwuY2xvc2VzdChub1N3aXBpbmdTZWxlY3RvcilbMF0pKSB7XG4gICAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnN3aXBlSGFuZGxlcikge1xuICAgICAgICBpZiAoISR0YXJnZXRFbC5jbG9zZXN0KHBhcmFtcy5zd2lwZUhhbmRsZXIpWzBdKSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRvdWNoZXMuY3VycmVudFggPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICB0b3VjaGVzLmN1cnJlbnRZID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgICAgY29uc3Qgc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgICAgIGNvbnN0IHN0YXJ0WSA9IHRvdWNoZXMuY3VycmVudFk7IC8vIERvIE5PVCBzdGFydCBpZiBpT1MgZWRnZSBzd2lwZSBpcyBkZXRlY3RlZC4gT3RoZXJ3aXNlIGlPUyBhcHAgY2Fubm90IHN3aXBlLXRvLWdvLWJhY2sgYW55bW9yZVxuXG4gICAgICBjb25zdCBlZGdlU3dpcGVEZXRlY3Rpb24gPSBwYXJhbXMuZWRnZVN3aXBlRGV0ZWN0aW9uIHx8IHBhcmFtcy5pT1NFZGdlU3dpcGVEZXRlY3Rpb247XG4gICAgICBjb25zdCBlZGdlU3dpcGVUaHJlc2hvbGQgPSBwYXJhbXMuZWRnZVN3aXBlVGhyZXNob2xkIHx8IHBhcmFtcy5pT1NFZGdlU3dpcGVUaHJlc2hvbGQ7XG5cbiAgICAgIGlmIChlZGdlU3dpcGVEZXRlY3Rpb24gJiYgKHN0YXJ0WCA8PSBlZGdlU3dpcGVUaHJlc2hvbGQgfHwgc3RhcnRYID49IHdpbmRvdy5pbm5lcldpZHRoIC0gZWRnZVN3aXBlVGhyZXNob2xkKSkge1xuICAgICAgICBpZiAoZWRnZVN3aXBlRGV0ZWN0aW9uID09PSAncHJldmVudCcpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgICAgaXNUb3VjaGVkOiB0cnVlLFxuICAgICAgICBpc01vdmVkOiBmYWxzZSxcbiAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdHJ1ZSxcbiAgICAgICAgaXNTY3JvbGxpbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnRNb3Zpbmc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICB0b3VjaGVzLnN0YXJ0WCA9IHN0YXJ0WDtcbiAgICAgIHRvdWNoZXMuc3RhcnRZID0gc3RhcnRZO1xuICAgICAgZGF0YS50b3VjaFN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgc3dpcGVyLmFsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgICAgIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChwYXJhbXMudGhyZXNob2xkID4gMCkgZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUgPSBmYWxzZTtcblxuICAgICAgaWYgKGUudHlwZSAhPT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIGxldCBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCR0YXJnZXRFbC5pcyhkYXRhLmZvY3VzYWJsZUVsZW1lbnRzKSkge1xuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoJHRhcmdldEVsWzBdLm5vZGVOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09ICR0YXJnZXRFbFswXSkge1xuICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2hvdWxkUHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdCAmJiBzd2lwZXIuYWxsb3dUb3VjaE1vdmUgJiYgcGFyYW1zLnRvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdDtcblxuICAgICAgICBpZiAoKHBhcmFtcy50b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdCB8fCBzaG91bGRQcmV2ZW50RGVmYXVsdCkgJiYgISR0YXJnZXRFbFswXS5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBzd2lwZXIucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgc3dpcGVyLmZyZWVNb2RlICYmIHN3aXBlci5hbmltYXRpbmcgJiYgIXBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIHN3aXBlci5mcmVlTW9kZS5vblRvdWNoU3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXQoJ3RvdWNoU3RhcnQnLCBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZShldmVudCkge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHRvdWNoZXMsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgICBsZXQgZSA9IGV2ZW50O1xuICAgICAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcblxuICAgICAgaWYgKCFkYXRhLmlzVG91Y2hlZCkge1xuICAgICAgICBpZiAoZGF0YS5zdGFydE1vdmluZyAmJiBkYXRhLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ3RvdWNoTW92ZU9wcG9zaXRlJywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmlzVG91Y2hFdmVudCAmJiBlLnR5cGUgIT09ICd0b3VjaG1vdmUnKSByZXR1cm47XG4gICAgICBjb25zdCB0YXJnZXRUb3VjaCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZS50YXJnZXRUb3VjaGVzICYmIChlLnRhcmdldFRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICBjb25zdCBwYWdlWCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyB0YXJnZXRUb3VjaC5wYWdlWCA6IGUucGFnZVg7XG4gICAgICBjb25zdCBwYWdlWSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyB0YXJnZXRUb3VjaC5wYWdlWSA6IGUucGFnZVk7XG5cbiAgICAgIGlmIChlLnByZXZlbnRlZEJ5TmVzdGVkU3dpcGVyKSB7XG4gICAgICAgIHRvdWNoZXMuc3RhcnRYID0gcGFnZVg7XG4gICAgICAgIHRvdWNoZXMuc3RhcnRZID0gcGFnZVk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzd2lwZXIuYWxsb3dUb3VjaE1vdmUpIHtcbiAgICAgICAgaWYgKCEkKGUudGFyZ2V0KS5pcyhkYXRhLmZvY3VzYWJsZUVsZW1lbnRzKSkge1xuICAgICAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5pc1RvdWNoZWQpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRvdWNoZXMsIHtcbiAgICAgICAgICAgIHN0YXJ0WDogcGFnZVgsXG4gICAgICAgICAgICBzdGFydFk6IHBhZ2VZLFxuICAgICAgICAgICAgY3VycmVudFg6IHBhZ2VYLFxuICAgICAgICAgICAgY3VycmVudFk6IHBhZ2VZXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGF0YS50b3VjaFN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5pc1RvdWNoRXZlbnQgJiYgcGFyYW1zLnRvdWNoUmVsZWFzZU9uRWRnZXMgJiYgIXBhcmFtcy5sb29wKSB7XG4gICAgICAgIGlmIChzd2lwZXIuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICAgICAgLy8gVmVydGljYWxcbiAgICAgICAgICBpZiAocGFnZVkgPCB0b3VjaGVzLnN0YXJ0WSAmJiBzd2lwZXIudHJhbnNsYXRlIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSB8fCBwYWdlWSA+IHRvdWNoZXMuc3RhcnRZICYmIHN3aXBlci50cmFuc2xhdGUgPj0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgICAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhZ2VYIDwgdG91Y2hlcy5zdGFydFggJiYgc3dpcGVyLnRyYW5zbGF0ZSA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgfHwgcGFnZVggPiB0b3VjaGVzLnN0YXJ0WCAmJiBzd2lwZXIudHJhbnNsYXRlID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5pc1RvdWNoRXZlbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgJChlLnRhcmdldCkuaXMoZGF0YS5mb2N1c2FibGVFbGVtZW50cykpIHtcbiAgICAgICAgICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuICAgICAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmFsbG93VG91Y2hDYWxsYmFja3MpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3RvdWNoTW92ZScsIGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSByZXR1cm47XG4gICAgICB0b3VjaGVzLmN1cnJlbnRYID0gcGFnZVg7XG4gICAgICB0b3VjaGVzLmN1cnJlbnRZID0gcGFnZVk7XG4gICAgICBjb25zdCBkaWZmWCA9IHRvdWNoZXMuY3VycmVudFggLSB0b3VjaGVzLnN0YXJ0WDtcbiAgICAgIGNvbnN0IGRpZmZZID0gdG91Y2hlcy5jdXJyZW50WSAtIHRvdWNoZXMuc3RhcnRZO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMudGhyZXNob2xkICYmIE1hdGguc3FydChkaWZmWCAqKiAyICsgZGlmZlkgKiogMikgPCBzd2lwZXIucGFyYW1zLnRocmVzaG9sZCkgcmV0dXJuO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEuaXNTY3JvbGxpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxldCB0b3VjaEFuZ2xlO1xuXG4gICAgICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgdG91Y2hlcy5jdXJyZW50WSA9PT0gdG91Y2hlcy5zdGFydFkgfHwgc3dpcGVyLmlzVmVydGljYWwoKSAmJiB0b3VjaGVzLmN1cnJlbnRYID09PSB0b3VjaGVzLnN0YXJ0WCkge1xuICAgICAgICAgIGRhdGEuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICBpZiAoZGlmZlggKiBkaWZmWCArIGRpZmZZICogZGlmZlkgPj0gMjUpIHtcbiAgICAgICAgICAgIHRvdWNoQW5nbGUgPSBNYXRoLmF0YW4yKE1hdGguYWJzKGRpZmZZKSwgTWF0aC5hYnMoZGlmZlgpKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgICAgICBkYXRhLmlzU2Nyb2xsaW5nID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gdG91Y2hBbmdsZSA+IHBhcmFtcy50b3VjaEFuZ2xlIDogOTAgLSB0b3VjaEFuZ2xlID4gcGFyYW1zLnRvdWNoQW5nbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmVPcHBvc2l0ZScsIGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRhdGEuc3RhcnRNb3ZpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0b3VjaGVzLmN1cnJlbnRYICE9PSB0b3VjaGVzLnN0YXJ0WCB8fCB0b3VjaGVzLmN1cnJlbnRZICE9PSB0b3VjaGVzLnN0YXJ0WSkge1xuICAgICAgICAgIGRhdGEuc3RhcnRNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhLnN0YXJ0TW92aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcblxuICAgICAgaWYgKCFwYXJhbXMuY3NzTW9kZSAmJiBlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiAmJiAhcGFyYW1zLm5lc3RlZCkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEuaXNNb3ZlZCkge1xuICAgICAgICBpZiAocGFyYW1zLmxvb3AgJiYgIXBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuc3RhcnRUcmFuc2xhdGUgPSBzd2lwZXIuZ2V0VHJhbnNsYXRlKCk7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuXG4gICAgICAgIGlmIChzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWwudHJpZ2dlcignd2Via2l0VHJhbnNpdGlvbkVuZCB0cmFuc2l0aW9uZW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSBmYWxzZTsgLy8gR3JhYiBDdXJzb3JcblxuICAgICAgICBpZiAocGFyYW1zLmdyYWJDdXJzb3IgJiYgKHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9PT0gdHJ1ZSB8fCBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPT09IHRydWUpKSB7XG4gICAgICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnc2xpZGVyRmlyc3RNb3ZlJywgZSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZXJNb3ZlJywgZSk7XG4gICAgICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuICAgICAgbGV0IGRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBkaWZmWCA6IGRpZmZZO1xuICAgICAgdG91Y2hlcy5kaWZmID0gZGlmZjtcbiAgICAgIGRpZmYgKj0gcGFyYW1zLnRvdWNoUmF0aW87XG4gICAgICBpZiAocnRsKSBkaWZmID0gLWRpZmY7XG4gICAgICBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPSBkaWZmID4gMCA/ICdwcmV2JyA6ICduZXh0JztcbiAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRpZmYgKyBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICAgICAgbGV0IGRpc2FibGVQYXJlbnRTd2lwZXIgPSB0cnVlO1xuICAgICAgbGV0IHJlc2lzdGFuY2VSYXRpbyA9IHBhcmFtcy5yZXNpc3RhbmNlUmF0aW87XG5cbiAgICAgIGlmIChwYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcykge1xuICAgICAgICByZXNpc3RhbmNlUmF0aW8gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZiA+IDAgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlID4gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgIGRpc2FibGVQYXJlbnRTd2lwZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmFtcy5yZXNpc3RhbmNlKSBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBzd2lwZXIubWluVHJhbnNsYXRlKCkgLSAxICsgKC1zd2lwZXIubWluVHJhbnNsYXRlKCkgKyBkYXRhLnN0YXJ0VHJhbnNsYXRlICsgZGlmZikgKiogcmVzaXN0YW5jZVJhdGlvO1xuICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPCBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xuICAgICAgICBpZiAocGFyYW1zLnJlc2lzdGFuY2UpIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSArIDEgLSAoc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gZGF0YS5zdGFydFRyYW5zbGF0ZSAtIGRpZmYpICoqIHJlc2lzdGFuY2VSYXRpbztcbiAgICAgIH1cblxuICAgICAgaWYgKGRpc2FibGVQYXJlbnRTd2lwZXIpIHtcbiAgICAgICAgZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciA9IHRydWU7XG4gICAgICB9IC8vIERpcmVjdGlvbnMgbG9ja3NcblxuXG4gICAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlTmV4dCAmJiBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0JyAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPCBkYXRhLnN0YXJ0VHJhbnNsYXRlKSB7XG4gICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA+IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgIXN3aXBlci5hbGxvd1NsaWRlTmV4dCkge1xuICAgICAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICAgICAgfSAvLyBUaHJlc2hvbGRcblxuXG4gICAgICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID4gcGFyYW1zLnRocmVzaG9sZCB8fCBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xuICAgICAgICAgIGlmICghZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUpIHtcbiAgICAgICAgICAgIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRvdWNoZXMuc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgICAgICAgICAgIHRvdWNoZXMuc3RhcnRZID0gdG91Y2hlcy5jdXJyZW50WTtcbiAgICAgICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICAgICAgICB0b3VjaGVzLmRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5zdGFydFggOiB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyYW1zLmZvbGxvd0ZpbmdlciB8fCBwYXJhbXMuY3NzTW9kZSkgcmV0dXJuOyAvLyBVcGRhdGUgYWN0aXZlIGluZGV4IGluIGZyZWUgbW9kZVxuXG4gICAgICBpZiAocGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkICYmIHN3aXBlci5mcmVlTW9kZSB8fCBwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcykge1xuICAgICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgc3dpcGVyLmZyZWVNb2RlKSB7XG4gICAgICAgIHN3aXBlci5mcmVlTW9kZS5vblRvdWNoTW92ZSgpO1xuICAgICAgfSAvLyBVcGRhdGUgcHJvZ3Jlc3NcblxuXG4gICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoZGF0YS5jdXJyZW50VHJhbnNsYXRlKTsgLy8gVXBkYXRlIHRyYW5zbGF0ZVxuXG4gICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKGRhdGEuY3VycmVudFRyYW5zbGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaEVuZChldmVudCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHRvdWNoZXMsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgICAgICBzbGlkZXNHcmlkLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgICBsZXQgZSA9IGV2ZW50O1xuICAgICAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcblxuICAgICAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xuICAgICAgICBzd2lwZXIuZW1pdCgndG91Y2hFbmQnLCBlKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5hbGxvd1RvdWNoQ2FsbGJhY2tzID0gZmFsc2U7XG5cbiAgICAgIGlmICghZGF0YS5pc1RvdWNoZWQpIHtcbiAgICAgICAgaWYgKGRhdGEuaXNNb3ZlZCAmJiBwYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUmV0dXJuIEdyYWIgQ3Vyc29yXG5cblxuICAgICAgaWYgKHBhcmFtcy5ncmFiQ3Vyc29yICYmIGRhdGEuaXNNb3ZlZCAmJiBkYXRhLmlzVG91Y2hlZCAmJiAoc3dpcGVyLmFsbG93U2xpZGVOZXh0ID09PSB0cnVlIHx8IHN3aXBlci5hbGxvd1NsaWRlUHJldiA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoZmFsc2UpO1xuICAgICAgfSAvLyBUaW1lIGRpZmZcblxuXG4gICAgICBjb25zdCB0b3VjaEVuZFRpbWUgPSBub3coKTtcbiAgICAgIGNvbnN0IHRpbWVEaWZmID0gdG91Y2hFbmRUaW1lIC0gZGF0YS50b3VjaFN0YXJ0VGltZTsgLy8gVGFwLCBkb3VibGVUYXAsIENsaWNrXG5cbiAgICAgIGlmIChzd2lwZXIuYWxsb3dDbGljaykge1xuICAgICAgICBjb25zdCBwYXRoVHJlZSA9IGUucGF0aCB8fCBlLmNvbXBvc2VkUGF0aCAmJiBlLmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICBzd2lwZXIudXBkYXRlQ2xpY2tlZFNsaWRlKHBhdGhUcmVlICYmIHBhdGhUcmVlWzBdIHx8IGUudGFyZ2V0KTtcbiAgICAgICAgc3dpcGVyLmVtaXQoJ3RhcCBjbGljaycsIGUpO1xuXG4gICAgICAgIGlmICh0aW1lRGlmZiA8IDMwMCAmJiB0b3VjaEVuZFRpbWUgLSBkYXRhLmxhc3RDbGlja1RpbWUgPCAzMDApIHtcbiAgICAgICAgICBzd2lwZXIuZW1pdCgnZG91YmxlVGFwIGRvdWJsZUNsaWNrJywgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGF0YS5sYXN0Q2xpY2tUaW1lID0gbm93KCk7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLmRlc3Ryb3llZCkgc3dpcGVyLmFsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghZGF0YS5pc1RvdWNoZWQgfHwgIWRhdGEuaXNNb3ZlZCB8fCAhc3dpcGVyLnN3aXBlRGlyZWN0aW9uIHx8IHRvdWNoZXMuZGlmZiA9PT0gMCB8fCBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPT09IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgICAgIGRhdGEuc3RhcnRNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gICAgICBsZXQgY3VycmVudFBvcztcblxuICAgICAgaWYgKHBhcmFtcy5mb2xsb3dGaW5nZXIpIHtcbiAgICAgICAgY3VycmVudFBvcyA9IHJ0bCA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRQb3MgPSAtZGF0YS5jdXJyZW50VHJhbnNsYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuZnJlZU1vZGUub25Ub3VjaEVuZCh7XG4gICAgICAgICAgY3VycmVudFBvc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGaW5kIGN1cnJlbnQgc2xpZGVcblxuXG4gICAgICBsZXQgc3RvcEluZGV4ID0gMDtcbiAgICAgIGxldCBncm91cFNpemUgPSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkWzBdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IGkgPCBwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cCkge1xuICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSBpIDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCAtIDEgPyAxIDogcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2xpZGVzR3JpZFtpICsgaW5jcmVtZW50XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoY3VycmVudFBvcyA+PSBzbGlkZXNHcmlkW2ldICYmIGN1cnJlbnRQb3MgPCBzbGlkZXNHcmlkW2kgKyBpbmNyZW1lbnRdKSB7XG4gICAgICAgICAgICBzdG9wSW5kZXggPSBpO1xuICAgICAgICAgICAgZ3JvdXBTaXplID0gc2xpZGVzR3JpZFtpICsgaW5jcmVtZW50XSAtIHNsaWRlc0dyaWRbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQb3MgPj0gc2xpZGVzR3JpZFtpXSkge1xuICAgICAgICAgIHN0b3BJbmRleCA9IGk7XG4gICAgICAgICAgZ3JvdXBTaXplID0gc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDFdIC0gc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDJdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCByZXdpbmRGaXJzdEluZGV4ID0gbnVsbDtcbiAgICAgIGxldCByZXdpbmRMYXN0SW5kZXggPSBudWxsO1xuXG4gICAgICBpZiAocGFyYW1zLnJld2luZCkge1xuICAgICAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nKSB7XG4gICAgICAgICAgcmV3aW5kTGFzdEluZGV4ID0gc3dpcGVyLnBhcmFtcy52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHN3aXBlci52aXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCAtIDEgOiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLmlzRW5kKSB7XG4gICAgICAgICAgcmV3aW5kRmlyc3RJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRmluZCBjdXJyZW50IHNsaWRlIHNpemVcblxuXG4gICAgICBjb25zdCByYXRpbyA9IChjdXJyZW50UG9zIC0gc2xpZGVzR3JpZFtzdG9wSW5kZXhdKSAvIGdyb3VwU2l6ZTtcbiAgICAgIGNvbnN0IGluY3JlbWVudCA9IHN0b3BJbmRleCA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgLSAxID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcblxuICAgICAgaWYgKHRpbWVEaWZmID4gcGFyYW1zLmxvbmdTd2lwZXNNcykge1xuICAgICAgICAvLyBMb25nIHRvdWNoZXNcbiAgICAgICAgaWYgKCFwYXJhbXMubG9uZ1N3aXBlcykge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgICAgICAgaWYgKHJhdGlvID49IHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHN3aXBlci5zbGlkZVRvKHBhcmFtcy5yZXdpbmQgJiYgc3dpcGVyLmlzRW5kID8gcmV3aW5kRmlyc3RJbmRleCA6IHN0b3BJbmRleCArIGluY3JlbWVudCk7ZWxzZSBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgICAgICAgaWYgKHJhdGlvID4gMSAtIHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIGluY3JlbWVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXdpbmRMYXN0SW5kZXggIT09IG51bGwgJiYgcmF0aW8gPCAwICYmIE1hdGguYWJzKHJhdGlvKSA+IHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHJld2luZExhc3RJbmRleCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaG9ydCBzd2lwZXNcbiAgICAgICAgaWYgKCFwYXJhbXMuc2hvcnRTd2lwZXMpIHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzTmF2QnV0dG9uVGFyZ2V0ID0gc3dpcGVyLm5hdmlnYXRpb24gJiYgKGUudGFyZ2V0ID09PSBzd2lwZXIubmF2aWdhdGlvbi5uZXh0RWwgfHwgZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLnByZXZFbCk7XG5cbiAgICAgICAgaWYgKCFpc05hdkJ1dHRvblRhcmdldCkge1xuICAgICAgICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG8ocmV3aW5kRmlyc3RJbmRleCAhPT0gbnVsbCA/IHJld2luZEZpcnN0SW5kZXggOiBzdG9wSW5kZXggKyBpbmNyZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG8ocmV3aW5kTGFzdEluZGV4ICE9PSBudWxsID8gcmV3aW5kTGFzdEluZGV4IDogc3RvcEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCkge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIGluY3JlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBlbFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmIChlbCAmJiBlbC5vZmZzZXRXaWR0aCA9PT0gMCkgcmV0dXJuOyAvLyBCcmVha3BvaW50c1xuXG4gICAgICBpZiAocGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgICAgIHN3aXBlci5zZXRCcmVha3BvaW50KCk7XG4gICAgICB9IC8vIFNhdmUgbG9ja3NcblxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93U2xpZGVOZXh0LFxuICAgICAgICBhbGxvd1NsaWRlUHJldixcbiAgICAgICAgc25hcEdyaWRcbiAgICAgIH0gPSBzd2lwZXI7IC8vIERpc2FibGUgbG9ja3Mgb24gcmVzaXplXG5cbiAgICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XG4gICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSB0cnVlO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG5cbiAgICAgIGlmICgocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpICYmIHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkgJiYgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkge1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkucnVuKCk7XG4gICAgICB9IC8vIFJldHVybiBsb2NrcyBhZnRlciByZXNpemVcblxuXG4gICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSBhbGxvd1NsaWRlUHJldjtcbiAgICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHNuYXBHcmlkICE9PSBzd2lwZXIuc25hcEdyaWQpIHtcbiAgICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5lbmFibGVkKSByZXR1cm47XG5cbiAgICAgIGlmICghc3dpcGVyLmFsbG93Q2xpY2spIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMucHJldmVudENsaWNrcykgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbiAmJiBzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TY3JvbGwoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3cmFwcGVyRWwsXG4gICAgICAgIHJ0bFRyYW5zbGF0ZSxcbiAgICAgICAgZW5hYmxlZFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgc3dpcGVyLnByZXZpb3VzVHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcblxuICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICBzd2lwZXIudHJhbnNsYXRlID0gLXdyYXBwZXJFbC5zY3JvbGxMZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnRyYW5zbGF0ZSA9IC13cmFwcGVyRWwuc2Nyb2xsVG9wO1xuICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuXG4gICAgICBpZiAoc3dpcGVyLnRyYW5zbGF0ZSA9PT0gMCkgc3dpcGVyLnRyYW5zbGF0ZSA9IDA7XG4gICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICBsZXQgbmV3UHJvZ3Jlc3M7XG4gICAgICBjb25zdCB0cmFuc2xhdGVzRGlmZiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKTtcblxuICAgICAgaWYgKHRyYW5zbGF0ZXNEaWZmID09PSAwKSB7XG4gICAgICAgIG5ld1Byb2dyZXNzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1Byb2dyZXNzID0gKHN3aXBlci50cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIC8gdHJhbnNsYXRlc0RpZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdQcm9ncmVzcyAhPT0gc3dpcGVyLnByb2dyZXNzKSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhydGxUcmFuc2xhdGUgPyAtc3dpcGVyLnRyYW5zbGF0ZSA6IHN3aXBlci50cmFuc2xhdGUpO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNsYXRlJywgc3dpcGVyLnRyYW5zbGF0ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGxldCBkdW1teUV2ZW50QXR0YWNoZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGR1bW15RXZlbnRMaXN0ZW5lcigpIHt9XG5cbiAgICBjb25zdCBldmVudHMgPSAoc3dpcGVyLCBtZXRob2QpID0+IHtcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB0b3VjaEV2ZW50cyxcbiAgICAgICAgZWwsXG4gICAgICAgIHdyYXBwZXJFbCxcbiAgICAgICAgZGV2aWNlLFxuICAgICAgICBzdXBwb3J0XG4gICAgICB9ID0gc3dpcGVyO1xuICAgICAgY29uc3QgY2FwdHVyZSA9ICEhcGFyYW1zLm5lc3RlZDtcbiAgICAgIGNvbnN0IGRvbU1ldGhvZCA9IG1ldGhvZCA9PT0gJ29uJyA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICAgIGNvbnN0IHN3aXBlck1ldGhvZCA9IG1ldGhvZDsgLy8gVG91Y2ggRXZlbnRzXG5cbiAgICAgIGlmICghc3VwcG9ydC50b3VjaCkge1xuICAgICAgICBlbFtkb21NZXRob2RdKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50W2RvbU1ldGhvZF0odG91Y2hFdmVudHMubW92ZSwgc3dpcGVyLm9uVG91Y2hNb3ZlLCBjYXB0dXJlKTtcbiAgICAgICAgZG9jdW1lbnRbZG9tTWV0aG9kXSh0b3VjaEV2ZW50cy5lbmQsIHN3aXBlci5vblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwYXNzaXZlTGlzdGVuZXIgPSB0b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIHN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzID8ge1xuICAgICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICAgICAgfSA6IGZhbHNlO1xuICAgICAgICBlbFtkb21NZXRob2RdKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICBlbFtkb21NZXRob2RdKHRvdWNoRXZlbnRzLm1vdmUsIHN3aXBlci5vblRvdWNoTW92ZSwgc3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgPyB7XG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZVxuICAgICAgICB9IDogY2FwdHVyZSk7XG4gICAgICAgIGVsW2RvbU1ldGhvZF0odG91Y2hFdmVudHMuZW5kLCBzd2lwZXIub25Ub3VjaEVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcblxuICAgICAgICBpZiAodG91Y2hFdmVudHMuY2FuY2VsKSB7XG4gICAgICAgICAgZWxbZG9tTWV0aG9kXSh0b3VjaEV2ZW50cy5jYW5jZWwsIHN3aXBlci5vblRvdWNoRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFByZXZlbnQgTGlua3MgQ2xpY2tzXG5cblxuICAgICAgaWYgKHBhcmFtcy5wcmV2ZW50Q2xpY2tzIHx8IHBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZWxbZG9tTWV0aG9kXSgnY2xpY2snLCBzd2lwZXIub25DbGljaywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICB3cmFwcGVyRWxbZG9tTWV0aG9kXSgnc2Nyb2xsJywgc3dpcGVyLm9uU2Nyb2xsKTtcbiAgICAgIH0gLy8gUmVzaXplIGhhbmRsZXJcblxuXG4gICAgICBpZiAocGFyYW1zLnVwZGF0ZU9uV2luZG93UmVzaXplKSB7XG4gICAgICAgIHN3aXBlcltzd2lwZXJNZXRob2RdKGRldmljZS5pb3MgfHwgZGV2aWNlLmFuZHJvaWQgPyAncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlIG9ic2VydmVyVXBkYXRlJyA6ICdyZXNpemUgb2JzZXJ2ZXJVcGRhdGUnLCBvblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXJbc3dpcGVyTWV0aG9kXSgnb2JzZXJ2ZXJVcGRhdGUnLCBvblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgc3VwcG9ydFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIHN3aXBlci5vblRvdWNoU3RhcnQgPSBvblRvdWNoU3RhcnQuYmluZChzd2lwZXIpO1xuICAgICAgc3dpcGVyLm9uVG91Y2hNb3ZlID0gb25Ub3VjaE1vdmUuYmluZChzd2lwZXIpO1xuICAgICAgc3dpcGVyLm9uVG91Y2hFbmQgPSBvblRvdWNoRW5kLmJpbmQoc3dpcGVyKTtcblxuICAgICAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIHN3aXBlci5vblNjcm9sbCA9IG9uU2Nyb2xsLmJpbmQoc3dpcGVyKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLm9uQ2xpY2sgPSBvbkNsaWNrLmJpbmQoc3dpcGVyKTtcblxuICAgICAgaWYgKHN1cHBvcnQudG91Y2ggJiYgIWR1bW15RXZlbnRBdHRhY2hlZCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZHVtbXlFdmVudExpc3RlbmVyKTtcbiAgICAgICAgZHVtbXlFdmVudEF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzKHN3aXBlciwgJ29uJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0YWNoRXZlbnRzKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGV2ZW50cyhzd2lwZXIsICdvZmYnKTtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRzJDEgPSB7XG4gICAgICBhdHRhY2hFdmVudHMsXG4gICAgICBkZXRhY2hFdmVudHNcbiAgICB9O1xuXG4gICAgY29uc3QgaXNHcmlkRW5hYmxlZCA9IChzd2lwZXIsIHBhcmFtcykgPT4ge1xuICAgICAgcmV0dXJuIHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRCcmVha3BvaW50KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlSW5kZXgsXG4gICAgICAgIGluaXRpYWxpemVkLFxuICAgICAgICBsb29wZWRTbGlkZXMgPSAwLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgICRlbFxuICAgICAgfSA9IHN3aXBlcjtcbiAgICAgIGNvbnN0IGJyZWFrcG9pbnRzID0gcGFyYW1zLmJyZWFrcG9pbnRzO1xuICAgICAgaWYgKCFicmVha3BvaW50cyB8fCBicmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhicmVha3BvaW50cykubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIEdldCBicmVha3BvaW50IGZvciB3aW5kb3cgd2lkdGggYW5kIHVwZGF0ZSBwYXJhbWV0ZXJzXG5cbiAgICAgIGNvbnN0IGJyZWFrcG9pbnQgPSBzd2lwZXIuZ2V0QnJlYWtwb2ludChicmVha3BvaW50cywgc3dpcGVyLnBhcmFtcy5icmVha3BvaW50c0Jhc2UsIHN3aXBlci5lbCk7XG4gICAgICBpZiAoIWJyZWFrcG9pbnQgfHwgc3dpcGVyLmN1cnJlbnRCcmVha3BvaW50ID09PSBicmVha3BvaW50KSByZXR1cm47XG4gICAgICBjb25zdCBicmVha3BvaW50T25seVBhcmFtcyA9IGJyZWFrcG9pbnQgaW4gYnJlYWtwb2ludHMgPyBicmVha3BvaW50c1ticmVha3BvaW50XSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGJyZWFrcG9pbnRQYXJhbXMgPSBicmVha3BvaW50T25seVBhcmFtcyB8fCBzd2lwZXIub3JpZ2luYWxQYXJhbXM7XG4gICAgICBjb25zdCB3YXNNdWx0aVJvdyA9IGlzR3JpZEVuYWJsZWQoc3dpcGVyLCBwYXJhbXMpO1xuICAgICAgY29uc3QgaXNNdWx0aVJvdyA9IGlzR3JpZEVuYWJsZWQoc3dpcGVyLCBicmVha3BvaW50UGFyYW1zKTtcbiAgICAgIGNvbnN0IHdhc0VuYWJsZWQgPSBwYXJhbXMuZW5hYmxlZDtcblxuICAgICAgaWYgKHdhc011bHRpUm93ICYmICFpc011bHRpUm93KSB7XG4gICAgICAgICRlbC5yZW1vdmVDbGFzcyhgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkICR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKTtcbiAgICAgICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgICB9IGVsc2UgaWYgKCF3YXNNdWx0aVJvdyAmJiBpc011bHRpUm93KSB7XG4gICAgICAgICRlbC5hZGRDbGFzcyhgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkYCk7XG5cbiAgICAgICAgaWYgKGJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsICYmIGJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsID09PSAnY29sdW1uJyB8fCAhYnJlYWtwb2ludFBhcmFtcy5ncmlkLmZpbGwgJiYgcGFyYW1zLmdyaWQuZmlsbCA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAkZWwuYWRkQ2xhc3MoYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICAgICAgfSAvLyBUb2dnbGUgbmF2aWdhdGlvbiwgcGFnaW5hdGlvbiwgc2Nyb2xsYmFyXG5cblxuICAgICAgWyduYXZpZ2F0aW9uJywgJ3BhZ2luYXRpb24nLCAnc2Nyb2xsYmFyJ10uZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgY29uc3Qgd2FzTW9kdWxlRW5hYmxlZCA9IHBhcmFtc1twcm9wXSAmJiBwYXJhbXNbcHJvcF0uZW5hYmxlZDtcbiAgICAgICAgY29uc3QgaXNNb2R1bGVFbmFibGVkID0gYnJlYWtwb2ludFBhcmFtc1twcm9wXSAmJiBicmVha3BvaW50UGFyYW1zW3Byb3BdLmVuYWJsZWQ7XG5cbiAgICAgICAgaWYgKHdhc01vZHVsZUVuYWJsZWQgJiYgIWlzTW9kdWxlRW5hYmxlZCkge1xuICAgICAgICAgIHN3aXBlcltwcm9wXS5kaXNhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXdhc01vZHVsZUVuYWJsZWQgJiYgaXNNb2R1bGVFbmFibGVkKSB7XG4gICAgICAgICAgc3dpcGVyW3Byb3BdLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbkNoYW5nZWQgPSBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAmJiBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAhPT0gcGFyYW1zLmRpcmVjdGlvbjtcbiAgICAgIGNvbnN0IG5lZWRzUmVMb29wID0gcGFyYW1zLmxvb3AgJiYgKGJyZWFrcG9pbnRQYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gcGFyYW1zLnNsaWRlc1BlclZpZXcgfHwgZGlyZWN0aW9uQ2hhbmdlZCk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb25DaGFuZ2VkICYmIGluaXRpYWxpemVkKSB7XG4gICAgICAgIHN3aXBlci5jaGFuZ2VEaXJlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgZXh0ZW5kJDEoc3dpcGVyLnBhcmFtcywgYnJlYWtwb2ludFBhcmFtcyk7XG4gICAgICBjb25zdCBpc0VuYWJsZWQgPSBzd2lwZXIucGFyYW1zLmVuYWJsZWQ7XG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcbiAgICAgICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXG4gICAgICAgIGFsbG93U2xpZGVQcmV2OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVQcmV2XG4gICAgICB9KTtcblxuICAgICAgaWYgKHdhc0VuYWJsZWQgJiYgIWlzRW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuZGlzYWJsZSgpO1xuICAgICAgfSBlbHNlIGlmICghd2FzRW5hYmxlZCAmJiBpc0VuYWJsZWQpIHtcbiAgICAgICAgc3dpcGVyLmVuYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICBzd2lwZXIuY3VycmVudEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xuICAgICAgc3dpcGVyLmVtaXQoJ19iZWZvcmVCcmVha3BvaW50JywgYnJlYWtwb2ludFBhcmFtcyk7XG5cbiAgICAgIGlmIChuZWVkc1JlTG9vcCAmJiBpbml0aWFsaXplZCkge1xuICAgICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCAtIGxvb3BlZFNsaWRlcyArIHN3aXBlci5sb29wZWRTbGlkZXMsIDAsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLmVtaXQoJ2JyZWFrcG9pbnQnLCBicmVha3BvaW50UGFyYW1zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCcmVha3BvaW50KGJyZWFrcG9pbnRzLCBiYXNlLCBjb250YWluZXJFbCkge1xuICAgICAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBiYXNlID0gJ3dpbmRvdyc7XG4gICAgICB9XG5cbiAgICAgIGlmICghYnJlYWtwb2ludHMgfHwgYmFzZSA9PT0gJ2NvbnRhaW5lcicgJiYgIWNvbnRhaW5lckVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgbGV0IGJyZWFrcG9pbnQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgY29uc3QgY3VycmVudEhlaWdodCA9IGJhc2UgPT09ICd3aW5kb3cnID8gd2luZG93LmlubmVySGVpZ2h0IDogY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3QgcG9pbnRzID0gT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLm1hcChwb2ludCA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICdzdHJpbmcnICYmIHBvaW50LmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IG1pblJhdGlvID0gcGFyc2VGbG9hdChwb2ludC5zdWJzdHIoMSkpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudEhlaWdodCAqIG1pblJhdGlvO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHBvaW50XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHBvaW50LFxuICAgICAgICAgIHBvaW50XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHBvaW50cy5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhLnZhbHVlLCAxMCkgLSBwYXJzZUludChiLnZhbHVlLCAxMCkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSA9IHBvaW50c1tpXTtcblxuICAgICAgICBpZiAoYmFzZSA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEoYChtaW4td2lkdGg6ICR7dmFsdWV9cHgpYCkubWF0Y2hlcykge1xuICAgICAgICAgICAgYnJlYWtwb2ludCA9IHBvaW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8PSBjb250YWluZXJFbC5jbGllbnRXaWR0aCkge1xuICAgICAgICAgIGJyZWFrcG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJlYWtwb2ludCB8fCAnbWF4JztcbiAgICB9XG5cbiAgICB2YXIgYnJlYWtwb2ludHMgPSB7XG4gICAgICBzZXRCcmVha3BvaW50LFxuICAgICAgZ2V0QnJlYWtwb2ludFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ2xhc3NlcyhlbnRyaWVzLCBwcmVmaXgpIHtcbiAgICAgIGNvbnN0IHJlc3VsdENsYXNzZXMgPSBbXTtcbiAgICAgIGVudHJpZXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIE9iamVjdC5rZXlzKGl0ZW0pLmZvckVhY2goY2xhc3NOYW1lcyA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbVtjbGFzc05hbWVzXSkge1xuICAgICAgICAgICAgICByZXN1bHRDbGFzc2VzLnB1c2gocHJlZml4ICsgY2xhc3NOYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmVzdWx0Q2xhc3Nlcy5wdXNoKHByZWZpeCArIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHRDbGFzc2VzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc05hbWVzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHJ0bCxcbiAgICAgICAgJGVsLFxuICAgICAgICBkZXZpY2UsXG4gICAgICAgIHN1cHBvcnRcbiAgICAgIH0gPSBzd2lwZXI7IC8vIHByZXR0aWVyLWlnbm9yZVxuXG4gICAgICBjb25zdCBzdWZmaXhlcyA9IHByZXBhcmVDbGFzc2VzKFsnaW5pdGlhbGl6ZWQnLCBwYXJhbXMuZGlyZWN0aW9uLCB7XG4gICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICFzdXBwb3J0LnRvdWNoXG4gICAgICB9LCB7XG4gICAgICAgICdmcmVlLW1vZGUnOiBzd2lwZXIucGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkXG4gICAgICB9LCB7XG4gICAgICAgICdhdXRvaGVpZ2h0JzogcGFyYW1zLmF1dG9IZWlnaHRcbiAgICAgIH0sIHtcbiAgICAgICAgJ3J0bCc6IHJ0bFxuICAgICAgfSwge1xuICAgICAgICAnZ3JpZCc6IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxXG4gICAgICB9LCB7XG4gICAgICAgICdncmlkLWNvbHVtbic6IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxICYmIHBhcmFtcy5ncmlkLmZpbGwgPT09ICdjb2x1bW4nXG4gICAgICB9LCB7XG4gICAgICAgICdhbmRyb2lkJzogZGV2aWNlLmFuZHJvaWRcbiAgICAgIH0sIHtcbiAgICAgICAgJ2lvcyc6IGRldmljZS5pb3NcbiAgICAgIH0sIHtcbiAgICAgICAgJ2Nzcy1tb2RlJzogcGFyYW1zLmNzc01vZGVcbiAgICAgIH0sIHtcbiAgICAgICAgJ2NlbnRlcmVkJzogcGFyYW1zLmNzc01vZGUgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzXG4gICAgICB9LCB7XG4gICAgICAgICd3YXRjaC1wcm9ncmVzcyc6IHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzXG4gICAgICB9XSwgcGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MpO1xuICAgICAgY2xhc3NOYW1lcy5wdXNoKC4uLnN1ZmZpeGVzKTtcbiAgICAgICRlbC5hZGRDbGFzcyhbLi4uY2xhc3NOYW1lc10uam9pbignICcpKTtcbiAgICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICAkZWwsXG4gICAgICAgIGNsYXNzTmFtZXNcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAkZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lcy5qb2luKCcgJykpO1xuICAgICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzZXMgPSB7XG4gICAgICBhZGRDbGFzc2VzLFxuICAgICAgcmVtb3ZlQ2xhc3Nlc1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2FkSW1hZ2UoaW1hZ2VFbCwgc3JjLCBzcmNzZXQsIHNpemVzLCBjaGVja0ZvckNvbXBsZXRlLCBjYWxsYmFjaykge1xuICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICBsZXQgaW1hZ2U7XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVhZHkoKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNQaWN0dXJlID0gJChpbWFnZUVsKS5wYXJlbnQoJ3BpY3R1cmUnKVswXTtcblxuICAgICAgaWYgKCFpc1BpY3R1cmUgJiYgKCFpbWFnZUVsLmNvbXBsZXRlIHx8ICFjaGVja0ZvckNvbXBsZXRlKSkge1xuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKCk7XG4gICAgICAgICAgaW1hZ2Uub25sb2FkID0gb25SZWFkeTtcbiAgICAgICAgICBpbWFnZS5vbmVycm9yID0gb25SZWFkeTtcblxuICAgICAgICAgIGlmIChzaXplcykge1xuICAgICAgICAgICAgaW1hZ2Uuc2l6ZXMgPSBzaXplcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3Jjc2V0KSB7XG4gICAgICAgICAgICBpbWFnZS5zcmNzZXQgPSBzcmNzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvblJlYWR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGltYWdlIGFscmVhZHkgbG9hZGVkLi4uXG4gICAgICAgIG9uUmVhZHkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVsb2FkSW1hZ2VzKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5pbWFnZXNUb0xvYWQgPSBzd2lwZXIuJGVsLmZpbmQoJ2ltZycpO1xuXG4gICAgICBmdW5jdGlvbiBvblJlYWR5KCkge1xuICAgICAgICBpZiAodHlwZW9mIHN3aXBlciA9PT0gJ3VuZGVmaW5lZCcgfHwgc3dpcGVyID09PSBudWxsIHx8ICFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICBpZiAoc3dpcGVyLmltYWdlc0xvYWRlZCAhPT0gdW5kZWZpbmVkKSBzd2lwZXIuaW1hZ2VzTG9hZGVkICs9IDE7XG5cbiAgICAgICAgaWYgKHN3aXBlci5pbWFnZXNMb2FkZWQgPT09IHN3aXBlci5pbWFnZXNUb0xvYWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMudXBkYXRlT25JbWFnZXNSZWFkeSkgc3dpcGVyLnVwZGF0ZSgpO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdpbWFnZXNSZWFkeScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLmltYWdlc1RvTG9hZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBpbWFnZUVsID0gc3dpcGVyLmltYWdlc1RvTG9hZFtpXTtcbiAgICAgICAgc3dpcGVyLmxvYWRJbWFnZShpbWFnZUVsLCBpbWFnZUVsLmN1cnJlbnRTcmMgfHwgaW1hZ2VFbC5nZXRBdHRyaWJ1dGUoJ3NyYycpLCBpbWFnZUVsLnNyY3NldCB8fCBpbWFnZUVsLmdldEF0dHJpYnV0ZSgnc3Jjc2V0JyksIGltYWdlRWwuc2l6ZXMgfHwgaW1hZ2VFbC5nZXRBdHRyaWJ1dGUoJ3NpemVzJyksIHRydWUsIG9uUmVhZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbWFnZXMgPSB7XG4gICAgICBsb2FkSW1hZ2UsXG4gICAgICBwcmVsb2FkSW1hZ2VzXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3coKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc0xvY2tlZDogd2FzTG9ja2VkLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSBzd2lwZXI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNsaWRlc09mZnNldEJlZm9yZVxuICAgICAgfSA9IHBhcmFtcztcblxuICAgICAgaWYgKHNsaWRlc09mZnNldEJlZm9yZSkge1xuICAgICAgICBjb25zdCBsYXN0U2xpZGVJbmRleCA9IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbGFzdFNsaWRlUmlnaHRFZGdlID0gc3dpcGVyLnNsaWRlc0dyaWRbbGFzdFNsaWRlSW5kZXhdICsgc3dpcGVyLnNsaWRlc1NpemVzR3JpZFtsYXN0U2xpZGVJbmRleF0gKyBzbGlkZXNPZmZzZXRCZWZvcmUgKiAyO1xuICAgICAgICBzd2lwZXIuaXNMb2NrZWQgPSBzd2lwZXIuc2l6ZSA+IGxhc3RTbGlkZVJpZ2h0RWRnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5pc0xvY2tlZCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGggPT09IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuYWxsb3dTbGlkZU5leHQgPT09IHRydWUpIHtcbiAgICAgICAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gIXN3aXBlci5pc0xvY2tlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5hbGxvd1NsaWRlUHJldiA9PT0gdHJ1ZSkge1xuICAgICAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSAhc3dpcGVyLmlzTG9ja2VkO1xuICAgICAgfVxuXG4gICAgICBpZiAod2FzTG9ja2VkICYmIHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSB7XG4gICAgICAgIHN3aXBlci5pc0VuZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAod2FzTG9ja2VkICE9PSBzd2lwZXIuaXNMb2NrZWQpIHtcbiAgICAgICAgc3dpcGVyLmVtaXQoc3dpcGVyLmlzTG9ja2VkID8gJ2xvY2snIDogJ3VubG9jaycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGVja092ZXJmbG93JDEgPSB7XG4gICAgICBjaGVja092ZXJmbG93XG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGluaXQ6IHRydWUsXG4gICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgICAgIHRvdWNoRXZlbnRzVGFyZ2V0OiAnd3JhcHBlcicsXG4gICAgICBpbml0aWFsU2xpZGU6IDAsXG4gICAgICBzcGVlZDogMzAwLFxuICAgICAgY3NzTW9kZTogZmFsc2UsXG4gICAgICB1cGRhdGVPbldpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgIHJlc2l6ZU9ic2VydmVyOiB0cnVlLFxuICAgICAgbmVzdGVkOiBmYWxzZSxcbiAgICAgIGNyZWF0ZUVsZW1lbnRzOiBmYWxzZSxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb2N1c2FibGVFbGVtZW50czogJ2lucHV0LCBzZWxlY3QsIG9wdGlvbiwgdGV4dGFyZWEsIGJ1dHRvbiwgdmlkZW8sIGxhYmVsJyxcbiAgICAgIC8vIE92ZXJyaWRlc1xuICAgICAgd2lkdGg6IG51bGwsXG4gICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICAvL1xuICAgICAgcHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uOiBmYWxzZSxcbiAgICAgIC8vIHNzclxuICAgICAgdXNlckFnZW50OiBudWxsLFxuICAgICAgdXJsOiBudWxsLFxuICAgICAgLy8gVG8gc3VwcG9ydCBpT1MncyBzd2lwZS10by1nby1iYWNrIGdlc3R1cmUgKHdoZW4gYmVpbmcgdXNlZCBpbi1hcHApLlxuICAgICAgZWRnZVN3aXBlRGV0ZWN0aW9uOiBmYWxzZSxcbiAgICAgIGVkZ2VTd2lwZVRocmVzaG9sZDogMjAsXG4gICAgICAvLyBBdXRvaGVpZ2h0XG4gICAgICBhdXRvSGVpZ2h0OiBmYWxzZSxcbiAgICAgIC8vIFNldCB3cmFwcGVyIHdpZHRoXG4gICAgICBzZXRXcmFwcGVyU2l6ZTogZmFsc2UsXG4gICAgICAvLyBWaXJ0dWFsIFRyYW5zbGF0ZVxuICAgICAgdmlydHVhbFRyYW5zbGF0ZTogZmFsc2UsXG4gICAgICAvLyBFZmZlY3RzXG4gICAgICBlZmZlY3Q6ICdzbGlkZScsXG4gICAgICAvLyAnc2xpZGUnIG9yICdmYWRlJyBvciAnY3ViZScgb3IgJ2NvdmVyZmxvdycgb3IgJ2ZsaXAnXG4gICAgICAvLyBCcmVha3BvaW50c1xuICAgICAgYnJlYWtwb2ludHM6IHVuZGVmaW5lZCxcbiAgICAgIGJyZWFrcG9pbnRzQmFzZTogJ3dpbmRvdycsXG4gICAgICAvLyBTbGlkZXMgZ3JpZFxuICAgICAgc3BhY2VCZXR3ZWVuOiAwLFxuICAgICAgc2xpZGVzUGVyVmlldzogMSxcbiAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgc2xpZGVzUGVyR3JvdXBTa2lwOiAwLFxuICAgICAgc2xpZGVzUGVyR3JvdXBBdXRvOiBmYWxzZSxcbiAgICAgIGNlbnRlcmVkU2xpZGVzOiBmYWxzZSxcbiAgICAgIGNlbnRlcmVkU2xpZGVzQm91bmRzOiBmYWxzZSxcbiAgICAgIHNsaWRlc09mZnNldEJlZm9yZTogMCxcbiAgICAgIC8vIGluIHB4XG4gICAgICBzbGlkZXNPZmZzZXRBZnRlcjogMCxcbiAgICAgIC8vIGluIHB4XG4gICAgICBub3JtYWxpemVTbGlkZUluZGV4OiB0cnVlLFxuICAgICAgY2VudGVySW5zdWZmaWNpZW50U2xpZGVzOiBmYWxzZSxcbiAgICAgIC8vIERpc2FibGUgc3dpcGVyIGFuZCBoaWRlIG5hdmlnYXRpb24gd2hlbiBjb250YWluZXIgbm90IG92ZXJmbG93XG4gICAgICB3YXRjaE92ZXJmbG93OiB0cnVlLFxuICAgICAgLy8gUm91bmQgbGVuZ3RoXG4gICAgICByb3VuZExlbmd0aHM6IGZhbHNlLFxuICAgICAgLy8gVG91Y2hlc1xuICAgICAgdG91Y2hSYXRpbzogMSxcbiAgICAgIHRvdWNoQW5nbGU6IDQ1LFxuICAgICAgc2ltdWxhdGVUb3VjaDogdHJ1ZSxcbiAgICAgIHNob3J0U3dpcGVzOiB0cnVlLFxuICAgICAgbG9uZ1N3aXBlczogdHJ1ZSxcbiAgICAgIGxvbmdTd2lwZXNSYXRpbzogMC41LFxuICAgICAgbG9uZ1N3aXBlc01zOiAzMDAsXG4gICAgICBmb2xsb3dGaW5nZXI6IHRydWUsXG4gICAgICBhbGxvd1RvdWNoTW92ZTogdHJ1ZSxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXG4gICAgICB0b3VjaFN0YXJ0UHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICB0b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgICB0b3VjaFJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcbiAgICAgIC8vIFVuaXF1ZSBOYXZpZ2F0aW9uIEVsZW1lbnRzXG4gICAgICB1bmlxdWVOYXZFbGVtZW50czogdHJ1ZSxcbiAgICAgIC8vIFJlc2lzdGFuY2VcbiAgICAgIHJlc2lzdGFuY2U6IHRydWUsXG4gICAgICByZXNpc3RhbmNlUmF0aW86IDAuODUsXG4gICAgICAvLyBQcm9ncmVzc1xuICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogZmFsc2UsXG4gICAgICAvLyBDdXJzb3JcbiAgICAgIGdyYWJDdXJzb3I6IGZhbHNlLFxuICAgICAgLy8gQ2xpY2tzXG4gICAgICBwcmV2ZW50Q2xpY2tzOiB0cnVlLFxuICAgICAgcHJldmVudENsaWNrc1Byb3BhZ2F0aW9uOiB0cnVlLFxuICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogZmFsc2UsXG4gICAgICAvLyBJbWFnZXNcbiAgICAgIHByZWxvYWRJbWFnZXM6IHRydWUsXG4gICAgICB1cGRhdGVPbkltYWdlc1JlYWR5OiB0cnVlLFxuICAgICAgLy8gbG9vcFxuICAgICAgbG9vcDogZmFsc2UsXG4gICAgICBsb29wQWRkaXRpb25hbFNsaWRlczogMCxcbiAgICAgIGxvb3BlZFNsaWRlczogbnVsbCxcbiAgICAgIGxvb3BlZFNsaWRlc0xpbWl0OiB0cnVlLFxuICAgICAgbG9vcEZpbGxHcm91cFdpdGhCbGFuazogZmFsc2UsXG4gICAgICBsb29wUHJldmVudHNTbGlkZTogdHJ1ZSxcbiAgICAgIC8vIHJld2luZFxuICAgICAgcmV3aW5kOiBmYWxzZSxcbiAgICAgIC8vIFN3aXBpbmcvbm8gc3dpcGluZ1xuICAgICAgYWxsb3dTbGlkZVByZXY6IHRydWUsXG4gICAgICBhbGxvd1NsaWRlTmV4dDogdHJ1ZSxcbiAgICAgIHN3aXBlSGFuZGxlcjogbnVsbCxcbiAgICAgIC8vICcuc3dpcGUtaGFuZGxlcicsXG4gICAgICBub1N3aXBpbmc6IHRydWUsXG4gICAgICBub1N3aXBpbmdDbGFzczogJ3N3aXBlci1uby1zd2lwaW5nJyxcbiAgICAgIG5vU3dpcGluZ1NlbGVjdG9yOiBudWxsLFxuICAgICAgLy8gUGFzc2l2ZSBMaXN0ZW5lcnNcbiAgICAgIHBhc3NpdmVMaXN0ZW5lcnM6IHRydWUsXG4gICAgICBtYXhCYWNrZmFjZUhpZGRlblNsaWRlczogMTAsXG4gICAgICAvLyBOU1xuICAgICAgY29udGFpbmVyTW9kaWZpZXJDbGFzczogJ3N3aXBlci0nLFxuICAgICAgLy8gTkVXXG4gICAgICBzbGlkZUNsYXNzOiAnc3dpcGVyLXNsaWRlJyxcbiAgICAgIHNsaWRlQmxhbmtDbGFzczogJ3N3aXBlci1zbGlkZS1pbnZpc2libGUtYmxhbmsnLFxuICAgICAgc2xpZGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1hY3RpdmUnLFxuICAgICAgc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUtYWN0aXZlJyxcbiAgICAgIHNsaWRlVmlzaWJsZUNsYXNzOiAnc3dpcGVyLXNsaWRlLXZpc2libGUnLFxuICAgICAgc2xpZGVEdXBsaWNhdGVDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUnLFxuICAgICAgc2xpZGVOZXh0Q2xhc3M6ICdzd2lwZXItc2xpZGUtbmV4dCcsXG4gICAgICBzbGlkZUR1cGxpY2F0ZU5leHRDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUtbmV4dCcsXG4gICAgICBzbGlkZVByZXZDbGFzczogJ3N3aXBlci1zbGlkZS1wcmV2JyxcbiAgICAgIHNsaWRlRHVwbGljYXRlUHJldkNsYXNzOiAnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1wcmV2JyxcbiAgICAgIHdyYXBwZXJDbGFzczogJ3N3aXBlci13cmFwcGVyJyxcbiAgICAgIC8vIENhbGxiYWNrc1xuICAgICAgcnVuQ2FsbGJhY2tzT25Jbml0OiB0cnVlLFxuICAgICAgLy8gSW50ZXJuYWxzXG4gICAgICBfZW1pdENsYXNzZXM6IGZhbHNlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1vZHVsZUV4dGVuZFBhcmFtcyhwYXJhbXMsIGFsbE1vZHVsZXNQYXJhbXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBleHRlbmRQYXJhbXMob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT09IHZvaWQgMCkge1xuICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kdWxlUGFyYW1OYW1lID0gT2JqZWN0LmtleXMob2JqKVswXTtcbiAgICAgICAgY29uc3QgbW9kdWxlUGFyYW1zID0gb2JqW21vZHVsZVBhcmFtTmFtZV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVQYXJhbXMgIT09ICdvYmplY3QnIHx8IG1vZHVsZVBhcmFtcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGV4dGVuZCQxKGFsbE1vZHVsZXNQYXJhbXMsIG9iaik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFsnbmF2aWdhdGlvbicsICdwYWdpbmF0aW9uJywgJ3Njcm9sbGJhciddLmluZGV4T2YobW9kdWxlUGFyYW1OYW1lKSA+PSAwICYmIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSB0cnVlKSB7XG4gICAgICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7XG4gICAgICAgICAgICBhdXRvOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKG1vZHVsZVBhcmFtTmFtZSBpbiBwYXJhbXMgJiYgJ2VuYWJsZWQnIGluIG1vZHVsZVBhcmFtcykpIHtcbiAgICAgICAgICBleHRlbmQkMShhbGxNb2R1bGVzUGFyYW1zLCBvYmopO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID0ge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSAnb2JqZWN0JyAmJiAhKCdlbmFibGVkJyBpbiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSkpIHtcbiAgICAgICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0pIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID0ge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGV4dGVuZCQxKGFsbE1vZHVsZXNQYXJhbXMsIG9iaik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogXCJvZmZcIiAqL1xuICAgIGNvbnN0IHByb3RvdHlwZXMgPSB7XG4gICAgICBldmVudHNFbWl0dGVyLFxuICAgICAgdXBkYXRlLFxuICAgICAgdHJhbnNsYXRlLFxuICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiQxLFxuICAgICAgc2xpZGUsXG4gICAgICBsb29wLFxuICAgICAgZ3JhYkN1cnNvcixcbiAgICAgIGV2ZW50czogZXZlbnRzJDEsXG4gICAgICBicmVha3BvaW50cyxcbiAgICAgIGNoZWNrT3ZlcmZsb3c6IGNoZWNrT3ZlcmZsb3ckMSxcbiAgICAgIGNsYXNzZXMsXG4gICAgICBpbWFnZXNcbiAgICB9O1xuICAgIGNvbnN0IGV4dGVuZGVkRGVmYXVsdHMgPSB7fTtcblxuICAgIGNsYXNzIFN3aXBlciB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IGVsO1xuICAgICAgICBsZXQgcGFyYW1zO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgYXJnc1swXS5jb25zdHJ1Y3RvciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnc1swXSkuc2xpY2UoOCwgLTEpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgW2VsLCBwYXJhbXNdID0gYXJncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICAgICAgcGFyYW1zID0gZXh0ZW5kJDEoe30sIHBhcmFtcyk7XG4gICAgICAgIGlmIChlbCAmJiAhcGFyYW1zLmVsKSBwYXJhbXMuZWwgPSBlbDtcblxuICAgICAgICBpZiAocGFyYW1zLmVsICYmICQocGFyYW1zLmVsKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29uc3Qgc3dpcGVycyA9IFtdO1xuICAgICAgICAgICQocGFyYW1zLmVsKS5lYWNoKGNvbnRhaW5lckVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IGV4dGVuZCQxKHt9LCBwYXJhbXMsIHtcbiAgICAgICAgICAgICAgZWw6IGNvbnRhaW5lckVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN3aXBlcnMucHVzaChuZXcgU3dpcGVyKG5ld1BhcmFtcykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBzd2lwZXJzO1xuICAgICAgICB9IC8vIFN3aXBlciBJbnN0YW5jZVxuXG5cbiAgICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgICAgc3dpcGVyLl9fc3dpcGVyX18gPSB0cnVlO1xuICAgICAgICBzd2lwZXIuc3VwcG9ydCA9IGdldFN1cHBvcnQoKTtcbiAgICAgICAgc3dpcGVyLmRldmljZSA9IGdldERldmljZSh7XG4gICAgICAgICAgdXNlckFnZW50OiBwYXJhbXMudXNlckFnZW50XG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXIuYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICAgICAgc3dpcGVyLmV2ZW50c0xpc3RlbmVycyA9IHt9O1xuICAgICAgICBzd2lwZXIuZXZlbnRzQW55TGlzdGVuZXJzID0gW107XG4gICAgICAgIHN3aXBlci5tb2R1bGVzID0gWy4uLnN3aXBlci5fX21vZHVsZXNfX107XG5cbiAgICAgICAgaWYgKHBhcmFtcy5tb2R1bGVzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLm1vZHVsZXMpKSB7XG4gICAgICAgICAgc3dpcGVyLm1vZHVsZXMucHVzaCguLi5wYXJhbXMubW9kdWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbGxNb2R1bGVzUGFyYW1zID0ge307XG4gICAgICAgIHN3aXBlci5tb2R1bGVzLmZvckVhY2gobW9kID0+IHtcbiAgICAgICAgICBtb2Qoe1xuICAgICAgICAgICAgc3dpcGVyLFxuICAgICAgICAgICAgZXh0ZW5kUGFyYW1zOiBtb2R1bGVFeHRlbmRQYXJhbXMocGFyYW1zLCBhbGxNb2R1bGVzUGFyYW1zKSxcbiAgICAgICAgICAgIG9uOiBzd2lwZXIub24uYmluZChzd2lwZXIpLFxuICAgICAgICAgICAgb25jZTogc3dpcGVyLm9uY2UuYmluZChzd2lwZXIpLFxuICAgICAgICAgICAgb2ZmOiBzd2lwZXIub2ZmLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgICAgIGVtaXQ6IHN3aXBlci5lbWl0LmJpbmQoc3dpcGVyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggbW9kdWxlcyBwYXJhbXNcblxuICAgICAgICBjb25zdCBzd2lwZXJQYXJhbXMgPSBleHRlbmQkMSh7fSwgZGVmYXVsdHMsIGFsbE1vZHVsZXNQYXJhbXMpOyAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBwYXNzZWQgcGFyYW1zXG5cbiAgICAgICAgc3dpcGVyLnBhcmFtcyA9IGV4dGVuZCQxKHt9LCBzd2lwZXJQYXJhbXMsIGV4dGVuZGVkRGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcyA9IGV4dGVuZCQxKHt9LCBzd2lwZXIucGFyYW1zKTtcbiAgICAgICAgc3dpcGVyLnBhc3NlZFBhcmFtcyA9IGV4dGVuZCQxKHt9LCBwYXJhbXMpOyAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzXG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMgJiYgc3dpcGVyLnBhcmFtcy5vbikge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHN3aXBlci5wYXJhbXMub24pLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgICAgICAgIHN3aXBlci5vbihldmVudE5hbWUsIHN3aXBlci5wYXJhbXMub25bZXZlbnROYW1lXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcyAmJiBzd2lwZXIucGFyYW1zLm9uQW55KSB7XG4gICAgICAgICAgc3dpcGVyLm9uQW55KHN3aXBlci5wYXJhbXMub25BbnkpO1xuICAgICAgICB9IC8vIFNhdmUgRG9tIGxpYlxuXG5cbiAgICAgICAgc3dpcGVyLiQgPSAkOyAvLyBFeHRlbmQgU3dpcGVyXG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgICAgICBlbmFibGVkOiBzd2lwZXIucGFyYW1zLmVuYWJsZWQsXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgLy8gQ2xhc3Nlc1xuICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgIC8vIFNsaWRlc1xuICAgICAgICAgIHNsaWRlczogJCgpLFxuICAgICAgICAgIHNsaWRlc0dyaWQ6IFtdLFxuICAgICAgICAgIHNuYXBHcmlkOiBbXSxcbiAgICAgICAgICBzbGlkZXNTaXplc0dyaWQ6IFtdLFxuXG4gICAgICAgICAgLy8gaXNEaXJlY3Rpb25cbiAgICAgICAgICBpc0hvcml6b250YWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaXNWZXJ0aWNhbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gSW5kZXhlc1xuICAgICAgICAgIGFjdGl2ZUluZGV4OiAwLFxuICAgICAgICAgIHJlYWxJbmRleDogMCxcbiAgICAgICAgICAvL1xuICAgICAgICAgIGlzQmVnaW5uaW5nOiB0cnVlLFxuICAgICAgICAgIGlzRW5kOiBmYWxzZSxcbiAgICAgICAgICAvLyBQcm9wc1xuICAgICAgICAgIHRyYW5zbGF0ZTogMCxcbiAgICAgICAgICBwcmV2aW91c1RyYW5zbGF0ZTogMCxcbiAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICB2ZWxvY2l0eTogMCxcbiAgICAgICAgICBhbmltYXRpbmc6IGZhbHNlLFxuICAgICAgICAgIC8vIExvY2tzXG4gICAgICAgICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXG4gICAgICAgICAgYWxsb3dTbGlkZVByZXY6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZVByZXYsXG4gICAgICAgICAgLy8gVG91Y2ggRXZlbnRzXG4gICAgICAgICAgdG91Y2hFdmVudHM6IGZ1bmN0aW9uIHRvdWNoRXZlbnRzKCkge1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJ107XG4gICAgICAgICAgICBjb25zdCBkZXNrdG9wID0gWydwb2ludGVyZG93bicsICdwb2ludGVybW92ZScsICdwb2ludGVydXAnXTtcbiAgICAgICAgICAgIHN3aXBlci50b3VjaEV2ZW50c1RvdWNoID0ge1xuICAgICAgICAgICAgICBzdGFydDogdG91Y2hbMF0sXG4gICAgICAgICAgICAgIG1vdmU6IHRvdWNoWzFdLFxuICAgICAgICAgICAgICBlbmQ6IHRvdWNoWzJdLFxuICAgICAgICAgICAgICBjYW5jZWw6IHRvdWNoWzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGVza3RvcCA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRlc2t0b3BbMF0sXG4gICAgICAgICAgICAgIG1vdmU6IGRlc2t0b3BbMV0sXG4gICAgICAgICAgICAgIGVuZDogZGVza3RvcFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzd2lwZXIuc3VwcG9ydC50b3VjaCB8fCAhc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoID8gc3dpcGVyLnRvdWNoRXZlbnRzVG91Y2ggOiBzd2lwZXIudG91Y2hFdmVudHNEZXNrdG9wO1xuICAgICAgICAgIH0oKSxcbiAgICAgICAgICB0b3VjaEV2ZW50c0RhdGE6IHtcbiAgICAgICAgICAgIGlzVG91Y2hlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNNb3ZlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG91Y2hTdGFydFRpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGFydFRyYW5zbGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3dUaHJlc2hvbGRNb3ZlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBGb3JtIGVsZW1lbnRzIHRvIG1hdGNoXG4gICAgICAgICAgICBmb2N1c2FibGVFbGVtZW50czogc3dpcGVyLnBhcmFtcy5mb2N1c2FibGVFbGVtZW50cyxcbiAgICAgICAgICAgIC8vIExhc3QgY2xpY2sgdGltZVxuICAgICAgICAgICAgbGFzdENsaWNrVGltZTogbm93KCksXG4gICAgICAgICAgICBjbGlja1RpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFZlbG9jaXRpZXNcbiAgICAgICAgICAgIHZlbG9jaXRpZXM6IFtdLFxuICAgICAgICAgICAgYWxsb3dNb21lbnR1bUJvdW5jZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGFydE1vdmluZzogdW5kZWZpbmVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBDbGlja3NcbiAgICAgICAgICBhbGxvd0NsaWNrOiB0cnVlLFxuICAgICAgICAgIC8vIFRvdWNoZXNcbiAgICAgICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcbiAgICAgICAgICB0b3VjaGVzOiB7XG4gICAgICAgICAgICBzdGFydFg6IDAsXG4gICAgICAgICAgICBzdGFydFk6IDAsXG4gICAgICAgICAgICBjdXJyZW50WDogMCxcbiAgICAgICAgICAgIGN1cnJlbnRZOiAwLFxuICAgICAgICAgICAgZGlmZjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gSW1hZ2VzXG4gICAgICAgICAgaW1hZ2VzVG9Mb2FkOiBbXSxcbiAgICAgICAgICBpbWFnZXNMb2FkZWQ6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlci5lbWl0KCdfc3dpcGVyJyk7IC8vIEluaXRcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5pbml0KSB7XG4gICAgICAgICAgc3dpcGVyLmluaXQoKTtcbiAgICAgICAgfSAvLyBSZXR1cm4gYXBwIGluc3RhbmNlXG5cblxuICAgICAgICByZXR1cm4gc3dpcGVyO1xuICAgICAgfVxuXG4gICAgICBlbmFibGUoKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBzd2lwZXIuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnZW5hYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGRpc2FibGUoKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yKSB7XG4gICAgICAgICAgc3dpcGVyLnVuc2V0R3JhYkN1cnNvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmVtaXQoJ2Rpc2FibGUnKTtcbiAgICAgIH1cblxuICAgICAgc2V0UHJvZ3Jlc3MocHJvZ3Jlc3MsIHNwZWVkKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIHByb2dyZXNzID0gTWF0aC5taW4oTWF0aC5tYXgocHJvZ3Jlc3MsIDApLCAxKTtcbiAgICAgICAgY29uc3QgbWluID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICBjb25zdCBtYXggPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSAobWF4IC0gbWluKSAqIHByb2dyZXNzICsgbWluO1xuICAgICAgICBzd2lwZXIudHJhbnNsYXRlVG8oY3VycmVudCwgdHlwZW9mIHNwZWVkID09PSAndW5kZWZpbmVkJyA/IDAgOiBzcGVlZCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgICAgfVxuXG4gICAgICBlbWl0Q29udGFpbmVyQ2xhc3NlcygpIHtcbiAgICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLl9lbWl0Q2xhc3NlcyB8fCAhc3dpcGVyLmVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGNscyA9IHN3aXBlci5lbC5jbGFzc05hbWUuc3BsaXQoJyAnKS5maWx0ZXIoY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3N3aXBlcicpID09PSAwIHx8IGNsYXNzTmFtZS5pbmRleE9mKHN3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcykgPT09IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXIuZW1pdCgnX2NvbnRhaW5lckNsYXNzZXMnLCBjbHMuam9pbignICcpKTtcbiAgICAgIH1cblxuICAgICAgZ2V0U2xpZGVDbGFzc2VzKHNsaWRlRWwpIHtcbiAgICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgICAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybiAnJztcbiAgICAgICAgcmV0dXJuIHNsaWRlRWwuY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKCdzd2lwZXItc2xpZGUnKSA9PT0gMCB8fCBjbGFzc05hbWUuaW5kZXhPZihzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3MpID09PSAwO1xuICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICB9XG5cbiAgICAgIGVtaXRTbGlkZXNDbGFzc2VzKCkge1xuICAgICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuX2VtaXRDbGFzc2VzIHx8ICFzd2lwZXIuZWwpIHJldHVybjtcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgICAgICBzd2lwZXIuc2xpZGVzLmVhY2goc2xpZGVFbCA9PiB7XG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IHN3aXBlci5nZXRTbGlkZUNsYXNzZXMoc2xpZGVFbCk7XG4gICAgICAgICAgdXBkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNsaWRlRWwsXG4gICAgICAgICAgICBjbGFzc05hbWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ19zbGlkZUNsYXNzJywgc2xpZGVFbCwgY2xhc3NOYW1lcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXIuZW1pdCgnX3NsaWRlQ2xhc3NlcycsIHVwZGF0ZXMpO1xuICAgICAgfVxuXG4gICAgICBzbGlkZXNQZXJWaWV3RHluYW1pYyh2aWV3LCBleGFjdCkge1xuICAgICAgICBpZiAodmlldyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmlldyA9ICdjdXJyZW50JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGFjdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZXhhY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgIHNsaWRlc0dyaWQsXG4gICAgICAgICAgc2xpZGVzU2l6ZXNHcmlkLFxuICAgICAgICAgIHNpemU6IHN3aXBlclNpemUsXG4gICAgICAgICAgYWN0aXZlSW5kZXhcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgbGV0IHNwdiA9IDE7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICAgIGxldCBzbGlkZVNpemUgPSBzbGlkZXNbYWN0aXZlSW5kZXhdLnN3aXBlclNsaWRlU2l6ZTtcbiAgICAgICAgICBsZXQgYnJlYWtMb29wO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHNsaWRlc1tpXSAmJiAhYnJlYWtMb29wKSB7XG4gICAgICAgICAgICAgIHNsaWRlU2l6ZSArPSBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplO1xuICAgICAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKHNsaWRlU2l6ZSA+IHN3aXBlclNpemUpIGJyZWFrTG9vcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgIGlmIChzbGlkZXNbaV0gJiYgIWJyZWFrTG9vcCkge1xuICAgICAgICAgICAgICBzbGlkZVNpemUgKz0gc2xpZGVzW2ldLnN3aXBlclNsaWRlU2l6ZTtcbiAgICAgICAgICAgICAgc3B2ICs9IDE7XG4gICAgICAgICAgICAgIGlmIChzbGlkZVNpemUgPiBzd2lwZXJTaXplKSBicmVha0xvb3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICBpZiAodmlldyA9PT0gJ2N1cnJlbnQnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggKyAxOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlSW5WaWV3ID0gZXhhY3QgPyBzbGlkZXNHcmlkW2ldICsgc2xpZGVzU2l6ZXNHcmlkW2ldIC0gc2xpZGVzR3JpZFthY3RpdmVJbmRleF0gPCBzd2lwZXJTaXplIDogc2xpZGVzR3JpZFtpXSAtIHNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdIDwgc3dpcGVyU2l6ZTtcblxuICAgICAgICAgICAgICBpZiAoc2xpZGVJblZpZXcpIHtcbiAgICAgICAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2xpZGVJblZpZXcgPSBzbGlkZXNHcmlkW2FjdGl2ZUluZGV4XSAtIHNsaWRlc0dyaWRbaV0gPCBzd2lwZXJTaXplO1xuXG4gICAgICAgICAgICAgIGlmIChzbGlkZUluVmlldykge1xuICAgICAgICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNwdjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKCkge1xuICAgICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICBwYXJhbXNcbiAgICAgICAgfSA9IHN3aXBlcjsgLy8gQnJlYWtwb2ludHNcblxuICAgICAgICBpZiAocGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgICAgICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci51cGRhdGVTaXplKCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlKCkge1xuICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgKiAtMSA6IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICAgICAgY29uc3QgbmV3VHJhbnNsYXRlID0gTWF0aC5taW4oTWF0aC5tYXgodHJhbnNsYXRlVmFsdWUsIHN3aXBlci5tYXhUcmFuc2xhdGUoKSksIHN3aXBlci5taW5UcmFuc2xhdGUoKSk7XG4gICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdUcmFuc2xhdGUpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdHJhbnNsYXRlZDtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBzd2lwZXIucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQpIHtcbiAgICAgICAgICBzZXRUcmFuc2xhdGUoKTtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgfHwgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZWQgPSBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRyYW5zbGF0ZWQpIHtcbiAgICAgICAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzbmFwR3JpZCAhPT0gc3dpcGVyLnNuYXBHcmlkKSB7XG4gICAgICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlci5lbWl0KCd1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlRGlyZWN0aW9uKG5ld0RpcmVjdGlvbiwgbmVlZFVwZGF0ZSkge1xuICAgICAgICBpZiAobmVlZFVwZGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgICBjb25zdCBjdXJyZW50RGlyZWN0aW9uID0gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb247XG5cbiAgICAgICAgaWYgKCFuZXdEaXJlY3Rpb24pIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICBuZXdEaXJlY3Rpb24gPSBjdXJyZW50RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0RpcmVjdGlvbiA9PT0gY3VycmVudERpcmVjdGlvbiB8fCBuZXdEaXJlY3Rpb24gIT09ICdob3Jpem9udGFsJyAmJiBuZXdEaXJlY3Rpb24gIT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICByZXR1cm4gc3dpcGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLiRlbC5yZW1vdmVDbGFzcyhgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHtjdXJyZW50RGlyZWN0aW9ufWApLmFkZENsYXNzKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30ke25ld0RpcmVjdGlvbn1gKTtcbiAgICAgICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgICAgIHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID0gbmV3RGlyZWN0aW9uO1xuICAgICAgICBzd2lwZXIuc2xpZGVzLmVhY2goc2xpZGVFbCA9PiB7XG4gICAgICAgICAgaWYgKG5ld0RpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgc2xpZGVFbC5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGlkZUVsLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlci5lbWl0KCdjaGFuZ2VEaXJlY3Rpb24nKTtcbiAgICAgICAgaWYgKG5lZWRVcGRhdGUpIHN3aXBlci51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHN3aXBlcjtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlTGFuZ3VhZ2VEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChzd2lwZXIucnRsICYmIGRpcmVjdGlvbiA9PT0gJ3J0bCcgfHwgIXN3aXBlci5ydGwgJiYgZGlyZWN0aW9uID09PSAnbHRyJykgcmV0dXJuO1xuICAgICAgICBzd2lwZXIucnRsID0gZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgc3dpcGVyLnJ0bFRyYW5zbGF0ZSA9IHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgc3dpcGVyLnJ0bDtcblxuICAgICAgICBpZiAoc3dpcGVyLnJ0bCkge1xuICAgICAgICAgIHN3aXBlci4kZWwuYWRkQ2xhc3MoYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXJ0bGApO1xuICAgICAgICAgIHN3aXBlci5lbC5kaXIgPSAncnRsJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuJGVsLnJlbW92ZUNsYXNzKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ydGxgKTtcbiAgICAgICAgICBzd2lwZXIuZWwuZGlyID0gJ2x0cic7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIG1vdW50KGVsKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChzd2lwZXIubW91bnRlZCkgcmV0dXJuIHRydWU7IC8vIEZpbmQgZWxcblxuICAgICAgICBjb25zdCAkZWwgPSAkKGVsIHx8IHN3aXBlci5wYXJhbXMuZWwpO1xuICAgICAgICBlbCA9ICRlbFswXTtcblxuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuc3dpcGVyID0gc3dpcGVyO1xuXG4gICAgICAgIGNvbnN0IGdldFdyYXBwZXJTZWxlY3RvciA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gYC4keyhzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzcyB8fCAnJykudHJpbSgpLnNwbGl0KCcgJykuam9pbignLicpfWA7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZ2V0V3JhcHBlciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoZWwgJiYgZWwuc2hhZG93Um9vdCAmJiBlbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9ICQoZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGdldFdyYXBwZXJTZWxlY3RvcigpKSk7IC8vIENoaWxkcmVuIG5lZWRzIHRvIHJldHVybiBzbG90IGl0ZW1zXG5cbiAgICAgICAgICAgIHJlcy5jaGlsZHJlbiA9IG9wdGlvbnMgPT4gJGVsLmNoaWxkcmVuKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghJGVsLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm4gJCgkZWwpLmNoaWxkcmVuKGdldFdyYXBwZXJTZWxlY3RvcigpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJGVsLmNoaWxkcmVuKGdldFdyYXBwZXJTZWxlY3RvcigpKTtcbiAgICAgICAgfTsgLy8gRmluZCBXcmFwcGVyXG5cblxuICAgICAgICBsZXQgJHdyYXBwZXJFbCA9IGdldFdyYXBwZXIoKTtcblxuICAgICAgICBpZiAoJHdyYXBwZXJFbC5sZW5ndGggPT09IDAgJiYgc3dpcGVyLnBhcmFtcy5jcmVhdGVFbGVtZW50cykge1xuICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgJHdyYXBwZXJFbCA9ICQod3JhcHBlcik7XG4gICAgICAgICAgd3JhcHBlci5jbGFzc05hbWUgPSBzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzcztcbiAgICAgICAgICAkZWwuYXBwZW5kKHdyYXBwZXIpO1xuICAgICAgICAgICRlbC5jaGlsZHJlbihgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWApLmVhY2goc2xpZGVFbCA9PiB7XG4gICAgICAgICAgICAkd3JhcHBlckVsLmFwcGVuZChzbGlkZUVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgICAgICAgJGVsLFxuICAgICAgICAgIGVsLFxuICAgICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgICAgd3JhcHBlckVsOiAkd3JhcHBlckVsWzBdLFxuICAgICAgICAgIG1vdW50ZWQ6IHRydWUsXG4gICAgICAgICAgLy8gUlRMXG4gICAgICAgICAgcnRsOiBlbC5kaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCcgfHwgJGVsLmNzcygnZGlyZWN0aW9uJykgPT09ICdydGwnLFxuICAgICAgICAgIHJ0bFRyYW5zbGF0ZTogc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiAoZWwuZGlyLnRvTG93ZXJDYXNlKCkgPT09ICdydGwnIHx8ICRlbC5jc3MoJ2RpcmVjdGlvbicpID09PSAncnRsJyksXG4gICAgICAgICAgd3JvbmdSVEw6ICR3cmFwcGVyRWwuY3NzKCdkaXNwbGF5JykgPT09ICctd2Via2l0LWJveCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpbml0KGVsKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybiBzd2lwZXI7XG4gICAgICAgIGNvbnN0IG1vdW50ZWQgPSBzd2lwZXIubW91bnQoZWwpO1xuICAgICAgICBpZiAobW91bnRlZCA9PT0gZmFsc2UpIHJldHVybiBzd2lwZXI7XG4gICAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVJbml0Jyk7IC8vIFNldCBicmVha3BvaW50XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYnJlYWtwb2ludHMpIHtcbiAgICAgICAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xuICAgICAgICB9IC8vIEFkZCBDbGFzc2VzXG5cblxuICAgICAgICBzd2lwZXIuYWRkQ2xhc3NlcygpOyAvLyBDcmVhdGUgbG9vcFxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xuICAgICAgICB9IC8vIFVwZGF0ZSBzaXplXG5cblxuICAgICAgICBzd2lwZXIudXBkYXRlU2l6ZSgpOyAvLyBVcGRhdGUgc2xpZGVzXG5cbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cpIHtcbiAgICAgICAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICAgICAgICB9IC8vIFNldCBHcmFiIEN1cnNvclxuXG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvciAmJiBzd2lwZXIuZW5hYmxlZCkge1xuICAgICAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5wcmVsb2FkSW1hZ2VzKSB7XG4gICAgICAgICAgc3dpcGVyLnByZWxvYWRJbWFnZXMoKTtcbiAgICAgICAgfSAvLyBTbGlkZSBUbyBJbml0aWFsIFNsaWRlXG5cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnBhcmFtcy5pbml0aWFsU2xpZGUgKyBzd2lwZXIubG9vcGVkU2xpZGVzLCAwLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlLCAwLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IC8vIEF0dGFjaCBldmVudHNcblxuXG4gICAgICAgIHN3aXBlci5hdHRhY2hFdmVudHMoKTsgLy8gSW5pdCBGbGFnXG5cbiAgICAgICAgc3dpcGVyLmluaXRpYWxpemVkID0gdHJ1ZTsgLy8gRW1pdFxuXG4gICAgICAgIHN3aXBlci5lbWl0KCdpbml0Jyk7XG4gICAgICAgIHN3aXBlci5lbWl0KCdhZnRlckluaXQnKTtcbiAgICAgICAgcmV0dXJuIHN3aXBlcjtcbiAgICAgIH1cblxuICAgICAgZGVzdHJveShkZWxldGVJbnN0YW5jZSwgY2xlYW5TdHlsZXMpIHtcbiAgICAgICAgaWYgKGRlbGV0ZUluc3RhbmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkZWxldGVJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xlYW5TdHlsZXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNsZWFuU3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgJGVsLFxuICAgICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgICAgc2xpZGVzXG4gICAgICAgIH0gPSBzd2lwZXI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zID09PSAndW5kZWZpbmVkJyB8fCBzd2lwZXIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlRGVzdHJveScpOyAvLyBJbml0IEZsYWdcblxuICAgICAgICBzd2lwZXIuaW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy8gRGV0YWNoIGV2ZW50c1xuXG4gICAgICAgIHN3aXBlci5kZXRhY2hFdmVudHMoKTsgLy8gRGVzdHJveSBsb29wXG5cbiAgICAgICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gICAgICAgIH0gLy8gQ2xlYW51cCBzdHlsZXNcblxuXG4gICAgICAgIGlmIChjbGVhblN0eWxlcykge1xuICAgICAgICAgIHN3aXBlci5yZW1vdmVDbGFzc2VzKCk7XG4gICAgICAgICAgJGVsLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG4gICAgICAgICAgJHdyYXBwZXJFbC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXG4gICAgICAgICAgaWYgKHNsaWRlcyAmJiBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzbGlkZXMucmVtb3ZlQ2xhc3MoW3BhcmFtcy5zbGlkZVZpc2libGVDbGFzcywgcGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MsIHBhcmFtcy5zbGlkZU5leHRDbGFzcywgcGFyYW1zLnNsaWRlUHJldkNsYXNzXS5qb2luKCcgJykpLnJlbW92ZUF0dHIoJ3N0eWxlJykucmVtb3ZlQXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZW1pdCgnZGVzdHJveScpOyAvLyBEZXRhY2ggZW1pdHRlciBldmVudHNcblxuICAgICAgICBPYmplY3Qua2V5cyhzd2lwZXIuZXZlbnRzTGlzdGVuZXJzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgICAgc3dpcGVyLm9mZihldmVudE5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGVsZXRlSW5zdGFuY2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgc3dpcGVyLiRlbFswXS5zd2lwZXIgPSBudWxsO1xuICAgICAgICAgIGRlbGV0ZVByb3BzKHN3aXBlcik7XG4gICAgICAgIH1cblxuICAgICAgICBzd2lwZXIuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBleHRlbmREZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICAgICAgICBleHRlbmQkMShleHRlbmRlZERlZmF1bHRzLCBuZXdEZWZhdWx0cyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBnZXQgZXh0ZW5kZWREZWZhdWx0cygpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZGVkRGVmYXVsdHM7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGluc3RhbGxNb2R1bGUobW9kKSB7XG4gICAgICAgIGlmICghU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXykgU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXyA9IFtdO1xuICAgICAgICBjb25zdCBtb2R1bGVzID0gU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXztcblxuICAgICAgICBpZiAodHlwZW9mIG1vZCA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGVzLmluZGV4T2YobW9kKSA8IDApIHtcbiAgICAgICAgICBtb2R1bGVzLnB1c2gobW9kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0aWMgdXNlKG1vZHVsZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtb2R1bGUpKSB7XG4gICAgICAgICAgbW9kdWxlLmZvckVhY2gobSA9PiBTd2lwZXIuaW5zdGFsbE1vZHVsZShtKSk7XG4gICAgICAgICAgcmV0dXJuIFN3aXBlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIFN3aXBlci5pbnN0YWxsTW9kdWxlKG1vZHVsZSk7XG4gICAgICAgIHJldHVybiBTd2lwZXI7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhwcm90b3R5cGVzKS5mb3JFYWNoKHByb3RvdHlwZUdyb3VwID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHByb3RvdHlwZXNbcHJvdG90eXBlR3JvdXBdKS5mb3JFYWNoKHByb3RvTWV0aG9kID0+IHtcbiAgICAgICAgU3dpcGVyLnByb3RvdHlwZVtwcm90b01ldGhvZF0gPSBwcm90b3R5cGVzW3Byb3RvdHlwZUdyb3VwXVtwcm90b01ldGhvZF07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBTd2lwZXIudXNlKFtSZXNpemUsIE9ic2VydmVyXSk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuICAgIGZ1bmN0aW9uIE1vdXNld2hlZWwoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgc3dpcGVyLFxuICAgICAgICBleHRlbmRQYXJhbXMsXG4gICAgICAgIG9uLFxuICAgICAgICBlbWl0XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgZXh0ZW5kUGFyYW1zKHtcbiAgICAgICAgbW91c2V3aGVlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcbiAgICAgICAgICBpbnZlcnQ6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlVG9BeGlzOiBmYWxzZSxcbiAgICAgICAgICBzZW5zaXRpdml0eTogMSxcbiAgICAgICAgICBldmVudHNUYXJnZXQ6ICdjb250YWluZXInLFxuICAgICAgICAgIHRocmVzaG9sZERlbHRhOiBudWxsLFxuICAgICAgICAgIHRocmVzaG9sZFRpbWU6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzd2lwZXIubW91c2V3aGVlbCA9IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgdGltZW91dDtcbiAgICAgIGxldCBsYXN0U2Nyb2xsVGltZSA9IG5vdygpO1xuICAgICAgbGV0IGxhc3RFdmVudEJlZm9yZVNuYXA7XG4gICAgICBjb25zdCByZWNlbnRXaGVlbEV2ZW50cyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBub3JtYWxpemUoZSkge1xuICAgICAgICAvLyBSZWFzb25hYmxlIGRlZmF1bHRzXG4gICAgICAgIGNvbnN0IFBJWEVMX1NURVAgPSAxMDtcbiAgICAgICAgY29uc3QgTElORV9IRUlHSFQgPSA0MDtcbiAgICAgICAgY29uc3QgUEFHRV9IRUlHSFQgPSA4MDA7XG4gICAgICAgIGxldCBzWCA9IDA7XG4gICAgICAgIGxldCBzWSA9IDA7IC8vIHNwaW5YLCBzcGluWVxuXG4gICAgICAgIGxldCBwWCA9IDA7XG4gICAgICAgIGxldCBwWSA9IDA7IC8vIHBpeGVsWCwgcGl4ZWxZXG4gICAgICAgIC8vIExlZ2FjeVxuXG4gICAgICAgIGlmICgnZGV0YWlsJyBpbiBlKSB7XG4gICAgICAgICAgc1kgPSBlLmRldGFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnd2hlZWxEZWx0YScgaW4gZSkge1xuICAgICAgICAgIHNZID0gLWUud2hlZWxEZWx0YSAvIDEyMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnd2hlZWxEZWx0YVknIGluIGUpIHtcbiAgICAgICAgICBzWSA9IC1lLndoZWVsRGVsdGFZIC8gMTIwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCd3aGVlbERlbHRhWCcgaW4gZSkge1xuICAgICAgICAgIHNYID0gLWUud2hlZWxEZWx0YVggLyAxMjA7XG4gICAgICAgIH0gLy8gc2lkZSBzY3JvbGxpbmcgb24gRkYgd2l0aCBET01Nb3VzZVNjcm9sbFxuXG5cbiAgICAgICAgaWYgKCdheGlzJyBpbiBlICYmIGUuYXhpcyA9PT0gZS5IT1JJWk9OVEFMX0FYSVMpIHtcbiAgICAgICAgICBzWCA9IHNZO1xuICAgICAgICAgIHNZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBYID0gc1ggKiBQSVhFTF9TVEVQO1xuICAgICAgICBwWSA9IHNZICogUElYRUxfU1RFUDtcblxuICAgICAgICBpZiAoJ2RlbHRhWScgaW4gZSkge1xuICAgICAgICAgIHBZID0gZS5kZWx0YVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2RlbHRhWCcgaW4gZSkge1xuICAgICAgICAgIHBYID0gZS5kZWx0YVg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiAhcFgpIHtcbiAgICAgICAgICAvLyBpZiB1c2VyIHNjcm9sbHMgd2l0aCBzaGlmdCBoZSB3YW50cyBob3Jpem9udGFsIHNjcm9sbFxuICAgICAgICAgIHBYID0gcFk7XG4gICAgICAgICAgcFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwWCB8fCBwWSkgJiYgZS5kZWx0YU1vZGUpIHtcbiAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGRlbHRhIGluIExJTkUgdW5pdHNcbiAgICAgICAgICAgIHBYICo9IExJTkVfSEVJR0hUO1xuICAgICAgICAgICAgcFkgKj0gTElORV9IRUlHSFQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlbHRhIGluIFBBR0UgdW5pdHNcbiAgICAgICAgICAgIHBYICo9IFBBR0VfSEVJR0hUO1xuICAgICAgICAgICAgcFkgKj0gUEFHRV9IRUlHSFQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEZhbGwtYmFjayBpZiBzcGluIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG5cblxuICAgICAgICBpZiAocFggJiYgIXNYKSB7XG4gICAgICAgICAgc1ggPSBwWCA8IDEgPyAtMSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocFkgJiYgIXNZKSB7XG4gICAgICAgICAgc1kgPSBwWSA8IDEgPyAtMSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwaW5YOiBzWCxcbiAgICAgICAgICBzcGluWTogc1ksXG4gICAgICAgICAgcGl4ZWxYOiBwWCxcbiAgICAgICAgICBwaXhlbFk6IHBZXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRW50ZXIoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLm1vdXNlRW50ZXJlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLm1vdXNlRW50ZXJlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhbmltYXRlU2xpZGVyKG5ld0V2ZW50KSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkRGVsdGEgJiYgbmV3RXZlbnQuZGVsdGEgPCBzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkRGVsdGEpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGlmIGRlbHRhIG9mIHdoZWVsIHNjcm9sbCBkZWx0YSBpcyBiZWxvdyBjb25maWd1cmVkIHRocmVzaG9sZFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkVGltZSAmJiBub3coKSAtIGxhc3RTY3JvbGxUaW1lIDwgc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLnRocmVzaG9sZFRpbWUpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGlmIHRpbWUgYmV0d2VlbiBzY3JvbGxzIGlzIGJlbG93IGNvbmZpZ3VyZWQgdGhyZXNob2xkXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIElmIHRoZSBtb3ZlbWVudCBpcyBOT1QgYmlnIGVub3VnaCBhbmRcbiAgICAgICAgLy8gaWYgdGhlIGxhc3QgdGltZSB0aGUgdXNlciBzY3JvbGxlZCB3YXMgdG9vIGNsb3NlIHRvIHRoZSBjdXJyZW50IG9uZSAoYXZvaWQgY29udGludW91c2x5IHRyaWdnZXJpbmcgdGhlIHNsaWRlcik6XG4gICAgICAgIC8vICAgRG9uJ3QgZ28gYW55IGZ1cnRoZXIgKGF2b2lkIGluc2lnbmlmaWNhbnQgc2Nyb2xsIG1vdmVtZW50KS5cblxuXG4gICAgICAgIGlmIChuZXdFdmVudC5kZWx0YSA+PSA2ICYmIG5vdygpIC0gbGFzdFNjcm9sbFRpbWUgPCA2MCkge1xuICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBhcyBhIGRlZmF1bHRcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBJZiB1c2VyIGlzIHNjcm9sbGluZyB0b3dhcmRzIHRoZSBlbmQ6XG4gICAgICAgIC8vICAgSWYgdGhlIHNsaWRlciBoYXNuJ3QgaGl0IHRoZSBsYXRlc3Qgc2xpZGUgb3JcbiAgICAgICAgLy8gICBpZiB0aGUgc2xpZGVyIGlzIGEgbG9vcCBhbmRcbiAgICAgICAgLy8gICBpZiB0aGUgc2xpZGVyIGlzbid0IG1vdmluZyByaWdodCBub3c6XG4gICAgICAgIC8vICAgICBHbyB0byBuZXh0IHNsaWRlIGFuZFxuICAgICAgICAvLyAgICAgZW1pdCBhIHNjcm9sbCBldmVudC5cbiAgICAgICAgLy8gRWxzZSAodGhlIHVzZXIgaXMgc2Nyb2xsaW5nIHRvd2FyZHMgdGhlIGJlZ2lubmluZykgYW5kXG4gICAgICAgIC8vIGlmIHRoZSBzbGlkZXIgaGFzbid0IGhpdCB0aGUgZmlyc3Qgc2xpZGUgb3JcbiAgICAgICAgLy8gaWYgdGhlIHNsaWRlciBpcyBhIGxvb3AgYW5kXG4gICAgICAgIC8vIGlmIHRoZSBzbGlkZXIgaXNuJ3QgbW92aW5nIHJpZ2h0IG5vdzpcbiAgICAgICAgLy8gICBHbyB0byBwcmV2IHNsaWRlIGFuZFxuICAgICAgICAvLyAgIGVtaXQgYSBzY3JvbGwgZXZlbnQuXG5cblxuICAgICAgICBpZiAobmV3RXZlbnQuZGlyZWN0aW9uIDwgMCkge1xuICAgICAgICAgIGlmICgoIXN3aXBlci5pc0VuZCB8fCBzd2lwZXIucGFyYW1zLmxvb3ApICYmICFzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVOZXh0KCk7XG4gICAgICAgICAgICBlbWl0KCdzY3JvbGwnLCBuZXdFdmVudC5yYXcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgoIXN3aXBlci5pc0JlZ2lubmluZyB8fCBzd2lwZXIucGFyYW1zLmxvb3ApICYmICFzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlUHJldigpO1xuICAgICAgICAgIGVtaXQoJ3Njcm9sbCcsIG5ld0V2ZW50LnJhdyk7XG4gICAgICAgIH0gLy8gSWYgeW91IGdvdCBoZXJlIGlzIGJlY2F1c2UgYW4gYW5pbWF0aW9uIGhhcyBiZWVuIHRyaWdnZXJlZCBzbyBzdG9yZSB0aGUgY3VycmVudCB0aW1lXG5cblxuICAgICAgICBsYXN0U2Nyb2xsVGltZSA9IG5ldyB3aW5kb3cuRGF0ZSgpLmdldFRpbWUoKTsgLy8gUmV0dXJuIGZhbHNlIGFzIGEgZGVmYXVsdFxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVsZWFzZVNjcm9sbChuZXdFdmVudCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm1vdXNld2hlZWw7XG5cbiAgICAgICAgaWYgKG5ld0V2ZW50LmRpcmVjdGlvbiA8IDApIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgcGFyYW1zLnJlbGVhc2VPbkVkZ2VzKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdHJ1ZSB0byBhbmltYXRlIHNjcm9sbCBvbiBlZGdlc1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0JlZ2lubmluZyAmJiAhc3dpcGVyLnBhcmFtcy5sb29wICYmIHBhcmFtcy5yZWxlYXNlT25FZGdlcykge1xuICAgICAgICAgIC8vIFJldHVybiB0cnVlIHRvIGFuaW1hdGUgc2Nyb2xsIG9uIGVkZ2VzXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShldmVudCkge1xuICAgICAgICBsZXQgZSA9IGV2ZW50O1xuICAgICAgICBsZXQgZGlzYWJsZVBhcmVudFN3aXBlciA9IHRydWU7XG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGFyZ2V0ID0gc3dpcGVyLiRlbDtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCAhPT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgICB0YXJnZXQgPSAkKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzd2lwZXIubW91c2VFbnRlcmVkICYmICF0YXJnZXRbMF0uY29udGFpbnMoZS50YXJnZXQpICYmICFwYXJhbXMucmVsZWFzZU9uRWRnZXMpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50OyAvLyBqcXVlcnkgZml4XG5cbiAgICAgICAgbGV0IGRlbHRhID0gMDtcbiAgICAgICAgY29uc3QgcnRsRmFjdG9yID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5vcm1hbGl6ZShlKTtcblxuICAgICAgICBpZiAocGFyYW1zLmZvcmNlVG9BeGlzKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRhdGEucGl4ZWxYKSA+IE1hdGguYWJzKGRhdGEucGl4ZWxZKSkgZGVsdGEgPSAtZGF0YS5waXhlbFggKiBydGxGYWN0b3I7ZWxzZSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRhdGEucGl4ZWxZKSA+IE1hdGguYWJzKGRhdGEucGl4ZWxYKSkgZGVsdGEgPSAtZGF0YS5waXhlbFk7ZWxzZSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YSA9IE1hdGguYWJzKGRhdGEucGl4ZWxYKSA+IE1hdGguYWJzKGRhdGEucGl4ZWxZKSA/IC1kYXRhLnBpeGVsWCAqIHJ0bEZhY3RvciA6IC1kYXRhLnBpeGVsWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChwYXJhbXMuaW52ZXJ0KSBkZWx0YSA9IC1kZWx0YTsgLy8gR2V0IHRoZSBzY3JvbGwgcG9zaXRpb25zXG5cbiAgICAgICAgbGV0IHBvc2l0aW9ucyA9IHN3aXBlci5nZXRUcmFuc2xhdGUoKSArIGRlbHRhICogcGFyYW1zLnNlbnNpdGl2aXR5O1xuICAgICAgICBpZiAocG9zaXRpb25zID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkgcG9zaXRpb25zID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICBpZiAocG9zaXRpb25zIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkgcG9zaXRpb25zID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpOyAvLyBXaGVuIGxvb3AgaXMgdHJ1ZTpcbiAgICAgICAgLy8gICAgIHRoZSBkaXNhYmxlUGFyZW50U3dpcGVyIHdpbGwgYmUgdHJ1ZS5cbiAgICAgICAgLy8gV2hlbiBsb29wIGlzIGZhbHNlOlxuICAgICAgICAvLyAgICAgaWYgdGhlIHNjcm9sbCBwb3NpdGlvbnMgaXMgbm90IG9uIGVkZ2UsXG4gICAgICAgIC8vICAgICB0aGVuIHRoZSBkaXNhYmxlUGFyZW50U3dpcGVyIHdpbGwgYmUgdHJ1ZS5cbiAgICAgICAgLy8gICAgIGlmIHRoZSBzY3JvbGwgb24gZWRnZSBwb3NpdGlvbnMsXG4gICAgICAgIC8vICAgICB0aGVuIHRoZSBkaXNhYmxlUGFyZW50U3dpcGVyIHdpbGwgYmUgZmFsc2UuXG5cbiAgICAgICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IHN3aXBlci5wYXJhbXMubG9vcCA/IHRydWUgOiAhKHBvc2l0aW9ucyA9PT0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIHx8IHBvc2l0aW9ucyA9PT0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKTtcbiAgICAgICAgaWYgKGRpc2FibGVQYXJlbnRTd2lwZXIgJiYgc3dpcGVyLnBhcmFtcy5uZXN0ZWQpIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmZyZWVNb2RlIHx8ICFzd2lwZXIucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQpIHtcbiAgICAgICAgICAvLyBSZWdpc3RlciB0aGUgbmV3IGV2ZW50IGluIGEgdmFyaWFibGUgd2hpY2ggc3RvcmVzIHRoZSByZWxldmFudCBkYXRhXG4gICAgICAgICAgY29uc3QgbmV3RXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgIGRlbHRhOiBNYXRoLmFicyhkZWx0YSksXG4gICAgICAgICAgICBkaXJlY3Rpb246IE1hdGguc2lnbihkZWx0YSksXG4gICAgICAgICAgICByYXc6IGV2ZW50XG4gICAgICAgICAgfTsgLy8gS2VlcCB0aGUgbW9zdCByZWNlbnQgZXZlbnRzXG5cbiAgICAgICAgICBpZiAocmVjZW50V2hlZWxFdmVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHJlY2VudFdoZWVsRXZlbnRzLnNoaWZ0KCk7IC8vIG9ubHkgc3RvcmUgdGhlIGxhc3QgTiBldmVudHNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwcmV2RXZlbnQgPSByZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggPyByZWNlbnRXaGVlbEV2ZW50c1tyZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5wdXNoKG5ld0V2ZW50KTsgLy8gSWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByZXZpb3VzIHJlY29yZGVkIGV2ZW50OlxuICAgICAgICAgIC8vICAgSWYgZGlyZWN0aW9uIGhhcyBjaGFuZ2VkIG9yXG4gICAgICAgICAgLy8gICBpZiB0aGUgc2Nyb2xsIGlzIHF1aWNrZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lOlxuICAgICAgICAgIC8vICAgICBBbmltYXRlIHRoZSBzbGlkZXIuXG4gICAgICAgICAgLy8gRWxzZSAodGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgd2hlZWwgaXMgbW92ZWQpOlxuICAgICAgICAgIC8vICAgICBBbmltYXRlIHRoZSBzbGlkZXIuXG5cbiAgICAgICAgICBpZiAocHJldkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAobmV3RXZlbnQuZGlyZWN0aW9uICE9PSBwcmV2RXZlbnQuZGlyZWN0aW9uIHx8IG5ld0V2ZW50LmRlbHRhID4gcHJldkV2ZW50LmRlbHRhIHx8IG5ld0V2ZW50LnRpbWUgPiBwcmV2RXZlbnQudGltZSArIDE1MCkge1xuICAgICAgICAgICAgICBhbmltYXRlU2xpZGVyKG5ld0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5pbWF0ZVNsaWRlcihuZXdFdmVudCk7XG4gICAgICAgICAgfSAvLyBJZiBpdCdzIHRpbWUgdG8gcmVsZWFzZSB0aGUgc2Nyb2xsOlxuICAgICAgICAgIC8vICAgUmV0dXJuIG5vdyBzbyB5b3UgZG9uJ3QgaGl0IHRoZSBwcmV2ZW50RGVmYXVsdC5cblxuXG4gICAgICAgICAgaWYgKHJlbGVhc2VTY3JvbGwobmV3RXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRnJlZW1vZGUgb3Igc2Nyb2xsQ29udGFpbmVyOlxuICAgICAgICAgIC8vIElmIHdlIHJlY2VudGx5IHNuYXBwZWQgYWZ0ZXIgYSBtb21lbnR1bSBzY3JvbGwsIHRoZW4gaWdub3JlIHdoZWVsIGV2ZW50c1xuICAgICAgICAgIC8vIHRvIGdpdmUgdGltZSBmb3IgdGhlIGRlY2VsZXJhdGlvbiB0byBmaW5pc2guIFN0b3AgaWdub3JpbmcgYWZ0ZXIgNTAwIG1zZWNzXG4gICAgICAgICAgLy8gb3IgaWYgaXQncyBhIG5ldyBzY3JvbGwgKGxhcmdlciBkZWx0YSBvciBpbnZlcnNlIHNpZ24gYXMgbGFzdCBldmVudCBiZWZvcmVcbiAgICAgICAgICAvLyBhbiBlbmQtb2YtbW9tZW50dW0gc25hcCkuXG4gICAgICAgICAgY29uc3QgbmV3RXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgIGRlbHRhOiBNYXRoLmFicyhkZWx0YSksXG4gICAgICAgICAgICBkaXJlY3Rpb246IE1hdGguc2lnbihkZWx0YSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGlnbm9yZVdoZWVsRXZlbnRzID0gbGFzdEV2ZW50QmVmb3JlU25hcCAmJiBuZXdFdmVudC50aW1lIDwgbGFzdEV2ZW50QmVmb3JlU25hcC50aW1lICsgNTAwICYmIG5ld0V2ZW50LmRlbHRhIDw9IGxhc3RFdmVudEJlZm9yZVNuYXAuZGVsdGEgJiYgbmV3RXZlbnQuZGlyZWN0aW9uID09PSBsYXN0RXZlbnRCZWZvcmVTbmFwLmRpcmVjdGlvbjtcblxuICAgICAgICAgIGlmICghaWdub3JlV2hlZWxFdmVudHMpIHtcbiAgICAgICAgICAgIGxhc3RFdmVudEJlZm9yZVNuYXAgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpICsgZGVsdGEgKiBwYXJhbXMuc2Vuc2l0aXZpdHk7XG4gICAgICAgICAgICBjb25zdCB3YXNCZWdpbm5pbmcgPSBzd2lwZXIuaXNCZWdpbm5pbmc7XG4gICAgICAgICAgICBjb25zdCB3YXNFbmQgPSBzd2lwZXIuaXNFbmQ7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSBwb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHBvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuXG4gICAgICAgICAgICBpZiAoIXdhc0JlZ2lubmluZyAmJiBzd2lwZXIuaXNCZWdpbm5pbmcgfHwgIXdhc0VuZCAmJiBzd2lwZXIuaXNFbmQpIHtcbiAgICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUuc3RpY2t5KSB7XG4gICAgICAgICAgICAgIC8vIFdoZW4gd2hlZWwgc2Nyb2xsaW5nIHN0YXJ0cyB3aXRoIHN0aWNreSAoYWthIHNuYXApIGVuYWJsZWQsIHRoZW4gZGV0ZWN0XG4gICAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgYSBtb21lbnR1bSBzY3JvbGwgYnkgc3RvcmluZyByZWNlbnQgKE49MTU/KSB3aGVlbCBldmVudHMuXG4gICAgICAgICAgICAgIC8vIDEuIGRvIGFsbCBOIGV2ZW50cyBoYXZlIGRlY3JlYXNpbmcgb3Igc2FtZSAoYWJzb2x1dGUgdmFsdWUpIGRlbHRhP1xuICAgICAgICAgICAgICAvLyAyLiBkaWQgYWxsIE4gZXZlbnRzIGFycml2ZSBpbiB0aGUgbGFzdCBNIChNPTUwMD8pIG1zZWNzP1xuICAgICAgICAgICAgICAvLyAzLiBkb2VzIHRoZSBlYXJsaWVzdCBldmVudCBoYXZlIGFuIChhYnNvbHV0ZSB2YWx1ZSkgZGVsdGEgdGhhdCdzXG4gICAgICAgICAgICAgIC8vICAgIGF0IGxlYXN0IFAgKFA9MT8pIGxhcmdlciB0aGFuIHRoZSBtb3N0IHJlY2VudCBldmVudCdzIGRlbHRhP1xuICAgICAgICAgICAgICAvLyA0LiBkb2VzIHRoZSBsYXRlc3QgZXZlbnQgaGF2ZSBhIGRlbHRhIHRoYXQncyBzbWFsbGVyIHRoYW4gUSAoUT02PykgcGl4ZWxzP1xuICAgICAgICAgICAgICAvLyBJZiAxLTQgYXJlIFwieWVzXCIgdGhlbiB3ZSdyZSBuZWFyIHRoZSBlbmQgb2YgYSBtb21lbnR1bSBzY3JvbGwgZGVjZWxlcmF0aW9uLlxuICAgICAgICAgICAgICAvLyBTbmFwIGltbWVkaWF0ZWx5IGFuZCBpZ25vcmUgcmVtYWluaW5nIHdoZWVsIGV2ZW50cyBpbiB0aGlzIHNjcm9sbC5cbiAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgZm9yIFwicmVtYWluaW5nIHdoZWVsIGV2ZW50cyBpbiB0aGlzIHNjcm9sbFwiIGRldGVybWluYXRpb24uXG4gICAgICAgICAgICAgIC8vIElmIDEtNCBhcmVuJ3Qgc2F0aXNmaWVkLCB0aGVuIHdhaXQgdG8gc25hcCB1bnRpbCA1MDBtcyBhZnRlciB0aGUgbGFzdCBldmVudC5cbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIGlmIChyZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggPj0gMTUpIHtcbiAgICAgICAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5zaGlmdCgpOyAvLyBvbmx5IHN0b3JlIHRoZSBsYXN0IE4gZXZlbnRzXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBwcmV2RXZlbnQgPSByZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggPyByZWNlbnRXaGVlbEV2ZW50c1tyZWNlbnRXaGVlbEV2ZW50cy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RFdmVudCA9IHJlY2VudFdoZWVsRXZlbnRzWzBdO1xuICAgICAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5wdXNoKG5ld0V2ZW50KTtcblxuICAgICAgICAgICAgICBpZiAocHJldkV2ZW50ICYmIChuZXdFdmVudC5kZWx0YSA+IHByZXZFdmVudC5kZWx0YSB8fCBuZXdFdmVudC5kaXJlY3Rpb24gIT09IHByZXZFdmVudC5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5jcmVhc2luZyBvciByZXZlcnNlLXNpZ24gZGVsdGEgbWVhbnMgdGhlIHVzZXIgc3RhcnRlZCBzY3JvbGxpbmcgYWdhaW4uIENsZWFyIHRoZSB3aGVlbCBldmVudCBsb2cuXG4gICAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlY2VudFdoZWVsRXZlbnRzLmxlbmd0aCA+PSAxNSAmJiBuZXdFdmVudC50aW1lIC0gZmlyc3RFdmVudC50aW1lIDwgNTAwICYmIGZpcnN0RXZlbnQuZGVsdGEgLSBuZXdFdmVudC5kZWx0YSA+PSAxICYmIG5ld0V2ZW50LmRlbHRhIDw9IDYpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBkZWNlbGVyYXRpb24gb2YgYSBtb21lbnR1bSBzY3JvbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAgICAgICAgICAgICAgIC8vIHRvIHdhaXQgZm9yIG1vcmUgZXZlbnRzLiBTbmFwIEFTQVAgb24gdGhlIG5leHQgdGljay5cbiAgICAgICAgICAgICAgICAvLyBBbHNvLCBiZWNhdXNlIHRoZXJlJ3Mgc29tZSByZW1haW5pbmcgbW9tZW50dW0gd2UnbGwgYmlhcyB0aGUgc25hcCBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBkaXJlY3Rpb24gb2YgdGhlIG9uZ29pbmcgc2Nyb2xsIGJlY2F1c2UgaXQncyBiZXR0ZXIgVVggZm9yIHRoZSBzY3JvbGwgdG8gc25hcFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGUgc2Nyb2xsIGluc3RlYWQgb2YgcmV2ZXJzaW5nIHRvIHNuYXAuICBUaGVyZWZvcmUsXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbHJlYWR5IHNjcm9sbGVkIG1vcmUgdGhhbiAyMCUgaW4gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBrZWVwIGdvaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IHNuYXBUb1RocmVzaG9sZCA9IGRlbHRhID4gMCA/IDAuOCA6IDAuMjtcbiAgICAgICAgICAgICAgICBsYXN0RXZlbnRCZWZvcmVTbmFwID0gbmV3RXZlbnQ7XG4gICAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3Qoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdW5kZWZpbmVkLCBzbmFwVG9UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgIH0sIDApOyAvLyBubyBkZWxheTsgbW92ZSBvbiBuZXh0IHRpY2tcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGdldCBoZXJlLCB0aGVuIHdlIGhhdmVuJ3QgZGV0ZWN0ZWQgdGhlIGVuZCBvZiBhIG1vbWVudHVtIHNjcm9sbCwgc29cbiAgICAgICAgICAgICAgICAvLyB3ZSdsbCBjb25zaWRlciBhIHNjcm9sbCBcImNvbXBsZXRlXCIgd2hlbiB0aGVyZSBoYXZlbid0IGJlZW4gYW55IHdoZWVsIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIGZvciA1MDBtcy5cbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc25hcFRvVGhyZXNob2xkID0gMC41O1xuICAgICAgICAgICAgICAgICAgbGFzdEV2ZW50QmVmb3JlU25hcCA9IG5ld0V2ZW50O1xuICAgICAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHVuZGVmaW5lZCwgc25hcFRvVGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIEVtaXQgZXZlbnRcblxuXG4gICAgICAgICAgICBpZiAoIWlnbm9yZVdoZWVsRXZlbnRzKSBlbWl0KCdzY3JvbGwnLCBlKTsgLy8gU3RvcCBhdXRvcGxheVxuXG4gICAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheSAmJiBzd2lwZXIucGFyYW1zLmF1dG9wbGF5RGlzYWJsZU9uSW50ZXJhY3Rpb24pIHN3aXBlci5hdXRvcGxheS5zdG9wKCk7IC8vIFJldHVybiBwYWdlIHNjcm9sbCBvbiBlZGdlIHBvc2l0aW9uc1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IHN3aXBlci5taW5UcmFuc2xhdGUoKSB8fCBwb3NpdGlvbiA9PT0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGV2ZW50cyhtZXRob2QpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHN3aXBlci4kZWw7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQgIT09ICdjb250YWluZXInKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gJChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFttZXRob2RdKCdtb3VzZWVudGVyJywgaGFuZGxlTW91c2VFbnRlcik7XG4gICAgICAgIHRhcmdldFttZXRob2RdKCdtb3VzZWxlYXZlJywgaGFuZGxlTW91c2VMZWF2ZSk7XG4gICAgICAgIHRhcmdldFttZXRob2RdKCd3aGVlbCcsIGhhbmRsZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICAgIHN3aXBlci53cmFwcGVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBoYW5kbGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZXZlbnRzKCdvbicpO1xuICAgICAgICBzd2lwZXIubW91c2V3aGVlbC5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZXZlbnRzKCdvZmYnKTtcbiAgICAgICAgc3dpcGVyLm1vdXNld2hlZWwuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgICAgZGlzYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5lbmFibGVkKSBlbmFibGUoKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBlbmFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIubW91c2V3aGVlbC5lbmFibGVkKSBkaXNhYmxlKCk7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLm1vdXNld2hlZWwsIHtcbiAgICAgICAgZW5hYmxlLFxuICAgICAgICBkaXNhYmxlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkKHN3aXBlciwgb3JpZ2luYWxQYXJhbXMsIHBhcmFtcywgY2hlY2tQcm9wcykge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jcmVhdGVFbGVtZW50cykge1xuICAgICAgICBPYmplY3Qua2V5cyhjaGVja1Byb3BzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgaWYgKCFwYXJhbXNba2V5XSAmJiBwYXJhbXMuYXV0byA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBzd2lwZXIuJGVsLmNoaWxkcmVuKGAuJHtjaGVja1Byb3BzW2tleV19YClbMF07XG5cbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2hlY2tQcm9wc1trZXldO1xuICAgICAgICAgICAgICBzd2lwZXIuJGVsLmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyYW1zW2tleV0gPSBlbGVtZW50O1xuICAgICAgICAgICAgb3JpZ2luYWxQYXJhbXNba2V5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgICBvbixcbiAgICAgICAgZW1pdFxuICAgICAgfSA9IF9yZWY7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBuYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgbmV4dEVsOiBudWxsLFxuICAgICAgICAgIHByZXZFbDogbnVsbCxcbiAgICAgICAgICBoaWRlT25DbGljazogZmFsc2UsXG4gICAgICAgICAgZGlzYWJsZWRDbGFzczogJ3N3aXBlci1idXR0b24tZGlzYWJsZWQnLFxuICAgICAgICAgIGhpZGRlbkNsYXNzOiAnc3dpcGVyLWJ1dHRvbi1oaWRkZW4nLFxuICAgICAgICAgIGxvY2tDbGFzczogJ3N3aXBlci1idXR0b24tbG9jaycsXG4gICAgICAgICAgbmF2aWdhdGlvbkRpc2FibGVkQ2xhc3M6ICdzd2lwZXItbmF2aWdhdGlvbi1kaXNhYmxlZCdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzd2lwZXIubmF2aWdhdGlvbiA9IHtcbiAgICAgICAgbmV4dEVsOiBudWxsLFxuICAgICAgICAkbmV4dEVsOiBudWxsLFxuICAgICAgICBwcmV2RWw6IG51bGwsXG4gICAgICAgICRwcmV2RWw6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGdldEVsKGVsKSB7XG4gICAgICAgIGxldCAkZWw7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgJGVsID0gJChlbCk7XG5cbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnICYmICRlbC5sZW5ndGggPiAxICYmIHN3aXBlci4kZWwuZmluZChlbCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAkZWwgPSBzd2lwZXIuJGVsLmZpbmQoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkZWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRvZ2dsZUVsKCRlbCwgZGlzYWJsZWQpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uO1xuXG4gICAgICAgIGlmICgkZWwgJiYgJGVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAkZWxbZGlzYWJsZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10ocGFyYW1zLmRpc2FibGVkQ2xhc3MpO1xuICAgICAgICAgIGlmICgkZWxbMF0gJiYgJGVsWzBdLnRhZ05hbWUgPT09ICdCVVRUT04nKSAkZWxbMF0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICRlbFtzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10ocGFyYW1zLmxvY2tDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gVXBkYXRlIE5hdmlnYXRpb24gQnV0dG9uc1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkbmV4dEVsLFxuICAgICAgICAgICRwcmV2RWxcbiAgICAgICAgfSA9IHN3aXBlci5uYXZpZ2F0aW9uO1xuICAgICAgICB0b2dnbGVFbCgkcHJldkVsLCBzd2lwZXIuaXNCZWdpbm5pbmcgJiYgIXN3aXBlci5wYXJhbXMucmV3aW5kKTtcbiAgICAgICAgdG9nZ2xlRWwoJG5leHRFbCwgc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLnJld2luZCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUHJldkNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgIXN3aXBlci5wYXJhbXMucmV3aW5kKSByZXR1cm47XG4gICAgICAgIHN3aXBlci5zbGlkZVByZXYoKTtcbiAgICAgICAgZW1pdCgnbmF2aWdhdGlvblByZXYnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25OZXh0Q2xpY2soZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5wYXJhbXMubG9vcCAmJiAhc3dpcGVyLnBhcmFtcy5yZXdpbmQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLnNsaWRlTmV4dCgpO1xuICAgICAgICBlbWl0KCduYXZpZ2F0aW9uTmV4dCcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb247XG4gICAgICAgIHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbiA9IGNyZWF0ZUVsZW1lbnRJZk5vdERlZmluZWQoc3dpcGVyLCBzd2lwZXIub3JpZ2luYWxQYXJhbXMubmF2aWdhdGlvbiwgc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLCB7XG4gICAgICAgICAgbmV4dEVsOiAnc3dpcGVyLWJ1dHRvbi1uZXh0JyxcbiAgICAgICAgICBwcmV2RWw6ICdzd2lwZXItYnV0dG9uLXByZXYnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIShwYXJhbXMubmV4dEVsIHx8IHBhcmFtcy5wcmV2RWwpKSByZXR1cm47XG4gICAgICAgIGNvbnN0ICRuZXh0RWwgPSBnZXRFbChwYXJhbXMubmV4dEVsKTtcbiAgICAgICAgY29uc3QgJHByZXZFbCA9IGdldEVsKHBhcmFtcy5wcmV2RWwpO1xuXG4gICAgICAgIGlmICgkbmV4dEVsICYmICRuZXh0RWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICRuZXh0RWwub24oJ2NsaWNrJywgb25OZXh0Q2xpY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRwcmV2RWwgJiYgJHByZXZFbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgJHByZXZFbC5vbignY2xpY2snLCBvblByZXZDbGljayk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKHN3aXBlci5uYXZpZ2F0aW9uLCB7XG4gICAgICAgICAgJG5leHRFbCxcbiAgICAgICAgICBuZXh0RWw6ICRuZXh0RWwgJiYgJG5leHRFbFswXSxcbiAgICAgICAgICAkcHJldkVsLFxuICAgICAgICAgIHByZXZFbDogJHByZXZFbCAmJiAkcHJldkVsWzBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoJG5leHRFbCkgJG5leHRFbC5hZGRDbGFzcyhwYXJhbXMubG9ja0NsYXNzKTtcbiAgICAgICAgICBpZiAoJHByZXZFbCkgJHByZXZFbC5hZGRDbGFzcyhwYXJhbXMubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJG5leHRFbCxcbiAgICAgICAgICAkcHJldkVsXG4gICAgICAgIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcblxuICAgICAgICBpZiAoJG5leHRFbCAmJiAkbmV4dEVsLmxlbmd0aCkge1xuICAgICAgICAgICRuZXh0RWwub2ZmKCdjbGljaycsIG9uTmV4dENsaWNrKTtcbiAgICAgICAgICAkbmV4dEVsLnJlbW92ZUNsYXNzKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5kaXNhYmxlZENsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcHJldkVsICYmICRwcmV2RWwubGVuZ3RoKSB7XG4gICAgICAgICAgJHByZXZFbC5vZmYoJ2NsaWNrJywgb25QcmV2Q2xpY2spO1xuICAgICAgICAgICRwcmV2RWwucmVtb3ZlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgZGlzYWJsZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbigndG9FZGdlIGZyb21FZGdlIGxvY2sgdW5sb2NrJywgKCkgPT4ge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIGRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2VuYWJsZSBkaXNhYmxlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJG5leHRFbCxcbiAgICAgICAgICAkcHJldkVsXG4gICAgICAgIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcblxuICAgICAgICBpZiAoJG5leHRFbCkge1xuICAgICAgICAgICRuZXh0RWxbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmxvY2tDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJHByZXZFbCkge1xuICAgICAgICAgICRwcmV2RWxbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmxvY2tDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2NsaWNrJywgKF9zLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkbmV4dEVsLFxuICAgICAgICAgICRwcmV2RWxcbiAgICAgICAgfSA9IHN3aXBlci5uYXZpZ2F0aW9uO1xuICAgICAgICBjb25zdCB0YXJnZXRFbCA9IGUudGFyZ2V0O1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZU9uQ2xpY2sgJiYgISQodGFyZ2V0RWwpLmlzKCRwcmV2RWwpICYmICEkKHRhcmdldEVsKS5pcygkbmV4dEVsKSkge1xuICAgICAgICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbiAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24gJiYgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmNsaWNrYWJsZSAmJiAoc3dpcGVyLnBhZ2luYXRpb24uZWwgPT09IHRhcmdldEVsIHx8IHN3aXBlci5wYWdpbmF0aW9uLmVsLmNvbnRhaW5zKHRhcmdldEVsKSkpIHJldHVybjtcbiAgICAgICAgICBsZXQgaXNIaWRkZW47XG5cbiAgICAgICAgICBpZiAoJG5leHRFbCkge1xuICAgICAgICAgICAgaXNIaWRkZW4gPSAkbmV4dEVsLmhhc0NsYXNzKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICgkcHJldkVsKSB7XG4gICAgICAgICAgICBpc0hpZGRlbiA9ICRwcmV2RWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGVtaXQoJ25hdmlnYXRpb25TaG93Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVtaXQoJ25hdmlnYXRpb25IaWRlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCRuZXh0RWwpIHtcbiAgICAgICAgICAgICRuZXh0RWwudG9nZ2xlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHByZXZFbCkge1xuICAgICAgICAgICAgJHByZXZFbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVuYWJsZSA9ICgpID0+IHtcbiAgICAgICAgc3dpcGVyLiRlbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24ubmF2aWdhdGlvbkRpc2FibGVkQ2xhc3MpO1xuICAgICAgICBpbml0KCk7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZGlzYWJsZSA9ICgpID0+IHtcbiAgICAgICAgc3dpcGVyLiRlbC5hZGRDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24ubmF2aWdhdGlvbkRpc2FibGVkQ2xhc3MpO1xuICAgICAgICBkZXN0cm95KCk7XG4gICAgICB9O1xuXG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlci5uYXZpZ2F0aW9uLCB7XG4gICAgICAgIGVuYWJsZSxcbiAgICAgICAgZGlzYWJsZSxcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBpbml0LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFzc2VzVG9TZWxlY3RvcihjbGFzc2VzKSB7XG4gICAgICBpZiAoY2xhc3NlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNsYXNzZXMgPSAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGAuJHtjbGFzc2VzLnRyaW0oKS5yZXBsYWNlKC8oW1xcLjohXFwvXSkvZywgJ1xcXFwkMScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgLnJlcGxhY2UoLyAvZywgJy4nKX1gO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBhZ2luYXRpb24oX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgc3dpcGVyLFxuICAgICAgICBleHRlbmRQYXJhbXMsXG4gICAgICAgIG9uLFxuICAgICAgICBlbWl0XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IHBmeCA9ICdzd2lwZXItcGFnaW5hdGlvbic7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgICAgZWw6IG51bGwsXG4gICAgICAgICAgYnVsbGV0RWxlbWVudDogJ3NwYW4nLFxuICAgICAgICAgIGNsaWNrYWJsZTogZmFsc2UsXG4gICAgICAgICAgaGlkZU9uQ2xpY2s6IGZhbHNlLFxuICAgICAgICAgIHJlbmRlckJ1bGxldDogbnVsbCxcbiAgICAgICAgICByZW5kZXJQcm9ncmVzc2JhcjogbnVsbCxcbiAgICAgICAgICByZW5kZXJGcmFjdGlvbjogbnVsbCxcbiAgICAgICAgICByZW5kZXJDdXN0b206IG51bGwsXG4gICAgICAgICAgcHJvZ3Jlc3NiYXJPcHBvc2l0ZTogZmFsc2UsXG4gICAgICAgICAgdHlwZTogJ2J1bGxldHMnLFxuICAgICAgICAgIC8vICdidWxsZXRzJyBvciAncHJvZ3Jlc3NiYXInIG9yICdmcmFjdGlvbicgb3IgJ2N1c3RvbSdcbiAgICAgICAgICBkeW5hbWljQnVsbGV0czogZmFsc2UsXG4gICAgICAgICAgZHluYW1pY01haW5CdWxsZXRzOiAxLFxuICAgICAgICAgIGZvcm1hdEZyYWN0aW9uQ3VycmVudDogbnVtYmVyID0+IG51bWJlcixcbiAgICAgICAgICBmb3JtYXRGcmFjdGlvblRvdGFsOiBudW1iZXIgPT4gbnVtYmVyLFxuICAgICAgICAgIGJ1bGxldENsYXNzOiBgJHtwZnh9LWJ1bGxldGAsXG4gICAgICAgICAgYnVsbGV0QWN0aXZlQ2xhc3M6IGAke3BmeH0tYnVsbGV0LWFjdGl2ZWAsXG4gICAgICAgICAgbW9kaWZpZXJDbGFzczogYCR7cGZ4fS1gLFxuICAgICAgICAgIGN1cnJlbnRDbGFzczogYCR7cGZ4fS1jdXJyZW50YCxcbiAgICAgICAgICB0b3RhbENsYXNzOiBgJHtwZnh9LXRvdGFsYCxcbiAgICAgICAgICBoaWRkZW5DbGFzczogYCR7cGZ4fS1oaWRkZW5gLFxuICAgICAgICAgIHByb2dyZXNzYmFyRmlsbENsYXNzOiBgJHtwZnh9LXByb2dyZXNzYmFyLWZpbGxgLFxuICAgICAgICAgIHByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzczogYCR7cGZ4fS1wcm9ncmVzc2Jhci1vcHBvc2l0ZWAsXG4gICAgICAgICAgY2xpY2thYmxlQ2xhc3M6IGAke3BmeH0tY2xpY2thYmxlYCxcbiAgICAgICAgICBsb2NrQ2xhc3M6IGAke3BmeH0tbG9ja2AsXG4gICAgICAgICAgaG9yaXpvbnRhbENsYXNzOiBgJHtwZnh9LWhvcml6b250YWxgLFxuICAgICAgICAgIHZlcnRpY2FsQ2xhc3M6IGAke3BmeH0tdmVydGljYWxgLFxuICAgICAgICAgIHBhZ2luYXRpb25EaXNhYmxlZENsYXNzOiBgJHtwZnh9LWRpc2FibGVkYFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uID0ge1xuICAgICAgICBlbDogbnVsbCxcbiAgICAgICAgJGVsOiBudWxsLFxuICAgICAgICBidWxsZXRzOiBbXVxuICAgICAgfTtcbiAgICAgIGxldCBidWxsZXRTaXplO1xuICAgICAgbGV0IGR5bmFtaWNCdWxsZXRJbmRleCA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIGlzUGFnaW5hdGlvbkRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gIXN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uZWwgfHwgIXN3aXBlci5wYWdpbmF0aW9uLiRlbCB8fCBzd2lwZXIucGFnaW5hdGlvbi4kZWwubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRTaWRlQnVsbGV0cygkYnVsbGV0RWwsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBidWxsZXRBY3RpdmVDbGFzc1xuICAgICAgICB9ID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgICAgICAkYnVsbGV0RWxbcG9zaXRpb25dKCkuYWRkQ2xhc3MoYCR7YnVsbGV0QWN0aXZlQ2xhc3N9LSR7cG9zaXRpb259YClbcG9zaXRpb25dKCkuYWRkQ2xhc3MoYCR7YnVsbGV0QWN0aXZlQ2xhc3N9LSR7cG9zaXRpb259LSR7cG9zaXRpb259YCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gUmVuZGVyIHx8IFVwZGF0ZSBQYWdpbmF0aW9uIGJ1bGxldHMvaXRlbXNcbiAgICAgICAgY29uc3QgcnRsID0gc3dpcGVyLnJ0bDtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgICAgICBpZiAoaXNQYWdpbmF0aW9uRGlzYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgJGVsID0gc3dpcGVyLnBhZ2luYXRpb24uJGVsOyAvLyBDdXJyZW50L1RvdGFsXG5cbiAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gc3dpcGVyLnBhcmFtcy5sb29wID8gTWF0aC5jZWlsKChzbGlkZXNMZW5ndGggLSBzd2lwZXIubG9vcGVkU2xpZGVzICogMikgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKSA6IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBNYXRoLmNlaWwoKHN3aXBlci5hY3RpdmVJbmRleCAtIHN3aXBlci5sb29wZWRTbGlkZXMpIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCA+IHNsaWRlc0xlbmd0aCAtIDEgLSBzd2lwZXIubG9vcGVkU2xpZGVzICogMikge1xuICAgICAgICAgICAgY3VycmVudCAtPSBzbGlkZXNMZW5ndGggLSBzd2lwZXIubG9vcGVkU2xpZGVzICogMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudCA+IHRvdGFsIC0gMSkgY3VycmVudCAtPSB0b3RhbDtcbiAgICAgICAgICBpZiAoY3VycmVudCA8IDAgJiYgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uVHlwZSAhPT0gJ2J1bGxldHMnKSBjdXJyZW50ID0gdG90YWwgKyBjdXJyZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzd2lwZXIuc25hcEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGN1cnJlbnQgPSBzd2lwZXIuc25hcEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnQgPSBzd2lwZXIuYWN0aXZlSW5kZXggfHwgMDtcbiAgICAgICAgfSAvLyBUeXBlc1xuXG5cbiAgICAgICAgaWYgKHBhcmFtcy50eXBlID09PSAnYnVsbGV0cycgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBidWxsZXRzID0gc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cztcbiAgICAgICAgICBsZXQgZmlyc3RJbmRleDtcbiAgICAgICAgICBsZXQgbGFzdEluZGV4O1xuICAgICAgICAgIGxldCBtaWRJbmRleDtcblxuICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgICAgIGJ1bGxldFNpemUgPSBidWxsZXRzLmVxKDApW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdvdXRlcldpZHRoJyA6ICdvdXRlckhlaWdodCddKHRydWUpO1xuICAgICAgICAgICAgJGVsLmNzcyhzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnd2lkdGgnIDogJ2hlaWdodCcsIGAke2J1bGxldFNpemUgKiAocGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyArIDQpfXB4YCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzID4gMSAmJiBzd2lwZXIucHJldmlvdXNJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGR5bmFtaWNCdWxsZXRJbmRleCArPSBjdXJyZW50IC0gKHN3aXBlci5wcmV2aW91c0luZGV4IC0gc3dpcGVyLmxvb3BlZFNsaWRlcyB8fCAwKTtcblxuICAgICAgICAgICAgICBpZiAoZHluYW1pY0J1bGxldEluZGV4ID4gcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyAtIDEpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljQnVsbGV0SW5kZXggPSBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIC0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkeW5hbWljQnVsbGV0SW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0J1bGxldEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gTWF0aC5tYXgoY3VycmVudCAtIGR5bmFtaWNCdWxsZXRJbmRleCwgMCk7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBmaXJzdEluZGV4ICsgKE1hdGgubWluKGJ1bGxldHMubGVuZ3RoLCBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzKSAtIDEpO1xuICAgICAgICAgICAgbWlkSW5kZXggPSAobGFzdEluZGV4ICsgZmlyc3RJbmRleCkgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJ1bGxldHMucmVtb3ZlQ2xhc3MoWycnLCAnLW5leHQnLCAnLW5leHQtbmV4dCcsICctcHJldicsICctcHJldi1wcmV2JywgJy1tYWluJ10ubWFwKHN1ZmZpeCA9PiBgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9JHtzdWZmaXh9YCkuam9pbignICcpKTtcblxuICAgICAgICAgIGlmICgkZWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYnVsbGV0cy5lYWNoKGJ1bGxldCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0ICRidWxsZXQgPSAkKGJ1bGxldCk7XG4gICAgICAgICAgICAgIGNvbnN0IGJ1bGxldEluZGV4ID0gJGJ1bGxldC5pbmRleCgpO1xuXG4gICAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICRidWxsZXQuYWRkQ2xhc3MocGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPj0gZmlyc3RJbmRleCAmJiBidWxsZXRJbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICRidWxsZXQuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1tYWluYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJ1bGxldEluZGV4ID09PSBmaXJzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBzZXRTaWRlQnVsbGV0cygkYnVsbGV0LCAncHJldicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBzZXRTaWRlQnVsbGV0cygkYnVsbGV0LCAnbmV4dCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0ICRidWxsZXQgPSBidWxsZXRzLmVxKGN1cnJlbnQpO1xuICAgICAgICAgICAgY29uc3QgYnVsbGV0SW5kZXggPSAkYnVsbGV0LmluZGV4KCk7XG4gICAgICAgICAgICAkYnVsbGV0LmFkZENsYXNzKHBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcyk7XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgJGZpcnN0RGlzcGxheWVkQnVsbGV0ID0gYnVsbGV0cy5lcShmaXJzdEluZGV4KTtcbiAgICAgICAgICAgICAgY29uc3QgJGxhc3REaXNwbGF5ZWRCdWxsZXQgPSBidWxsZXRzLmVxKGxhc3RJbmRleCk7XG5cbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0SW5kZXg7IGkgPD0gbGFzdEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBidWxsZXRzLmVxKGkpLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbWFpbmApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA+PSBidWxsZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHM7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1bGxldHMuZXEoYnVsbGV0cy5sZW5ndGggLSBpKS5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnVsbGV0cy5lcShidWxsZXRzLmxlbmd0aCAtIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxKS5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LXByZXZgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2V0U2lkZUJ1bGxldHMoJGZpcnN0RGlzcGxheWVkQnVsbGV0LCAncHJldicpO1xuICAgICAgICAgICAgICAgICAgc2V0U2lkZUJ1bGxldHMoJGxhc3REaXNwbGF5ZWRCdWxsZXQsICduZXh0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFNpZGVCdWxsZXRzKCRmaXJzdERpc3BsYXllZEJ1bGxldCwgJ3ByZXYnKTtcbiAgICAgICAgICAgICAgICBzZXRTaWRlQnVsbGV0cygkbGFzdERpc3BsYXllZEJ1bGxldCwgJ25leHQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNCdWxsZXRzTGVuZ3RoID0gTWF0aC5taW4oYnVsbGV0cy5sZW5ndGgsIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgKyA0KTtcbiAgICAgICAgICAgIGNvbnN0IGJ1bGxldHNPZmZzZXQgPSAoYnVsbGV0U2l6ZSAqIGR5bmFtaWNCdWxsZXRzTGVuZ3RoIC0gYnVsbGV0U2l6ZSkgLyAyIC0gbWlkSW5kZXggKiBidWxsZXRTaXplO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0UHJvcCA9IHJ0bCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICBidWxsZXRzLmNzcyhzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBvZmZzZXRQcm9wIDogJ3RvcCcsIGAke2J1bGxldHNPZmZzZXR9cHhgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICAkZWwuZmluZChjbGFzc2VzVG9TZWxlY3RvcihwYXJhbXMuY3VycmVudENsYXNzKSkudGV4dChwYXJhbXMuZm9ybWF0RnJhY3Rpb25DdXJyZW50KGN1cnJlbnQgKyAxKSk7XG4gICAgICAgICAgJGVsLmZpbmQoY2xhc3Nlc1RvU2VsZWN0b3IocGFyYW1zLnRvdGFsQ2xhc3MpKS50ZXh0KHBhcmFtcy5mb3JtYXRGcmFjdGlvblRvdGFsKHRvdGFsKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdwcm9ncmVzc2JhcicpIHtcbiAgICAgICAgICBsZXQgcHJvZ3Jlc3NiYXJEaXJlY3Rpb247XG5cbiAgICAgICAgICBpZiAocGFyYW1zLnByb2dyZXNzYmFyT3Bwb3NpdGUpIHtcbiAgICAgICAgICAgIHByb2dyZXNzYmFyRGlyZWN0aW9uID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvZ3Jlc3NiYXJEaXJlY3Rpb24gPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnaG9yaXpvbnRhbCcgOiAndmVydGljYWwnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHNjYWxlID0gKGN1cnJlbnQgKyAxKSAvIHRvdGFsO1xuICAgICAgICAgIGxldCBzY2FsZVggPSAxO1xuICAgICAgICAgIGxldCBzY2FsZVkgPSAxO1xuXG4gICAgICAgICAgaWYgKHByb2dyZXNzYmFyRGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZVkgPSBzY2FsZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkZWwuZmluZChjbGFzc2VzVG9TZWxlY3RvcihwYXJhbXMucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MpKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZVgoJHtzY2FsZVh9KSBzY2FsZVkoJHtzY2FsZVl9KWApLnRyYW5zaXRpb24oc3dpcGVyLnBhcmFtcy5zcGVlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdjdXN0b20nICYmIHBhcmFtcy5yZW5kZXJDdXN0b20pIHtcbiAgICAgICAgICAkZWwuaHRtbChwYXJhbXMucmVuZGVyQ3VzdG9tKHN3aXBlciwgY3VycmVudCArIDEsIHRvdGFsKSk7XG4gICAgICAgICAgZW1pdCgncGFnaW5hdGlvblJlbmRlcicsICRlbFswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW1pdCgncGFnaW5hdGlvblVwZGF0ZScsICRlbFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5lbmFibGVkKSB7XG4gICAgICAgICAgJGVsW3N3aXBlci5pc0xvY2tlZCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShwYXJhbXMubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIC8vIFJlbmRlciBDb250YWluZXJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgICAgICBpZiAoaXNQYWdpbmF0aW9uRGlzYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgJGVsID0gc3dpcGVyLnBhZ2luYXRpb24uJGVsO1xuICAgICAgICBsZXQgcGFnaW5hdGlvbkhUTUwgPSAnJztcblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJykge1xuICAgICAgICAgIGxldCBudW1iZXJPZkJ1bGxldHMgPSBzd2lwZXIucGFyYW1zLmxvb3AgPyBNYXRoLmNlaWwoKHNsaWRlc0xlbmd0aCAtIHN3aXBlci5sb29wZWRTbGlkZXMgKiAyKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogc3dpcGVyLnNuYXBHcmlkLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZyZWVNb2RlICYmIHN3aXBlci5wYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCAmJiAhc3dpcGVyLnBhcmFtcy5sb29wICYmIG51bWJlck9mQnVsbGV0cyA+IHNsaWRlc0xlbmd0aCkge1xuICAgICAgICAgICAgbnVtYmVyT2ZCdWxsZXRzID0gc2xpZGVzTGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZCdWxsZXRzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucmVuZGVyQnVsbGV0KSB7XG4gICAgICAgICAgICAgIHBhZ2luYXRpb25IVE1MICs9IHBhcmFtcy5yZW5kZXJCdWxsZXQuY2FsbChzd2lwZXIsIGksIHBhcmFtcy5idWxsZXRDbGFzcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYWdpbmF0aW9uSFRNTCArPSBgPCR7cGFyYW1zLmJ1bGxldEVsZW1lbnR9IGNsYXNzPVwiJHtwYXJhbXMuYnVsbGV0Q2xhc3N9XCI+PC8ke3BhcmFtcy5idWxsZXRFbGVtZW50fT5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbC5odG1sKHBhZ2luYXRpb25IVE1MKTtcbiAgICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzID0gJGVsLmZpbmQoY2xhc3Nlc1RvU2VsZWN0b3IocGFyYW1zLmJ1bGxldENsYXNzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLnJlbmRlckZyYWN0aW9uKSB7XG4gICAgICAgICAgICBwYWdpbmF0aW9uSFRNTCA9IHBhcmFtcy5yZW5kZXJGcmFjdGlvbi5jYWxsKHN3aXBlciwgcGFyYW1zLmN1cnJlbnRDbGFzcywgcGFyYW1zLnRvdGFsQ2xhc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWdpbmF0aW9uSFRNTCA9IGA8c3BhbiBjbGFzcz1cIiR7cGFyYW1zLmN1cnJlbnRDbGFzc31cIj48L3NwYW4+YCArICcgLyAnICsgYDxzcGFuIGNsYXNzPVwiJHtwYXJhbXMudG90YWxDbGFzc31cIj48L3NwYW4+YDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdwcm9ncmVzc2JhcicpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLnJlbmRlclByb2dyZXNzYmFyKSB7XG4gICAgICAgICAgICBwYWdpbmF0aW9uSFRNTCA9IHBhcmFtcy5yZW5kZXJQcm9ncmVzc2Jhci5jYWxsKHN3aXBlciwgcGFyYW1zLnByb2dyZXNzYmFyRmlsbENsYXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFnaW5hdGlvbkhUTUwgPSBgPHNwYW4gY2xhc3M9XCIke3BhcmFtcy5wcm9ncmVzc2JhckZpbGxDbGFzc31cIj48L3NwYW4+YDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdjdXN0b20nKSB7XG4gICAgICAgICAgZW1pdCgncGFnaW5hdGlvblJlbmRlcicsIHN3aXBlci5wYWdpbmF0aW9uLiRlbFswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uID0gY3JlYXRlRWxlbWVudElmTm90RGVmaW5lZChzd2lwZXIsIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5wYWdpbmF0aW9uLCBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24sIHtcbiAgICAgICAgICBlbDogJ3N3aXBlci1wYWdpbmF0aW9uJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgICAgICBpZiAoIXBhcmFtcy5lbCkgcmV0dXJuO1xuICAgICAgICBsZXQgJGVsID0gJChwYXJhbXMuZWwpO1xuICAgICAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmIHR5cGVvZiBwYXJhbXMuZWwgPT09ICdzdHJpbmcnICYmICRlbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgJGVsID0gc3dpcGVyLiRlbC5maW5kKHBhcmFtcy5lbCk7IC8vIGNoZWNrIGlmIGl0IGJlbG9uZ3MgdG8gYW5vdGhlciBuZXN0ZWQgU3dpcGVyXG5cbiAgICAgICAgICBpZiAoJGVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICRlbCA9ICRlbC5maWx0ZXIoZWwgPT4ge1xuICAgICAgICAgICAgICBpZiAoJChlbCkucGFyZW50cygnLnN3aXBlcicpWzBdICE9PSBzd2lwZXIuZWwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJyAmJiBwYXJhbXMuY2xpY2thYmxlKSB7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5jbGlja2FibGVDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICAkZWwuYWRkQ2xhc3MocGFyYW1zLm1vZGlmaWVyQ2xhc3MgKyBwYXJhbXMudHlwZSk7XG4gICAgICAgICRlbC5hZGRDbGFzcyhzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBwYXJhbXMuaG9yaXpvbnRhbENsYXNzIDogcGFyYW1zLnZlcnRpY2FsQ2xhc3MpO1xuXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xuICAgICAgICAgICRlbC5hZGRDbGFzcyhgJHtwYXJhbXMubW9kaWZpZXJDbGFzc30ke3BhcmFtcy50eXBlfS1keW5hbWljYCk7XG4gICAgICAgICAgZHluYW1pY0J1bGxldEluZGV4ID0gMDtcblxuICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIDwgMSkge1xuICAgICAgICAgICAgcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy50eXBlID09PSAncHJvZ3Jlc3NiYXInICYmIHBhcmFtcy5wcm9ncmVzc2Jhck9wcG9zaXRlKSB7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5wcm9ncmVzc2Jhck9wcG9zaXRlQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5jbGlja2FibGUpIHtcbiAgICAgICAgICAkZWwub24oJ2NsaWNrJywgY2xhc3Nlc1RvU2VsZWN0b3IocGFyYW1zLmJ1bGxldENsYXNzKSwgZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkKHRoaXMpLmluZGV4KCkgKiBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkgaW5kZXggKz0gc3dpcGVyLmxvb3BlZFNsaWRlcztcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLnBhZ2luYXRpb24sIHtcbiAgICAgICAgICAkZWwsXG4gICAgICAgICAgZWw6ICRlbFswXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXN3aXBlci5lbmFibGVkKSB7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5sb2NrQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcbiAgICAgICAgaWYgKGlzUGFnaW5hdGlvbkRpc2FibGVkKCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgJGVsID0gc3dpcGVyLnBhZ2luYXRpb24uJGVsO1xuICAgICAgICAkZWwucmVtb3ZlQ2xhc3MocGFyYW1zLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKHBhcmFtcy5tb2RpZmllckNsYXNzICsgcGFyYW1zLnR5cGUpO1xuICAgICAgICAkZWwucmVtb3ZlQ2xhc3Moc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gcGFyYW1zLmhvcml6b250YWxDbGFzcyA6IHBhcmFtcy52ZXJ0aWNhbENsYXNzKTtcbiAgICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5yZW1vdmVDbGFzcykgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5yZW1vdmVDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xuXG4gICAgICAgIGlmIChwYXJhbXMuY2xpY2thYmxlKSB7XG4gICAgICAgICAgJGVsLm9mZignY2xpY2snLCBjbGFzc2VzVG9TZWxlY3RvcihwYXJhbXMuYnVsbGV0Q2xhc3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgIGRpc2FibGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0KCk7XG4gICAgICAgICAgcmVuZGVyKCk7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2FjdGl2ZUluZGV4Q2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN3aXBlci5zbmFwSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ3NuYXBJbmRleENoYW5nZScsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignc2xpZGVzTGVuZ3RoQ2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgcmVuZGVyKCk7XG4gICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ3NuYXBHcmlkTGVuZ3RoQ2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICAgIHJlbmRlcigpO1xuICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICBkZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdlbmFibGUgZGlzYWJsZScsICgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbFxuICAgICAgICB9ID0gc3dpcGVyLnBhZ2luYXRpb247XG5cbiAgICAgICAgaWYgKCRlbCkge1xuICAgICAgICAgICRlbFtzd2lwZXIuZW5hYmxlZCA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnXShzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24ubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignbG9jayB1bmxvY2snLCAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBvbignY2xpY2snLCAoX3MsIGUpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSBlLnRhcmdldDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbFxuICAgICAgICB9ID0gc3dpcGVyLnBhZ2luYXRpb247XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5lbCAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZU9uQ2xpY2sgJiYgJGVsICYmICRlbC5sZW5ndGggPiAwICYmICEkKHRhcmdldEVsKS5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpKSB7XG4gICAgICAgICAgaWYgKHN3aXBlci5uYXZpZ2F0aW9uICYmIChzd2lwZXIubmF2aWdhdGlvbi5uZXh0RWwgJiYgdGFyZ2V0RWwgPT09IHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCB8fCBzd2lwZXIubmF2aWdhdGlvbi5wcmV2RWwgJiYgdGFyZ2V0RWwgPT09IHN3aXBlci5uYXZpZ2F0aW9uLnByZXZFbCkpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBpc0hpZGRlbiA9ICRlbC5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICBlbWl0KCdwYWdpbmF0aW9uU2hvdycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbWl0KCdwYWdpbmF0aW9uSGlkZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZW5hYmxlID0gKCkgPT4ge1xuICAgICAgICBzd2lwZXIuJGVsLnJlbW92ZUNsYXNzKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5wYWdpbmF0aW9uRGlzYWJsZWRDbGFzcyk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uLiRlbCkge1xuICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLiRlbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24ucGFnaW5hdGlvbkRpc2FibGVkQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdCgpO1xuICAgICAgICByZW5kZXIoKTtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBkaXNhYmxlID0gKCkgPT4ge1xuICAgICAgICBzd2lwZXIuJGVsLmFkZENsYXNzKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5wYWdpbmF0aW9uRGlzYWJsZWRDbGFzcyk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uLiRlbCkge1xuICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLiRlbC5hZGRDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24ucGFnaW5hdGlvbkRpc2FibGVkQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdHJveSgpO1xuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIucGFnaW5hdGlvbiwge1xuICAgICAgICBlbmFibGUsXG4gICAgICAgIGRpc2FibGUsXG4gICAgICAgIHJlbmRlcixcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBpbml0LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTY3JvbGxiYXIoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgc3dpcGVyLFxuICAgICAgICBleHRlbmRQYXJhbXMsXG4gICAgICAgIG9uLFxuICAgICAgICBlbWl0XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgIGxldCBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGxldCBkcmFnVGltZW91dCA9IG51bGw7XG4gICAgICBsZXQgZHJhZ1N0YXJ0UG9zO1xuICAgICAgbGV0IGRyYWdTaXplO1xuICAgICAgbGV0IHRyYWNrU2l6ZTtcbiAgICAgIGxldCBkaXZpZGVyO1xuICAgICAgZXh0ZW5kUGFyYW1zKHtcbiAgICAgICAgc2Nyb2xsYmFyOiB7XG4gICAgICAgICAgZWw6IG51bGwsXG4gICAgICAgICAgZHJhZ1NpemU6ICdhdXRvJyxcbiAgICAgICAgICBoaWRlOiBmYWxzZSxcbiAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgIHNuYXBPblJlbGVhc2U6IHRydWUsXG4gICAgICAgICAgbG9ja0NsYXNzOiAnc3dpcGVyLXNjcm9sbGJhci1sb2NrJyxcbiAgICAgICAgICBkcmFnQ2xhc3M6ICdzd2lwZXItc2Nyb2xsYmFyLWRyYWcnLFxuICAgICAgICAgIHNjcm9sbGJhckRpc2FibGVkQ2xhc3M6ICdzd2lwZXItc2Nyb2xsYmFyLWRpc2FibGVkJyxcbiAgICAgICAgICBob3Jpem9udGFsQ2xhc3M6IGBzd2lwZXItc2Nyb2xsYmFyLWhvcml6b250YWxgLFxuICAgICAgICAgIHZlcnRpY2FsQ2xhc3M6IGBzd2lwZXItc2Nyb2xsYmFyLXZlcnRpY2FsYFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIgPSB7XG4gICAgICAgIGVsOiBudWxsLFxuICAgICAgICBkcmFnRWw6IG51bGwsXG4gICAgICAgICRlbDogbnVsbCxcbiAgICAgICAgJGRyYWdFbDogbnVsbFxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlKCkge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsIHx8ICFzd2lwZXIuc2Nyb2xsYmFyLmVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzY3JvbGxiYXIsXG4gICAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgICAgcHJvZ3Jlc3NcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRkcmFnRWwsXG4gICAgICAgICAgJGVsXG4gICAgICAgIH0gPSBzY3JvbGxiYXI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyO1xuICAgICAgICBsZXQgbmV3U2l6ZSA9IGRyYWdTaXplO1xuICAgICAgICBsZXQgbmV3UG9zID0gKHRyYWNrU2l6ZSAtIGRyYWdTaXplKSAqIHByb2dyZXNzO1xuXG4gICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICBuZXdQb3MgPSAtbmV3UG9zO1xuXG4gICAgICAgICAgaWYgKG5ld1BvcyA+IDApIHtcbiAgICAgICAgICAgIG5ld1NpemUgPSBkcmFnU2l6ZSAtIG5ld1BvcztcbiAgICAgICAgICAgIG5ld1BvcyA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmICgtbmV3UG9zICsgZHJhZ1NpemUgPiB0cmFja1NpemUpIHtcbiAgICAgICAgICAgIG5ld1NpemUgPSB0cmFja1NpemUgKyBuZXdQb3M7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld1BvcyA8IDApIHtcbiAgICAgICAgICBuZXdTaXplID0gZHJhZ1NpemUgKyBuZXdQb3M7XG4gICAgICAgICAgbmV3UG9zID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChuZXdQb3MgKyBkcmFnU2l6ZSA+IHRyYWNrU2l6ZSkge1xuICAgICAgICAgIG5ld1NpemUgPSB0cmFja1NpemUgLSBuZXdQb3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgJGRyYWdFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7bmV3UG9zfXB4LCAwLCAwKWApO1xuICAgICAgICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSBgJHtuZXdTaXplfXB4YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZHJhZ0VsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMHB4LCAke25ld1Bvc31weCwgMClgKTtcbiAgICAgICAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9IGAke25ld1NpemV9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5oaWRlKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAkZWxbMF0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICAkZWwudHJhbnNpdGlvbig0MDApO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCB8fCAhc3dpcGVyLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgICAgICBzd2lwZXIuc2Nyb2xsYmFyLiRkcmFnRWwudHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNjcm9sbGJhclxuICAgICAgICB9ID0gc3dpcGVyO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJGRyYWdFbCxcbiAgICAgICAgICAkZWxcbiAgICAgICAgfSA9IHNjcm9sbGJhcjtcbiAgICAgICAgJGRyYWdFbFswXS5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICB0cmFja1NpemUgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAkZWxbMF0ub2Zmc2V0V2lkdGggOiAkZWxbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBkaXZpZGVyID0gc3dpcGVyLnNpemUgLyAoc3dpcGVyLnZpcnR1YWxTaXplICsgc3dpcGVyLnBhcmFtcy5zbGlkZXNPZmZzZXRCZWZvcmUgLSAoc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5zbmFwR3JpZFswXSA6IDApKTtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ1NpemUgPT09ICdhdXRvJykge1xuICAgICAgICAgIGRyYWdTaXplID0gdHJhY2tTaXplICogZGl2aWRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmFnU2l6ZSA9IHBhcnNlSW50KHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdTaXplLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgJGRyYWdFbFswXS5zdHlsZS53aWR0aCA9IGAke2RyYWdTaXplfXB4YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9IGAke2RyYWdTaXplfXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXZpZGVyID49IDEpIHtcbiAgICAgICAgICAkZWxbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZWxbMF0uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmhpZGUpIHtcbiAgICAgICAgICAkZWxbMF0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5lbmFibGVkKSB7XG4gICAgICAgICAgc2Nyb2xsYmFyLiRlbFtzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQb2ludGVyUG9zaXRpb24oZSkge1xuICAgICAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkgOiBlLmNsaWVudFk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldERyYWdQb3NpdGlvbihlKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzY3JvbGxiYXIsXG4gICAgICAgICAgcnRsVHJhbnNsYXRlOiBydGxcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbFxuICAgICAgICB9ID0gc2Nyb2xsYmFyO1xuICAgICAgICBsZXQgcG9zaXRpb25SYXRpbztcbiAgICAgICAgcG9zaXRpb25SYXRpbyA9IChnZXRQb2ludGVyUG9zaXRpb24oZSkgLSAkZWwub2Zmc2V0KClbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ2xlZnQnIDogJ3RvcCddIC0gKGRyYWdTdGFydFBvcyAhPT0gbnVsbCA/IGRyYWdTdGFydFBvcyA6IGRyYWdTaXplIC8gMikpIC8gKHRyYWNrU2l6ZSAtIGRyYWdTaXplKTtcbiAgICAgICAgcG9zaXRpb25SYXRpbyA9IE1hdGgubWF4KE1hdGgubWluKHBvc2l0aW9uUmF0aW8sIDEpLCAwKTtcblxuICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgcG9zaXRpb25SYXRpbyA9IDEgLSBwb3NpdGlvblJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCkgKyAoc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAqIHBvc2l0aW9uUmF0aW87XG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhwb3NpdGlvbik7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUocG9zaXRpb24pO1xuICAgICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25EcmFnU3RhcnQoZSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNjcm9sbGJhcixcbiAgICAgICAgICAkd3JhcHBlckVsXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkZWwsXG4gICAgICAgICAgJGRyYWdFbFxuICAgICAgICB9ID0gc2Nyb2xsYmFyO1xuICAgICAgICBpc1RvdWNoZWQgPSB0cnVlO1xuICAgICAgICBkcmFnU3RhcnRQb3MgPSBlLnRhcmdldCA9PT0gJGRyYWdFbFswXSB8fCBlLnRhcmdldCA9PT0gJGRyYWdFbCA/IGdldFBvaW50ZXJQb3NpdGlvbihlKSAtIGUudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdsZWZ0JyA6ICd0b3AnXSA6IG51bGw7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uKDEwMCk7XG4gICAgICAgICRkcmFnRWwudHJhbnNpdGlvbigxMDApO1xuICAgICAgICBzZXREcmFnUG9zaXRpb24oZSk7XG4gICAgICAgIGNsZWFyVGltZW91dChkcmFnVGltZW91dCk7XG4gICAgICAgICRlbC50cmFuc2l0aW9uKDApO1xuXG4gICAgICAgIGlmIChwYXJhbXMuaGlkZSkge1xuICAgICAgICAgICRlbC5jc3MoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC5jc3MoJ3Njcm9sbC1zbmFwLXR5cGUnLCAnbm9uZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdCgnc2Nyb2xsYmFyRHJhZ1N0YXJ0JywgZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRHJhZ01vdmUoZSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2Nyb2xsYmFyLFxuICAgICAgICAgICR3cmFwcGVyRWxcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbCxcbiAgICAgICAgICAkZHJhZ0VsXG4gICAgICAgIH0gPSBzY3JvbGxiYXI7XG4gICAgICAgIGlmICghaXNUb3VjaGVkKSByZXR1cm47XG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7ZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIHNldERyYWdQb3NpdGlvbihlKTtcbiAgICAgICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uKDApO1xuICAgICAgICAkZWwudHJhbnNpdGlvbigwKTtcbiAgICAgICAgJGRyYWdFbC50cmFuc2l0aW9uKDApO1xuICAgICAgICBlbWl0KCdzY3JvbGxiYXJEcmFnTW92ZScsIGUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkRyYWdFbmQoZSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNjcm9sbGJhcixcbiAgICAgICAgICAkd3JhcHBlckVsXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkZWxcbiAgICAgICAgfSA9IHNjcm9sbGJhcjtcbiAgICAgICAgaWYgKCFpc1RvdWNoZWQpIHJldHVybjtcbiAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsLmNzcygnc2Nyb2xsLXNuYXAtdHlwZScsICcnKTtcbiAgICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb24oJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5oaWRlKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGRyYWdUaW1lb3V0KTtcbiAgICAgICAgICBkcmFnVGltZW91dCA9IG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICRlbC5jc3MoJ29wYWNpdHknLCAwKTtcbiAgICAgICAgICAgICRlbC50cmFuc2l0aW9uKDQwMCk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KCdzY3JvbGxiYXJEcmFnRW5kJywgZSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5zbmFwT25SZWxlYXNlKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXZlbnRzKG1ldGhvZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2Nyb2xsYmFyLFxuICAgICAgICAgIHRvdWNoRXZlbnRzVG91Y2gsXG4gICAgICAgICAgdG91Y2hFdmVudHNEZXNrdG9wLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICBzdXBwb3J0XG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGNvbnN0ICRlbCA9IHNjcm9sbGJhci4kZWw7XG4gICAgICAgIGlmICghJGVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRhcmdldCA9ICRlbFswXTtcbiAgICAgICAgY29uc3QgYWN0aXZlTGlzdGVuZXIgPSBzdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBmYWxzZVxuICAgICAgICB9IDogZmFsc2U7XG4gICAgICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IHN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzID8ge1xuICAgICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICAgICAgfSA6IGZhbHNlO1xuICAgICAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBldmVudE1ldGhvZCA9IG1ldGhvZCA9PT0gJ29uJyA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcblxuICAgICAgICBpZiAoIXN1cHBvcnQudG91Y2gpIHtcbiAgICAgICAgICB0YXJnZXRbZXZlbnRNZXRob2RdKHRvdWNoRXZlbnRzRGVza3RvcC5zdGFydCwgb25EcmFnU3RhcnQsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgICAgICBkb2N1bWVudFtldmVudE1ldGhvZF0odG91Y2hFdmVudHNEZXNrdG9wLm1vdmUsIG9uRHJhZ01vdmUsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgICAgICBkb2N1bWVudFtldmVudE1ldGhvZF0odG91Y2hFdmVudHNEZXNrdG9wLmVuZCwgb25EcmFnRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtldmVudE1ldGhvZF0odG91Y2hFdmVudHNUb3VjaC5zdGFydCwgb25EcmFnU3RhcnQsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgICAgICB0YXJnZXRbZXZlbnRNZXRob2RdKHRvdWNoRXZlbnRzVG91Y2gubW92ZSwgb25EcmFnTW92ZSwgYWN0aXZlTGlzdGVuZXIpO1xuICAgICAgICAgIHRhcmdldFtldmVudE1ldGhvZF0odG91Y2hFdmVudHNUb3VjaC5lbmQsIG9uRHJhZ0VuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbmFibGVEcmFnZ2FibGUoKSB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcbiAgICAgICAgZXZlbnRzKCdvbicpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkaXNhYmxlRHJhZ2dhYmxlKCkge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsIHx8ICFzd2lwZXIuc2Nyb2xsYmFyLmVsKSByZXR1cm47XG4gICAgICAgIGV2ZW50cygnb2ZmJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzY3JvbGxiYXIsXG4gICAgICAgICAgJGVsOiAkc3dpcGVyRWxcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIgPSBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkKHN3aXBlciwgc3dpcGVyLm9yaWdpbmFsUGFyYW1zLnNjcm9sbGJhciwgc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIsIHtcbiAgICAgICAgICBlbDogJ3N3aXBlci1zY3JvbGxiYXInXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICAgICAgaWYgKCFwYXJhbXMuZWwpIHJldHVybjtcbiAgICAgICAgbGV0ICRlbCA9ICQocGFyYW1zLmVsKTtcblxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiB0eXBlb2YgcGFyYW1zLmVsID09PSAnc3RyaW5nJyAmJiAkZWwubGVuZ3RoID4gMSAmJiAkc3dpcGVyRWwuZmluZChwYXJhbXMuZWwpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICRlbCA9ICRzd2lwZXJFbC5maW5kKHBhcmFtcy5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICAkZWwuYWRkQ2xhc3Moc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gcGFyYW1zLmhvcml6b250YWxDbGFzcyA6IHBhcmFtcy52ZXJ0aWNhbENsYXNzKTtcbiAgICAgICAgbGV0ICRkcmFnRWwgPSAkZWwuZmluZChgLiR7c3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ0NsYXNzfWApO1xuXG4gICAgICAgIGlmICgkZHJhZ0VsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICRkcmFnRWwgPSAkKGA8ZGl2IGNsYXNzPVwiJHtzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5kcmFnQ2xhc3N9XCI+PC9kaXY+YCk7XG4gICAgICAgICAgJGVsLmFwcGVuZCgkZHJhZ0VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2Nyb2xsYmFyLCB7XG4gICAgICAgICAgJGVsLFxuICAgICAgICAgIGVsOiAkZWxbMF0sXG4gICAgICAgICAgJGRyYWdFbCxcbiAgICAgICAgICBkcmFnRWw6ICRkcmFnRWxbMF1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICBlbmFibGVEcmFnZ2FibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkZWwpIHtcbiAgICAgICAgICAkZWxbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICAgICAgY29uc3QgJGVsID0gc3dpcGVyLnNjcm9sbGJhci4kZWw7XG5cbiAgICAgICAgaWYgKCRlbCkge1xuICAgICAgICAgICRlbC5yZW1vdmVDbGFzcyhzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBwYXJhbXMuaG9yaXpvbnRhbENsYXNzIDogcGFyYW1zLnZlcnRpY2FsQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzYWJsZURyYWdnYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICBvbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgZGlzYWJsZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgICB1cGRhdGVTaXplKCk7XG4gICAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ3VwZGF0ZSByZXNpemUgb2JzZXJ2ZXJVcGRhdGUgbG9jayB1bmxvY2snLCAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVNpemUoKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ3NldFRyYW5zbGF0ZScsICgpID0+IHtcbiAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdzZXRUcmFuc2l0aW9uJywgKF9zLCBkdXJhdGlvbikgPT4ge1xuICAgICAgICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgb24oJ2VuYWJsZSBkaXNhYmxlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJGVsXG4gICAgICAgIH0gPSBzd2lwZXIuc2Nyb2xsYmFyO1xuXG4gICAgICAgIGlmICgkZWwpIHtcbiAgICAgICAgICAkZWxbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgZGVzdHJveSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVuYWJsZSA9ICgpID0+IHtcbiAgICAgICAgc3dpcGVyLiRlbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5zY3JvbGxiYXJEaXNhYmxlZENsYXNzKTtcblxuICAgICAgICBpZiAoc3dpcGVyLnNjcm9sbGJhci4kZWwpIHtcbiAgICAgICAgICBzd2lwZXIuc2Nyb2xsYmFyLiRlbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5zY3JvbGxiYXJEaXNhYmxlZENsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgdXBkYXRlU2l6ZSgpO1xuICAgICAgICBzZXRUcmFuc2xhdGUoKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGRpc2FibGUgPSAoKSA9PiB7XG4gICAgICAgIHN3aXBlci4kZWwuYWRkQ2xhc3Moc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuc2Nyb2xsYmFyRGlzYWJsZWRDbGFzcyk7XG5cbiAgICAgICAgaWYgKHN3aXBlci5zY3JvbGxiYXIuJGVsKSB7XG4gICAgICAgICAgc3dpcGVyLnNjcm9sbGJhci4kZWwuYWRkQ2xhc3Moc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuc2Nyb2xsYmFyRGlzYWJsZWRDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0cm95KCk7XG4gICAgICB9O1xuXG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlci5zY3JvbGxiYXIsIHtcbiAgICAgICAgZW5hYmxlLFxuICAgICAgICBkaXNhYmxlLFxuICAgICAgICB1cGRhdGVTaXplLFxuICAgICAgICBzZXRUcmFuc2xhdGUsXG4gICAgICAgIGluaXQsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBhcmFsbGF4KF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgICBvblxuICAgICAgfSA9IF9yZWY7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBwYXJhbGxheDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2Zvcm0gPSAoZWwsIHByb2dyZXNzKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBydGxcbiAgICAgICAgfSA9IHN3aXBlcjtcbiAgICAgICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgICAgIGNvbnN0IHJ0bEZhY3RvciA9IHJ0bCA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgcCA9ICRlbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheCcpIHx8ICcwJztcbiAgICAgICAgbGV0IHggPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgteCcpO1xuICAgICAgICBsZXQgeSA9ICRlbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheC15Jyk7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gJGVsLmF0dHIoJ2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlJyk7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eScpO1xuXG4gICAgICAgIGlmICh4IHx8IHkpIHtcbiAgICAgICAgICB4ID0geCB8fCAnMCc7XG4gICAgICAgICAgeSA9IHkgfHwgJzAnO1xuICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgIHggPSBwO1xuICAgICAgICAgIHkgPSAnMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeSA9IHA7XG4gICAgICAgICAgeCA9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4LmluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICAgICAgeCA9IGAke3BhcnNlSW50KHgsIDEwKSAqIHByb2dyZXNzICogcnRsRmFjdG9yfSVgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBgJHt4ICogcHJvZ3Jlc3MgKiBydGxGYWN0b3J9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkuaW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICB5ID0gYCR7cGFyc2VJbnQoeSwgMTApICogcHJvZ3Jlc3N9JWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeSA9IGAke3kgKiBwcm9ncmVzc31weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnICYmIG9wYWNpdHkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50T3BhY2l0eSA9IG9wYWNpdHkgLSAob3BhY2l0eSAtIDEpICogKDEgLSBNYXRoLmFicyhwcm9ncmVzcykpO1xuICAgICAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gY3VycmVudE9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNjYWxlID09PSAndW5kZWZpbmVkJyB8fCBzY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICRlbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7eH0sICR7eX0sIDBweClgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U2NhbGUgPSBzY2FsZSAtIChzY2FsZSAtIDEpICogKDEgLSBNYXRoLmFicyhwcm9ncmVzcykpO1xuICAgICAgICAgICRlbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7eH0sICR7eX0sIDBweCkgc2NhbGUoJHtjdXJyZW50U2NhbGV9KWApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2xhdGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkZWwsXG4gICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgIHNuYXBHcmlkXG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgICRlbC5jaGlsZHJlbignW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpLmVhY2goZWwgPT4ge1xuICAgICAgICAgIHNldFRyYW5zZm9ybShlbCwgcHJvZ3Jlc3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2xpZGVzLmVhY2goKHNsaWRlRWwsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgICAgICBsZXQgc2xpZGVQcm9ncmVzcyA9IHNsaWRlRWwucHJvZ3Jlc3M7XG5cbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA+IDEgJiYgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHNsaWRlUHJvZ3Jlc3MgKz0gTWF0aC5jZWlsKHNsaWRlSW5kZXggLyAyKSAtIHByb2dyZXNzICogKHNuYXBHcmlkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNsaWRlUHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heChzbGlkZVByb2dyZXNzLCAtMSksIDEpO1xuICAgICAgICAgICQoc2xpZGVFbCkuZmluZCgnW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpLmVhY2goZWwgPT4ge1xuICAgICAgICAgICAgc2V0VHJhbnNmb3JtKGVsLCBzbGlkZVByb2dyZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZHVyYXRpb24gPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRlbFxuICAgICAgICB9ID0gc3dpcGVyO1xuICAgICAgICAkZWwuZmluZCgnW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXScpLmVhY2gocGFyYWxsYXhFbCA9PiB7XG4gICAgICAgICAgY29uc3QgJHBhcmFsbGF4RWwgPSAkKHBhcmFsbGF4RWwpO1xuICAgICAgICAgIGxldCBwYXJhbGxheER1cmF0aW9uID0gcGFyc2VJbnQoJHBhcmFsbGF4RWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgtZHVyYXRpb24nKSwgMTApIHx8IGR1cmF0aW9uO1xuICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCkgcGFyYWxsYXhEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgJHBhcmFsbGF4RWwudHJhbnNpdGlvbihwYXJhbGxheER1cmF0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBvbignYmVmb3JlSW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgc3dpcGVyLm9yaWdpbmFsUGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBvbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIG9uKCdzZXRUcmFuc2xhdGUnLCAoKSA9PiB7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkKSByZXR1cm47XG4gICAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBvbignc2V0VHJhbnNpdGlvbicsIChfc3dpcGVyLCBkdXJhdGlvbikgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIGVzbGludCBuby11bmRlcnNjb3JlLWRhbmdsZTogXCJvZmZcIiAqL1xuICAgIGZ1bmN0aW9uIEF1dG9wbGF5KF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgZXh0ZW5kUGFyYW1zLFxuICAgICAgICBvbixcbiAgICAgICAgZW1pdFxuICAgICAgfSA9IF9yZWY7XG4gICAgICBsZXQgdGltZW91dDtcbiAgICAgIHN3aXBlci5hdXRvcGxheSA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIHBhdXNlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBhdXRvcGxheToge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIGRlbGF5OiAzMDAwLFxuICAgICAgICAgIHdhaXRGb3JUcmFuc2l0aW9uOiB0cnVlLFxuICAgICAgICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiB0cnVlLFxuICAgICAgICAgIHN0b3BPbkxhc3RTbGlkZTogZmFsc2UsXG4gICAgICAgICAgcmV2ZXJzZURpcmVjdGlvbjogZmFsc2UsXG4gICAgICAgICAgcGF1c2VPbk1vdXNlRW50ZXI6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBydW4oKSB7XG4gICAgICAgIGlmICghc3dpcGVyLnNpemUpIHtcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCAkYWN0aXZlU2xpZGVFbCA9IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgbGV0IGRlbGF5ID0gc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kZWxheTtcblxuICAgICAgICBpZiAoJGFjdGl2ZVNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItYXV0b3BsYXknKSkge1xuICAgICAgICAgIGRlbGF5ID0gJGFjdGl2ZVNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItYXV0b3BsYXknKSB8fCBzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRlbGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIGxldCBhdXRvcGxheVJlc3VsdDtcblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnJldmVyc2VEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICAgICAgYXV0b3BsYXlSZXN1bHQgPSBzd2lwZXIuc2xpZGVQcmV2KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICBlbWl0KCdhdXRvcGxheScpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3dpcGVyLmlzQmVnaW5uaW5nKSB7XG4gICAgICAgICAgICAgIGF1dG9wbGF5UmVzdWx0ID0gc3dpcGVyLnNsaWRlUHJldihzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlKSB7XG4gICAgICAgICAgICAgIGF1dG9wbGF5UmVzdWx0ID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCBzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICAgIGF1dG9wbGF5UmVzdWx0ID0gc3dpcGVyLnNsaWRlTmV4dChzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghc3dpcGVyLmlzRW5kKSB7XG4gICAgICAgICAgICBhdXRvcGxheVJlc3VsdCA9IHN3aXBlci5zbGlkZU5leHQoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBlbWl0KCdhdXRvcGxheScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlKSB7XG4gICAgICAgICAgICBhdXRvcGxheVJlc3VsdCA9IHN3aXBlci5zbGlkZVRvKDAsIHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUgJiYgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHJ1bigpO2Vsc2UgaWYgKGF1dG9wbGF5UmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcnVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkucnVubmluZyA9IHRydWU7XG4gICAgICAgIGVtaXQoJ2F1dG9wbGF5U3RhcnQnKTtcbiAgICAgICAgcnVuKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBpZiAoIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgZW1pdCgnYXV0b3BsYXlTdG9wJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXVzZShzcGVlZCkge1xuICAgICAgICBpZiAoIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm47XG4gICAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucGF1c2VkKSByZXR1cm47XG4gICAgICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzcGVlZCA9PT0gMCB8fCAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS53YWl0Rm9yVHJhbnNpdGlvbikge1xuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICBydW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcblxuICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJyAmJiBzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZSkge1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuJHdyYXBwZXJFbCkgcmV0dXJuO1xuICAgICAgICBpZiAoZS50YXJnZXQgIT09IHN3aXBlci4kd3JhcHBlckVsWzBdKSByZXR1cm47XG4gICAgICAgIFsndHJhbnNpdGlvbmVuZCcsICd3ZWJraXRUcmFuc2l0aW9uRW5kJ10uZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSB7XG4gICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VFbnRlcigpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW1pdCgnYXV0b3BsYXlQYXVzZScpO1xuICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICBlbWl0KCdhdXRvcGxheVJlc3VtZScpO1xuICAgICAgICBydW4oKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXR0YWNoTW91c2VFdmVudHMoKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnBhdXNlT25Nb3VzZUVudGVyKSB7XG4gICAgICAgICAgc3dpcGVyLiRlbC5vbignbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgICAgICAgc3dpcGVyLiRlbC5vbignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0YWNoTW91c2VFdmVudHMoKSB7XG4gICAgICAgIHN3aXBlci4kZWwub2ZmKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgc3dpcGVyLiRlbC5vZmYoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgfVxuXG4gICAgICBvbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZCkge1xuICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICAgIGF0dGFjaE1vdXNlRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb24oJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIChfcywgc3BlZWQsIGludGVybmFsKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbCB8fCAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlKHNwZWVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbignc2xpZGVyRmlyc3RNb3ZlJywgKCkgPT4ge1xuICAgICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbigndG91Y2hFbmQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCAmJiAhc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICBkZXRhY2hNb3VzZUV2ZW50cygpO1xuXG4gICAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLmF1dG9wbGF5LCB7XG4gICAgICAgIHBhdXNlLFxuICAgICAgICBydW4sXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBzdG9wXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcmVlTW9kZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICBzd2lwZXIsXG4gICAgICAgIGV4dGVuZFBhcmFtcyxcbiAgICAgICAgZW1pdCxcbiAgICAgICAgb25jZVxuICAgICAgfSA9IF9yZWY7XG4gICAgICBleHRlbmRQYXJhbXMoe1xuICAgICAgICBmcmVlTW9kZToge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIG1vbWVudHVtOiB0cnVlLFxuICAgICAgICAgIG1vbWVudHVtUmF0aW86IDEsXG4gICAgICAgICAgbW9tZW50dW1Cb3VuY2U6IHRydWUsXG4gICAgICAgICAgbW9tZW50dW1Cb3VuY2VSYXRpbzogMSxcbiAgICAgICAgICBtb21lbnR1bVZlbG9jaXR5UmF0aW86IDEsXG4gICAgICAgICAgc3RpY2t5OiBmYWxzZSxcbiAgICAgICAgICBtaW5pbXVtVmVsb2NpdHk6IDAuMDJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uVG91Y2hTdGFydCgpIHtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSk7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNEYXRhLnZlbG9jaXRpZXMubGVuZ3RoID0gMDtcbiAgICAgICAgc3dpcGVyLmZyZWVNb2RlLm9uVG91Y2hFbmQoe1xuICAgICAgICAgIGN1cnJlbnRQb3M6IHN3aXBlci5ydGwgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdG91Y2hFdmVudHNEYXRhOiBkYXRhLFxuICAgICAgICAgIHRvdWNoZXNcbiAgICAgICAgfSA9IHN3aXBlcjsgLy8gVmVsb2NpdHlcblxuICAgICAgICBpZiAoZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRhdGEudmVsb2NpdGllcy5wdXNoKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdzdGFydFgnIDogJ3N0YXJ0WSddLFxuICAgICAgICAgICAgdGltZTogZGF0YS50b3VjaFN0YXJ0VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS52ZWxvY2l0aWVzLnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdjdXJyZW50WCcgOiAnY3VycmVudFknXSxcbiAgICAgICAgICB0aW1lOiBub3coKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Ub3VjaEVuZChfcmVmMikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRQb3NcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICR3cmFwcGVyRWwsXG4gICAgICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgdG91Y2hFdmVudHNEYXRhOiBkYXRhXG4gICAgICAgIH0gPSBzd2lwZXI7IC8vIFRpbWUgZGlmZlxuXG4gICAgICAgIGNvbnN0IHRvdWNoRW5kVGltZSA9IG5vdygpO1xuICAgICAgICBjb25zdCB0aW1lRGlmZiA9IHRvdWNoRW5kVGltZSAtIGRhdGEudG91Y2hTdGFydFRpbWU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQb3MgPCAtc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudFBvcyA+IC1zd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgICAgICBpZiAoc3dpcGVyLnNsaWRlcy5sZW5ndGggPCBzbmFwR3JpZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNuYXBHcmlkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuZnJlZU1vZGUubW9tZW50dW0pIHtcbiAgICAgICAgICBpZiAoZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RNb3ZlRXZlbnQgPSBkYXRhLnZlbG9jaXRpZXMucG9wKCk7XG4gICAgICAgICAgICBjb25zdCB2ZWxvY2l0eUV2ZW50ID0gZGF0YS52ZWxvY2l0aWVzLnBvcCgpO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBsYXN0TW92ZUV2ZW50LnBvc2l0aW9uIC0gdmVsb2NpdHlFdmVudC5wb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBsYXN0TW92ZUV2ZW50LnRpbWUgLSB2ZWxvY2l0eUV2ZW50LnRpbWU7XG4gICAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSBkaXN0YW5jZSAvIHRpbWU7XG4gICAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgLz0gMjtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHN3aXBlci52ZWxvY2l0eSkgPCBwYXJhbXMuZnJlZU1vZGUubWluaW11bVZlbG9jaXR5KSB7XG4gICAgICAgICAgICAgIHN3aXBlci52ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICB9IC8vIHRoaXMgaW1wbGllcyB0aGF0IHRoZSB1c2VyIHN0b3BwZWQgbW92aW5nIGEgZmluZ2VyIHRoZW4gcmVsZWFzZWQuXG4gICAgICAgICAgICAvLyBUaGVyZSB3b3VsZCBiZSBubyBldmVudHMgd2l0aCBkaXN0YW5jZSB6ZXJvLCBzbyB0aGUgbGFzdCBldmVudCBpcyBzdGFsZS5cblxuXG4gICAgICAgICAgICBpZiAodGltZSA+IDE1MCB8fCBub3coKSAtIGxhc3RNb3ZlRXZlbnQudGltZSA+IDMwMCkge1xuICAgICAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXBlci52ZWxvY2l0eSAqPSBwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1WZWxvY2l0eVJhdGlvO1xuICAgICAgICAgIGRhdGEudmVsb2NpdGllcy5sZW5ndGggPSAwO1xuICAgICAgICAgIGxldCBtb21lbnR1bUR1cmF0aW9uID0gMTAwMCAqIHBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bVJhdGlvO1xuICAgICAgICAgIGNvbnN0IG1vbWVudHVtRGlzdGFuY2UgPSBzd2lwZXIudmVsb2NpdHkgKiBtb21lbnR1bUR1cmF0aW9uO1xuICAgICAgICAgIGxldCBuZXdQb3NpdGlvbiA9IHN3aXBlci50cmFuc2xhdGUgKyBtb21lbnR1bURpc3RhbmNlO1xuICAgICAgICAgIGlmIChydGwpIG5ld1Bvc2l0aW9uID0gLW5ld1Bvc2l0aW9uO1xuICAgICAgICAgIGxldCBkb0JvdW5jZSA9IGZhbHNlO1xuICAgICAgICAgIGxldCBhZnRlckJvdW5jZVBvc2l0aW9uO1xuICAgICAgICAgIGNvbnN0IGJvdW5jZUFtb3VudCA9IE1hdGguYWJzKHN3aXBlci52ZWxvY2l0eSkgKiAyMCAqIHBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bUJvdW5jZVJhdGlvO1xuICAgICAgICAgIGxldCBuZWVkc0xvb3BGaXg7XG5cbiAgICAgICAgICBpZiAobmV3UG9zaXRpb24gPCBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2UpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uICsgc3dpcGVyLm1heFRyYW5zbGF0ZSgpIDwgLWJvdW5jZUFtb3VudCkge1xuICAgICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gYm91bmNlQW1vdW50O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYWZ0ZXJCb3VuY2VQb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcbiAgICAgICAgICAgICAgZG9Cb3VuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMubG9vcCAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIG5lZWRzTG9vcEZpeCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXdQb3NpdGlvbiA+IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bUJvdW5jZSkge1xuICAgICAgICAgICAgICBpZiAobmV3UG9zaXRpb24gLSBzd2lwZXIubWluVHJhbnNsYXRlKCkgPiBib3VuY2VBbW91bnQpIHtcbiAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKSArIGJvdW5jZUFtb3VudDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFmdGVyQm91bmNlUG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gICAgICAgICAgICAgIGRvQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZGF0YS5hbGxvd01vbWVudHVtQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmxvb3AgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSBuZWVkc0xvb3BGaXggPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlLnN0aWNreSkge1xuICAgICAgICAgICAgbGV0IG5leHRTbGlkZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbmFwR3JpZC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoc25hcEdyaWRbal0gPiAtbmV3UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBuZXh0U2xpZGUgPSBqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzbmFwR3JpZFtuZXh0U2xpZGVdIC0gbmV3UG9zaXRpb24pIDwgTWF0aC5hYnMoc25hcEdyaWRbbmV4dFNsaWRlIC0gMV0gLSBuZXdQb3NpdGlvbikgfHwgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAnbmV4dCcpIHtcbiAgICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBzbmFwR3JpZFtuZXh0U2xpZGVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBzbmFwR3JpZFtuZXh0U2xpZGUgLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSAtbmV3UG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lZWRzTG9vcEZpeCkge1xuICAgICAgICAgICAgb25jZSgndHJhbnNpdGlvbkVuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gRml4IGR1cmF0aW9uXG5cblxuICAgICAgICAgIGlmIChzd2lwZXIudmVsb2NpdHkgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGguYWJzKCgtbmV3UG9zaXRpb24gLSBzd2lwZXIudHJhbnNsYXRlKSAvIHN3aXBlci52ZWxvY2l0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtb21lbnR1bUR1cmF0aW9uID0gTWF0aC5hYnMoKG5ld1Bvc2l0aW9uIC0gc3dpcGVyLnRyYW5zbGF0ZSkgLyBzd2lwZXIudmVsb2NpdHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlLnN0aWNreSkge1xuICAgICAgICAgICAgICAvLyBJZiBmcmVlTW9kZS5zdGlja3kgaXMgYWN0aXZlIGFuZCB0aGUgdXNlciBlbmRzIGEgc3dpcGUgd2l0aCBhIHNsb3ctdmVsb2NpdHlcbiAgICAgICAgICAgICAgLy8gZXZlbnQsIHRoZW4gZHVyYXRpb25zIGNhbiBiZSAyMCsgc2Vjb25kcyB0byBzbGlkZSBvbmUgKG9yIHplcm8hKSBzbGlkZXMuXG4gICAgICAgICAgICAgIC8vIEl0J3MgZWFzeSB0byBzZWUgdGhpcyB3aGVuIHNpbXVsYXRpbmcgdG91Y2ggd2l0aCBtb3VzZSBldmVudHMuIFRvIGZpeCB0aGlzLFxuICAgICAgICAgICAgICAvLyBsaW1pdCBzaW5nbGUtc2xpZGUgc3dpcGVzIHRvIHRoZSBkZWZhdWx0IHNsaWRlIGR1cmF0aW9uLiBUaGlzIGFsc28gaGFzIHRoZVxuICAgICAgICAgICAgICAvLyBuaWNlIHNpZGUgZWZmZWN0IG9mIG1hdGNoaW5nIHNsaWRlIHNwZWVkIGlmIHRoZSB1c2VyIHN0b3BwZWQgbW92aW5nIGJlZm9yZVxuICAgICAgICAgICAgICAvLyBsaWZ0aW5nIGZpbmdlciBvciBtb3VzZSB2cy4gbW92aW5nIHNsb3dseSBiZWZvcmUgbGlmdGluZyB0aGUgZmluZ2VyL21vdXNlLlxuICAgICAgICAgICAgICAvLyBGb3IgZmFzdGVyIHN3aXBlcywgYWxzbyBhcHBseSBsaW1pdHMgKGFsYmVpdCBoaWdoZXIgb25lcykuXG4gICAgICAgICAgICAgIGNvbnN0IG1vdmVEaXN0YW5jZSA9IE1hdGguYWJzKChydGwgPyAtbmV3UG9zaXRpb24gOiBuZXdQb3NpdGlvbikgLSBzd2lwZXIudHJhbnNsYXRlKTtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNsaWRlU2l6ZSA9IHN3aXBlci5zbGlkZXNTaXplc0dyaWRbc3dpcGVyLmFjdGl2ZUluZGV4XTtcblxuICAgICAgICAgICAgICBpZiAobW92ZURpc3RhbmNlIDwgY3VycmVudFNsaWRlU2l6ZSkge1xuICAgICAgICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBwYXJhbXMuc3BlZWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobW92ZURpc3RhbmNlIDwgMiAqIGN1cnJlbnRTbGlkZVNpemUpIHtcbiAgICAgICAgICAgICAgICBtb21lbnR1bUR1cmF0aW9uID0gcGFyYW1zLnNwZWVkICogMS41O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBwYXJhbXMuc3BlZWQgKiAyLjU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5mcmVlTW9kZS5zdGlja3kpIHtcbiAgICAgICAgICAgIHN3aXBlci5zbGlkZVRvQ2xvc2VzdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2UgJiYgZG9Cb3VuY2UpIHtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhhZnRlckJvdW5jZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKG1vbWVudHVtRHVyYXRpb24pO1xuICAgICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvblN0YXJ0KHRydWUsIHN3aXBlci5zd2lwZURpcmVjdGlvbik7XG4gICAgICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIWRhdGEuYWxsb3dNb21lbnR1bUJvdW5jZSkgcmV0dXJuO1xuICAgICAgICAgICAgICBlbWl0KCdtb21lbnR1bUJvdW5jZScpO1xuICAgICAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihwYXJhbXMuc3BlZWQpO1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKGFmdGVyQm91bmNlUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLnZlbG9jaXR5KSB7XG4gICAgICAgICAgICBlbWl0KCdfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZScpO1xuICAgICAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKG1vbWVudHVtRHVyYXRpb24pO1xuICAgICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvblN0YXJ0KHRydWUsIHN3aXBlci5zd2lwZURpcmVjdGlvbik7XG5cbiAgICAgICAgICAgIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uRW5kKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhuZXdQb3NpdGlvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuZnJlZU1vZGUuc3RpY2t5KSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5mcmVlTW9kZSkge1xuICAgICAgICAgIGVtaXQoJ19mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bSB8fCB0aW1lRGlmZiA+PSBwYXJhbXMubG9uZ1N3aXBlc01zKSB7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgICAgICBmcmVlTW9kZToge1xuICAgICAgICAgIG9uVG91Y2hTdGFydCxcbiAgICAgICAgICBvblRvdWNoTW92ZSxcbiAgICAgICAgICBvblRvdWNoRW5kXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4gICAgZnVuY3Rpb24gdW53cmFwRXhwb3J0cyAoeCkge1xuICAgIFx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG4gICAgXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG4gICAgfVxuXG4gICAgdmFyIGFvcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAhZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHQoKSA7XG4gICAgfShjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZ1bmN0aW9uIHQobykge1xuICAgICAgICAgIGlmIChuW29dKSByZXR1cm4gbltvXS5leHBvcnRzO1xuICAgICAgICAgIHZhciBpID0gbltvXSA9IHtcbiAgICAgICAgICAgIGV4cG9ydHM6IHt9LFxuICAgICAgICAgICAgaWQ6IG8sXG4gICAgICAgICAgICBsb2FkZWQ6ICExXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZVtvXS5jYWxsKGkuZXhwb3J0cywgaSwgaS5leHBvcnRzLCB0KSwgaS5sb2FkZWQgPSAhMCwgaS5leHBvcnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4gPSB7fTtcbiAgICAgICAgcmV0dXJuIHQubSA9IGUsIHQuYyA9IG4sIHQucCA9IFwiZGlzdC9cIiwgdCgwKTtcbiAgICAgIH0oW2Z1bmN0aW9uIChlLCB0LCBuKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gbyhlKSB7XG4gICAgICAgICAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHZhciBuID0gYXJndW1lbnRzW3RdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBvIGluIG4pIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCBvKSAmJiAoZVtvXSA9IG5bb10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LFxuICAgICAgICAgICAgciA9IG4oMSksXG4gICAgICAgICAgICBhID0gKG8ociksIG4oNikpLFxuICAgICAgICAgICAgdSA9IG8oYSksXG4gICAgICAgICAgICBjID0gbig3KSxcbiAgICAgICAgICAgIHMgPSBvKGMpLFxuICAgICAgICAgICAgZiA9IG4oOCksXG4gICAgICAgICAgICBkID0gbyhmKSxcbiAgICAgICAgICAgIGwgPSBuKDkpLFxuICAgICAgICAgICAgcCA9IG8obCksXG4gICAgICAgICAgICBtID0gbigxMCksXG4gICAgICAgICAgICBiID0gbyhtKSxcbiAgICAgICAgICAgIHYgPSBuKDExKSxcbiAgICAgICAgICAgIHkgPSBvKHYpLFxuICAgICAgICAgICAgZyA9IG4oMTQpLFxuICAgICAgICAgICAgaCA9IG8oZyksXG4gICAgICAgICAgICB3ID0gW10sXG4gICAgICAgICAgICBrID0gITEsXG4gICAgICAgICAgICB4ID0ge1xuICAgICAgICAgIG9mZnNldDogMTIwLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIGVhc2luZzogXCJlYXNlXCIsXG4gICAgICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgICAgICBkaXNhYmxlOiAhMSxcbiAgICAgICAgICBvbmNlOiAhMSxcbiAgICAgICAgICBzdGFydEV2ZW50OiBcIkRPTUNvbnRlbnRMb2FkZWRcIixcbiAgICAgICAgICB0aHJvdHRsZURlbGF5OiA5OSxcbiAgICAgICAgICBkZWJvdW5jZURlbGF5OiA1MCxcbiAgICAgICAgICBkaXNhYmxlTXV0YXRpb25PYnNlcnZlcjogITFcbiAgICAgICAgfSxcbiAgICAgICAgICAgIGogPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgaWYgKGUgJiYgKGsgPSAhMCksIGspIHJldHVybiB3ID0gKDAsIHkuZGVmYXVsdCkodywgeCksICgwLCBiLmRlZmF1bHQpKHcsIHgub25jZSksIHc7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBPID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHcgPSAoMCwgaC5kZWZhdWx0KSgpLCBqKCk7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBNID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHcuZm9yRWFjaChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgZS5ub2RlLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtYW9zXCIpLCBlLm5vZGUucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1hb3MtZWFzaW5nXCIpLCBlLm5vZGUucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1hb3MtZHVyYXRpb25cIiksIGUubm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWFvcy1kZWxheVwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIFMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlID09PSAhMCB8fCBcIm1vYmlsZVwiID09PSBlICYmIHAuZGVmYXVsdC5tb2JpbGUoKSB8fCBcInBob25lXCIgPT09IGUgJiYgcC5kZWZhdWx0LnBob25lKCkgfHwgXCJ0YWJsZXRcIiA9PT0gZSAmJiBwLmRlZmF1bHQudGFibGV0KCkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlICYmIGUoKSA9PT0gITA7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBfID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB4ID0gaSh4LCBlKSwgdyA9ICgwLCBoLmRlZmF1bHQpKCk7XG4gICAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xuICAgICAgICAgIHJldHVybiBTKHguZGlzYWJsZSkgfHwgdCA/IE0oKSA6ICh4LmRpc2FibGVNdXRhdGlvbk9ic2VydmVyIHx8IGQuZGVmYXVsdC5pc1N1cHBvcnRlZCgpIHx8IChjb25zb2xlLmluZm8oJ1xcbiAgICAgIGFvczogTXV0YXRpb25PYnNlcnZlciBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlcixcXG4gICAgICBjb2RlIG11dGF0aW9ucyBvYnNlcnZpbmcgaGFzIGJlZW4gZGlzYWJsZWQuXFxuICAgICAgWW91IG1heSBoYXZlIHRvIGNhbGwgXCJyZWZyZXNoSGFyZCgpXCIgYnkgeW91cnNlbGYuXFxuICAgICcpLCB4LmRpc2FibGVNdXRhdGlvbk9ic2VydmVyID0gITApLCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYm9keVwiKS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFvcy1lYXNpbmdcIiwgeC5lYXNpbmcpLCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYm9keVwiKS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFvcy1kdXJhdGlvblwiLCB4LmR1cmF0aW9uKSwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJvZHlcIikuc2V0QXR0cmlidXRlKFwiZGF0YS1hb3MtZGVsYXlcIiwgeC5kZWxheSksIFwiRE9NQ29udGVudExvYWRlZFwiID09PSB4LnN0YXJ0RXZlbnQgJiYgW1wiY29tcGxldGVcIiwgXCJpbnRlcmFjdGl2ZVwiXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID4gLTEgPyBqKCEwKSA6IFwibG9hZFwiID09PSB4LnN0YXJ0RXZlbnQgPyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcih4LnN0YXJ0RXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGooITApO1xuICAgICAgICAgIH0pIDogZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih4LnN0YXJ0RXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGooITApO1xuICAgICAgICAgIH0pLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoMCwgcy5kZWZhdWx0KShqLCB4LmRlYm91bmNlRGVsYXksICEwKSksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgKDAsIHMuZGVmYXVsdCkoaiwgeC5kZWJvdW5jZURlbGF5LCAhMCkpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoMCwgdS5kZWZhdWx0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAoMCwgYi5kZWZhdWx0KSh3LCB4Lm9uY2UpO1xuICAgICAgICAgIH0sIHgudGhyb3R0bGVEZWxheSkpLCB4LmRpc2FibGVNdXRhdGlvbk9ic2VydmVyIHx8IGQuZGVmYXVsdC5yZWFkeShcIltkYXRhLWFvc11cIiwgTyksIHcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGUuZXhwb3J0cyA9IHtcbiAgICAgICAgICBpbml0OiBfLFxuICAgICAgICAgIHJlZnJlc2g6IGosXG4gICAgICAgICAgcmVmcmVzaEhhcmQ6IE9cbiAgICAgICAgfTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlLCB0KSB7fSwsLCwsIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIChmdW5jdGlvbiAodCkge1xuXG4gICAgICAgICAgZnVuY3Rpb24gbihlLCB0LCBuKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBvKHQpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBiLFxuICAgICAgICAgICAgICAgICAgbyA9IHY7XG4gICAgICAgICAgICAgIHJldHVybiBiID0gdiA9IHZvaWQgMCwgayA9IHQsIGcgPSBlLmFwcGx5KG8sIG4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGsgPSBlLCBoID0gc2V0VGltZW91dChmLCB0KSwgTSA/IG8oZSkgOiBnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBhKGUpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBlIC0gdyxcbiAgICAgICAgICAgICAgICAgIG8gPSBlIC0gayxcbiAgICAgICAgICAgICAgICAgIGkgPSB0IC0gbjtcbiAgICAgICAgICAgICAgcmV0dXJuIFMgPyBqKGksIHkgLSBvKSA6IGk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSkge1xuICAgICAgICAgICAgICB2YXIgbiA9IGUgLSB3LFxuICAgICAgICAgICAgICAgICAgbyA9IGUgLSBrO1xuICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSB3IHx8IG4gPj0gdCB8fCBuIDwgMCB8fCBTICYmIG8gPj0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSBPKCk7XG4gICAgICAgICAgICAgIHJldHVybiBjKGUpID8gZChlKSA6IHZvaWQgKGggPSBzZXRUaW1lb3V0KGYsIGEoZSkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoID0gdm9pZCAwLCBfICYmIGIgPyBvKGUpIDogKGIgPSB2ID0gdm9pZCAwLCBnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBoICYmIGNsZWFyVGltZW91dChoKSwgayA9IDAsIGIgPSB3ID0gdiA9IGggPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGggPyBnIDogZChPKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBtKCkge1xuICAgICAgICAgICAgICB2YXIgZSA9IE8oKSxcbiAgICAgICAgICAgICAgICAgIG4gPSBjKGUpO1xuXG4gICAgICAgICAgICAgIGlmIChiID0gYXJndW1lbnRzLCB2ID0gdGhpcywgdyA9IGUsIG4pIHtcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBoKSByZXR1cm4gcih3KTtcbiAgICAgICAgICAgICAgICBpZiAoUykgcmV0dXJuIGggPSBzZXRUaW1lb3V0KGYsIHQpLCBvKHcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaCAmJiAoaCA9IHNldFRpbWVvdXQoZiwgdCkpLCBnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYixcbiAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgZyxcbiAgICAgICAgICAgICAgICBoLFxuICAgICAgICAgICAgICAgIHcsXG4gICAgICAgICAgICAgICAgayA9IDAsXG4gICAgICAgICAgICAgICAgTSA9ICExLFxuICAgICAgICAgICAgICAgIFMgPSAhMSxcbiAgICAgICAgICAgICAgICBfID0gITA7XG5cbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHRocm93IG5ldyBUeXBlRXJyb3Iocyk7XG4gICAgICAgICAgICByZXR1cm4gdCA9IHUodCkgfHwgMCwgaShuKSAmJiAoTSA9ICEhbi5sZWFkaW5nLCBTID0gXCJtYXhXYWl0XCIgaW4gbiwgeSA9IFMgPyB4KHUobi5tYXhXYWl0KSB8fCAwLCB0KSA6IHksIF8gPSBcInRyYWlsaW5nXCIgaW4gbiA/ICEhbi50cmFpbGluZyA6IF8pLCBtLmNhbmNlbCA9IGwsIG0uZmx1c2ggPSBwLCBtO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG8oZSwgdCwgbykge1xuICAgICAgICAgICAgdmFyIHIgPSAhMCxcbiAgICAgICAgICAgICAgICBhID0gITA7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKHMpO1xuICAgICAgICAgICAgcmV0dXJuIGkobykgJiYgKHIgPSBcImxlYWRpbmdcIiBpbiBvID8gISFvLmxlYWRpbmcgOiByLCBhID0gXCJ0cmFpbGluZ1wiIGluIG8gPyAhIW8udHJhaWxpbmcgOiBhKSwgbihlLCB0LCB7XG4gICAgICAgICAgICAgIGxlYWRpbmc6IHIsXG4gICAgICAgICAgICAgIG1heFdhaXQ6IHQsXG4gICAgICAgICAgICAgIHRyYWlsaW5nOiBhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgZSA/IFwidW5kZWZpbmVkXCIgOiBjKGUpO1xuICAgICAgICAgICAgcmV0dXJuICEhZSAmJiAoXCJvYmplY3RcIiA9PSB0IHx8IFwiZnVuY3Rpb25cIiA9PSB0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiByKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWUgJiYgXCJvYmplY3RcIiA9PSAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgZSA/IFwidW5kZWZpbmVkXCIgOiBjKGUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBcInN5bWJvbFwiID09IChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBlID8gXCJ1bmRlZmluZWRcIiA6IGMoZSkpIHx8IHIoZSkgJiYgay5jYWxsKGUpID09IGQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdShlKSB7XG4gICAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgZSkgcmV0dXJuIGU7XG4gICAgICAgICAgICBpZiAoYShlKSkgcmV0dXJuIGY7XG5cbiAgICAgICAgICAgIGlmIChpKGUpKSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlLnZhbHVlT2YgPyBlLnZhbHVlT2YoKSA6IGU7XG4gICAgICAgICAgICAgIGUgPSBpKHQpID8gdCArIFwiXCIgOiB0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSkgcmV0dXJuIDAgPT09IGUgPyBlIDogK2U7XG4gICAgICAgICAgICBlID0gZS5yZXBsYWNlKGwsIFwiXCIpO1xuICAgICAgICAgICAgdmFyIG4gPSBtLnRlc3QoZSk7XG4gICAgICAgICAgICByZXR1cm4gbiB8fCBiLnRlc3QoZSkgPyB2KGUuc2xpY2UoMiksIG4gPyAyIDogOCkgOiBwLnRlc3QoZSkgPyBmIDogK2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGMgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcyA9IFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiLFxuICAgICAgICAgICAgICBmID0gTmFOLFxuICAgICAgICAgICAgICBkID0gXCJbb2JqZWN0IFN5bWJvbF1cIixcbiAgICAgICAgICAgICAgbCA9IC9eXFxzK3xcXHMrJC9nLFxuICAgICAgICAgICAgICBwID0gL15bLStdMHhbMC05YS1mXSskL2ksXG4gICAgICAgICAgICAgIG0gPSAvXjBiWzAxXSskL2ksXG4gICAgICAgICAgICAgIGIgPSAvXjBvWzAtN10rJC9pLFxuICAgICAgICAgICAgICB2ID0gcGFyc2VJbnQsXG4gICAgICAgICAgICAgIHkgPSBcIm9iamVjdFwiID09IChcInVuZGVmaW5lZFwiID09IHR5cGVvZiB0ID8gXCJ1bmRlZmluZWRcIiA6IGModCkpICYmIHQgJiYgdC5PYmplY3QgPT09IE9iamVjdCAmJiB0LFxuICAgICAgICAgICAgICBnID0gXCJvYmplY3RcIiA9PSAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygc2VsZiA/IFwidW5kZWZpbmVkXCIgOiBjKHNlbGYpKSAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZixcbiAgICAgICAgICAgICAgaCA9IHkgfHwgZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCksXG4gICAgICAgICAgICAgIHcgPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICAgICAgICBrID0gdy50b1N0cmluZyxcbiAgICAgICAgICAgICAgeCA9IE1hdGgubWF4LFxuICAgICAgICAgICAgICBqID0gTWF0aC5taW4sXG4gICAgICAgICAgICAgIE8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaC5EYXRlLm5vdygpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBlLmV4cG9ydHMgPSBvO1xuICAgICAgICB9KS5jYWxsKHQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSgpKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIChmdW5jdGlvbiAodCkge1xuXG4gICAgICAgICAgZnVuY3Rpb24gbihlLCB0LCBuKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBiLFxuICAgICAgICAgICAgICAgICAgbyA9IHY7XG4gICAgICAgICAgICAgIHJldHVybiBiID0gdiA9IHZvaWQgMCwgTyA9IHQsIGcgPSBlLmFwcGx5KG8sIG4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE8gPSBlLCBoID0gc2V0VGltZW91dChmLCB0KSwgTSA/IGkoZSkgOiBnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB1KGUpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBlIC0gdyxcbiAgICAgICAgICAgICAgICAgIG8gPSBlIC0gTyxcbiAgICAgICAgICAgICAgICAgIGkgPSB0IC0gbjtcbiAgICAgICAgICAgICAgcmV0dXJuIFMgPyB4KGksIHkgLSBvKSA6IGk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSkge1xuICAgICAgICAgICAgICB2YXIgbiA9IGUgLSB3LFxuICAgICAgICAgICAgICAgICAgbyA9IGUgLSBPO1xuICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSB3IHx8IG4gPj0gdCB8fCBuIDwgMCB8fCBTICYmIG8gPj0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSBqKCk7XG4gICAgICAgICAgICAgIHJldHVybiBzKGUpID8gZChlKSA6IHZvaWQgKGggPSBzZXRUaW1lb3V0KGYsIHUoZSkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoID0gdm9pZCAwLCBfICYmIGIgPyBpKGUpIDogKGIgPSB2ID0gdm9pZCAwLCBnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBoICYmIGNsZWFyVGltZW91dChoKSwgTyA9IDAsIGIgPSB3ID0gdiA9IGggPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGggPyBnIDogZChqKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBtKCkge1xuICAgICAgICAgICAgICB2YXIgZSA9IGooKSxcbiAgICAgICAgICAgICAgICAgIG4gPSBzKGUpO1xuXG4gICAgICAgICAgICAgIGlmIChiID0gYXJndW1lbnRzLCB2ID0gdGhpcywgdyA9IGUsIG4pIHtcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBoKSByZXR1cm4gcih3KTtcbiAgICAgICAgICAgICAgICBpZiAoUykgcmV0dXJuIGggPSBzZXRUaW1lb3V0KGYsIHQpLCBpKHcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaCAmJiAoaCA9IHNldFRpbWVvdXQoZiwgdCkpLCBnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYixcbiAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgZyxcbiAgICAgICAgICAgICAgICBoLFxuICAgICAgICAgICAgICAgIHcsXG4gICAgICAgICAgICAgICAgTyA9IDAsXG4gICAgICAgICAgICAgICAgTSA9ICExLFxuICAgICAgICAgICAgICAgIFMgPSAhMSxcbiAgICAgICAgICAgICAgICBfID0gITA7XG5cbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHRocm93IG5ldyBUeXBlRXJyb3IoYyk7XG4gICAgICAgICAgICByZXR1cm4gdCA9IGEodCkgfHwgMCwgbyhuKSAmJiAoTSA9ICEhbi5sZWFkaW5nLCBTID0gXCJtYXhXYWl0XCIgaW4gbiwgeSA9IFMgPyBrKGEobi5tYXhXYWl0KSB8fCAwLCB0KSA6IHksIF8gPSBcInRyYWlsaW5nXCIgaW4gbiA/ICEhbi50cmFpbGluZyA6IF8pLCBtLmNhbmNlbCA9IGwsIG0uZmx1c2ggPSBwLCBtO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG8oZSkge1xuICAgICAgICAgICAgdmFyIHQgPSBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBlID8gXCJ1bmRlZmluZWRcIiA6IHUoZSk7XG4gICAgICAgICAgICByZXR1cm4gISFlICYmIChcIm9iamVjdFwiID09IHQgfHwgXCJmdW5jdGlvblwiID09IHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICAgICAgcmV0dXJuICEhZSAmJiBcIm9iamVjdFwiID09IChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBlID8gXCJ1bmRlZmluZWRcIiA6IHUoZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHIoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwic3ltYm9sXCIgPT0gKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGUgPyBcInVuZGVmaW5lZFwiIDogdShlKSkgfHwgaShlKSAmJiB3LmNhbGwoZSkgPT0gZjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhKGUpIHtcbiAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBlKSByZXR1cm4gZTtcbiAgICAgICAgICAgIGlmIChyKGUpKSByZXR1cm4gcztcblxuICAgICAgICAgICAgaWYgKG8oZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUudmFsdWVPZiA/IGUudmFsdWVPZigpIDogZTtcbiAgICAgICAgICAgICAgZSA9IG8odCkgPyB0ICsgXCJcIiA6IHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBlKSByZXR1cm4gMCA9PT0gZSA/IGUgOiArZTtcbiAgICAgICAgICAgIGUgPSBlLnJlcGxhY2UoZCwgXCJcIik7XG4gICAgICAgICAgICB2YXIgbiA9IHAudGVzdChlKTtcbiAgICAgICAgICAgIHJldHVybiBuIHx8IG0udGVzdChlKSA/IGIoZS5zbGljZSgyKSwgbiA/IDIgOiA4KSA6IGwudGVzdChlKSA/IHMgOiArZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGU7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjID0gXCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgIHMgPSBOYU4sXG4gICAgICAgICAgICAgIGYgPSBcIltvYmplY3QgU3ltYm9sXVwiLFxuICAgICAgICAgICAgICBkID0gL15cXHMrfFxccyskL2csXG4gICAgICAgICAgICAgIGwgPSAvXlstK10weFswLTlhLWZdKyQvaSxcbiAgICAgICAgICAgICAgcCA9IC9eMGJbMDFdKyQvaSxcbiAgICAgICAgICAgICAgbSA9IC9eMG9bMC03XSskL2ksXG4gICAgICAgICAgICAgIGIgPSBwYXJzZUludCxcbiAgICAgICAgICAgICAgdiA9IFwib2JqZWN0XCIgPT0gKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIHQgPyBcInVuZGVmaW5lZFwiIDogdSh0KSkgJiYgdCAmJiB0Lk9iamVjdCA9PT0gT2JqZWN0ICYmIHQsXG4gICAgICAgICAgICAgIHkgPSBcIm9iamVjdFwiID09IChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBzZWxmID8gXCJ1bmRlZmluZWRcIiA6IHUoc2VsZikpICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmLFxuICAgICAgICAgICAgICBnID0gdiB8fCB5IHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSxcbiAgICAgICAgICAgICAgaCA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgICAgICAgIHcgPSBoLnRvU3RyaW5nLFxuICAgICAgICAgICAgICBrID0gTWF0aC5tYXgsXG4gICAgICAgICAgICAgIHggPSBNYXRoLm1pbixcbiAgICAgICAgICAgICAgaiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnLkRhdGUubm93KCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGUuZXhwb3J0cyA9IG47XG4gICAgICAgIH0pLmNhbGwodCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KCkpO1xuICAgICAgfSwgZnVuY3Rpb24gKGUsIHQpIHtcblxuICAgICAgICBmdW5jdGlvbiBuKGUpIHtcbiAgICAgICAgICB2YXIgdCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgbyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgaSA9IHZvaWQgMDtcblxuICAgICAgICAgIGZvciAodCA9IDA7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSB7XG4gICAgICAgICAgICBpZiAobyA9IGVbdF0sIG8uZGF0YXNldCAmJiBvLmRhdGFzZXQuYW9zKSByZXR1cm4gITA7XG4gICAgICAgICAgICBpZiAoaSA9IG8uY2hpbGRyZW4gJiYgbihvLmNoaWxkcmVuKSkgcmV0dXJuICEwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG8oKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5Nb3pNdXRhdGlvbk9ic2VydmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgICByZXR1cm4gISFvKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByKGUsIHQpIHtcbiAgICAgICAgICB2YXIgbiA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgICAgICAgaSA9IG8oKSxcbiAgICAgICAgICAgICAgciA9IG5ldyBpKGEpO1xuICAgICAgICAgIHUgPSB0LCByLm9ic2VydmUobi5kb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogITAsXG4gICAgICAgICAgICBzdWJ0cmVlOiAhMCxcbiAgICAgICAgICAgIHJlbW92ZWROb2RlczogITBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGEoZSkge1xuICAgICAgICAgIGUgJiYgZS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUuYWRkZWROb2RlcyksXG4gICAgICAgICAgICAgICAgbyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUucmVtb3ZlZE5vZGVzKSxcbiAgICAgICAgICAgICAgICBpID0gdC5jb25jYXQobyk7XG4gICAgICAgICAgICBpZiAobihpKSkgcmV0dXJuIHUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgIHQuZGVmYXVsdCA9IHtcbiAgICAgICAgICBpc1N1cHBvcnRlZDogaSxcbiAgICAgICAgICByZWFkeTogclxuICAgICAgICB9O1xuICAgICAgfSwgZnVuY3Rpb24gKGUsIHQpIHtcblxuICAgICAgICBmdW5jdGlvbiBuKGUsIHQpIHtcbiAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50IHx8IG5hdmlnYXRvci52ZW5kb3IgfHwgd2luZG93Lm9wZXJhIHx8IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gZShlLCB0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgdmFyIG8gPSB0W25dO1xuICAgICAgICAgICAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgby5rZXksIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgbiwgbykge1xuICAgICAgICAgICAgcmV0dXJuIG4gJiYgZSh0LnByb3RvdHlwZSwgbiksIG8gJiYgZSh0LCBvKSwgdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCksXG4gICAgICAgICAgICByID0gLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLFxuICAgICAgICAgICAgYSA9IC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLFxuICAgICAgICAgICAgdSA9IC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm98YW5kcm9pZHxpcGFkfHBsYXlib29rfHNpbGsvaSxcbiAgICAgICAgICAgIGMgPSAvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaSxcbiAgICAgICAgICAgIHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICAgIG4odGhpcywgZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGkoZSwgW3tcbiAgICAgICAgICAgIGtleTogXCJwaG9uZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSBvKCk7XG4gICAgICAgICAgICAgIHJldHVybiAhKCFyLnRlc3QoZSkgJiYgIWEudGVzdChlLnN1YnN0cigwLCA0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogXCJtb2JpbGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBlID0gbygpO1xuICAgICAgICAgICAgICByZXR1cm4gISghdS50ZXN0KGUpICYmICFjLnRlc3QoZS5zdWJzdHIoMCwgNCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6IFwidGFibGV0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb2JpbGUoKSAmJiAhdGhpcy5waG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1dKSwgZTtcbiAgICAgICAgfSgpO1xuXG4gICAgICAgIHQuZGVmYXVsdCA9IG5ldyBzKCk7XG4gICAgICB9LCBmdW5jdGlvbiAoZSwgdCkge1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbiA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgdmFyIG8gPSBlLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1hb3Mtb25jZVwiKTtcbiAgICAgICAgICB0ID4gZS5wb3NpdGlvbiA/IGUubm9kZS5jbGFzc0xpc3QuYWRkKFwiYW9zLWFuaW1hdGVcIikgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBvICYmIChcImZhbHNlXCIgPT09IG8gfHwgIW4gJiYgXCJ0cnVlXCIgIT09IG8pICYmIGUubm9kZS5jbGFzc0xpc3QucmVtb3ZlKFwiYW9zLWFuaW1hdGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBvID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICB2YXIgbyA9IHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgICAgICAgaSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICBlLmZvckVhY2goZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICAgIG4oZSwgaSArIG8sIHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHQuZGVmYXVsdCA9IG87XG4gICAgICB9LCBmdW5jdGlvbiAoZSwgdCwgbikge1xuXG4gICAgICAgIGZ1bmN0aW9uIG8oZSkge1xuICAgICAgICAgIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaSA9IG4oMTIpLFxuICAgICAgICAgICAgciA9IG8oaSksXG4gICAgICAgICAgICBhID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICByZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICBlLm5vZGUuY2xhc3NMaXN0LmFkZChcImFvcy1pbml0XCIpLCBlLnBvc2l0aW9uID0gKDAsIHIuZGVmYXVsdCkoZS5ub2RlLCB0Lm9mZnNldCk7XG4gICAgICAgICAgfSksIGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdC5kZWZhdWx0ID0gYTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gbyhlKSB7XG4gICAgICAgICAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBpID0gbigxMyksXG4gICAgICAgICAgICByID0gbyhpKSxcbiAgICAgICAgICAgIGEgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICAgICAgbyA9IDAsXG4gICAgICAgICAgICAgIGkgPSB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICAgIGEgPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1hb3Mtb2Zmc2V0XCIpLFxuICAgICAgICAgICAgYW5jaG9yOiBlLmdldEF0dHJpYnV0ZShcImRhdGEtYW9zLWFuY2hvclwiKSxcbiAgICAgICAgICAgIGFuY2hvclBsYWNlbWVudDogZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWFvcy1hbmNob3ItcGxhY2VtZW50XCIpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHN3aXRjaCAoYS5vZmZzZXQgJiYgIWlzTmFOKGEub2Zmc2V0KSAmJiAobyA9IHBhcnNlSW50KGEub2Zmc2V0KSksIGEuYW5jaG9yICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYS5hbmNob3IpICYmIChlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChhLmFuY2hvcilbMF0pLCBuID0gKDAsIHIuZGVmYXVsdCkoZSkudG9wLCBhLmFuY2hvclBsYWNlbWVudCkge1xuICAgICAgICAgICAgY2FzZSBcInRvcC1ib3R0b21cIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJjZW50ZXItYm90dG9tXCI6XG4gICAgICAgICAgICAgIG4gKz0gZS5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImJvdHRvbS1ib3R0b21cIjpcbiAgICAgICAgICAgICAgbiArPSBlLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJ0b3AtY2VudGVyXCI6XG4gICAgICAgICAgICAgIG4gKz0gaSAvIDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiYm90dG9tLWNlbnRlclwiOlxuICAgICAgICAgICAgICBuICs9IGkgLyAyICsgZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiY2VudGVyLWNlbnRlclwiOlxuICAgICAgICAgICAgICBuICs9IGkgLyAyICsgZS5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInRvcC10b3BcIjpcbiAgICAgICAgICAgICAgbiArPSBpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImJvdHRvbS10b3BcIjpcbiAgICAgICAgICAgICAgbiArPSBlLm9mZnNldEhlaWdodCArIGk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiY2VudGVyLXRvcFwiOlxuICAgICAgICAgICAgICBuICs9IGUub2Zmc2V0SGVpZ2h0IC8gMiArIGk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGEuYW5jaG9yUGxhY2VtZW50IHx8IGEub2Zmc2V0IHx8IGlzTmFOKHQpIHx8IChvID0gdCksIG4gKyBvO1xuICAgICAgICB9O1xuXG4gICAgICAgIHQuZGVmYXVsdCA9IGE7XG4gICAgICB9LCBmdW5jdGlvbiAoZSwgdCkge1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZm9yICh2YXIgdCA9IDAsIG4gPSAwOyBlICYmICFpc05hTihlLm9mZnNldExlZnQpICYmICFpc05hTihlLm9mZnNldFRvcCk7KSB0ICs9IGUub2Zmc2V0TGVmdCAtIChcIkJPRFlcIiAhPSBlLnRhZ05hbWUgPyBlLnNjcm9sbExlZnQgOiAwKSwgbiArPSBlLm9mZnNldFRvcCAtIChcIkJPRFlcIiAhPSBlLnRhZ05hbWUgPyBlLnNjcm9sbFRvcCA6IDApLCBlID0gZS5vZmZzZXRQYXJlbnQ7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBuLFxuICAgICAgICAgICAgbGVmdDogdFxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdC5kZWZhdWx0ID0gbjtcbiAgICAgIH0sIGZ1bmN0aW9uIChlLCB0KSB7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZSA9IGUgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWFvc11cIiksIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbm9kZTogZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0LmRlZmF1bHQgPSBuO1xuICAgICAgfV0pO1xuICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIEFPUyA9IHVud3JhcEV4cG9ydHMoYW9zKTtcbiAgICB2YXIgYW9zXzEgPSBhb3MuQU9TO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRmFzaGlvblNsaWRlcihlbCkge1xuICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItZmFzaGlvbicpKSB7XG4gICAgICAgIGNvbnN0IHN3aXBlckVsID0gZWwucXVlcnlTZWxlY3RvcignLnN3aXBlci1mYXNoaW9uJyk7XG4gICAgICAgIGxldCBuYXZpZ2F0aW9uTG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGxldCB0cmFuc2l0aW9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZyYW1lSWQ7XG5cbiAgICAgICAgY29uc3QgZGlzYWJsZVRyYW5zaXRpb25zID0gJGVsID0+IHtcbiAgICAgICAgICAkZWwuYWRkQ2xhc3MoJ2Zhc2hpb24tc2xpZGVyLW5vLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICB0cmFuc2l0aW9uRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgICAgICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgJGVsLnJlbW92ZUNsYXNzKCdmYXNoaW9uLXNsaWRlci1uby10cmFuc2l0aW9uJyk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG5hdmlnYXRpb25Mb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpbml0TmF2aWdhdGlvbiA9IHN3aXBlciA9PiB7XG4gICAgICAgICAgLy8gVXNlIGxvY2sgdG8gY29udHJvbCB0aGUgYnV0dG9uIGxvY2tpbmcgdGltZSB3aXRob3V0IHVzaW5nIHRoZSBidXR0b24gY29tcG9uZW50IHRoYXQgY29tZXMgd2l0aCBpdFxuICAgICAgICAgIHN3aXBlci4kZWwuZmluZCgnLmZhc2hpb24tc2xpZGVyLWJ1dHRvbi1uZXh0Jykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFuYXZpZ2F0aW9uTG9ja2VkKSB7XG4gICAgICAgICAgICAgIHN3aXBlci5zbGlkZU5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzd2lwZXIuJGVsLmZpbmQoJy5mYXNoaW9uLXNsaWRlci1idXR0b24tcHJldicpLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghbmF2aWdhdGlvbkxvY2tlZCkge1xuICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVQcmV2KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZGVzdHJveU5hdmlnYXRpb24gPSBzd2lwZXIgPT4ge1xuICAgICAgICAgIHN3aXBlci4kZWwuZmluZCgnLmZhc2hpb24tc2xpZGVyLWJ1dHRvbi1uZXh0LCAuZmFzaGlvbi1zbGlkZXItYnV0dG9uLXByZXYnKS5vZmYoJ2NsaWNrJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZmFzaGlvblNsaWRlciA9IG5ldyBTd2lwZXIoc3dpcGVyRWwsIHtcbiAgICAgICAgICBtb2R1bGVzOiBbUGFyYWxsYXgsIFBhZ2luYXRpb24sIEF1dG9wbGF5XSxcbiAgICAgICAgICBzcGVlZDogMTMwMCxcbiAgICAgICAgICBhbGxvd1RvdWNoTW92ZTogZmFsc2UsXG4gICAgICAgICAgLy8gbm8gdG91Y2ggc3dpcGluZ1xuICAgICAgICAgIHBhcmFsbGF4OiB0cnVlLFxuICAgICAgICAgIC8vIHRleHQgcGFyYWxsYXhcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgdHJhbnNpdGlvblN0YXJ0KHN3aXBlcikge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXgsXG4gICAgICAgICAgICAgICAgYWN0aXZlSW5kZXgsXG4gICAgICAgICAgICAgICAgJGVsXG4gICAgICAgICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgICAgICAgIGlmICghdHJhbnNpdGlvbkRpc2FibGVkKSBuYXZpZ2F0aW9uTG9ja2VkID0gdHJ1ZTsgLy8gbG9jayBuYXZpZ2F0aW9uIGJ1dHRvbnNcblxuICAgICAgICAgICAgICBjb25zdCAkYWN0aXZlU2xpZGUgPSBzbGlkZXMuZXEoYWN0aXZlSW5kZXgpO1xuICAgICAgICAgICAgICBjb25zdCAkcHJldmlvdXNTbGlkZSA9IHNsaWRlcy5lcShwcmV2aW91c0luZGV4KTtcbiAgICAgICAgICAgICAgY29uc3QgJHByZXZpb3VzSW1hZ2VTY2FsZSA9ICRwcmV2aW91c1NsaWRlLmZpbmQoJy5mYXNoaW9uLXNsaWRlci1zY2FsZScpOyAvLyBpbWFnZSB3cmFwcGVyXG5cbiAgICAgICAgICAgICAgY29uc3QgJHByZXZpb3VzSW1hZ2UgPSAkcHJldmlvdXNTbGlkZS5maW5kKCdpbWcnKTsgLy8gY3VycmVudCBpbWFnZVxuXG4gICAgICAgICAgICAgIGNvbnN0ICRhY3RpdmVJbWFnZSA9ICRhY3RpdmVTbGlkZS5maW5kKCdpbWcnKTsgLy8gbmV4dCBpbWFnZVxuXG4gICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGFjdGl2ZUluZGV4IC0gcHJldmlvdXNJbmRleDtcbiAgICAgICAgICAgICAgY29uc3QgYmdDb2xvciA9ICRhY3RpdmVTbGlkZS5hdHRyKCdkYXRhLXNsaWRlLWJnLWNvbG9yJyk7XG4gICAgICAgICAgICAgICRlbC5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBiZ0NvbG9yKTsgLy8gYmFja2dyb3VuZCBjb2xvciBhbmltYXRpb25cblxuICAgICAgICAgICAgICAkcHJldmlvdXNJbWFnZVNjYWxlLnRyYW5zZm9ybSgnc2NhbGUoMC42KScpO1xuICAgICAgICAgICAgICAkcHJldmlvdXNJbWFnZS50cmFuc2l0aW9uKDEwMDApLnRyYW5zZm9ybSgnc2NhbGUoMS4yKScpOyAvLyBpbWFnZSBzY2FsaW5nIHBhcmFsbGF4XG5cbiAgICAgICAgICAgICAgJHByZXZpb3VzU2xpZGUuZmluZCgnLmZhc2hpb24tc2xpZGVyLXRpdGxlLXRleHQnKS50cmFuc2l0aW9uKDEwMDApLmNzcygnY29sb3InLCAncmdiYSgyNTUsMjU1LDI1NSwwKScpIC8vIHRleHQgdHJhbnNwYXJlbmN5IGFuaW1hdGlvblxuICAgICAgICAgICAgICAuY3NzKCdvcGFjaXR5JywgJzAnKTsgLy8gdGV4dCB0cmFuc3BhcmVuY3kgYW5pbWF0aW9uXG5cbiAgICAgICAgICAgICAgJHByZXZpb3VzSW1hZ2UudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgJGFjdGl2ZUltYWdlLnRyYW5zaXRpb24oMTMwMCkudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgwLCAwLCAwKSBzY2FsZSgxLjIpJyk7IC8vIGltYWdlIHNoaWZ0IHBhcmFsbGF4XG5cbiAgICAgICAgICAgICAgICAkcHJldmlvdXNJbWFnZS50cmFuc2l0aW9uKDEzMDApLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHs2MCAqIGRpcmVjdGlvbn0lLCAwLCAwKSAgc2NhbGUoMS4yKWApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRyYW5zaXRpb25FbmQoc3dpcGVyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBzbGlkZXMsXG4gICAgICAgICAgICAgICAgYWN0aXZlSW5kZXgsXG4gICAgICAgICAgICAgICAgJGVsXG4gICAgICAgICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgICAgICAgIGNvbnN0ICRhY3RpdmVTbGlkZSA9IHNsaWRlcy5lcShhY3RpdmVJbmRleCk7XG4gICAgICAgICAgICAgIGNvbnN0ICRhY3RpdmVJbWFnZSA9ICRhY3RpdmVTbGlkZS5maW5kKCdpbWcnKTtcbiAgICAgICAgICAgICAgJGFjdGl2ZVNsaWRlLmZpbmQoJy5mYXNoaW9uLXNsaWRlci1zY2FsZScpLnRyYW5zZm9ybSgnc2NhbGUoMSknKTtcbiAgICAgICAgICAgICAgJGFjdGl2ZUltYWdlLnRyYW5zaXRpb24oMTAwMCkudHJhbnNmb3JtKCdzY2FsZSgxKScpO1xuICAgICAgICAgICAgICAkYWN0aXZlU2xpZGUuZmluZCgnLmZhc2hpb24tc2xpZGVyLXRpdGxlLXRleHQnKS50cmFuc2l0aW9uKDEwMDApLmNzcygnY29sb3InLCAncmdiYSgyNTUsMjU1LDI1NSwxKScpLmNzcygnb3BhY2l0eScsICcxJyk7IC8vIHRleHQgdHJhbnNwYXJlbmN5IGFuaW1hdGlvblxuXG4gICAgICAgICAgICAgICRhY3RpdmVJbWFnZS50cmFuc2l0aW9uRW5kKCgpID0+IHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uTG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0pOyAvLyBGaXJzdCBhbmQgbGFzdCwgZGlzYWJsZSBidXR0b25cblxuICAgICAgICAgICAgICBpZiAoYWN0aXZlSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAkZWwuZmluZCgnLmZhc2hpb24tc2xpZGVyLWJ1dHRvbi1wcmV2JykuYWRkQ2xhc3MoJ2Zhc2hpb24tc2xpZGVyLWJ1dHRvbi1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRlbC5maW5kKCcuZmFzaGlvbi1zbGlkZXItYnV0dG9uLXByZXYnKS5yZW1vdmVDbGFzcygnZmFzaGlvbi1zbGlkZXItYnV0dG9uLWRpc2FibGVkJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYWN0aXZlSW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgJGVsLmZpbmQoJy5mYXNoaW9uLXNsaWRlci1idXR0b24tbmV4dCcpLmFkZENsYXNzKCdmYXNoaW9uLXNsaWRlci1idXR0b24tZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkZWwuZmluZCgnLmZhc2hpb24tc2xpZGVyLWJ1dHRvbi1uZXh0JykucmVtb3ZlQ2xhc3MoJ2Zhc2hpb24tc2xpZGVyLWJ1dHRvbi1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbml0KHN3aXBlcikge1xuICAgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCBzbGlkZSBiZyBjb2xvclxuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICAgICAgICAgICRlbFxuICAgICAgICAgICAgICB9ID0gc3dpcGVyOyAvLyBkaXNhYmxlIGluaXRpYWwgdHJhbnNpdGlvblxuXG4gICAgICAgICAgICAgIGRpc2FibGVUcmFuc2l0aW9ucygkZWwpOyAvLyBzZXQgY3VycmVudCBiZyBjb2xvclxuXG4gICAgICAgICAgICAgIGNvbnN0IGJnQ29sb3IgPSBzbGlkZXMuZXEoYWN0aXZlSW5kZXgpLmF0dHIoJ2RhdGEtc2xpZGUtYmctY29sb3InKTtcbiAgICAgICAgICAgICAgJGVsLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIGJnQ29sb3IpOyAvLyBiYWNrZ3JvdW5kIGNvbG9yIGFuaW1hdGlvblxuICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSB0cmFuc2l0aW9uRW5kIGV2ZW50IG9uY2UgZHVyaW5nIGluaXRpYWxpemF0aW9uXG5cbiAgICAgICAgICAgICAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25FbmQnKTsgLy8gaW5pdCBuYXZpZ2F0aW9uXG5cbiAgICAgICAgICAgICAgaW5pdE5hdmlnYXRpb24oc3dpcGVyKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc2l6ZShzd2lwZXIpIHtcbiAgICAgICAgICAgICAgZGlzYWJsZVRyYW5zaXRpb25zKHN3aXBlci4kZWwpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGVzdHJveShzd2lwZXIpIHtcbiAgICAgICAgICAgICAgZGVzdHJveU5hdmlnYXRpb24oc3dpcGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgZWw6IFwiLmZhc2hpb24tcGFnaW5hdGlvblwiLFxuICAgICAgICAgICAgdHlwZTogJ2J1bGxldHMnLFxuICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdXRvcGxheToge1xuICAgICAgICAgICAgZGVsYXk6IDI1MDAsXG4gICAgICAgICAgICBkaXNhYmxlT25JbnRlcmFjdGlvbjogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFzaGlvblNsaWRlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAZmFuY3lhcHBzL3VpL0ZhbmN5Ym94IHY0LjAuMzFcbiAgICBjb25zdCB0ID0gdCA9PiBcIm9iamVjdFwiID09IHR5cGVvZiB0ICYmIG51bGwgIT09IHQgJiYgdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIFwiW29iamVjdCBPYmplY3RdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxcbiAgICAgICAgICBlID0gKC4uLmkpID0+IHtcbiAgICAgIGxldCBzID0gITE7XG4gICAgICBcImJvb2xlYW5cIiA9PSB0eXBlb2YgaVswXSAmJiAocyA9IGkuc2hpZnQoKSk7XG4gICAgICBsZXQgbyA9IGlbMF07XG4gICAgICBpZiAoIW8gfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgbykgdGhyb3cgbmV3IEVycm9yKFwiZXh0ZW5kZWUgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICBjb25zdCBuID0gaS5zbGljZSgxKSxcbiAgICAgICAgICAgIGEgPSBuLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IG5baV07XG5cbiAgICAgICAgZm9yIChsZXQgaSBpbiBhKSBpZiAoYS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGNvbnN0IG4gPSBhW2ldO1xuXG4gICAgICAgICAgaWYgKHMgJiYgKEFycmF5LmlzQXJyYXkobikgfHwgdChuKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBBcnJheS5pc0FycmF5KG4pID8gW10gOiB7fTtcbiAgICAgICAgICAgIG9baV0gPSBlKCEwLCBvLmhhc093blByb3BlcnR5KGkpID8gb1tpXSA6IHQsIG4pO1xuICAgICAgICAgIH0gZWxzZSBvW2ldID0gbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuICAgICAgICAgIGkgPSAodCwgZSA9IDFlNCkgPT4gKHQgPSBwYXJzZUZsb2F0KHQpIHx8IDAsIE1hdGgucm91bmQoKHQgKyBOdW1iZXIuRVBTSUxPTikgKiBlKSAvIGUpLFxuICAgICAgICAgIHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICEhKHQgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiB0IGluc3RhbmNlb2YgRWxlbWVudCAmJiB0ICE9PSBkb2N1bWVudC5ib2R5KSAmJiAhdC5fX1Bhbnpvb20gJiYgKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSBnZXRDb21wdXRlZFN0eWxlKHQpW1wib3ZlcmZsb3cteVwiXSxcbiAgICAgICAgICAgICAgaSA9IGdldENvbXB1dGVkU3R5bGUodClbXCJvdmVyZmxvdy14XCJdLFxuICAgICAgICAgICAgICBzID0gKFwic2Nyb2xsXCIgPT09IGUgfHwgXCJhdXRvXCIgPT09IGUpICYmIE1hdGguYWJzKHQuc2Nyb2xsSGVpZ2h0IC0gdC5jbGllbnRIZWlnaHQpID4gMSxcbiAgICAgICAgICAgICAgbyA9IChcInNjcm9sbFwiID09PSBpIHx8IFwiYXV0b1wiID09PSBpKSAmJiBNYXRoLmFicyh0LnNjcm9sbFdpZHRoIC0gdC5jbGllbnRXaWR0aCkgPiAxO1xuICAgICAgICByZXR1cm4gcyB8fCBvO1xuICAgICAgfSh0KSA/IHQgOiBzKHQucGFyZW50Tm9kZSkpO1xuICAgIH0sXG4gICAgICAgICAgbyA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgfHwgY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gW10sIHRoaXMuYm91bmRDaGVjayA9IHRoaXMuY2hlY2suYmluZCh0aGlzKSwgdGhpcy5ib3VuZENoZWNrKCksIHRoaXMuY2FsbGJhY2sgPSB0O1xuICAgICAgfVxuXG4gICAgICBvYnNlcnZlKHQpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2YWJsZXMuc29tZShlID0+IGUuZWwgPT09IHQpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgICAgZWw6IHQsXG4gICAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgaGVpZ2h0OiB0LmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB0LmNsaWVudFdpZHRoXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzLnB1c2goZSk7XG4gICAgICB9XG5cbiAgICAgIHVub2JzZXJ2ZSh0KSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSB0aGlzLm9ic2VydmFibGVzLmZpbHRlcihlID0+IGUuZWwgIT09IHQpO1xuICAgICAgfVxuXG4gICAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gW107XG4gICAgICB9XG5cbiAgICAgIGNoZWNrKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5vYnNlcnZhYmxlcy5maWx0ZXIodCA9PiB7XG4gICAgICAgICAgY29uc3QgZSA9IHQuZWwuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGkgPSB0LmVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgIGlmICh0LnNpemUuaGVpZ2h0ICE9PSBlIHx8IHQuc2l6ZS53aWR0aCAhPT0gaSkgcmV0dXJuIHQuc2l6ZS5oZWlnaHQgPSBlLCB0LnNpemUud2lkdGggPSBpLCAhMDtcbiAgICAgICAgfSkubWFwKHQgPT4gdC5lbCk7XG4gICAgICAgIHQubGVuZ3RoID4gMCAmJiB0aGlzLmNhbGxiYWNrKHQpLCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYm91bmRDaGVjayk7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgY2xhc3MgbiB7XG4gICAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHRoaXMuaWQgPSBzZWxmLlRvdWNoICYmIHQgaW5zdGFuY2VvZiBUb3VjaCA/IHQuaWRlbnRpZmllciA6IC0xLCB0aGlzLnBhZ2VYID0gdC5wYWdlWCwgdGhpcy5wYWdlWSA9IHQucGFnZVksIHRoaXMuY2xpZW50WCA9IHQuY2xpZW50WCwgdGhpcy5jbGllbnRZID0gdC5jbGllbnRZO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgY29uc3QgYSA9ICh0LCBlKSA9PiBlID8gTWF0aC5zcXJ0KChlLmNsaWVudFggLSB0LmNsaWVudFgpICoqIDIgKyAoZS5jbGllbnRZIC0gdC5jbGllbnRZKSAqKiAyKSA6IDAsXG4gICAgICAgICAgciA9ICh0LCBlKSA9PiBlID8ge1xuICAgICAgY2xpZW50WDogKHQuY2xpZW50WCArIGUuY2xpZW50WCkgLyAyLFxuICAgICAgY2xpZW50WTogKHQuY2xpZW50WSArIGUuY2xpZW50WSkgLyAyXG4gICAgfSA6IHQ7XG5cbiAgICBjbGFzcyBoIHtcbiAgICAgIGNvbnN0cnVjdG9yKHQsIHtcbiAgICAgICAgc3RhcnQ6IGUgPSAoKSA9PiAhMCxcbiAgICAgICAgbW92ZTogaSA9ICgpID0+IHt9LFxuICAgICAgICBlbmQ6IHMgPSAoKSA9PiB7fVxuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLnN0YXJ0UG9pbnRlcnMgPSBbXSwgdGhpcy5jdXJyZW50UG9pbnRlcnMgPSBbXSwgdGhpcy5fcG9pbnRlclN0YXJ0ID0gdCA9PiB7XG4gICAgICAgICAgaWYgKHQuYnV0dG9ucyA+IDAgJiYgMCAhPT0gdC5idXR0b24pIHJldHVybjtcbiAgICAgICAgICBjb25zdCBlID0gbmV3IG4odCk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnRlcnMuc29tZSh0ID0+IHQuaWQgPT09IGUuaWQpIHx8IHRoaXMuX3RyaWdnZXJQb2ludGVyU3RhcnQoZSwgdCkgJiYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdmUpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fcG9pbnRlckVuZCkpO1xuICAgICAgICB9LCB0aGlzLl90b3VjaFN0YXJ0ID0gdCA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlIG9mIEFycmF5LmZyb20odC5jaGFuZ2VkVG91Y2hlcyB8fCBbXSkpIHRoaXMuX3RyaWdnZXJQb2ludGVyU3RhcnQobmV3IG4oZSksIHQpO1xuICAgICAgICB9LCB0aGlzLl9tb3ZlID0gdCA9PiB7XG4gICAgICAgICAgY29uc3QgZSA9IHRoaXMuY3VycmVudFBvaW50ZXJzLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgaSA9ICh0ID0+IFwiY2hhbmdlZFRvdWNoZXNcIiBpbiB0KSh0KSA/IEFycmF5LmZyb20odC5jaGFuZ2VkVG91Y2hlcykubWFwKHQgPT4gbmV3IG4odCkpIDogW25ldyBuKHQpXTtcblxuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBpKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcy5jdXJyZW50UG9pbnRlcnMuZmluZEluZGV4KGUgPT4gZS5pZCA9PT0gdC5pZCk7XG4gICAgICAgICAgICBlIDwgMCB8fCAodGhpcy5jdXJyZW50UG9pbnRlcnNbZV0gPSB0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tb3ZlQ2FsbGJhY2soZSwgdGhpcy5jdXJyZW50UG9pbnRlcnMuc2xpY2UoKSwgdCk7XG4gICAgICAgIH0sIHRoaXMuX3RyaWdnZXJQb2ludGVyRW5kID0gKHQsIGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gdGhpcy5jdXJyZW50UG9pbnRlcnMuZmluZEluZGV4KGUgPT4gZS5pZCA9PT0gdC5pZCk7XG4gICAgICAgICAgcmV0dXJuICEoaSA8IDApICYmICh0aGlzLmN1cnJlbnRQb2ludGVycy5zcGxpY2UoaSwgMSksIHRoaXMuc3RhcnRQb2ludGVycy5zcGxpY2UoaSwgMSksIHRoaXMuX2VuZENhbGxiYWNrKHQsIGUpLCAhMCk7XG4gICAgICAgIH0sIHRoaXMuX3BvaW50ZXJFbmQgPSB0ID0+IHtcbiAgICAgICAgICB0LmJ1dHRvbnMgPiAwICYmIDAgIT09IHQuYnV0dG9uIHx8IHRoaXMuX3RyaWdnZXJQb2ludGVyRW5kKG5ldyBuKHQpLCB0KSAmJiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fbW92ZSwge1xuICAgICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgICB9KSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX3BvaW50ZXJFbmQsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LCB0aGlzLl90b3VjaEVuZCA9IHQgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBBcnJheS5mcm9tKHQuY2hhbmdlZFRvdWNoZXMgfHwgW10pKSB0aGlzLl90cmlnZ2VyUG9pbnRlckVuZChuZXcgbihlKSwgdCk7XG4gICAgICAgIH0sIHRoaXMuX3N0YXJ0Q2FsbGJhY2sgPSBlLCB0aGlzLl9tb3ZlQ2FsbGJhY2sgPSBpLCB0aGlzLl9lbmRDYWxsYmFjayA9IHMsIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9wb2ludGVyU3RhcnQsIHtcbiAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICB9KSwgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaFN0YXJ0LCB7XG4gICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgfSksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9tb3ZlLCB7XG4gICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgfSksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3RvdWNoRW5kKSwgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy5fdG91Y2hFbmQpO1xuICAgICAgfVxuXG4gICAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fcG9pbnRlclN0YXJ0LCB7XG4gICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgfSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hTdGFydCwge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fbW92ZSwge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaEVuZCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIHRoaXMuX3RvdWNoRW5kKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fbW92ZSksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9wb2ludGVyRW5kKTtcbiAgICAgIH1cblxuICAgICAgX3RyaWdnZXJQb2ludGVyU3RhcnQodCwgZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zdGFydENhbGxiYWNrKHQsIGUpICYmICh0aGlzLmN1cnJlbnRQb2ludGVycy5wdXNoKHQpLCB0aGlzLnN0YXJ0UG9pbnRlcnMucHVzaCh0KSwgITApO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgY2xhc3MgbCB7XG4gICAgICBjb25zdHJ1Y3Rvcih0ID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZSghMCwge30sIHQpLCB0aGlzLnBsdWdpbnMgPSBbXSwgdGhpcy5ldmVudHMgPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgW1wib25cIiwgXCJvbmNlXCJdKSBmb3IgKGNvbnN0IGUgb2YgT2JqZWN0LmVudHJpZXModGhpcy5vcHRpb25zW3RdIHx8IHt9KSkgdGhpc1t0XSguLi5lKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9uKHQsIGUsIC4uLmkpIHtcbiAgICAgICAgdCA9IFN0cmluZyh0KTtcbiAgICAgICAgbGV0IHMgPSAobyA9IHQsIG4gPSB0aGlzLm9wdGlvbnMsIG8uc3BsaXQoXCIuXCIpLnJlZHVjZShmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0ICYmIHRbZV07XG4gICAgICAgIH0sIG4pKTtcbiAgICAgICAgdmFyIG8sIG47XG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHMgJiYgKHMgPSBzLmNhbGwodGhpcywgdGhpcywgLi4uaSkpLCB2b2lkIDAgPT09IHMgPyBlIDogcztcbiAgICAgIH1cblxuICAgICAgbG9jYWxpemUodCwgZSA9IFtdKSB7XG4gICAgICAgIHJldHVybiB0ID0gKHQgPSBTdHJpbmcodCkucmVwbGFjZSgvXFx7XFx7KFxcdyspLj8oXFx3Kyk/XFx9XFx9L2csICh0LCBpLCBzKSA9PiB7XG4gICAgICAgICAgbGV0IG8gPSBcIlwiO1xuICAgICAgICAgIHMgPyBvID0gdGhpcy5vcHRpb24oYCR7aVswXSArIGkudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMSl9LmwxMG4uJHtzfWApIDogaSAmJiAobyA9IHRoaXMub3B0aW9uKGBsMTBuLiR7aX1gKSksIG8gfHwgKG8gPSB0KTtcblxuICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKykgbyA9IG8uc3BsaXQoZVt0XVswXSkuam9pbihlW3RdWzFdKTtcblxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9KSkucmVwbGFjZSgvXFx7XFx7KC4qKVxcfVxcfS8sICh0LCBlKSA9PiBlKTtcbiAgICAgIH1cblxuICAgICAgb24oZSwgaSkge1xuICAgICAgICBpZiAodChlKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBPYmplY3QuZW50cmllcyhlKSkgdGhpcy5vbiguLi50KTtcblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN0cmluZyhlKS5zcGxpdChcIiBcIikuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBjb25zdCBlID0gdGhpcy5ldmVudHNbdF0gPSB0aGlzLmV2ZW50c1t0XSB8fCBbXTtcbiAgICAgICAgICAtMSA9PSBlLmluZGV4T2YoaSkgJiYgZS5wdXNoKGkpO1xuICAgICAgICB9KSwgdGhpcztcbiAgICAgIH1cblxuICAgICAgb25jZShlLCBpKSB7XG4gICAgICAgIGlmICh0KGUpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB0IG9mIE9iamVjdC5lbnRyaWVzKGUpKSB0aGlzLm9uY2UoLi4udCk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTdHJpbmcoZSkuc3BsaXQoXCIgXCIpLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgY29uc3QgZSA9ICguLi5zKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9mZih0LCBlKSwgaS5jYWxsKHRoaXMsIHRoaXMsIC4uLnMpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBlLl8gPSBpLCB0aGlzLm9uKHQsIGUpO1xuICAgICAgICB9KSwgdGhpcztcbiAgICAgIH1cblxuICAgICAgb2ZmKGUsIGkpIHtcbiAgICAgICAgaWYgKCF0KGUpKSByZXR1cm4gZS5zcGxpdChcIiBcIikuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBjb25zdCBlID0gdGhpcy5ldmVudHNbdF07XG4gICAgICAgICAgaWYgKCFlIHx8ICFlLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgbGV0IHMgPSAtMTtcblxuICAgICAgICAgIGZvciAobGV0IHQgPSAwLCBvID0gZS5sZW5ndGg7IHQgPCBvOyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBlW3RdO1xuXG4gICAgICAgICAgICBpZiAobyAmJiAobyA9PT0gaSB8fCBvLl8gPT09IGkpKSB7XG4gICAgICAgICAgICAgIHMgPSB0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAtMSAhPSBzICYmIGUuc3BsaWNlKHMsIDEpO1xuICAgICAgICB9KSwgdGhpcztcblxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgT2JqZWN0LmVudHJpZXMoZSkpIHRoaXMub2ZmKC4uLnQpO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyKHQsIC4uLmUpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIFsuLi4odGhpcy5ldmVudHNbdF0gfHwgW10pXS5zbGljZSgpKSBpZiAoaSAmJiAhMSA9PT0gaS5jYWxsKHRoaXMsIHRoaXMsIC4uLmUpKSByZXR1cm4gITE7XG5cbiAgICAgICAgZm9yIChjb25zdCBpIG9mIFsuLi4odGhpcy5ldmVudHNbXCIqXCJdIHx8IFtdKV0uc2xpY2UoKSkgaWYgKGkgJiYgITEgPT09IGkuY2FsbCh0aGlzLCB0LCB0aGlzLCAuLi5lKSkgcmV0dXJuICExO1xuXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cblxuICAgICAgYXR0YWNoUGx1Z2lucyh0KSB7XG4gICAgICAgIGNvbnN0IGkgPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtzLCBvXSBvZiBPYmplY3QuZW50cmllcyh0IHx8IHt9KSkgITEgPT09IHRoaXMub3B0aW9uc1tzXSB8fCB0aGlzLnBsdWdpbnNbc10gfHwgKHRoaXMub3B0aW9uc1tzXSA9IGUoe30sIG8uZGVmYXVsdHMgfHwge30sIHRoaXMub3B0aW9uc1tzXSksIGlbc10gPSBuZXcgbyh0aGlzKSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbdCwgZV0gb2YgT2JqZWN0LmVudHJpZXMoaSkpIGUuYXR0YWNoKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBsdWdpbnMsIGkpLCB0aGlzO1xuICAgICAgfVxuXG4gICAgICBkZXRhY2hQbHVnaW5zKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgbGV0IGU7XG4gICAgICAgICAgKGUgPSB0aGlzLnBsdWdpbnNbdF0pICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5kZXRhY2ggJiYgZS5kZXRhY2godGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5zID0ge30sIHRoaXM7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBjb25zdCBjID0ge1xuICAgICAgdG91Y2g6ICEwLFxuICAgICAgem9vbTogITAsXG4gICAgICBwaW5jaFRvWm9vbTogITAsXG4gICAgICBwYW5Pbmx5Wm9vbWVkOiAhMSxcbiAgICAgIGxvY2tBeGlzOiAhMSxcbiAgICAgIGZyaWN0aW9uOiAuNjQsXG4gICAgICBkZWNlbEZyaWN0aW9uOiAuODgsXG4gICAgICB6b29tRnJpY3Rpb246IC43NCxcbiAgICAgIGJvdW5jZUZvcmNlOiAuMixcbiAgICAgIGJhc2VTY2FsZTogMSxcbiAgICAgIG1pblNjYWxlOiAxLFxuICAgICAgbWF4U2NhbGU6IDIsXG4gICAgICBzdGVwOiAuNSxcbiAgICAgIHRleHRTZWxlY3Rpb246ICExLFxuICAgICAgY2xpY2s6IFwidG9nZ2xlWm9vbVwiLFxuICAgICAgd2hlZWw6IFwiem9vbVwiLFxuICAgICAgd2hlZWxGYWN0b3I6IDQyLFxuICAgICAgd2hlZWxMaW1pdDogNSxcbiAgICAgIGRyYWdnYWJsZUNsYXNzOiBcImlzLWRyYWdnYWJsZVwiLFxuICAgICAgZHJhZ2dpbmdDbGFzczogXCJpcy1kcmFnZ2luZ1wiLFxuICAgICAgcmF0aW86IDFcbiAgICB9O1xuXG4gICAgY2xhc3MgZCBleHRlbmRzIGwge1xuICAgICAgY29uc3RydWN0b3IodCwgaSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGUoITAsIHt9LCBjLCBpKSksIHRoaXMuc3RhdGUgPSBcImluaXRcIiwgdGhpcy4kY29udGFpbmVyID0gdDtcblxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgW1wib25Mb2FkXCIsIFwib25XaGVlbFwiLCBcIm9uQ2xpY2tcIl0pIHRoaXNbdF0gPSB0aGlzW3RdLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5pbml0TGF5b3V0KCksIHRoaXMucmVzZXRWYWx1ZXMoKSwgdGhpcy5hdHRhY2hQbHVnaW5zKGQuUGx1Z2lucyksIHRoaXMudHJpZ2dlcihcImluaXRcIiksIHRoaXMudXBkYXRlTWV0cmljcygpLCB0aGlzLmF0dGFjaEV2ZW50cygpLCB0aGlzLnRyaWdnZXIoXCJyZWFkeVwiKSwgITEgPT09IHRoaXMub3B0aW9uKFwiY2VudGVyT25TdGFydFwiKSA/IHRoaXMuc3RhdGUgPSBcInJlYWR5XCIgOiB0aGlzLnBhblRvKHtcbiAgICAgICAgICBmcmljdGlvbjogMFxuICAgICAgICB9KSwgdC5fX1Bhbnpvb20gPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpbml0TGF5b3V0KCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy4kY29udGFpbmVyO1xuICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJQYW56b29tOiBDb250YWluZXIgbm90IGZvdW5kXCIpO1xuICAgICAgICBjb25zdCBlID0gdGhpcy5vcHRpb24oXCJjb250ZW50XCIpIHx8IHQucXVlcnlTZWxlY3RvcihcIi5wYW56b29tX19jb250ZW50XCIpO1xuICAgICAgICBpZiAoIWUpIHRocm93IG5ldyBFcnJvcihcIlBhbnpvb206IENvbnRlbnQgbm90IGZvdW5kXCIpO1xuICAgICAgICB0aGlzLiRjb250ZW50ID0gZTtcbiAgICAgICAgbGV0IGkgPSB0aGlzLm9wdGlvbihcInZpZXdwb3J0XCIpIHx8IHQucXVlcnlTZWxlY3RvcihcIi5wYW56b29tX192aWV3cG9ydFwiKTtcbiAgICAgICAgaSB8fCAhMSA9PT0gdGhpcy5vcHRpb24oXCJ3cmFwSW5uZXJcIikgfHwgKGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBpLmNsYXNzTGlzdC5hZGQoXCJwYW56b29tX192aWV3cG9ydFwiKSwgaS5hcHBlbmQoLi4udC5jaGlsZE5vZGVzKSwgdC5hcHBlbmRDaGlsZChpKSksIHRoaXMuJHZpZXdwb3J0ID0gaSB8fCBlLnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0VmFsdWVzKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJhdGUgPSB0aGlzLm9wdGlvbihcInVwZGF0ZVJhdGVcIiwgL2lQaG9uZXxpUGFkfGlQb2R8QW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPyAyNTAgOiAyNCksIHRoaXMuY29udGFpbmVyID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LCB0aGlzLnZpZXdwb3J0ID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LCB0aGlzLmNvbnRlbnQgPSB7XG4gICAgICAgICAgb3JpZ1dpZHRoOiAwLFxuICAgICAgICAgIG9yaWdIZWlnaHQ6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIHg6IHRoaXMub3B0aW9uKFwieFwiLCAwKSxcbiAgICAgICAgICB5OiB0aGlzLm9wdGlvbihcInlcIiwgMCksXG4gICAgICAgICAgc2NhbGU6IHRoaXMub3B0aW9uKFwiYmFzZVNjYWxlXCIpXG4gICAgICAgIH0sIHRoaXMudHJhbnNmb3JtID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICBzY2FsZTogMVxuICAgICAgICB9LCB0aGlzLnJlc2V0RHJhZ1Bvc2l0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIG9uTG9hZCh0KSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWV0cmljcygpLCB0aGlzLnBhblRvKHtcbiAgICAgICAgICBzY2FsZTogdGhpcy5vcHRpb24oXCJiYXNlU2NhbGVcIiksXG4gICAgICAgICAgZnJpY3Rpb246IDBcbiAgICAgICAgfSksIHRoaXMudHJpZ2dlcihcImxvYWRcIiwgdCk7XG4gICAgICB9XG5cbiAgICAgIG9uQ2xpY2sodCkge1xuICAgICAgICBpZiAodC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY2xvc2VzdChcIltjb250ZW50ZWRpdGFibGVdXCIpKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbihcInRleHRTZWxlY3Rpb25cIikgJiYgd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCkubGVuZ3RoICYmICghdC50YXJnZXQgfHwgIXQudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtZmFuY3lib3gtY2xvc2VcIikpKSByZXR1cm4gdm9pZCB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCBlID0gdGhpcy4kY29udGVudC5nZXRDbGllbnRSZWN0cygpWzBdO1xuICAgICAgICBpZiAoXCJyZWFkeVwiICE9PSB0aGlzLnN0YXRlICYmICh0aGlzLmRyYWdQb3NpdGlvbi5taWRQb2ludCB8fCBNYXRoLmFicyhlLnRvcCAtIHRoaXMuZHJhZ1N0YXJ0LnJlY3QudG9wKSA+IDEgfHwgTWF0aC5hYnMoZS5sZWZ0IC0gdGhpcy5kcmFnU3RhcnQucmVjdC5sZWZ0KSA+IDEpKSByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpLCB2b2lkIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICExICE9PSB0aGlzLnRyaWdnZXIoXCJjbGlja1wiLCB0KSAmJiB0aGlzLm9wdGlvbihcInpvb21cIikgJiYgXCJ0b2dnbGVab29tXCIgPT09IHRoaXMub3B0aW9uKFwiY2xpY2tcIikgJiYgKHQucHJldmVudERlZmF1bHQoKSwgdC5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy56b29tV2l0aENsaWNrKHQpKTtcbiAgICAgIH1cblxuICAgICAgb25XaGVlbCh0KSB7XG4gICAgICAgICExICE9PSB0aGlzLnRyaWdnZXIoXCJ3aGVlbFwiLCB0KSAmJiB0aGlzLm9wdGlvbihcInpvb21cIikgJiYgdGhpcy5vcHRpb24oXCJ3aGVlbFwiKSAmJiB0aGlzLnpvb21XaXRoV2hlZWwodCk7XG4gICAgICB9XG5cbiAgICAgIHpvb21XaXRoV2hlZWwodCkge1xuICAgICAgICB2b2lkIDAgPT09IHRoaXMuY2hhbmdlZERlbHRhICYmICh0aGlzLmNoYW5nZWREZWx0YSA9IDApO1xuICAgICAgICBjb25zdCBlID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIC10LmRlbHRhWSB8fCAtdC5kZWx0YVggfHwgdC53aGVlbERlbHRhIHx8IC10LmRldGFpbCkpLFxuICAgICAgICAgICAgICBpID0gdGhpcy5jb250ZW50LnNjYWxlO1xuICAgICAgICBsZXQgcyA9IGkgKiAoMTAwICsgZSAqIHRoaXMub3B0aW9uKFwid2hlZWxGYWN0b3JcIikpIC8gMTAwO1xuICAgICAgICBpZiAoZSA8IDAgJiYgTWF0aC5hYnMoaSAtIHRoaXMub3B0aW9uKFwibWluU2NhbGVcIikpIDwgLjAxIHx8IGUgPiAwICYmIE1hdGguYWJzKGkgLSB0aGlzLm9wdGlvbihcIm1heFNjYWxlXCIpKSA8IC4wMSA/ICh0aGlzLmNoYW5nZWREZWx0YSArPSBNYXRoLmFicyhlKSwgcyA9IGkpIDogKHRoaXMuY2hhbmdlZERlbHRhID0gMCwgcyA9IE1hdGgubWF4KE1hdGgubWluKHMsIHRoaXMub3B0aW9uKFwibWF4U2NhbGVcIikpLCB0aGlzLm9wdGlvbihcIm1pblNjYWxlXCIpKSksIHRoaXMuY2hhbmdlZERlbHRhID4gdGhpcy5vcHRpb24oXCJ3aGVlbExpbWl0XCIpKSByZXR1cm47XG4gICAgICAgIGlmICh0LnByZXZlbnREZWZhdWx0KCksIHMgPT09IGkpIHJldHVybjtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuJGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgIG4gPSB0LmNsaWVudFggLSBvLmxlZnQsXG4gICAgICAgICAgICAgIGEgPSB0LmNsaWVudFkgLSBvLnRvcDtcbiAgICAgICAgdGhpcy56b29tVG8ocywge1xuICAgICAgICAgIHg6IG4sXG4gICAgICAgICAgeTogYVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgem9vbVdpdGhDbGljayh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLiRjb250ZW50LmdldENsaWVudFJlY3RzKClbMF0sXG4gICAgICAgICAgICAgIGkgPSB0LmNsaWVudFggLSBlLmxlZnQsXG4gICAgICAgICAgICAgIHMgPSB0LmNsaWVudFkgLSBlLnRvcDtcbiAgICAgICAgdGhpcy50b2dnbGVab29tKHtcbiAgICAgICAgICB4OiBpLFxuICAgICAgICAgIHk6IHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgICAgdGhpcy4kY29udGVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLm9uTG9hZCksIHRoaXMuJGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5vbldoZWVsLCB7XG4gICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgfSksIHRoaXMuJGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5vbkNsaWNrLCB7XG4gICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgfSksIHRoaXMuaW5pdE9ic2VydmVyKCk7XG4gICAgICAgIGNvbnN0IHQgPSBuZXcgaCh0aGlzLiRjb250YWluZXIsIHtcbiAgICAgICAgICBzdGFydDogKGUsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb24oXCJ0b3VjaFwiKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgaWYgKHRoaXMudmVsb2NpdHkuc2NhbGUgPCAwKSByZXR1cm4gITE7XG4gICAgICAgICAgICBjb25zdCBvID0gaS5jb21wb3NlZFBhdGgoKVswXTtcblxuICAgICAgICAgICAgaWYgKCF0LmN1cnJlbnRQb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKC0xICE9PSBbXCJCVVRUT05cIiwgXCJURVhUQVJFQVwiLCBcIk9QVElPTlwiLCBcIklOUFVUXCIsIFwiU0VMRUNUXCIsIFwiVklERU9cIl0uaW5kZXhPZihvLm5vZGVOYW1lKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb24oXCJ0ZXh0U2VsZWN0aW9uXCIpICYmICgodCwgZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0LmNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgbyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBzW3RdO1xuICAgICAgICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIG8uc2VsZWN0Tm9kZUNvbnRlbnRzKG4pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoZSA+PSBhLmxlZnQgJiYgaSA+PSBhLnRvcCAmJiBlIDw9IGEucmlnaHQgJiYgaSA8PSBhLmJvdHRvbSkgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICB9KShvLCBlLmNsaWVudFgsIGUuY2xpZW50WSkpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICFzKG8pICYmICExICE9PSB0aGlzLnRyaWdnZXIoXCJ0b3VjaFN0YXJ0XCIsIGkpICYmIChcIm1vdXNlZG93blwiID09PSBpLnR5cGUgJiYgaS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnN0YXRlID0gXCJwb2ludGVyZG93blwiLCB0aGlzLnJlc2V0RHJhZ1Bvc2l0aW9uKCksIHRoaXMuZHJhZ1Bvc2l0aW9uLm1pZFBvaW50ID0gbnVsbCwgdGhpcy5kcmFnUG9zaXRpb24udGltZSA9IERhdGUubm93KCksICEwKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vdmU6IChlLCBpLCBzKSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJwb2ludGVyZG93blwiICE9PSB0aGlzLnN0YXRlKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoITEgPT09IHRoaXMudHJpZ2dlcihcInRvdWNoTW92ZVwiLCBzKSkgcmV0dXJuIHZvaWQgcy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGkubGVuZ3RoIDwgMiAmJiAhMCA9PT0gdGhpcy5vcHRpb24oXCJwYW5Pbmx5Wm9vbWVkXCIpICYmIHRoaXMuY29udGVudC53aWR0aCA8PSB0aGlzLnZpZXdwb3J0LndpZHRoICYmIHRoaXMuY29udGVudC5oZWlnaHQgPD0gdGhpcy52aWV3cG9ydC5oZWlnaHQgJiYgdGhpcy50cmFuc2Zvcm0uc2NhbGUgPD0gdGhpcy5vcHRpb24oXCJiYXNlU2NhbGVcIikpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChpLmxlbmd0aCA+IDEgJiYgKCF0aGlzLm9wdGlvbihcInpvb21cIikgfHwgITEgPT09IHRoaXMub3B0aW9uKFwicGluY2hUb1pvb21cIikpKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBvID0gcihlWzBdLCBlWzFdKSxcbiAgICAgICAgICAgICAgICAgIG4gPSByKGlbMF0sIGlbMV0pLFxuICAgICAgICAgICAgICAgICAgaCA9IG4uY2xpZW50WCAtIG8uY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgIGwgPSBuLmNsaWVudFkgLSBvLmNsaWVudFksXG4gICAgICAgICAgICAgICAgICBjID0gYShlWzBdLCBlWzFdKSxcbiAgICAgICAgICAgICAgICAgIGQgPSBhKGlbMF0sIGlbMV0pLFxuICAgICAgICAgICAgICAgICAgdSA9IGMgJiYgZCA/IGQgLyBjIDogMTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ09mZnNldC54ICs9IGgsIHRoaXMuZHJhZ09mZnNldC55ICs9IGwsIHRoaXMuZHJhZ09mZnNldC5zY2FsZSAqPSB1LCB0aGlzLmRyYWdPZmZzZXQudGltZSA9IERhdGUubm93KCkgLSB0aGlzLmRyYWdQb3NpdGlvbi50aW1lO1xuICAgICAgICAgICAgY29uc3QgZiA9IDEgPT09IHRoaXMuZHJhZ1N0YXJ0LnNjYWxlICYmIHRoaXMub3B0aW9uKFwibG9ja0F4aXNcIik7XG5cbiAgICAgICAgICAgIGlmIChmICYmICF0aGlzLmxvY2tBeGlzKSB7XG4gICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmRyYWdPZmZzZXQueCkgPCA2ICYmIE1hdGguYWJzKHRoaXMuZHJhZ09mZnNldC55KSA8IDYpIHJldHVybiB2b2lkIHMucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgY29uc3QgdCA9IE1hdGguYWJzKDE4MCAqIE1hdGguYXRhbjIodGhpcy5kcmFnT2Zmc2V0LnksIHRoaXMuZHJhZ09mZnNldC54KSAvIE1hdGguUEkpO1xuICAgICAgICAgICAgICB0aGlzLmxvY2tBeGlzID0gdCA+IDQ1ICYmIHQgPCAxMzUgPyBcInlcIiA6IFwieFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXCJ4eVwiID09PSBmIHx8IFwieVwiICE9PSB0aGlzLmxvY2tBeGlzKSB7XG4gICAgICAgICAgICAgIGlmIChzLnByZXZlbnREZWZhdWx0KCksIHMuc3RvcFByb3BhZ2F0aW9uKCksIHMuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIHRoaXMubG9ja0F4aXMgJiYgKHRoaXMuZHJhZ09mZnNldFtcInhcIiA9PT0gdGhpcy5sb2NrQXhpcyA/IFwieVwiIDogXCJ4XCJdID0gMCksIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9uKFwiZHJhZ2dpbmdDbGFzc1wiKSksIHRoaXMudHJhbnNmb3JtLnNjYWxlID09PSB0aGlzLm9wdGlvbihcImJhc2VTY2FsZVwiKSAmJiBcInlcIiA9PT0gdGhpcy5sb2NrQXhpcyB8fCAodGhpcy5kcmFnUG9zaXRpb24ueCA9IHRoaXMuZHJhZ1N0YXJ0LnggKyB0aGlzLmRyYWdPZmZzZXQueCksIHRoaXMudHJhbnNmb3JtLnNjYWxlID09PSB0aGlzLm9wdGlvbihcImJhc2VTY2FsZVwiKSAmJiBcInhcIiA9PT0gdGhpcy5sb2NrQXhpcyB8fCAodGhpcy5kcmFnUG9zaXRpb24ueSA9IHRoaXMuZHJhZ1N0YXJ0LnkgKyB0aGlzLmRyYWdPZmZzZXQueSksIHRoaXMuZHJhZ1Bvc2l0aW9uLnNjYWxlID0gdGhpcy5kcmFnU3RhcnQuc2NhbGUgKiB0aGlzLmRyYWdPZmZzZXQuc2NhbGUsIGkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSByKHQuc3RhcnRQb2ludGVyc1swXSwgdC5zdGFydFBvaW50ZXJzWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICBpID0gZS5jbGllbnRYIC0gdGhpcy5kcmFnU3RhcnQucmVjdC54LFxuICAgICAgICAgICAgICAgICAgICAgIHMgPSBlLmNsaWVudFkgLSB0aGlzLmRyYWdTdGFydC5yZWN0LnksXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZGVsdGFYOiBvLFxuICAgICAgICAgICAgICAgICAgZGVsdGFZOiBhXG4gICAgICAgICAgICAgICAgfSA9IHRoaXMuZ2V0Wm9vbURlbHRhKHRoaXMuY29udGVudC5zY2FsZSAqIHRoaXMuZHJhZ09mZnNldC5zY2FsZSwgaSwgcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnUG9zaXRpb24ueCAtPSBvLCB0aGlzLmRyYWdQb3NpdGlvbi55IC09IGEsIHRoaXMuZHJhZ1Bvc2l0aW9uLm1pZFBvaW50ID0gbjtcbiAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuc2V0RHJhZ1Jlc2lzdGFuY2UoKTtcblxuICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmRyYWdQb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuZHJhZ1Bvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgc2NhbGU6IHRoaXMuZHJhZ1Bvc2l0aW9uLnNjYWxlXG4gICAgICAgICAgICAgIH0sIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDogKGUsIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChcInBvaW50ZXJkb3duXCIgIT09IHRoaXMuc3RhdGUpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmFnT2Zmc2V0ID0geyAuLi50aGlzLmRyYWdPZmZzZXRcbiAgICAgICAgICAgIH0sIHQuY3VycmVudFBvaW50ZXJzLmxlbmd0aCkgcmV0dXJuIHZvaWQgdGhpcy5yZXNldERyYWdQb3NpdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPSBcImRlY2VsXCIsIHRoaXMuZnJpY3Rpb24gPSB0aGlzLm9wdGlvbihcImRlY2VsRnJpY3Rpb25cIiksIHRoaXMucmVjYWxjdWxhdGVUcmFuc2Zvcm0oKSwgdGhpcy4kY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb24oXCJkcmFnZ2luZ0NsYXNzXCIpKSwgITEgPT09IHRoaXMudHJpZ2dlcihcInRvdWNoRW5kXCIsIGkpKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoXCJkZWNlbFwiICE9PSB0aGlzLnN0YXRlKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5vcHRpb24oXCJtaW5TY2FsZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybS5zY2FsZSA8IHMpIHJldHVybiB2b2lkIHRoaXMuem9vbVRvKHMsIHtcbiAgICAgICAgICAgICAgZnJpY3Rpb246IC42NFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvID0gdGhpcy5vcHRpb24oXCJtYXhTY2FsZVwiKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtLnNjYWxlIC0gbyA+IC4wMSkge1xuICAgICAgICAgICAgICBjb25zdCB0ID0gdGhpcy5kcmFnUG9zaXRpb24ubWlkUG9pbnQgfHwgZSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuJGNvbnRlbnQuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgICAgICAgICAgdGhpcy56b29tVG8obywge1xuICAgICAgICAgICAgICAgIGZyaWN0aW9uOiAuNjQsXG4gICAgICAgICAgICAgICAgeDogdC5jbGllbnRYIC0gaS5sZWZ0LFxuICAgICAgICAgICAgICAgIHk6IHQuY2xpZW50WSAtIGkudG9wXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9pbnRlclRyYWNrZXIgPSB0O1xuICAgICAgfVxuXG4gICAgICBpbml0T2JzZXJ2ZXIoKSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgfHwgKHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgbygoKSA9PiB7XG4gICAgICAgICAgdGhpcy51cGRhdGVUaW1lciB8fCAodGhpcy51cGRhdGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuJGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHQud2lkdGggJiYgdC5oZWlnaHQgPyAoKE1hdGguYWJzKHQud2lkdGggLSB0aGlzLmNvbnRhaW5lci53aWR0aCkgPiAxIHx8IE1hdGguYWJzKHQuaGVpZ2h0IC0gdGhpcy5jb250YWluZXIuaGVpZ2h0KSA+IDEpICYmICh0aGlzLmlzQW5pbWF0aW5nKCkgJiYgdGhpcy5lbmRBbmltYXRpb24oITApLCB0aGlzLnVwZGF0ZU1ldHJpY3MoKSwgdGhpcy5wYW5Ubyh7XG4gICAgICAgICAgICAgIHg6IHRoaXMuY29udGVudC54LFxuICAgICAgICAgICAgICB5OiB0aGlzLmNvbnRlbnQueSxcbiAgICAgICAgICAgICAgc2NhbGU6IHRoaXMub3B0aW9uKFwiYmFzZVNjYWxlXCIpLFxuICAgICAgICAgICAgICBmcmljdGlvbjogMFxuICAgICAgICAgICAgfSkpLCB0aGlzLnVwZGF0ZVRpbWVyID0gbnVsbCkgOiB0aGlzLnVwZGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICB9LCB0aGlzLnVwZGF0ZVJhdGUpKTtcbiAgICAgICAgfSksIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRjb250YWluZXIpKTtcbiAgICAgIH1cblxuICAgICAgcmVzZXREcmFnUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMubG9ja0F4aXMgPSBudWxsLCB0aGlzLmZyaWN0aW9uID0gdGhpcy5vcHRpb24oXCJmcmljdGlvblwiKSwgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgc2NhbGU6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHg6IHQsXG4gICAgICAgICAgeTogZSxcbiAgICAgICAgICBzY2FsZTogaVxuICAgICAgICB9ID0gdGhpcy5jb250ZW50O1xuICAgICAgICB0aGlzLmRyYWdTdGFydCA9IHtcbiAgICAgICAgICByZWN0OiB0aGlzLiRjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIHg6IHQsXG4gICAgICAgICAgeTogZSxcbiAgICAgICAgICBzY2FsZTogaVxuICAgICAgICB9LCB0aGlzLmRyYWdQb3NpdGlvbiA9IHsgLi4udGhpcy5kcmFnUG9zaXRpb24sXG4gICAgICAgICAgeDogdCxcbiAgICAgICAgICB5OiBlLFxuICAgICAgICAgIHNjYWxlOiBpXG4gICAgICAgIH0sIHRoaXMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgICAgdGltZTogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVNZXRyaWNzKHQpIHtcbiAgICAgICAgITAgIT09IHQgJiYgdGhpcy50cmlnZ2VyKFwiYmVmb3JlVXBkYXRlXCIpO1xuICAgICAgICBjb25zdCBlID0gdGhpcy4kY29udGFpbmVyLFxuICAgICAgICAgICAgICBzID0gdGhpcy4kY29udGVudCxcbiAgICAgICAgICAgICAgbyA9IHRoaXMuJHZpZXdwb3J0LFxuICAgICAgICAgICAgICBuID0gcyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsXG4gICAgICAgICAgICAgIGEgPSB0aGlzLm9wdGlvbihcInpvb21cIiksXG4gICAgICAgICAgICAgIHIgPSB0aGlzLm9wdGlvbihcInJlc2l6ZVBhcmVudFwiLCBhKTtcbiAgICAgICAgbGV0IGggPSB0aGlzLm9wdGlvbihcIndpZHRoXCIpLFxuICAgICAgICAgICAgbCA9IHRoaXMub3B0aW9uKFwiaGVpZ2h0XCIpLFxuICAgICAgICAgICAgYyA9IGggfHwgKGQgPSBzLCBNYXRoLm1heChwYXJzZUZsb2F0KGQubmF0dXJhbFdpZHRoIHx8IDApLCBwYXJzZUZsb2F0KGQud2lkdGggJiYgZC53aWR0aC5iYXNlVmFsICYmIGQud2lkdGguYmFzZVZhbC52YWx1ZSB8fCAwKSwgcGFyc2VGbG9hdChkLm9mZnNldFdpZHRoIHx8IDApLCBwYXJzZUZsb2F0KGQuc2Nyb2xsV2lkdGggfHwgMCkpKTtcbiAgICAgICAgdmFyIGQ7XG5cbiAgICAgICAgbGV0IHUgPSBsIHx8ICh0ID0+IE1hdGgubWF4KHBhcnNlRmxvYXQodC5uYXR1cmFsSGVpZ2h0IHx8IDApLCBwYXJzZUZsb2F0KHQuaGVpZ2h0ICYmIHQuaGVpZ2h0LmJhc2VWYWwgJiYgdC5oZWlnaHQuYmFzZVZhbC52YWx1ZSB8fCAwKSwgcGFyc2VGbG9hdCh0Lm9mZnNldEhlaWdodCB8fCAwKSwgcGFyc2VGbG9hdCh0LnNjcm9sbEhlaWdodCB8fCAwKSkpKHMpO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocy5zdHlsZSwge1xuICAgICAgICAgIHdpZHRoOiBoID8gYCR7aH1weGAgOiBcIlwiLFxuICAgICAgICAgIGhlaWdodDogbCA/IGAke2x9cHhgIDogXCJcIixcbiAgICAgICAgICBtYXhXaWR0aDogXCJcIixcbiAgICAgICAgICBtYXhIZWlnaHQ6IFwiXCJcbiAgICAgICAgfSksIHIgJiYgT2JqZWN0LmFzc2lnbihvLnN0eWxlLCB7XG4gICAgICAgICAgd2lkdGg6IFwiXCIsXG4gICAgICAgICAgaGVpZ2h0OiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmID0gdGhpcy5vcHRpb24oXCJyYXRpb1wiKTtcbiAgICAgICAgYyA9IGkoYyAqIGYpLCB1ID0gaSh1ICogZiksIGggPSBjLCBsID0gdTtcbiAgICAgICAgY29uc3QgZyA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgIHAgPSBvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICBtID0gbyA9PSBlID8gcCA6IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5tYXgoby5vZmZzZXRXaWR0aCwgaShwLndpZHRoKSksXG4gICAgICAgICAgICB2ID0gTWF0aC5tYXgoby5vZmZzZXRIZWlnaHQsIGkocC5oZWlnaHQpKSxcbiAgICAgICAgICAgIGIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShvKTtcblxuICAgICAgICBpZiAoeSAtPSBwYXJzZUZsb2F0KGIucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChiLnBhZGRpbmdSaWdodCksIHYgLT0gcGFyc2VGbG9hdChiLnBhZGRpbmdUb3ApICsgcGFyc2VGbG9hdChiLnBhZGRpbmdCb3R0b20pLCB0aGlzLnZpZXdwb3J0LndpZHRoID0geSwgdGhpcy52aWV3cG9ydC5oZWlnaHQgPSB2LCBhKSB7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGMgLSBnLndpZHRoKSA+IC4xIHx8IE1hdGguYWJzKHUgLSBnLmhlaWdodCkgPiAuMSkge1xuICAgICAgICAgICAgY29uc3QgdCA9ICgodCwgZSwgaSwgcykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBvID0gTWF0aC5taW4oaSAvIHQgfHwgMCwgcyAvIGUpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0ICogbyB8fCAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZSAqIG8gfHwgMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoYywgdSwgTWF0aC5taW4oYywgZy53aWR0aCksIE1hdGgubWluKHUsIGcuaGVpZ2h0KSk7XG5cbiAgICAgICAgICAgIGggPSBpKHQud2lkdGgpLCBsID0gaSh0LmhlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihzLnN0eWxlLCB7XG4gICAgICAgICAgICB3aWR0aDogYCR7aH1weGAsXG4gICAgICAgICAgICBoZWlnaHQ6IGAke2x9cHhgLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAociAmJiAoT2JqZWN0LmFzc2lnbihvLnN0eWxlLCB7XG4gICAgICAgICAgd2lkdGg6IGAke2h9cHhgLFxuICAgICAgICAgIGhlaWdodDogYCR7bH1weGBcbiAgICAgICAgfSksIHRoaXMudmlld3BvcnQgPSB7IC4uLnRoaXMudmlld3BvcnQsXG4gICAgICAgICAgd2lkdGg6IGgsXG4gICAgICAgICAgaGVpZ2h0OiBsXG4gICAgICAgIH0pLCBuICYmIGEgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0aGlzLm9wdGlvbnMubWF4U2NhbGUpIHtcbiAgICAgICAgICBjb25zdCB0ID0gdGhpcy5vcHRpb24oXCJtYXhTY2FsZVwiKTtcblxuICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQub3JpZ1dpZHRoID4gMCAmJiB0aGlzLmNvbnRlbnQuZml0V2lkdGggPiAwID8gdGhpcy5jb250ZW50Lm9yaWdXaWR0aCAvIHRoaXMuY29udGVudC5maXRXaWR0aCA6IHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGVudCA9IHsgLi4udGhpcy5jb250ZW50LFxuICAgICAgICAgIG9yaWdXaWR0aDogYyxcbiAgICAgICAgICBvcmlnSGVpZ2h0OiB1LFxuICAgICAgICAgIGZpdFdpZHRoOiBoLFxuICAgICAgICAgIGZpdEhlaWdodDogbCxcbiAgICAgICAgICB3aWR0aDogaCxcbiAgICAgICAgICBoZWlnaHQ6IGwsXG4gICAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgICAgaXNab29tYWJsZTogYVxuICAgICAgICB9LCB0aGlzLmNvbnRhaW5lciA9IHtcbiAgICAgICAgICB3aWR0aDogbS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IG0uaGVpZ2h0XG4gICAgICAgIH0sICEwICE9PSB0ICYmIHRoaXMudHJpZ2dlcihcImFmdGVyVXBkYXRlXCIpO1xuICAgICAgfVxuXG4gICAgICB6b29tSW4odCkge1xuICAgICAgICB0aGlzLnpvb21Ubyh0aGlzLmNvbnRlbnQuc2NhbGUgKyAodCB8fCB0aGlzLm9wdGlvbihcInN0ZXBcIikpKTtcbiAgICAgIH1cblxuICAgICAgem9vbU91dCh0KSB7XG4gICAgICAgIHRoaXMuem9vbVRvKHRoaXMuY29udGVudC5zY2FsZSAtICh0IHx8IHRoaXMub3B0aW9uKFwic3RlcFwiKSkpO1xuICAgICAgfVxuXG4gICAgICB0b2dnbGVab29tKHQgPSB7fSkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5vcHRpb24oXCJtYXhTY2FsZVwiKSxcbiAgICAgICAgICAgICAgaSA9IHRoaXMub3B0aW9uKFwiYmFzZVNjYWxlXCIpLFxuICAgICAgICAgICAgICBzID0gdGhpcy5jb250ZW50LnNjYWxlID4gaSArIC41ICogKGUgLSBpKSA/IGkgOiBlO1xuICAgICAgICB0aGlzLnpvb21UbyhzLCB0KTtcbiAgICAgIH1cblxuICAgICAgem9vbVRvKHQgPSB0aGlzLm9wdGlvbihcImJhc2VTY2FsZVwiKSwge1xuICAgICAgICB4OiBlID0gbnVsbCxcbiAgICAgICAgeTogcyA9IG51bGxcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICB0ID0gTWF0aC5tYXgoTWF0aC5taW4odCwgdGhpcy5vcHRpb24oXCJtYXhTY2FsZVwiKSksIHRoaXMub3B0aW9uKFwibWluU2NhbGVcIikpO1xuICAgICAgICBjb25zdCBvID0gaSh0aGlzLmNvbnRlbnQuc2NhbGUgLyAodGhpcy5jb250ZW50LndpZHRoIC8gdGhpcy5jb250ZW50LmZpdFdpZHRoKSwgMWU3KTtcbiAgICAgICAgbnVsbCA9PT0gZSAmJiAoZSA9IHRoaXMuY29udGVudC53aWR0aCAqIG8gKiAuNSksIG51bGwgPT09IHMgJiYgKHMgPSB0aGlzLmNvbnRlbnQuaGVpZ2h0ICogbyAqIC41KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRlbHRhWDogbixcbiAgICAgICAgICBkZWx0YVk6IGFcbiAgICAgICAgfSA9IHRoaXMuZ2V0Wm9vbURlbHRhKHQsIGUsIHMpO1xuICAgICAgICBlID0gdGhpcy5jb250ZW50LnggLSBuLCBzID0gdGhpcy5jb250ZW50LnkgLSBhLCB0aGlzLnBhblRvKHtcbiAgICAgICAgICB4OiBlLFxuICAgICAgICAgIHk6IHMsXG4gICAgICAgICAgc2NhbGU6IHQsXG4gICAgICAgICAgZnJpY3Rpb246IHRoaXMub3B0aW9uKFwiem9vbUZyaWN0aW9uXCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnZXRab29tRGVsdGEodCwgZSA9IDAsIGkgPSAwKSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmNvbnRlbnQuZml0V2lkdGggKiB0aGlzLmNvbnRlbnQuc2NhbGUsXG4gICAgICAgICAgICAgIG8gPSB0aGlzLmNvbnRlbnQuZml0SGVpZ2h0ICogdGhpcy5jb250ZW50LnNjYWxlLFxuICAgICAgICAgICAgICBuID0gZSA+IDAgJiYgcyA/IGUgLyBzIDogMCxcbiAgICAgICAgICAgICAgYSA9IGkgPiAwICYmIG8gPyBpIC8gbyA6IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVsdGFYOiAodGhpcy5jb250ZW50LmZpdFdpZHRoICogdCAtIHMpICogbixcbiAgICAgICAgICBkZWx0YVk6ICh0aGlzLmNvbnRlbnQuZml0SGVpZ2h0ICogdCAtIG8pICogYVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBwYW5Ubyh7XG4gICAgICAgIHg6IHQgPSB0aGlzLmNvbnRlbnQueCxcbiAgICAgICAgeTogZSA9IHRoaXMuY29udGVudC55LFxuICAgICAgICBzY2FsZTogaSxcbiAgICAgICAgZnJpY3Rpb246IHMgPSB0aGlzLm9wdGlvbihcImZyaWN0aW9uXCIpLFxuICAgICAgICBpZ25vcmVCb3VuZHM6IG8gPSAhMVxuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGlmIChpID0gaSB8fCB0aGlzLmNvbnRlbnQuc2NhbGUgfHwgMSwgIW8pIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBib3VuZFg6IHMsXG4gICAgICAgICAgICBib3VuZFk6IG9cbiAgICAgICAgICB9ID0gdGhpcy5nZXRCb3VuZHMoaSk7XG4gICAgICAgICAgcyAmJiAodCA9IE1hdGgubWF4KE1hdGgubWluKHQsIHMudG8pLCBzLmZyb20pKSwgbyAmJiAoZSA9IE1hdGgubWF4KE1hdGgubWluKGUsIG8udG8pLCBvLmZyb20pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZnJpY3Rpb24gPSBzLCB0aGlzLnRyYW5zZm9ybSA9IHsgLi4udGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgeDogdCxcbiAgICAgICAgICB5OiBlLFxuICAgICAgICAgIHNjYWxlOiBpXG4gICAgICAgIH0sIHMgPyAodGhpcy5zdGF0ZSA9IFwicGFubmluZ1wiLCB0aGlzLnZlbG9jaXR5ID0ge1xuICAgICAgICAgIHg6ICgxIC8gdGhpcy5mcmljdGlvbiAtIDEpICogKHQgLSB0aGlzLmNvbnRlbnQueCksXG4gICAgICAgICAgeTogKDEgLyB0aGlzLmZyaWN0aW9uIC0gMSkgKiAoZSAtIHRoaXMuY29udGVudC55KSxcbiAgICAgICAgICBzY2FsZTogKDEgLyB0aGlzLmZyaWN0aW9uIC0gMSkgKiAoaSAtIHRoaXMuY29udGVudC5zY2FsZSlcbiAgICAgICAgfSwgdGhpcy5zdGFydEFuaW1hdGlvbigpKSA6IHRoaXMuZW5kQW5pbWF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0QW5pbWF0aW9uKCkge1xuICAgICAgICB0aGlzLnJBRiA/IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuckFGKSA6IHRoaXMudHJpZ2dlcihcInN0YXJ0QW5pbWF0aW9uXCIpLCB0aGlzLnJBRiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGUoKSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldEVkZ2VGb3JjZSgpLCB0aGlzLnNldERyYWdGb3JjZSgpLCB0aGlzLnZlbG9jaXR5LnggKj0gdGhpcy5mcmljdGlvbiwgdGhpcy52ZWxvY2l0eS55ICo9IHRoaXMuZnJpY3Rpb24sIHRoaXMudmVsb2NpdHkuc2NhbGUgKj0gdGhpcy5mcmljdGlvbiwgdGhpcy5jb250ZW50LnggKz0gdGhpcy52ZWxvY2l0eS54LCB0aGlzLmNvbnRlbnQueSArPSB0aGlzLnZlbG9jaXR5LnksIHRoaXMuY29udGVudC5zY2FsZSArPSB0aGlzLnZlbG9jaXR5LnNjYWxlLCB0aGlzLmlzQW5pbWF0aW5nKCkpIHRoaXMuc2V0VHJhbnNmb3JtKCk7ZWxzZSBpZiAoXCJwb2ludGVyZG93blwiICE9PSB0aGlzLnN0YXRlKSByZXR1cm4gdm9pZCB0aGlzLmVuZEFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLnJBRiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGUoKSk7XG4gICAgICB9XG5cbiAgICAgIGdldEJvdW5kcyh0KSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5ib3VuZFgsXG4gICAgICAgICAgICBzID0gdGhpcy5ib3VuZFk7XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGUgJiYgdm9pZCAwICE9PSBzKSByZXR1cm4ge1xuICAgICAgICAgIGJvdW5kWDogZSxcbiAgICAgICAgICBib3VuZFk6IHNcbiAgICAgICAgfTtcbiAgICAgICAgZSA9IHtcbiAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgIHRvOiAwXG4gICAgICAgIH0sIHMgPSB7XG4gICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICB0bzogMFxuICAgICAgICB9LCB0ID0gdCB8fCB0aGlzLnRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuY29udGVudC5maXRXaWR0aCAqIHQsXG4gICAgICAgICAgICAgIG4gPSB0aGlzLmNvbnRlbnQuZml0SGVpZ2h0ICogdCxcbiAgICAgICAgICAgICAgYSA9IHRoaXMudmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICAgIHIgPSB0aGlzLnZpZXdwb3J0LmhlaWdodDtcblxuICAgICAgICBpZiAobyA8IGEpIHtcbiAgICAgICAgICBjb25zdCB0ID0gaSguNSAqIChhIC0gbykpO1xuICAgICAgICAgIGUuZnJvbSA9IHQsIGUudG8gPSB0O1xuICAgICAgICB9IGVsc2UgZS5mcm9tID0gaShhIC0gbyk7XG5cbiAgICAgICAgaWYgKG4gPCByKSB7XG4gICAgICAgICAgY29uc3QgdCA9IC41ICogKHIgLSBuKTtcbiAgICAgICAgICBzLmZyb20gPSB0LCBzLnRvID0gdDtcbiAgICAgICAgfSBlbHNlIHMuZnJvbSA9IGkociAtIG4pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm91bmRYOiBlLFxuICAgICAgICAgIGJvdW5kWTogc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBzZXRFZGdlRm9yY2UoKSB7XG4gICAgICAgIGlmIChcImRlY2VsXCIgIT09IHRoaXMuc3RhdGUpIHJldHVybjtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMub3B0aW9uKFwiYm91bmNlRm9yY2VcIiksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICBib3VuZFg6IGUsXG4gICAgICAgICAgYm91bmRZOiBpXG4gICAgICAgIH0gPSB0aGlzLmdldEJvdW5kcyhNYXRoLm1heCh0aGlzLnRyYW5zZm9ybS5zY2FsZSwgdGhpcy5jb250ZW50LnNjYWxlKSk7XG4gICAgICAgIGxldCBzLCBvLCBuLCBhO1xuXG4gICAgICAgIGlmIChlICYmIChzID0gdGhpcy5jb250ZW50LnggPCBlLmZyb20sIG8gPSB0aGlzLmNvbnRlbnQueCA+IGUudG8pLCBpICYmIChuID0gdGhpcy5jb250ZW50LnkgPCBpLmZyb20sIGEgPSB0aGlzLmNvbnRlbnQueSA+IGkudG8pLCBzIHx8IG8pIHtcbiAgICAgICAgICBsZXQgaSA9ICgocyA/IGUuZnJvbSA6IGUudG8pIC0gdGhpcy5jb250ZW50LngpICogdDtcbiAgICAgICAgICBjb25zdCBvID0gdGhpcy5jb250ZW50LnggKyAodGhpcy52ZWxvY2l0eS54ICsgaSkgLyB0aGlzLmZyaWN0aW9uO1xuICAgICAgICAgIG8gPj0gZS5mcm9tICYmIG8gPD0gZS50byAmJiAoaSArPSB0aGlzLnZlbG9jaXR5LngpLCB0aGlzLnZlbG9jaXR5LnggPSBpLCB0aGlzLnJlY2FsY3VsYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiB8fCBhKSB7XG4gICAgICAgICAgbGV0IGUgPSAoKG4gPyBpLmZyb20gOiBpLnRvKSAtIHRoaXMuY29udGVudC55KSAqIHQ7XG4gICAgICAgICAgY29uc3QgcyA9IHRoaXMuY29udGVudC55ICsgKGUgKyB0aGlzLnZlbG9jaXR5LnkpIC8gdGhpcy5mcmljdGlvbjtcbiAgICAgICAgICBzID49IGkuZnJvbSAmJiBzIDw9IGkudG8gJiYgKGUgKz0gdGhpcy52ZWxvY2l0eS55KSwgdGhpcy52ZWxvY2l0eS55ID0gZSwgdGhpcy5yZWNhbGN1bGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldERyYWdSZXNpc3RhbmNlKCkge1xuICAgICAgICBpZiAoXCJwb2ludGVyZG93blwiICE9PSB0aGlzLnN0YXRlKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBib3VuZFg6IHQsXG4gICAgICAgICAgYm91bmRZOiBlXG4gICAgICAgIH0gPSB0aGlzLmdldEJvdW5kcyh0aGlzLmRyYWdQb3NpdGlvbi5zY2FsZSk7XG4gICAgICAgIGxldCBpLCBzLCBvLCBuO1xuXG4gICAgICAgIGlmICh0ICYmIChpID0gdGhpcy5kcmFnUG9zaXRpb24ueCA8IHQuZnJvbSwgcyA9IHRoaXMuZHJhZ1Bvc2l0aW9uLnggPiB0LnRvKSwgZSAmJiAobyA9IHRoaXMuZHJhZ1Bvc2l0aW9uLnkgPCBlLmZyb20sIG4gPSB0aGlzLmRyYWdQb3NpdGlvbi55ID4gZS50byksIChpIHx8IHMpICYmICghaSB8fCAhcykpIHtcbiAgICAgICAgICBjb25zdCBlID0gaSA/IHQuZnJvbSA6IHQudG8sXG4gICAgICAgICAgICAgICAgcyA9IGUgLSB0aGlzLmRyYWdQb3NpdGlvbi54O1xuICAgICAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uLnggPSBlIC0gLjMgKiBzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChvIHx8IG4pICYmICghbyB8fCAhbikpIHtcbiAgICAgICAgICBjb25zdCB0ID0gbyA/IGUuZnJvbSA6IGUudG8sXG4gICAgICAgICAgICAgICAgaSA9IHQgLSB0aGlzLmRyYWdQb3NpdGlvbi55O1xuICAgICAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uLnkgPSB0IC0gLjMgKiBpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldERyYWdGb3JjZSgpIHtcbiAgICAgICAgXCJwb2ludGVyZG93blwiID09PSB0aGlzLnN0YXRlICYmICh0aGlzLnZlbG9jaXR5LnggPSB0aGlzLmRyYWdQb3NpdGlvbi54IC0gdGhpcy5jb250ZW50LngsIHRoaXMudmVsb2NpdHkueSA9IHRoaXMuZHJhZ1Bvc2l0aW9uLnkgLSB0aGlzLmNvbnRlbnQueSwgdGhpcy52ZWxvY2l0eS5zY2FsZSA9IHRoaXMuZHJhZ1Bvc2l0aW9uLnNjYWxlIC0gdGhpcy5jb250ZW50LnNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgcmVjYWxjdWxhdGVUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnggPSB0aGlzLmNvbnRlbnQueCArIHRoaXMudmVsb2NpdHkueCAvICgxIC8gdGhpcy5mcmljdGlvbiAtIDEpLCB0aGlzLnRyYW5zZm9ybS55ID0gdGhpcy5jb250ZW50LnkgKyB0aGlzLnZlbG9jaXR5LnkgLyAoMSAvIHRoaXMuZnJpY3Rpb24gLSAxKSwgdGhpcy50cmFuc2Zvcm0uc2NhbGUgPSB0aGlzLmNvbnRlbnQuc2NhbGUgKyB0aGlzLnZlbG9jaXR5LnNjYWxlIC8gKDEgLyB0aGlzLmZyaWN0aW9uIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGlzQW5pbWF0aW5nKCkge1xuICAgICAgICByZXR1cm4gISghdGhpcy5mcmljdGlvbiB8fCAhKE1hdGguYWJzKHRoaXMudmVsb2NpdHkueCkgPiAuMDUgfHwgTWF0aC5hYnModGhpcy52ZWxvY2l0eS55KSA+IC4wNSB8fCBNYXRoLmFicyh0aGlzLnZlbG9jaXR5LnNjYWxlKSA+IC4wNSkpO1xuICAgICAgfVxuXG4gICAgICBzZXRUcmFuc2Zvcm0odCkge1xuICAgICAgICBsZXQgZSwgcywgbztcblxuICAgICAgICBpZiAodCA/IChlID0gaSh0aGlzLnRyYW5zZm9ybS54KSwgcyA9IGkodGhpcy50cmFuc2Zvcm0ueSksIG8gPSB0aGlzLnRyYW5zZm9ybS5zY2FsZSwgdGhpcy5jb250ZW50ID0geyAuLi50aGlzLmNvbnRlbnQsXG4gICAgICAgICAgeDogZSxcbiAgICAgICAgICB5OiBzLFxuICAgICAgICAgIHNjYWxlOiBvXG4gICAgICAgIH0pIDogKGUgPSBpKHRoaXMuY29udGVudC54KSwgcyA9IGkodGhpcy5jb250ZW50LnkpLCBvID0gdGhpcy5jb250ZW50LnNjYWxlIC8gKHRoaXMuY29udGVudC53aWR0aCAvIHRoaXMuY29udGVudC5maXRXaWR0aCksIHRoaXMuY29udGVudCA9IHsgLi4udGhpcy5jb250ZW50LFxuICAgICAgICAgIHg6IGUsXG4gICAgICAgICAgeTogc1xuICAgICAgICB9KSwgdGhpcy50cmlnZ2VyKFwiYmVmb3JlVHJhbnNmb3JtXCIpLCBlID0gaSh0aGlzLmNvbnRlbnQueCksIHMgPSBpKHRoaXMuY29udGVudC55KSwgdCAmJiB0aGlzLm9wdGlvbihcInpvb21cIikpIHtcbiAgICAgICAgICBsZXQgdCwgbjtcbiAgICAgICAgICB0ID0gaSh0aGlzLmNvbnRlbnQuZml0V2lkdGggKiBvKSwgbiA9IGkodGhpcy5jb250ZW50LmZpdEhlaWdodCAqIG8pLCB0aGlzLmNvbnRlbnQud2lkdGggPSB0LCB0aGlzLmNvbnRlbnQuaGVpZ2h0ID0gbiwgdGhpcy50cmFuc2Zvcm0gPSB7IC4uLnRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgd2lkdGg6IHQsXG4gICAgICAgICAgICBoZWlnaHQ6IG4sXG4gICAgICAgICAgICBzY2FsZTogb1xuICAgICAgICAgIH0sIE9iamVjdC5hc3NpZ24odGhpcy4kY29udGVudC5zdHlsZSwge1xuICAgICAgICAgICAgd2lkdGg6IGAke3R9cHhgLFxuICAgICAgICAgICAgaGVpZ2h0OiBgJHtufXB4YCxcbiAgICAgICAgICAgIG1heFdpZHRoOiBcIm5vbmVcIixcbiAgICAgICAgICAgIG1heEhlaWdodDogXCJub25lXCIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke2V9cHgsICR7c31weCwgMCkgc2NhbGUoMSlgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLiRjb250ZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2V9cHgsICR7c31weCwgMCkgc2NhbGUoJHtvfSlgO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcihcImFmdGVyVHJhbnNmb3JtXCIpO1xuICAgICAgfVxuXG4gICAgICBlbmRBbmltYXRpb24odCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJBRiksIHRoaXMuckFGID0gbnVsbCwgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgc2NhbGU6IDBcbiAgICAgICAgfSwgdGhpcy5zZXRUcmFuc2Zvcm0oITApLCB0aGlzLnN0YXRlID0gXCJyZWFkeVwiLCB0aGlzLmhhbmRsZUN1cnNvcigpLCAhMCAhPT0gdCAmJiB0aGlzLnRyaWdnZXIoXCJlbmRBbmltYXRpb25cIik7XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZUN1cnNvcigpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMub3B0aW9uKFwiZHJhZ2dhYmxlQ2xhc3NcIik7XG4gICAgICAgIHQgJiYgdGhpcy5vcHRpb24oXCJ0b3VjaFwiKSAmJiAoMSA9PSB0aGlzLm9wdGlvbihcInBhbk9ubHlab29tZWRcIikgJiYgdGhpcy5jb250ZW50LndpZHRoIDw9IHRoaXMudmlld3BvcnQud2lkdGggJiYgdGhpcy5jb250ZW50LmhlaWdodCA8PSB0aGlzLnZpZXdwb3J0LmhlaWdodCAmJiB0aGlzLnRyYW5zZm9ybS5zY2FsZSA8PSB0aGlzLm9wdGlvbihcImJhc2VTY2FsZVwiKSA/IHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHQpIDogdGhpcy4kY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodCkpO1xuICAgICAgfVxuXG4gICAgICBkZXRhY2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuJGNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5vbkxvYWQpLCB0aGlzLiRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0aGlzLiRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25DbGljaywge1xuICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgIH0pLCB0aGlzLnBvaW50ZXJUcmFja2VyICYmICh0aGlzLnBvaW50ZXJUcmFja2VyLnN0b3AoKSwgdGhpcy5wb2ludGVyVHJhY2tlciA9IG51bGwpLCB0aGlzLnJlc2l6ZU9ic2VydmVyICYmICh0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKSwgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGwpO1xuICAgICAgfVxuXG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICBcImRlc3Ryb3lcIiAhPT0gdGhpcy5zdGF0ZSAmJiAodGhpcy5zdGF0ZSA9IFwiZGVzdHJveVwiLCBjbGVhclRpbWVvdXQodGhpcy51cGRhdGVUaW1lciksIHRoaXMudXBkYXRlVGltZXIgPSBudWxsLCBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJBRiksIHRoaXMuckFGID0gbnVsbCwgdGhpcy5kZXRhY2hFdmVudHMoKSwgdGhpcy5kZXRhY2hQbHVnaW5zKCksIHRoaXMucmVzZXREcmFnUG9zaXRpb24oKSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBkLnZlcnNpb24gPSBcIjQuMC4zMVwiLCBkLlBsdWdpbnMgPSB7fTtcblxuICAgIGNvbnN0IHUgPSAodCwgZSkgPT4ge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5zKSB7XG4gICAgICAgIGNvbnN0IG8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgaWYgKCEobyAtIGkgPCBlKSkgcmV0dXJuIGkgPSBvLCB0KC4uLnMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY2xhc3MgZiB7XG4gICAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lciA9IG51bGwsIHRoaXMuJHByZXYgPSBudWxsLCB0aGlzLiRuZXh0ID0gbnVsbCwgdGhpcy5jYXJvdXNlbCA9IHQsIHRoaXMub25SZWZyZXNoID0gdGhpcy5vblJlZnJlc2guYmluZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fyb3VzZWwub3B0aW9uKGBOYXZpZ2F0aW9uLiR7dH1gKTtcbiAgICAgIH1cblxuICAgICAgY3JlYXRlQnV0dG9uKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIGUuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdGhpcy5jYXJvdXNlbC5sb2NhbGl6ZShge3ske3QudG9VcHBlckNhc2UoKX19fWApKTtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMub3B0aW9uKFwiY2xhc3NOYW1lcy5idXR0b25cIikgKyBcIiBcIiArIHRoaXMub3B0aW9uKGBjbGFzc05hbWVzLiR7dH1gKTtcbiAgICAgICAgcmV0dXJuIGUuY2xhc3NMaXN0LmFkZCguLi5pLnNwbGl0KFwiIFwiKSksIGUuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpLCBlLmlubmVySFRNTCA9IHRoaXMuY2Fyb3VzZWwubG9jYWxpemUodGhpcy5vcHRpb24oYCR7dH1UcGxgKSksIGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy5jYXJvdXNlbFtcInNsaWRlXCIgKyAoXCJuZXh0XCIgPT09IHQgPyBcIk5leHRcIiA6IFwiUHJldlwiKV0oKTtcbiAgICAgICAgfSksIGU7XG4gICAgICB9XG5cbiAgICAgIGJ1aWxkKCkge1xuICAgICAgICB0aGlzLiRjb250YWluZXIgfHwgKHRoaXMuJGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMub3B0aW9uKFwiY2xhc3NOYW1lcy5tYWluXCIpLnNwbGl0KFwiIFwiKSksIHRoaXMuY2Fyb3VzZWwuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLiRjb250YWluZXIpKSwgdGhpcy4kbmV4dCB8fCAodGhpcy4kbmV4dCA9IHRoaXMuY3JlYXRlQnV0dG9uKFwibmV4dFwiKSwgdGhpcy4kY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuJG5leHQpKSwgdGhpcy4kcHJldiB8fCAodGhpcy4kcHJldiA9IHRoaXMuY3JlYXRlQnV0dG9uKFwicHJldlwiKSwgdGhpcy4kY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuJHByZXYpKTtcbiAgICAgIH1cblxuICAgICAgb25SZWZyZXNoKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5jYXJvdXNlbC5wYWdlcy5sZW5ndGg7XG4gICAgICAgIHQgPD0gMSB8fCB0ID4gMSAmJiB0aGlzLmNhcm91c2VsLmVsZW1EaW1XaWR0aCA8IHRoaXMuY2Fyb3VzZWwud3JhcERpbVdpZHRoICYmICFOdW1iZXIuaXNJbnRlZ2VyKHRoaXMuY2Fyb3VzZWwub3B0aW9uKFwic2xpZGVzUGVyUGFnZVwiKSkgPyB0aGlzLmNsZWFudXAoKSA6ICh0aGlzLmJ1aWxkKCksIHRoaXMuJHByZXYucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHRoaXMuJG5leHQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHRoaXMuY2Fyb3VzZWwub3B0aW9uKFwiaW5maW5pdGVYXCIsIHRoaXMuY2Fyb3VzZWwub3B0aW9uKFwiaW5maW5pdGVcIikpIHx8ICh0aGlzLmNhcm91c2VsLnBhZ2UgPD0gMCAmJiB0aGlzLiRwcmV2LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0aGlzLmNhcm91c2VsLnBhZ2UgPj0gdCAtIDEgJiYgdGhpcy4kbmV4dC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSkpO1xuICAgICAgfVxuXG4gICAgICBjbGVhbnVwKCkge1xuICAgICAgICB0aGlzLiRwcmV2ICYmIHRoaXMuJHByZXYucmVtb3ZlKCksIHRoaXMuJHByZXYgPSBudWxsLCB0aGlzLiRuZXh0ICYmIHRoaXMuJG5leHQucmVtb3ZlKCksIHRoaXMuJG5leHQgPSBudWxsLCB0aGlzLiRjb250YWluZXIgJiYgdGhpcy4kY29udGFpbmVyLnJlbW92ZSgpLCB0aGlzLiRjb250YWluZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2goKSB7XG4gICAgICAgIHRoaXMuY2Fyb3VzZWwub24oXCJyZWZyZXNoIGNoYW5nZVwiLCB0aGlzLm9uUmVmcmVzaCk7XG4gICAgICB9XG5cbiAgICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5jYXJvdXNlbC5vZmYoXCJyZWZyZXNoIGNoYW5nZVwiLCB0aGlzLm9uUmVmcmVzaCksIHRoaXMuY2xlYW51cCgpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZi5kZWZhdWx0cyA9IHtcbiAgICAgIHByZXZUcGw6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgdGFiaW5kZXg9XCItMVwiPjxwYXRoIGQ9XCJNMTUgM2wtOSA5IDkgOVwiLz48L3N2Zz4nLFxuICAgICAgbmV4dFRwbDogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB0YWJpbmRleD1cIi0xXCI+PHBhdGggZD1cIk05IDNsOSA5LTkgOVwiLz48L3N2Zz4nLFxuICAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICBtYWluOiBcImNhcm91c2VsX19uYXZcIixcbiAgICAgICAgYnV0dG9uOiBcImNhcm91c2VsX19idXR0b25cIixcbiAgICAgICAgbmV4dDogXCJpcy1uZXh0XCIsXG4gICAgICAgIHByZXY6IFwiaXMtcHJldlwiXG4gICAgICB9XG4gICAgfTtcblxuICAgIGNsYXNzIGcge1xuICAgICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLmNhcm91c2VsID0gdCwgdGhpcy5zZWxlY3RlZEluZGV4ID0gbnVsbCwgdGhpcy5mcmljdGlvbiA9IDAsIHRoaXMub25OYXZSZWFkeSA9IHRoaXMub25OYXZSZWFkeS5iaW5kKHRoaXMpLCB0aGlzLm9uTmF2Q2xpY2sgPSB0aGlzLm9uTmF2Q2xpY2suYmluZCh0aGlzKSwgdGhpcy5vbk5hdkNyZWF0ZVNsaWRlID0gdGhpcy5vbk5hdkNyZWF0ZVNsaWRlLmJpbmQodGhpcyksIHRoaXMub25UYXJnZXRDaGFuZ2UgPSB0aGlzLm9uVGFyZ2V0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGFkZEFzVGFyZ2V0Rm9yKHQpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLmNhcm91c2VsLCB0aGlzLm5hdiA9IHQsIHRoaXMuYXR0YWNoRXZlbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIGFkZEFzTmF2Rm9yKHQpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0LCB0aGlzLm5hdiA9IHRoaXMuY2Fyb3VzZWwsIHRoaXMuYXR0YWNoRXZlbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5uYXYub3B0aW9ucy5pbml0aWFsU2xpZGUgPSB0aGlzLnRhcmdldC5vcHRpb25zLmluaXRpYWxQYWdlLCB0aGlzLm5hdi5vbihcInJlYWR5XCIsIHRoaXMub25OYXZSZWFkeSksIHRoaXMubmF2Lm9uKFwiY3JlYXRlU2xpZGVcIiwgdGhpcy5vbk5hdkNyZWF0ZVNsaWRlKSwgdGhpcy5uYXYub24oXCJQYW56b29tLmNsaWNrXCIsIHRoaXMub25OYXZDbGljayksIHRoaXMudGFyZ2V0Lm9uKFwiY2hhbmdlXCIsIHRoaXMub25UYXJnZXRDaGFuZ2UpLCB0aGlzLnRhcmdldC5vbihcIlBhbnpvb20uYWZ0ZXJVcGRhdGVcIiwgdGhpcy5vblRhcmdldENoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIG9uTmF2UmVhZHkoKSB7XG4gICAgICAgIHRoaXMub25UYXJnZXRDaGFuZ2UoITApO1xuICAgICAgfVxuXG4gICAgICBvbk5hdkNsaWNrKHQsIGUsIGkpIHtcbiAgICAgICAgY29uc3QgcyA9IGkudGFyZ2V0LmNsb3Nlc3QoXCIuY2Fyb3VzZWxfX3NsaWRlXCIpO1xuICAgICAgICBpZiAoIXMpIHJldHVybjtcbiAgICAgICAgaS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgbyA9IHBhcnNlSW50KHMuZGF0YXNldC5pbmRleCwgMTApLFxuICAgICAgICAgICAgICBuID0gdGhpcy50YXJnZXQuZmluZFBhZ2VGb3JTbGlkZShvKTtcbiAgICAgICAgdGhpcy50YXJnZXQucGFnZSAhPT0gbiAmJiB0aGlzLnRhcmdldC5zbGlkZVRvKG4sIHtcbiAgICAgICAgICBmcmljdGlvbjogdGhpcy5mcmljdGlvblxuICAgICAgICB9KSwgdGhpcy5tYXJrU2VsZWN0ZWRTbGlkZShvKTtcbiAgICAgIH1cblxuICAgICAgb25OYXZDcmVhdGVTbGlkZSh0LCBlKSB7XG4gICAgICAgIGUuaW5kZXggPT09IHRoaXMuc2VsZWN0ZWRJbmRleCAmJiB0aGlzLm1hcmtTZWxlY3RlZFNsaWRlKGUuaW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBvblRhcmdldENoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMudGFyZ2V0LnBhZ2VzW3RoaXMudGFyZ2V0LnBhZ2VdLmluZGV4ZXNbMF0sXG4gICAgICAgICAgICAgIGUgPSB0aGlzLm5hdi5maW5kUGFnZUZvclNsaWRlKHQpO1xuICAgICAgICB0aGlzLm5hdi5zbGlkZVRvKGUpLCB0aGlzLm1hcmtTZWxlY3RlZFNsaWRlKHQpO1xuICAgICAgfVxuXG4gICAgICBtYXJrU2VsZWN0ZWRTbGlkZSh0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHQsIFsuLi50aGlzLm5hdi5zbGlkZXNdLmZpbHRlcih0ID0+IHQuJGVsICYmIHQuJGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1uYXYtc2VsZWN0ZWRcIikpO1xuICAgICAgICBjb25zdCBlID0gdGhpcy5uYXYuc2xpZGVzW3RdO1xuICAgICAgICBlICYmIGUuJGVsICYmIGUuJGVsLmNsYXNzTGlzdC5hZGQoXCJpcy1uYXYtc2VsZWN0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGF0dGFjaCh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0Lm9wdGlvbnMuU3luYztcbiAgICAgICAgKGUudGFyZ2V0IHx8IGUubmF2KSAmJiAoZS50YXJnZXQgPyB0aGlzLmFkZEFzTmF2Rm9yKGUudGFyZ2V0KSA6IGUubmF2ICYmIHRoaXMuYWRkQXNUYXJnZXRGb3IoZS5uYXYpLCB0aGlzLmZyaWN0aW9uID0gZS5mcmljdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5uYXYgJiYgKHRoaXMubmF2Lm9mZihcInJlYWR5XCIsIHRoaXMub25OYXZSZWFkeSksIHRoaXMubmF2Lm9mZihcIlBhbnpvb20uY2xpY2tcIiwgdGhpcy5vbk5hdkNsaWNrKSwgdGhpcy5uYXYub2ZmKFwiY3JlYXRlU2xpZGVcIiwgdGhpcy5vbk5hdkNyZWF0ZVNsaWRlKSksIHRoaXMudGFyZ2V0ICYmICh0aGlzLnRhcmdldC5vZmYoXCJQYW56b29tLmFmdGVyVXBkYXRlXCIsIHRoaXMub25UYXJnZXRDaGFuZ2UpLCB0aGlzLnRhcmdldC5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5vblRhcmdldENoYW5nZSkpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZy5kZWZhdWx0cyA9IHtcbiAgICAgIGZyaWN0aW9uOiAuOTJcbiAgICB9O1xuICAgIGNvbnN0IHAgPSB7XG4gICAgICBOYXZpZ2F0aW9uOiBmLFxuICAgICAgRG90czogY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgICAgdGhpcy5jYXJvdXNlbCA9IHQsIHRoaXMuJGxpc3QgPSBudWxsLCB0aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIGNoYW5nZTogdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVmcmVzaDogdGhpcy5vblJlZnJlc2guYmluZCh0aGlzKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBidWlsZExpc3QoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2Fyb3VzZWwucGFnZXMubGVuZ3RoIDwgdGhpcy5jYXJvdXNlbC5vcHRpb24oXCJEb3RzLm1pblNsaWRlQ291bnRcIikpIHJldHVybjtcbiAgICAgICAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9sXCIpO1xuICAgICAgICAgIHJldHVybiB0LmNsYXNzTGlzdC5hZGQoXCJjYXJvdXNlbF9fZG90c1wiKSwgdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdCA9PiB7XG4gICAgICAgICAgICBpZiAoIShcInBhZ2VcIiBpbiB0LnRhcmdldC5kYXRhc2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgZSA9IHBhcnNlSW50KHQudGFyZ2V0LmRhdGFzZXQucGFnZSwgMTApLFxuICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuY2Fyb3VzZWw7XG4gICAgICAgICAgICBlICE9PSBpLnBhZ2UgJiYgKGkucGFnZXMubGVuZ3RoIDwgMyAmJiBpLm9wdGlvbihcImluZmluaXRlXCIpID8gaVswID09IGUgPyBcInNsaWRlUHJldlwiIDogXCJzbGlkZU5leHRcIl0oKSA6IGkuc2xpZGVUbyhlKSk7XG4gICAgICAgICAgfSksIHRoaXMuJGxpc3QgPSB0LCB0aGlzLmNhcm91c2VsLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodCksIHRoaXMuY2Fyb3VzZWwuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzLWRvdHNcIiksIHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdmVMaXN0KCkge1xuICAgICAgICAgIHRoaXMuJGxpc3QgJiYgKHRoaXMuJGxpc3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLiRsaXN0KSwgdGhpcy4kbGlzdCA9IG51bGwpLCB0aGlzLmNhcm91c2VsLiRjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcImhhcy1kb3RzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVidWlsZERvdHMoKSB7XG4gICAgICAgICAgbGV0IHQgPSB0aGlzLiRsaXN0O1xuICAgICAgICAgIGNvbnN0IGUgPSAhIXQsXG4gICAgICAgICAgICAgICAgaSA9IHRoaXMuY2Fyb3VzZWwucGFnZXMubGVuZ3RoO1xuICAgICAgICAgIGlmIChpIDwgMikgcmV0dXJuIHZvaWQgKGUgJiYgdGhpcy5yZW1vdmVMaXN0KCkpO1xuICAgICAgICAgIGUgfHwgKHQgPSB0aGlzLmJ1aWxkTGlzdCgpKTtcbiAgICAgICAgICBjb25zdCBzID0gdGhpcy4kbGlzdC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgaWYgKHMgPiBpKSBmb3IgKGxldCB0ID0gaTsgdCA8IHM7IHQrKykgdGhpcy4kbGlzdC5yZW1vdmVDaGlsZCh0aGlzLiRsaXN0Lmxhc3RDaGlsZCk7ZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gczsgdCA8IGk7IHQrKykge1xuICAgICAgICAgICAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgICAgICAgICAgICBlLmNsYXNzTGlzdC5hZGQoXCJjYXJvdXNlbF9fZG90XCIpLCBlLmRhdGFzZXQucGFnZSA9IHQsIGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImJ1dHRvblwiKSwgZS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIiksIGUuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdGhpcy5jYXJvdXNlbC5sb2NhbGl6ZShcInt7R09UT319XCIsIFtbXCIlZFwiLCB0ICsgMV1dKSksIGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IHQuY29kZTtcbiAgICAgICAgICAgICAgICBsZXQgcztcbiAgICAgICAgICAgICAgICBcIkVudGVyXCIgPT09IGkgfHwgXCJOdW1wYWRFbnRlclwiID09PSBpID8gcyA9IGUgOiBcIkFycm93UmlnaHRcIiA9PT0gaSA/IHMgPSBlLm5leHRTaWJsaW5nIDogXCJBcnJvd0xlZnRcIiA9PT0gaSAmJiAocyA9IGUucHJldmlvdXNTaWJsaW5nKSwgcyAmJiBzLmNsaWNrKCk7XG4gICAgICAgICAgICAgIH0pLCB0aGlzLiRsaXN0LmFwcGVuZENoaWxkKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZURvdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldEFjdGl2ZURvdCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuJGxpc3QpIHJldHVybjtcbiAgICAgICAgICB0aGlzLiRsaXN0LmNoaWxkTm9kZXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgIHQuY2xhc3NMaXN0LnJlbW92ZShcImlzLXNlbGVjdGVkXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLiRsaXN0LmNoaWxkTm9kZXNbdGhpcy5jYXJvdXNlbC5wYWdlXTtcbiAgICAgICAgICB0ICYmIHQuY2xhc3NMaXN0LmFkZChcImlzLXNlbGVjdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgb25DaGFuZ2UoKSB7XG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmVEb3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uUmVmcmVzaCgpIHtcbiAgICAgICAgICB0aGlzLnJlYnVpbGREb3RzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRhY2goKSB7XG4gICAgICAgICAgdGhpcy5jYXJvdXNlbC5vbih0aGlzLmV2ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRhY2goKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0KCksIHRoaXMuY2Fyb3VzZWwub2ZmKHRoaXMuZXZlbnRzKSwgdGhpcy5jYXJvdXNlbCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgfSxcbiAgICAgIFN5bmM6IGdcbiAgICB9O1xuICAgIGNvbnN0IG0gPSB7XG4gICAgICBzbGlkZXM6IFtdLFxuICAgICAgcHJlbG9hZDogMCxcbiAgICAgIHNsaWRlc1BlclBhZ2U6IFwiYXV0b1wiLFxuICAgICAgaW5pdGlhbFBhZ2U6IG51bGwsXG4gICAgICBpbml0aWFsU2xpZGU6IG51bGwsXG4gICAgICBmcmljdGlvbjogLjkyLFxuICAgICAgY2VudGVyOiAhMCxcbiAgICAgIGluZmluaXRlOiAhMCxcbiAgICAgIGZpbGw6ICEwLFxuICAgICAgZHJhZ0ZyZWU6ICExLFxuICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICB2aWV3cG9ydDogXCJjYXJvdXNlbF9fdmlld3BvcnRcIixcbiAgICAgICAgdHJhY2s6IFwiY2Fyb3VzZWxfX3RyYWNrXCIsXG4gICAgICAgIHNsaWRlOiBcImNhcm91c2VsX19zbGlkZVwiLFxuICAgICAgICBzbGlkZVNlbGVjdGVkOiBcImlzLXNlbGVjdGVkXCJcbiAgICAgIH0sXG4gICAgICBsMTBuOiB7XG4gICAgICAgIE5FWFQ6IFwiTmV4dCBzbGlkZVwiLFxuICAgICAgICBQUkVWOiBcIlByZXZpb3VzIHNsaWRlXCIsXG4gICAgICAgIEdPVE86IFwiR28gdG8gc2xpZGUgIyVkXCJcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2xhc3MgeSBleHRlbmRzIGwge1xuICAgICAgY29uc3RydWN0b3IodCwgaSA9IHt9KSB7XG4gICAgICAgIGlmIChzdXBlcihpID0gZSghMCwge30sIG0sIGkpKSwgdGhpcy5zdGF0ZSA9IFwiaW5pdFwiLCB0aGlzLiRjb250YWluZXIgPSB0LCAhKHRoaXMuJGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcm9vdCBlbGVtZW50IHByb3ZpZGVkXCIpO1xuICAgICAgICB0aGlzLnNsaWRlTmV4dCA9IHUodGhpcy5zbGlkZU5leHQuYmluZCh0aGlzKSwgMjUwKSwgdGhpcy5zbGlkZVByZXYgPSB1KHRoaXMuc2xpZGVQcmV2LmJpbmQodGhpcyksIDI1MCksIHRoaXMuaW5pdCgpLCB0Ll9fQ2Fyb3VzZWwgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnBhZ2VzID0gW10sIHRoaXMucGFnZSA9IHRoaXMucGFnZUluZGV4ID0gbnVsbCwgdGhpcy5wcmV2UGFnZSA9IHRoaXMucHJldlBhZ2VJbmRleCA9IG51bGwsIHRoaXMuYXR0YWNoUGx1Z2lucyh5LlBsdWdpbnMpLCB0aGlzLnRyaWdnZXIoXCJpbml0XCIpLCB0aGlzLmluaXRMYXlvdXQoKSwgdGhpcy5pbml0U2xpZGVzKCksIHRoaXMudXBkYXRlTWV0cmljcygpLCB0aGlzLiR0cmFjayAmJiB0aGlzLnBhZ2VzLmxlbmd0aCAmJiAodGhpcy4kdHJhY2suc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7LTEgKiB0aGlzLnBhZ2VzW3RoaXMucGFnZV0ubGVmdH1weCwgMHB4LCAwKSBzY2FsZSgxKWApLCB0aGlzLm1hbmFnZVNsaWRlVmlzaWJsaXR5KCksIHRoaXMuaW5pdFBhbnpvb20oKSwgdGhpcy5zdGF0ZSA9IFwicmVhZHlcIiwgdGhpcy50cmlnZ2VyKFwicmVhZHlcIik7XG4gICAgICB9XG5cbiAgICAgIGluaXRMYXlvdXQoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbihcInByZWZpeFwiKSxcbiAgICAgICAgICAgICAgZSA9IHRoaXMub3B0aW9uKFwiY2xhc3NOYW1lc1wiKTtcbiAgICAgICAgdGhpcy4kdmlld3BvcnQgPSB0aGlzLm9wdGlvbihcInZpZXdwb3J0XCIpIHx8IHRoaXMuJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGAuJHt0fSR7ZS52aWV3cG9ydH1gKSwgdGhpcy4kdmlld3BvcnQgfHwgKHRoaXMuJHZpZXdwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGhpcy4kdmlld3BvcnQuY2xhc3NMaXN0LmFkZCguLi4odCArIGUudmlld3BvcnQpLnNwbGl0KFwiIFwiKSksIHRoaXMuJHZpZXdwb3J0LmFwcGVuZCguLi50aGlzLiRjb250YWluZXIuY2hpbGROb2RlcyksIHRoaXMuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLiR2aWV3cG9ydCkpLCB0aGlzLiR0cmFjayA9IHRoaXMub3B0aW9uKFwidHJhY2tcIikgfHwgdGhpcy4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYC4ke3R9JHtlLnRyYWNrfWApLCB0aGlzLiR0cmFjayB8fCAodGhpcy4kdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB0aGlzLiR0cmFjay5jbGFzc0xpc3QuYWRkKC4uLih0ICsgZS50cmFjaykuc3BsaXQoXCIgXCIpKSwgdGhpcy4kdHJhY2suYXBwZW5kKC4uLnRoaXMuJHZpZXdwb3J0LmNoaWxkTm9kZXMpLCB0aGlzLiR2aWV3cG9ydC5hcHBlbmRDaGlsZCh0aGlzLiR0cmFjaykpO1xuICAgICAgfVxuXG4gICAgICBpbml0U2xpZGVzKCkge1xuICAgICAgICB0aGlzLnNsaWRlcyA9IFtdO1xuICAgICAgICB0aGlzLiR2aWV3cG9ydC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0aGlzLm9wdGlvbihcInByZWZpeFwiKX0ke3RoaXMub3B0aW9uKFwiY2xhc3NOYW1lcy5zbGlkZVwiKX1gKS5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgICAgICAkZWw6IHQsXG4gICAgICAgICAgICBpc0RvbTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuc2xpZGVzLnB1c2goZSksIHRoaXMudHJpZ2dlcihcImNyZWF0ZVNsaWRlXCIsIGUsIHRoaXMuc2xpZGVzLmxlbmd0aCk7XG4gICAgICAgIH0pLCBBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5zbGlkZXMpICYmICh0aGlzLnNsaWRlcyA9IGUoITAsIFsuLi50aGlzLnNsaWRlc10sIHRoaXMub3B0aW9ucy5zbGlkZXMpKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlTWV0cmljcygpIHtcbiAgICAgICAgbGV0IHQsXG4gICAgICAgICAgICBlID0gMCxcbiAgICAgICAgICAgIHMgPSBbXTtcbiAgICAgICAgdGhpcy5zbGlkZXMuZm9yRWFjaCgoaSwgbykgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSBpLiRlbCxcbiAgICAgICAgICAgICAgICBhID0gaS5pc0RvbSB8fCAhdCA/IHRoaXMuZ2V0U2xpZGVNZXRyaWNzKG4pIDogdDtcbiAgICAgICAgICBpLmluZGV4ID0gbywgaS53aWR0aCA9IGEsIGkubGVmdCA9IGUsIHQgPSBhLCBlICs9IGEsIHMucHVzaChvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBvID0gTWF0aC5tYXgodGhpcy4kdHJhY2sub2Zmc2V0V2lkdGgsIGkodGhpcy4kdHJhY2suZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpKSxcbiAgICAgICAgICAgIG4gPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJHRyYWNrKTtcbiAgICAgICAgbyAtPSBwYXJzZUZsb2F0KG4ucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChuLnBhZGRpbmdSaWdodCksIHRoaXMuY29udGVudFdpZHRoID0gZSwgdGhpcy52aWV3cG9ydFdpZHRoID0gbztcbiAgICAgICAgY29uc3QgYSA9IFtdLFxuICAgICAgICAgICAgICByID0gdGhpcy5vcHRpb24oXCJzbGlkZXNQZXJQYWdlXCIpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihyKSAmJiBlID4gbykgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLnNsaWRlcy5sZW5ndGg7IHQgKz0gcikgYS5wdXNoKHtcbiAgICAgICAgICBpbmRleGVzOiBzLnNsaWNlKHQsIHQgKyByKSxcbiAgICAgICAgICBzbGlkZXM6IHRoaXMuc2xpZGVzLnNsaWNlKHQsIHQgKyByKVxuICAgICAgICB9KTtlbHNlIHtcbiAgICAgICAgICBsZXQgdCA9IDAsXG4gICAgICAgICAgICAgIGUgPSAwO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGV0IHMgPSB0aGlzLnNsaWRlc1tpXTtcbiAgICAgICAgICAgICghYS5sZW5ndGggfHwgZSArIHMud2lkdGggPiBvKSAmJiAoYS5wdXNoKHtcbiAgICAgICAgICAgICAgaW5kZXhlczogW10sXG4gICAgICAgICAgICAgIHNsaWRlczogW11cbiAgICAgICAgICAgIH0pLCB0ID0gYS5sZW5ndGggLSAxLCBlID0gMCksIGUgKz0gcy53aWR0aCwgYVt0XS5pbmRleGVzLnB1c2goaSksIGFbdF0uc2xpZGVzLnB1c2gocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLm9wdGlvbihcImNlbnRlclwiKSxcbiAgICAgICAgICAgICAgbCA9IHRoaXMub3B0aW9uKFwiZmlsbFwiKTtcbiAgICAgICAgYS5mb3JFYWNoKCh0LCBpKSA9PiB7XG4gICAgICAgICAgdC5pbmRleCA9IGksIHQud2lkdGggPSB0LnNsaWRlcy5yZWR1Y2UoKHQsIGUpID0+IHQgKyBlLndpZHRoLCAwKSwgdC5sZWZ0ID0gdC5zbGlkZXNbMF0ubGVmdCwgaCAmJiAodC5sZWZ0ICs9IC41ICogKG8gLSB0LndpZHRoKSAqIC0xKSwgbCAmJiAhdGhpcy5vcHRpb24oXCJpbmZpbml0ZVhcIiwgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVwiKSkgJiYgZSA+IG8gJiYgKHQubGVmdCA9IE1hdGgubWF4KHQubGVmdCwgMCksIHQubGVmdCA9IE1hdGgubWluKHQubGVmdCwgZSAtIG8pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGMgPSBbXTtcbiAgICAgICAgbGV0IGQ7XG4gICAgICAgIGEuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBjb25zdCBlID0geyAuLi50XG4gICAgICAgICAgfTtcbiAgICAgICAgICBkICYmIGUubGVmdCA9PT0gZC5sZWZ0ID8gKGQud2lkdGggKz0gZS53aWR0aCwgZC5zbGlkZXMgPSBbLi4uZC5zbGlkZXMsIC4uLmUuc2xpZGVzXSwgZC5pbmRleGVzID0gWy4uLmQuaW5kZXhlcywgLi4uZS5pbmRleGVzXSkgOiAoZS5pbmRleCA9IGMubGVuZ3RoLCBkID0gZSwgYy5wdXNoKGUpKTtcbiAgICAgICAgfSksIHRoaXMucGFnZXMgPSBjO1xuICAgICAgICBsZXQgdSA9IHRoaXMucGFnZTtcblxuICAgICAgICBpZiAobnVsbCA9PT0gdSkge1xuICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbihcImluaXRpYWxTbGlkZVwiKTtcbiAgICAgICAgICB1ID0gbnVsbCAhPT0gdCA/IHRoaXMuZmluZFBhZ2VGb3JTbGlkZSh0KSA6IHBhcnNlSW50KHRoaXMub3B0aW9uKFwiaW5pdGlhbFBhZ2VcIiwgMCksIDEwKSB8fCAwLCBjW3VdIHx8ICh1ID0gYy5sZW5ndGggJiYgdSA+IGMubGVuZ3RoID8gY1tjLmxlbmd0aCAtIDFdLmluZGV4IDogMCksIHRoaXMucGFnZSA9IHUsIHRoaXMucGFnZUluZGV4ID0gdTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlUGFuem9vbSgpLCB0aGlzLnRyaWdnZXIoXCJyZWZyZXNoXCIpO1xuICAgICAgfVxuXG4gICAgICBnZXRTbGlkZU1ldHJpY3ModCkge1xuICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICBjb25zdCBlID0gdGhpcy5zbGlkZXNbMF07XG4gICAgICAgICAgKHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5kYXRhc2V0LmlzVGVzdEVsID0gMSwgdC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdC5jbGFzc0xpc3QuYWRkKC4uLih0aGlzLm9wdGlvbihcInByZWZpeFwiKSArIHRoaXMub3B0aW9uKFwiY2xhc3NOYW1lcy5zbGlkZVwiKSkuc3BsaXQoXCIgXCIpKSwgZS5jdXN0b21DbGFzcyAmJiB0LmNsYXNzTGlzdC5hZGQoLi4uZS5jdXN0b21DbGFzcy5zcGxpdChcIiBcIikpLCB0aGlzLiR0cmFjay5wcmVwZW5kKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGUgPSBNYXRoLm1heCh0Lm9mZnNldFdpZHRoLCBpKHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpKTtcbiAgICAgICAgY29uc3QgcyA9IHQuY3VycmVudFN0eWxlIHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpO1xuICAgICAgICByZXR1cm4gZSA9IGUgKyAocGFyc2VGbG9hdChzLm1hcmdpbkxlZnQpIHx8IDApICsgKHBhcnNlRmxvYXQocy5tYXJnaW5SaWdodCkgfHwgMCksIHQuZGF0YXNldC5pc1Rlc3RFbCAmJiB0LnJlbW92ZSgpLCBlO1xuICAgICAgfVxuXG4gICAgICBmaW5kUGFnZUZvclNsaWRlKHQpIHtcbiAgICAgICAgdCA9IHBhcnNlSW50KHQsIDEwKSB8fCAwO1xuICAgICAgICBjb25zdCBlID0gdGhpcy5wYWdlcy5maW5kKGUgPT4gZS5pbmRleGVzLmluZGV4T2YodCkgPiAtMSk7XG4gICAgICAgIHJldHVybiBlID8gZS5pbmRleCA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNsaWRlTmV4dCgpIHtcbiAgICAgICAgdGhpcy5zbGlkZVRvKHRoaXMucGFnZUluZGV4ICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHNsaWRlUHJldigpIHtcbiAgICAgICAgdGhpcy5zbGlkZVRvKHRoaXMucGFnZUluZGV4IC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHNsaWRlVG8odCwgZSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB4OiBpID0gLTEgKiB0aGlzLnNldFBhZ2UodCwgITApLFxuICAgICAgICAgIHk6IHMgPSAwLFxuICAgICAgICAgIGZyaWN0aW9uOiBvID0gdGhpcy5vcHRpb24oXCJmcmljdGlvblwiKVxuICAgICAgICB9ID0gZTtcbiAgICAgICAgdGhpcy5QYW56b29tLmNvbnRlbnQueCA9PT0gaSAmJiAhdGhpcy5QYW56b29tLnZlbG9jaXR5LnggJiYgbyB8fCAodGhpcy5QYW56b29tLnBhblRvKHtcbiAgICAgICAgICB4OiBpLFxuICAgICAgICAgIHk6IHMsXG4gICAgICAgICAgZnJpY3Rpb246IG8sXG4gICAgICAgICAgaWdub3JlQm91bmRzOiAhMFxuICAgICAgICB9KSwgXCJyZWFkeVwiID09PSB0aGlzLnN0YXRlICYmIFwicmVhZHlcIiA9PT0gdGhpcy5QYW56b29tLnN0YXRlICYmIHRoaXMudHJpZ2dlcihcInNldHRsZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIGluaXRQYW56b29tKCkge1xuICAgICAgICB0aGlzLlBhbnpvb20gJiYgdGhpcy5QYW56b29tLmRlc3Ryb3koKTtcbiAgICAgICAgY29uc3QgdCA9IGUoITAsIHt9LCB7XG4gICAgICAgICAgY29udGVudDogdGhpcy4kdHJhY2ssXG4gICAgICAgICAgd3JhcElubmVyOiAhMSxcbiAgICAgICAgICByZXNpemVQYXJlbnQ6ICExLFxuICAgICAgICAgIHpvb206ICExLFxuICAgICAgICAgIGNsaWNrOiAhMSxcbiAgICAgICAgICBsb2NrQXhpczogXCJ4XCIsXG4gICAgICAgICAgeDogdGhpcy5wYWdlcy5sZW5ndGggPyAtMSAqIHRoaXMucGFnZXNbdGhpcy5wYWdlXS5sZWZ0IDogMCxcbiAgICAgICAgICBjZW50ZXJPblN0YXJ0OiAhMSxcbiAgICAgICAgICB0ZXh0U2VsZWN0aW9uOiAoKSA9PiB0aGlzLm9wdGlvbihcInRleHRTZWxlY3Rpb25cIiwgITEpLFxuICAgICAgICAgIHBhbk9ubHlab29tZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQud2lkdGggPD0gdGhpcy52aWV3cG9ydC53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMub3B0aW9uKFwiUGFuem9vbVwiKSk7XG4gICAgICAgIHRoaXMuUGFuem9vbSA9IG5ldyBkKHRoaXMuJGNvbnRhaW5lciwgdCksIHRoaXMuUGFuem9vbS5vbih7XG4gICAgICAgICAgXCIqXCI6ICh0LCAuLi5lKSA9PiB0aGlzLnRyaWdnZXIoYFBhbnpvb20uJHt0fWAsIC4uLmUpLFxuICAgICAgICAgIGFmdGVyVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2UoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJlZm9yZVRyYW5zZm9ybTogdGhpcy5vbkJlZm9yZVRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgICAgICAgIHRvdWNoRW5kOiB0aGlzLm9uVG91Y2hFbmQuYmluZCh0aGlzKSxcbiAgICAgICAgICBlbmRBbmltYXRpb246ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcInNldHRsZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCB0aGlzLnVwZGF0ZU1ldHJpY3MoKSwgdGhpcy5tYW5hZ2VTbGlkZVZpc2libGl0eSgpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVQYW56b29tKCkge1xuICAgICAgICB0aGlzLlBhbnpvb20gJiYgKHRoaXMuUGFuem9vbS5jb250ZW50ID0geyAuLi50aGlzLlBhbnpvb20uY29udGVudCxcbiAgICAgICAgICBmaXRXaWR0aDogdGhpcy5jb250ZW50V2lkdGgsXG4gICAgICAgICAgb3JpZ1dpZHRoOiB0aGlzLmNvbnRlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogdGhpcy5jb250ZW50V2lkdGhcbiAgICAgICAgfSwgdGhpcy5wYWdlcy5sZW5ndGggPiAxICYmIHRoaXMub3B0aW9uKFwiaW5maW5pdGVYXCIsIHRoaXMub3B0aW9uKFwiaW5maW5pdGVcIikpID8gdGhpcy5QYW56b29tLmJvdW5kWCA9IG51bGwgOiB0aGlzLnBhZ2VzLmxlbmd0aCAmJiAodGhpcy5QYW56b29tLmJvdW5kWCA9IHtcbiAgICAgICAgICBmcm9tOiAtMSAqIHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXS5sZWZ0LFxuICAgICAgICAgIHRvOiAtMSAqIHRoaXMucGFnZXNbMF0ubGVmdFxuICAgICAgICB9KSwgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVlcIiwgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVwiKSkgPyB0aGlzLlBhbnpvb20uYm91bmRZID0gbnVsbCA6IHRoaXMuUGFuem9vbS5ib3VuZFkgPSB7XG4gICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICB0bzogMFxuICAgICAgICB9LCB0aGlzLlBhbnpvb20uaGFuZGxlQ3Vyc29yKCkpO1xuICAgICAgfVxuXG4gICAgICBtYW5hZ2VTbGlkZVZpc2libGl0eSgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuY29udGVudFdpZHRoLFxuICAgICAgICAgICAgICBlID0gdGhpcy52aWV3cG9ydFdpZHRoO1xuICAgICAgICBsZXQgaSA9IHRoaXMuUGFuem9vbSA/IC0xICogdGhpcy5QYW56b29tLmNvbnRlbnQueCA6IHRoaXMucGFnZXMubGVuZ3RoID8gdGhpcy5wYWdlc1t0aGlzLnBhZ2VdLmxlZnQgOiAwO1xuICAgICAgICBjb25zdCBzID0gdGhpcy5vcHRpb24oXCJwcmVsb2FkXCIpLFxuICAgICAgICAgICAgICBvID0gdGhpcy5vcHRpb24oXCJpbmZpbml0ZVhcIiwgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVwiKSksXG4gICAgICAgICAgICAgIG4gPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUodGhpcy4kdmlld3BvcnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLWxlZnRcIikpLFxuICAgICAgICAgICAgICBhID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKHRoaXMuJHZpZXdwb3J0LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1yaWdodFwiKSk7XG4gICAgICAgIHRoaXMuc2xpZGVzLmZvckVhY2gociA9PiB7XG4gICAgICAgICAgbGV0IGgsXG4gICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgIGggPSBpIC0gbiwgbCA9IGkgKyBlICsgYSwgaCAtPSBzICogKGUgKyBuICsgYSksIGwgKz0gcyAqIChlICsgbiArIGEpO1xuICAgICAgICAgIGNvbnN0IGQgPSByLmxlZnQgKyByLndpZHRoID4gaCAmJiByLmxlZnQgPCBsO1xuICAgICAgICAgIGggPSBpICsgdCAtIG4sIGwgPSBpICsgdCArIGUgKyBhLCBoIC09IHMgKiAoZSArIG4gKyBhKTtcbiAgICAgICAgICBjb25zdCB1ID0gbyAmJiByLmxlZnQgKyByLndpZHRoID4gaCAmJiByLmxlZnQgPCBsO1xuICAgICAgICAgIGggPSBpIC0gdCAtIG4sIGwgPSBpIC0gdCArIGUgKyBhLCBoIC09IHMgKiAoZSArIG4gKyBhKTtcbiAgICAgICAgICBjb25zdCBmID0gbyAmJiByLmxlZnQgKyByLndpZHRoID4gaCAmJiByLmxlZnQgPCBsO1xuICAgICAgICAgIHUgfHwgZCB8fCBmID8gKHRoaXMuY3JlYXRlU2xpZGVFbChyKSwgZCAmJiAoYyA9IDApLCB1ICYmIChjID0gLTEpLCBmICYmIChjID0gMSksIHIubGVmdCArIHIud2lkdGggPiBpICYmIHIubGVmdCA8PSBpICsgZSArIGEgJiYgKGMgPSAwKSkgOiB0aGlzLnJlbW92ZVNsaWRlRWwociksIHIuaGFzRGlmZiA9IGM7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgciA9IDAsXG4gICAgICAgICAgICBoID0gMDtcbiAgICAgICAgdGhpcy5zbGlkZXMuZm9yRWFjaCgoZSwgaSkgPT4ge1xuICAgICAgICAgIGxldCBzID0gMDtcbiAgICAgICAgICBlLiRlbCA/IChpICE9PSByIHx8IGUuaGFzRGlmZiA/IHMgPSBoICsgZS5oYXNEaWZmICogdCA6IGggPSAwLCBlLiRlbC5zdHlsZS5sZWZ0ID0gTWF0aC5hYnMocykgPiAuMSA/IGAke2ggKyBlLmhhc0RpZmYgKiB0fXB4YCA6IFwiXCIsIHIrKykgOiBoICs9IGUud2lkdGg7XG4gICAgICAgIH0pLCB0aGlzLm1hcmtTZWxlY3RlZFNsaWRlcygpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVTbGlkZUVsKHQpIHtcbiAgICAgICAgaWYgKCF0KSByZXR1cm47XG5cbiAgICAgICAgaWYgKHQuJGVsKSB7XG4gICAgICAgICAgbGV0IGUgPSB0LiRlbC5kYXRhc2V0LmluZGV4O1xuXG4gICAgICAgICAgaWYgKCFlIHx8IHBhcnNlSW50KGUsIDEwKSAhPT0gdC5pbmRleCkge1xuICAgICAgICAgICAgbGV0IGU7XG4gICAgICAgICAgICB0LiRlbC5kYXRhc2V0LmluZGV4ID0gdC5pbmRleCwgdC4kZWwucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWxhenktc3Jjc2V0XVwiKS5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgICAgICB0LnNyY3NldCA9IHQuZGF0YXNldC5sYXp5U3Jjc2V0O1xuICAgICAgICAgICAgfSksIHQuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1sYXp5LXNyY11cIikuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgbGV0IGUgPSB0LmRhdGFzZXQubGF6eVNyYztcbiAgICAgICAgICAgICAgdCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgPyB0LnNyYyA9IGUgOiB0LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJyR7ZX0nKWA7XG4gICAgICAgICAgICB9KSwgKGUgPSB0LiRlbC5kYXRhc2V0LmxhenlTcmMpICYmICh0LiRlbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke2V9JylgKSwgdC5zdGF0ZSA9IFwicmVhZHlcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZS5kYXRhc2V0LmluZGV4ID0gdC5pbmRleCwgZS5jbGFzc0xpc3QuYWRkKC4uLih0aGlzLm9wdGlvbihcInByZWZpeFwiKSArIHRoaXMub3B0aW9uKFwiY2xhc3NOYW1lcy5zbGlkZVwiKSkuc3BsaXQoXCIgXCIpKSwgdC5jdXN0b21DbGFzcyAmJiBlLmNsYXNzTGlzdC5hZGQoLi4udC5jdXN0b21DbGFzcy5zcGxpdChcIiBcIikpLCB0Lmh0bWwgJiYgKGUuaW5uZXJIVE1MID0gdC5odG1sKTtcbiAgICAgICAgY29uc3QgaSA9IFtdO1xuICAgICAgICB0aGlzLnNsaWRlcy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICAgICAgdC4kZWwgJiYgaS5wdXNoKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcyA9IHQuaW5kZXg7XG4gICAgICAgIGxldCBvID0gbnVsbDtcblxuICAgICAgICBpZiAoaS5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgdCA9IGkucmVkdWNlKCh0LCBlKSA9PiBNYXRoLmFicyhlIC0gcykgPCBNYXRoLmFicyh0IC0gcykgPyBlIDogdCk7XG4gICAgICAgICAgbyA9IHRoaXMuc2xpZGVzW3RdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJHRyYWNrLmluc2VydEJlZm9yZShlLCBvICYmIG8uJGVsID8gby5pbmRleCA8IHQuaW5kZXggPyBvLiRlbC5uZXh0U2libGluZyA6IG8uJGVsIDogbnVsbCksIHQuJGVsID0gZSwgdGhpcy50cmlnZ2VyKFwiY3JlYXRlU2xpZGVcIiwgdCwgcyksIHQ7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZVNsaWRlRWwodCkge1xuICAgICAgICB0LiRlbCAmJiAhdC5pc0RvbSAmJiAodGhpcy50cmlnZ2VyKFwicmVtb3ZlU2xpZGVcIiwgdCksIHQuJGVsLnJlbW92ZSgpLCB0LiRlbCA9IG51bGwpO1xuICAgICAgfVxuXG4gICAgICBtYXJrU2VsZWN0ZWRTbGlkZXMoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbihcImNsYXNzTmFtZXMuc2xpZGVTZWxlY3RlZFwiKSxcbiAgICAgICAgICAgICAgZSA9IFwiYXJpYS1oaWRkZW5cIjtcbiAgICAgICAgdGhpcy5zbGlkZXMuZm9yRWFjaCgoaSwgcykgPT4ge1xuICAgICAgICAgIGNvbnN0IG8gPSBpLiRlbDtcbiAgICAgICAgICBpZiAoIW8pIHJldHVybjtcbiAgICAgICAgICBjb25zdCBuID0gdGhpcy5wYWdlc1t0aGlzLnBhZ2VdO1xuICAgICAgICAgIG4gJiYgbi5pbmRleGVzICYmIG4uaW5kZXhlcy5pbmRleE9mKHMpID4gLTEgPyAodCAmJiAhby5jbGFzc0xpc3QuY29udGFpbnModCkgJiYgKG8uY2xhc3NMaXN0LmFkZCh0KSwgdGhpcy50cmlnZ2VyKFwic2VsZWN0U2xpZGVcIiwgaSkpLCBvLnJlbW92ZUF0dHJpYnV0ZShlKSkgOiAodCAmJiBvLmNsYXNzTGlzdC5jb250YWlucyh0KSAmJiAoby5jbGFzc0xpc3QucmVtb3ZlKHQpLCB0aGlzLnRyaWdnZXIoXCJ1bnNlbGVjdFNsaWRlXCIsIGkpKSwgby5zZXRBdHRyaWJ1dGUoZSwgITApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZVBhZ2UoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWV0cmljcygpLCB0aGlzLnNsaWRlVG8odGhpcy5wYWdlLCB7XG4gICAgICAgICAgZnJpY3Rpb246IDBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG9uQmVmb3JlVHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLm9wdGlvbihcImluZmluaXRlWFwiLCB0aGlzLm9wdGlvbihcImluZmluaXRlXCIpKSAmJiB0aGlzLm1hbmFnZUluZmluaXRlVHJhY2soKSwgdGhpcy5tYW5hZ2VTbGlkZVZpc2libGl0eSgpO1xuICAgICAgfVxuXG4gICAgICBtYW5hZ2VJbmZpbml0ZVRyYWNrKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5jb250ZW50V2lkdGgsXG4gICAgICAgICAgICAgIGUgPSB0aGlzLnZpZXdwb3J0V2lkdGg7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb24oXCJpbmZpbml0ZVhcIiwgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVwiKSkgfHwgdGhpcy5wYWdlcy5sZW5ndGggPCAyIHx8IHQgPCBlKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLlBhbnpvb207XG4gICAgICAgIGxldCBzID0gITE7XG4gICAgICAgIHJldHVybiBpLmNvbnRlbnQueCA8IC0xICogKHQgLSBlKSAmJiAoaS5jb250ZW50LnggKz0gdCwgdGhpcy5wYWdlSW5kZXggPSB0aGlzLnBhZ2VJbmRleCAtIHRoaXMucGFnZXMubGVuZ3RoLCBzID0gITApLCBpLmNvbnRlbnQueCA+IGUgJiYgKGkuY29udGVudC54IC09IHQsIHRoaXMucGFnZUluZGV4ID0gdGhpcy5wYWdlSW5kZXggKyB0aGlzLnBhZ2VzLmxlbmd0aCwgcyA9ICEwKSwgcyAmJiBcInBvaW50ZXJkb3duXCIgPT09IGkuc3RhdGUgJiYgaS5yZXNldERyYWdQb3NpdGlvbigpLCBzO1xuICAgICAgfVxuXG4gICAgICBvblRvdWNoRW5kKHQsIGUpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMub3B0aW9uKFwiZHJhZ0ZyZWVcIik7XG4gICAgICAgIGlmICghaSAmJiB0aGlzLnBhZ2VzLmxlbmd0aCA+IDEgJiYgdC5kcmFnT2Zmc2V0LnRpbWUgPCAzNTAgJiYgTWF0aC5hYnModC5kcmFnT2Zmc2V0LnkpIDwgMSAmJiBNYXRoLmFicyh0LmRyYWdPZmZzZXQueCkgPiA1KSB0aGlzW3QuZHJhZ09mZnNldC54IDwgMCA/IFwic2xpZGVOZXh0XCIgOiBcInNsaWRlUHJldlwiXSgpO2Vsc2UgaWYgKGkpIHtcbiAgICAgICAgICBjb25zdCBbLCBlXSA9IHRoaXMuZ2V0UGFnZUZyb21Qb3NpdGlvbigtMSAqIHQudHJhbnNmb3JtLngpO1xuICAgICAgICAgIHRoaXMuc2V0UGFnZShlKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuc2xpZGVUb0Nsb3Nlc3QoKTtcbiAgICAgIH1cblxuICAgICAgc2xpZGVUb0Nsb3Nlc3QodCA9IHt9KSB7XG4gICAgICAgIGxldCBbLCBlXSA9IHRoaXMuZ2V0UGFnZUZyb21Qb3NpdGlvbigtMSAqIHRoaXMuUGFuem9vbS5jb250ZW50LngpO1xuICAgICAgICB0aGlzLnNsaWRlVG8oZSwgdCk7XG4gICAgICB9XG5cbiAgICAgIGdldFBhZ2VGcm9tUG9zaXRpb24odCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5wYWdlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMub3B0aW9uKFwiY2VudGVyXCIpICYmICh0ICs9IC41ICogdGhpcy52aWV3cG9ydFdpZHRoKTtcbiAgICAgICAgY29uc3QgaSA9IE1hdGguZmxvb3IodCAvIHRoaXMuY29udGVudFdpZHRoKTtcbiAgICAgICAgdCAtPSBpICogdGhpcy5jb250ZW50V2lkdGg7XG4gICAgICAgIGxldCBzID0gdGhpcy5zbGlkZXMuZmluZChlID0+IGUubGVmdCA8PSB0ICYmIGUubGVmdCArIGUud2lkdGggPiB0KTtcblxuICAgICAgICBpZiAocykge1xuICAgICAgICAgIGxldCB0ID0gdGhpcy5maW5kUGFnZUZvclNsaWRlKHMuaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBbdCwgdCArIGkgKiBlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHNldFBhZ2UodCwgZSkge1xuICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICBzID0gcGFyc2VJbnQodCwgMTApIHx8IDA7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLnBhZ2UsXG4gICAgICAgICAgICAgIG4gPSB0aGlzLnBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgYSA9IHRoaXMucGFnZXMubGVuZ3RoLFxuICAgICAgICAgICAgICByID0gdGhpcy5jb250ZW50V2lkdGgsXG4gICAgICAgICAgICAgIGggPSB0aGlzLnZpZXdwb3J0V2lkdGg7XG5cbiAgICAgICAgaWYgKHQgPSAocyAlIGEgKyBhKSAlIGEsIHRoaXMub3B0aW9uKFwiaW5maW5pdGVYXCIsIHRoaXMub3B0aW9uKFwiaW5maW5pdGVcIikpICYmIHIgPiBoKSB7XG4gICAgICAgICAgY29uc3QgbyA9IE1hdGguZmxvb3IocyAvIGEpIHx8IDAsXG4gICAgICAgICAgICAgICAgbiA9IHI7XG5cbiAgICAgICAgICBpZiAoaSA9IHRoaXMucGFnZXNbdF0ubGVmdCArIG8gKiBuLCAhMCA9PT0gZSAmJiBhID4gMikge1xuICAgICAgICAgICAgbGV0IHQgPSAtMSAqIHRoaXMuUGFuem9vbS5jb250ZW50Lng7XG4gICAgICAgICAgICBjb25zdCBlID0gaSAtIG4sXG4gICAgICAgICAgICAgICAgICBvID0gaSArIG4sXG4gICAgICAgICAgICAgICAgICByID0gTWF0aC5hYnModCAtIGkpLFxuICAgICAgICAgICAgICAgICAgaCA9IE1hdGguYWJzKHQgLSBlKSxcbiAgICAgICAgICAgICAgICAgIGwgPSBNYXRoLmFicyh0IC0gbyk7XG4gICAgICAgICAgICBsIDwgciAmJiBsIDw9IGggPyAoaSA9IG8sIHMgKz0gYSkgOiBoIDwgciAmJiBoIDwgbCAmJiAoaSA9IGUsIHMgLT0gYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgdCA9IHMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzLCBhIC0gMSkpLCBpID0gdGhpcy5wYWdlcy5sZW5ndGggPyB0aGlzLnBhZ2VzW3RdLmxlZnQgOiAwO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2UgPSB0LCB0aGlzLnBhZ2VJbmRleCA9IHMsIG51bGwgIT09IG8gJiYgdCAhPT0gbyAmJiAodGhpcy5wcmV2UGFnZSA9IG8sIHRoaXMucHJldlBhZ2VJbmRleCA9IG4sIHRoaXMudHJpZ2dlcihcImNoYW5nZVwiLCB0LCBvKSksIGk7XG4gICAgICB9XG5cbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImRlc3Ryb3lcIiwgdGhpcy5zbGlkZXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVNsaWRlRWwodCk7XG4gICAgICAgIH0pLCB0aGlzLnNsaWRlcyA9IFtdLCB0aGlzLlBhbnpvb20uZGVzdHJveSgpLCB0aGlzLmRldGFjaFBsdWdpbnMoKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHkudmVyc2lvbiA9IFwiNC4wLjMxXCIsIHkuUGx1Z2lucyA9IHA7XG4gICAgY29uc3QgdiA9ICEoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgIXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbiAgICBsZXQgYiA9IG51bGw7XG5cbiAgICBjb25zdCB4ID0gW1wiYVtocmVmXVwiLCBcImFyZWFbaHJlZl1cIiwgJ2lucHV0Om5vdChbZGlzYWJsZWRdKTpub3QoW3R5cGU9XCJoaWRkZW5cIl0pOm5vdChbYXJpYS1oaWRkZW5dKScsIFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKTpub3QoW2FyaWEtaGlkZGVuXSlcIiwgXCJ0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pXCIsIFwiYnV0dG9uOm5vdChbZGlzYWJsZWRdKTpub3QoW2FyaWEtaGlkZGVuXSlcIiwgXCJpZnJhbWVcIiwgXCJvYmplY3RcIiwgXCJlbWJlZFwiLCBcInZpZGVvXCIsIFwiYXVkaW9cIiwgXCJbY29udGVudGVkaXRhYmxlXVwiLCAnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbZGlzYWJsZWRdKTpub3QoW2FyaWEtaGlkZGVuXSknXSxcbiAgICAgICAgICB3ID0gdCA9PiB7XG4gICAgICBpZiAodCAmJiB2KSB7XG4gICAgICAgIG51bGwgPT09IGIgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5mb2N1cyh7XG4gICAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICByZXR1cm4gYiA9ICEwLCAhMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodC5zZXRBY3RpdmUpIHQuc2V0QWN0aXZlKCk7ZWxzZSBpZiAoYikgdC5mb2N1cyh7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiAhMFxuICAgICAgICAgIH0pO2Vsc2Uge1xuICAgICAgICAgICAgY29uc3QgZSA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgIGkgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdC5mb2N1cygpLCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgdG9wOiBlLFxuICAgICAgICAgICAgICBsZWZ0OiBpLFxuICAgICAgICAgICAgICBiZWhhdmlvcjogXCJhdXRvXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAodCkge31cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgJCQxID0ge1xuICAgICAgbWluU2xpZGVDb3VudDogMixcbiAgICAgIG1pblNjcmVlbkhlaWdodDogNTAwLFxuICAgICAgYXV0b1N0YXJ0OiAhMCxcbiAgICAgIGtleTogXCJ0XCIsXG4gICAgICBDYXJvdXNlbDoge30sXG4gICAgICB0cGw6ICc8ZGl2IGNsYXNzPVwiZmFuY3lib3hfX3RodW1iXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWltYWdlOnVybChcXCd7e3NyY319XFwnKVwiPjwvZGl2PidcbiAgICB9O1xuXG4gICAgY2xhc3MgQyB7XG4gICAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3ggPSB0LCB0aGlzLiRjb250YWluZXIgPSBudWxsLCB0aGlzLnN0YXRlID0gXCJpbml0XCI7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIFtcIm9uUHJlcGFyZVwiLCBcIm9uQ2xvc2luZ1wiLCBcIm9uS2V5ZG93blwiXSkgdGhpc1t0XSA9IHRoaXNbdF0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICBwcmVwYXJlOiB0aGlzLm9uUHJlcGFyZSxcbiAgICAgICAgICBjbG9zaW5nOiB0aGlzLm9uQ2xvc2luZyxcbiAgICAgICAgICBrZXlkb3duOiB0aGlzLm9uS2V5ZG93blxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvblByZXBhcmUoKSB7XG4gICAgICAgIHRoaXMuZ2V0U2xpZGVzKCkubGVuZ3RoIDwgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJUaHVtYnMubWluU2xpZGVDb3VudFwiKSA/IHRoaXMuc3RhdGUgPSBcImRpc2FibGVkXCIgOiAhMCA9PT0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJUaHVtYnMuYXV0b1N0YXJ0XCIpICYmIHRoaXMuZmFuY3lib3guQ2Fyb3VzZWwuUGFuem9vbS5jb250ZW50LmhlaWdodCA+PSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIlRodW1icy5taW5TY3JlZW5IZWlnaHRcIikgJiYgdGhpcy5idWlsZCgpO1xuICAgICAgfVxuXG4gICAgICBvbkNsb3NpbmcoKSB7XG4gICAgICAgIHRoaXMuQ2Fyb3VzZWwgJiYgdGhpcy5DYXJvdXNlbC5QYW56b29tLmRldGFjaEV2ZW50cygpO1xuICAgICAgfVxuXG4gICAgICBvbktleWRvd24odCwgZSkge1xuICAgICAgICBlID09PSB0Lm9wdGlvbihcIlRodW1icy5rZXlcIikgJiYgdGhpcy50b2dnbGUoKTtcbiAgICAgIH1cblxuICAgICAgYnVpbGQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRjb250YWluZXIpIHJldHVybjtcbiAgICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHQuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X190aHVtYnNcIiksIHRoaXMuZmFuY3lib3guJGNhcm91c2VsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsIHRoaXMuZmFuY3lib3guJGNhcm91c2VsLm5leHRTaWJsaW5nKSwgdGhpcy5DYXJvdXNlbCA9IG5ldyB5KHQsIGUoITAsIHtcbiAgICAgICAgICBEb3RzOiAhMSxcbiAgICAgICAgICBOYXZpZ2F0aW9uOiAhMSxcbiAgICAgICAgICBTeW5jOiB7XG4gICAgICAgICAgICBmcmljdGlvbjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5maW5pdGU6ICExLFxuICAgICAgICAgIGNlbnRlcjogITAsXG4gICAgICAgICAgZmlsbDogITAsXG4gICAgICAgICAgZHJhZ0ZyZWU6ICEwLFxuICAgICAgICAgIHNsaWRlc1BlclBhZ2U6IDEsXG4gICAgICAgICAgcHJlbG9hZDogMVxuICAgICAgICB9LCB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIlRodW1icy5DYXJvdXNlbFwiKSwge1xuICAgICAgICAgIFN5bmM6IHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5mYW5jeWJveC5DYXJvdXNlbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2xpZGVzOiB0aGlzLmdldFNsaWRlcygpXG4gICAgICAgIH0pKSwgdGhpcy5DYXJvdXNlbC5QYW56b29tLm9uKFwid2hlZWxcIiwgKHQsIGUpID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuZmFuY3lib3hbZS5kZWx0YVkgPCAwID8gXCJwcmV2XCIgOiBcIm5leHRcIl0oKTtcbiAgICAgICAgfSksIHRoaXMuJGNvbnRhaW5lciA9IHQsIHRoaXMuc3RhdGUgPSBcInZpc2libGVcIjtcbiAgICAgIH1cblxuICAgICAgZ2V0U2xpZGVzKCkge1xuICAgICAgICBjb25zdCB0ID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuZmFuY3lib3guaXRlbXMpIHtcbiAgICAgICAgICBjb25zdCBpID0gZS50aHVtYjtcbiAgICAgICAgICBpICYmIHQucHVzaCh7XG4gICAgICAgICAgICBodG1sOiB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIlRodW1icy50cGxcIikucmVwbGFjZSgvXFx7XFx7c3JjXFx9XFx9L2dpLCBpKSxcbiAgICAgICAgICAgIGN1c3RvbUNsYXNzOiBgaGFzLXRodW1iIGhhcy0ke2UudHlwZSB8fCBcImltYWdlXCJ9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG5cbiAgICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgXCJ2aXNpYmxlXCIgPT09IHRoaXMuc3RhdGUgPyB0aGlzLmhpZGUoKSA6IFwiaGlkZGVuXCIgPT09IHRoaXMuc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuYnVpbGQoKTtcbiAgICAgIH1cblxuICAgICAgc2hvdygpIHtcbiAgICAgICAgXCJoaWRkZW5cIiA9PT0gdGhpcy5zdGF0ZSAmJiAodGhpcy4kY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiLCB0aGlzLkNhcm91c2VsLlBhbnpvb20uYXR0YWNoRXZlbnRzKCksIHRoaXMuc3RhdGUgPSBcInZpc2libGVcIik7XG4gICAgICB9XG5cbiAgICAgIGhpZGUoKSB7XG4gICAgICAgIFwidmlzaWJsZVwiID09PSB0aGlzLnN0YXRlICYmICh0aGlzLkNhcm91c2VsLlBhbnpvb20uZGV0YWNoRXZlbnRzKCksIHRoaXMuJGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIHRoaXMuc3RhdGUgPSBcImhpZGRlblwiKTtcbiAgICAgIH1cblxuICAgICAgY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5DYXJvdXNlbCAmJiAodGhpcy5DYXJvdXNlbC5kZXN0cm95KCksIHRoaXMuQ2Fyb3VzZWwgPSBudWxsKSwgdGhpcy4kY29udGFpbmVyICYmICh0aGlzLiRjb250YWluZXIucmVtb3ZlKCksIHRoaXMuJGNvbnRhaW5lciA9IG51bGwpLCB0aGlzLnN0YXRlID0gXCJpbml0XCI7XG4gICAgICB9XG5cbiAgICAgIGF0dGFjaCgpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveC5vbih0aGlzLmV2ZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveC5vZmYodGhpcy5ldmVudHMpLCB0aGlzLmNsZWFudXAoKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIEMuZGVmYXVsdHMgPSAkJDE7XG5cbiAgICBjb25zdCBTID0gKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBuZXcgVVJMKHQpLFxuICAgICAgICAgICAgcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoaS5zZWFyY2gpO1xuICAgICAgbGV0IG8gPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG5cbiAgICAgIGZvciAoY29uc3QgW3QsIGldIG9mIFsuLi5zLCAuLi5PYmplY3QuZW50cmllcyhlKV0pIFwidFwiID09PSB0ID8gby5zZXQoXCJzdGFydFwiLCBwYXJzZUludChpKSkgOiBvLnNldCh0LCBpKTtcblxuICAgICAgbyA9IG8udG9TdHJpbmcoKTtcbiAgICAgIGxldCBuID0gdC5tYXRjaCgvI3Q9KCguKik/XFxkK3MpLyk7XG4gICAgICByZXR1cm4gbiAmJiAobyArPSBgI3Q9JHtuWzFdfWApLCBvO1xuICAgIH0sXG4gICAgICAgICAgRSA9IHtcbiAgICAgIHZpZGVvOiB7XG4gICAgICAgIGF1dG9wbGF5OiAhMCxcbiAgICAgICAgcmF0aW86IDE2IC8gOVxuICAgICAgfSxcbiAgICAgIHlvdXR1YmU6IHtcbiAgICAgICAgYXV0b2hpZGU6IDEsXG4gICAgICAgIGZzOiAxLFxuICAgICAgICByZWw6IDAsXG4gICAgICAgIGhkOiAxLFxuICAgICAgICB3bW9kZTogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBlbmFibGVqc2FwaTogMSxcbiAgICAgICAgaHRtbDU6IDFcbiAgICAgIH0sXG4gICAgICB2aW1lbzoge1xuICAgICAgICBoZDogMSxcbiAgICAgICAgc2hvd190aXRsZTogMSxcbiAgICAgICAgc2hvd19ieWxpbmU6IDEsXG4gICAgICAgIHNob3dfcG9ydHJhaXQ6IDAsXG4gICAgICAgIGZ1bGxzY3JlZW46IDFcbiAgICAgIH0sXG4gICAgICBodG1sNXZpZGVvOiB7XG4gICAgICAgIHRwbDogJzx2aWRlbyBjbGFzcz1cImZhbmN5Ym94X19odG1sNXZpZGVvXCIgcGxheXNpbmxpbmUgY29udHJvbHMgY29udHJvbHNMaXN0PVwibm9kb3dubG9hZFwiIHBvc3Rlcj1cInt7cG9zdGVyfX1cIj5cXG4gIDxzb3VyY2Ugc3JjPVwie3tzcmN9fVwiIHR5cGU9XCJ7e2Zvcm1hdH19XCIgLz5Tb3JyeSwgeW91ciBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IGVtYmVkZGVkIHZpZGVvcy48L3ZpZGVvPicsXG4gICAgICAgIGZvcm1hdDogXCJcIlxuICAgICAgfVxuICAgIH07XG5cbiAgICBjbGFzcyBQIHtcbiAgICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveCA9IHQ7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIFtcIm9uSW5pdFwiLCBcIm9uUmVhZHlcIiwgXCJvbkNyZWF0ZVNsaWRlXCIsIFwib25SZW1vdmVTbGlkZVwiLCBcIm9uU2VsZWN0U2xpZGVcIiwgXCJvblVuc2VsZWN0U2xpZGVcIiwgXCJvblJlZnJlc2hcIiwgXCJvbk1lc3NhZ2VcIl0pIHRoaXNbdF0gPSB0aGlzW3RdLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICAgaW5pdDogdGhpcy5vbkluaXQsXG4gICAgICAgICAgcmVhZHk6IHRoaXMub25SZWFkeSxcbiAgICAgICAgICBcIkNhcm91c2VsLmNyZWF0ZVNsaWRlXCI6IHRoaXMub25DcmVhdGVTbGlkZSxcbiAgICAgICAgICBcIkNhcm91c2VsLnJlbW92ZVNsaWRlXCI6IHRoaXMub25SZW1vdmVTbGlkZSxcbiAgICAgICAgICBcIkNhcm91c2VsLnNlbGVjdFNsaWRlXCI6IHRoaXMub25TZWxlY3RTbGlkZSxcbiAgICAgICAgICBcIkNhcm91c2VsLnVuc2VsZWN0U2xpZGVcIjogdGhpcy5vblVuc2VsZWN0U2xpZGUsXG4gICAgICAgICAgXCJDYXJvdXNlbC5yZWZyZXNoXCI6IHRoaXMub25SZWZyZXNoXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9uSW5pdCgpIHtcbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRoaXMuZmFuY3lib3guaXRlbXMpIHRoaXMucHJvY2Vzc1R5cGUodCk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3NUeXBlKHQpIHtcbiAgICAgICAgaWYgKHQuaHRtbCkgcmV0dXJuIHQuc3JjID0gdC5odG1sLCB0LnR5cGUgPSBcImh0bWxcIiwgdm9pZCBkZWxldGUgdC5odG1sO1xuICAgICAgICBjb25zdCBpID0gdC5zcmMgfHwgXCJcIjtcbiAgICAgICAgbGV0IHMgPSB0LnR5cGUgfHwgdGhpcy5mYW5jeWJveC5vcHRpb25zLnR5cGUsXG4gICAgICAgICAgICBvID0gbnVsbDtcblxuICAgICAgICBpZiAoIWkgfHwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgaSkge1xuICAgICAgICAgIGlmIChvID0gaS5tYXRjaCgvKD86eW91dHViZVxcLmNvbXx5b3V0dVxcLmJlfHlvdXR1YmVcXC1ub2Nvb2tpZVxcLmNvbSlcXC8oPzp3YXRjaFxcPyg/Oi4qJik/dj18dlxcL3x1XFwvfGVtYmVkXFwvPyk/KHZpZGVvc2VyaWVzXFw/bGlzdD0oPzouKil8W1xcdy1dezExfXxcXD9saXN0VHlwZT0oPzouKikmbGlzdD0oPzouKikpKD86LiopL2kpKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gUyhpLCB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkh0bWwueW91dHViZVwiKSksXG4gICAgICAgICAgICAgICAgICBuID0gZW5jb2RlVVJJQ29tcG9uZW50KG9bMV0pO1xuICAgICAgICAgICAgdC52aWRlb0lkID0gbiwgdC5zcmMgPSBgaHR0cHM6Ly93d3cueW91dHViZS1ub2Nvb2tpZS5jb20vZW1iZWQvJHtufT8ke2V9YCwgdC50aHVtYiA9IHQudGh1bWIgfHwgYGh0dHBzOi8vaS55dGltZy5jb20vdmkvJHtufS9tcWRlZmF1bHQuanBnYCwgdC52ZW5kb3IgPSBcInlvdXR1YmVcIiwgcyA9IFwidmlkZW9cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG8gPSBpLm1hdGNoKC9eLit2aW1lby5jb21cXC8oPzpcXC8pPyhbXFxkXSspKC4qKT8vKSkge1xuICAgICAgICAgICAgY29uc3QgZSA9IFMoaSwgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJIdG1sLnZpbWVvXCIpKSxcbiAgICAgICAgICAgICAgICAgIG4gPSBlbmNvZGVVUklDb21wb25lbnQob1sxXSk7XG4gICAgICAgICAgICB0LnZpZGVvSWQgPSBuLCB0LnNyYyA9IGBodHRwczovL3BsYXllci52aW1lby5jb20vdmlkZW8vJHtufT8ke2V9YCwgdC52ZW5kb3IgPSBcInZpbWVvXCIsIHMgPSBcInZpZGVvXCI7XG4gICAgICAgICAgfSBlbHNlIChvID0gaS5tYXRjaCgvKD86bWFwc1xcLik/Z29vZ2xlXFwuKFthLXpdezIsM30oPzpcXC5bYS16XXsyfSk/KVxcLyg/Oig/Oig/Om1hcHNcXC8oPzpwbGFjZVxcLyg/Oi4qKVxcLyk/XFxAKC4qKSwoXFxkKy4/XFxkKz8peikpfCg/OlxcP2xsPSkpKC4qKT8vaSkpID8gKHQuc3JjID0gYC8vbWFwcy5nb29nbGUuJHtvWzFdfS8/bGw9JHsob1syXSA/IG9bMl0gKyBcIiZ6PVwiICsgTWF0aC5mbG9vcihvWzNdKSArIChvWzRdID8gb1s0XS5yZXBsYWNlKC9eXFwvLywgXCImXCIpIDogXCJcIikgOiBvWzRdICsgXCJcIikucmVwbGFjZSgvXFw/LywgXCImXCIpfSZvdXRwdXQ9JHtvWzRdICYmIG9bNF0uaW5kZXhPZihcImxheWVyPWNcIikgPiAwID8gXCJzdmVtYmVkXCIgOiBcImVtYmVkXCJ9YCwgcyA9IFwibWFwXCIpIDogKG8gPSBpLm1hdGNoKC8oPzptYXBzXFwuKT9nb29nbGVcXC4oW2Etel17MiwzfSg/OlxcLlthLXpdezJ9KT8pXFwvKD86bWFwc1xcL3NlYXJjaFxcLykoLiopL2kpKSAmJiAodC5zcmMgPSBgLy9tYXBzLmdvb2dsZS4ke29bMV19L21hcHM/cT0ke29bMl0ucmVwbGFjZShcInF1ZXJ5PVwiLCBcInE9XCIpLnJlcGxhY2UoXCJhcGk9MVwiLCBcIlwiKX0mb3V0cHV0PWVtYmVkYCwgcyA9IFwibWFwXCIpO1xuXG4gICAgICAgICAgcyB8fCAoXCIjXCIgPT09IGkuY2hhckF0KDApID8gcyA9IFwiaW5saW5lXCIgOiAobyA9IGkubWF0Y2goL1xcLihtcDR8bW92fG9ndnx3ZWJtKSgoXFw/fCMpLiopPyQvaSkpID8gKHMgPSBcImh0bWw1dmlkZW9cIiwgdC5mb3JtYXQgPSB0LmZvcm1hdCB8fCBcInZpZGVvL1wiICsgKFwib2d2XCIgPT09IG9bMV0gPyBcIm9nZ1wiIDogb1sxXSkpIDogaS5tYXRjaCgvKF5kYXRhOmltYWdlXFwvW2EtejAtOStcXC89XSosKXwoXFwuKGpwKGV8Z3xlZyl8Z2lmfHBuZ3xibXB8d2VicHxzdmd8aWNvKSgoXFw/fCMpLiopPyQpL2kpID8gcyA9IFwiaW1hZ2VcIiA6IGkubWF0Y2goL1xcLihwZGYpKChcXD98IykuKik/JC9pKSAmJiAocyA9IFwicGRmXCIpKSwgdC50eXBlID0gcyB8fCB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcImRlZmF1bHRUeXBlXCIsIFwiaW1hZ2VcIiksIFwiaHRtbDV2aWRlb1wiICE9PSBzICYmIFwidmlkZW9cIiAhPT0gcyB8fCAodC52aWRlbyA9IGUoe30sIHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSHRtbC52aWRlb1wiKSwgdC52aWRlbyksIHQuX3dpZHRoICYmIHQuX2hlaWdodCA/IHQucmF0aW8gPSBwYXJzZUZsb2F0KHQuX3dpZHRoKSAvIHBhcnNlRmxvYXQodC5faGVpZ2h0KSA6IHQucmF0aW8gPSB0LnJhdGlvIHx8IHQudmlkZW8ucmF0aW8gfHwgRS52aWRlby5yYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25SZWFkeSgpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveC5DYXJvdXNlbC5zbGlkZXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICB0LiRlbCAmJiAodGhpcy5zZXRDb250ZW50KHQpLCB0LmluZGV4ID09PSB0aGlzLmZhbmN5Ym94LmdldFNsaWRlKCkuaW5kZXggJiYgdGhpcy5wbGF5VmlkZW8odCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgb25DcmVhdGVTbGlkZSh0LCBlLCBpKSB7XG4gICAgICAgIFwicmVhZHlcIiA9PT0gdGhpcy5mYW5jeWJveC5zdGF0ZSAmJiB0aGlzLnNldENvbnRlbnQoaSk7XG4gICAgICB9XG5cbiAgICAgIGxvYWRJbmxpbmVDb250ZW50KHQpIHtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGlmICh0LnNyYyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSBlID0gdC5zcmM7ZWxzZSBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdC5zcmMpIHtcbiAgICAgICAgICBjb25zdCBpID0gdC5zcmMuc3BsaXQoXCIjXCIsIDIpLFxuICAgICAgICAgICAgICAgIHMgPSAyID09PSBpLmxlbmd0aCAmJiBcIlwiID09PSBpWzBdID8gaVsxXSA6IGlbMF07XG4gICAgICAgICAgZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBpZiAoXCJjbG9uZVwiID09PSB0LnR5cGUgfHwgZS4kcGxhY2VIb2xkZXIpIHtcbiAgICAgICAgICAgIGUgPSBlLmNsb25lTm9kZSghMCk7XG4gICAgICAgICAgICBsZXQgaSA9IGUuZ2V0QXR0cmlidXRlKFwiaWRcIik7XG4gICAgICAgICAgICBpID0gaSA/IGAke2l9LS1jbG9uZWAgOiBgY2xvbmUtJHt0aGlzLmZhbmN5Ym94LmlkfS0ke3QuaW5kZXh9YCwgZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0LmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveC1wbGFjZWhvbGRlclwiKSwgZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LCBlKSwgZS4kcGxhY2VIb2xkZXIgPSB0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZmFuY3lib3guc2V0Q29udGVudCh0LCBlKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuZmFuY3lib3guc2V0RXJyb3IodCwgXCJ7e0VMRU1FTlRfTk9UX0ZPVU5EfX1cIik7XG4gICAgICB9XG5cbiAgICAgIGxvYWRBamF4Q29udGVudCh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmZhbmN5Ym94LFxuICAgICAgICAgICAgICBpID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGUuc2hvd0xvYWRpbmcodCksIGkub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGkucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSAmJiBcInJlYWR5XCIgPT09IGUuc3RhdGUgJiYgKGUuaGlkZUxvYWRpbmcodCksIDIwMCA9PT0gaS5zdGF0dXMgPyBlLnNldENvbnRlbnQodCwgaS5yZXNwb25zZVRleHQpIDogZS5zZXRFcnJvcih0LCA0MDQgPT09IGkuc3RhdHVzID8gXCJ7e0FKQVhfTk9UX0ZPVU5EfX1cIiA6IFwie3tBSkFYX0ZPUkJJRERFTn19XCIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcyA9IHQuYWpheCB8fCBudWxsO1xuICAgICAgICBpLm9wZW4ocyA/IFwiUE9TVFwiIDogXCJHRVRcIiwgdC5zcmMpLCBpLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiksIGkuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKSwgaS5zZW5kKHMpLCB0LnhociA9IGk7XG4gICAgICB9XG5cbiAgICAgIGxvYWRJZnJhbWVDb250ZW50KHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZmFuY3lib3gsXG4gICAgICAgICAgICAgIGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBpZiAoaS5jbGFzc05hbWUgPSBcImZhbmN5Ym94X19pZnJhbWVcIiwgaS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgZmFuY3lib3hfX2lmcmFtZV8ke2UuaWR9XyR7dC5pbmRleH1gKSwgaS5zZXRBdHRyaWJ1dGUoXCJhbGxvd1wiLCBcImF1dG9wbGF5OyBmdWxsc2NyZWVuXCIpLCBpLnNldEF0dHJpYnV0ZShcInNjcm9sbGluZ1wiLCBcImF1dG9cIiksIHQuJGlmcmFtZSA9IGksIFwiaWZyYW1lXCIgIT09IHQudHlwZSB8fCAhMSA9PT0gdC5wcmVsb2FkKSByZXR1cm4gaS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdC5zcmMpLCB0aGlzLmZhbmN5Ym94LnNldENvbnRlbnQodCwgaSksIHZvaWQgdGhpcy5yZXNpemVJZnJhbWUodCk7XG4gICAgICAgIGUuc2hvd0xvYWRpbmcodCk7XG4gICAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiLCB0aGlzLmZhbmN5Ym94LnNldENvbnRlbnQodCwgcyksIHMuYXBwZW5kQ2hpbGQoaSksIGkub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBlLnNldEVycm9yKHQsIFwie3tJRlJBTUVfRVJST1J9fVwiKTtcbiAgICAgICAgfSwgaS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgZS5oaWRlTG9hZGluZyh0KTtcbiAgICAgICAgICBsZXQgcyA9ICExO1xuICAgICAgICAgIGkuaXNSZWFkeSB8fCAoaS5pc1JlYWR5ID0gITAsIHMgPSAhMCksIGkuc3JjLmxlbmd0aCAmJiAoaS5wYXJlbnROb2RlLnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiLCB0aGlzLnJlc2l6ZUlmcmFtZSh0KSwgcyAmJiBlLnJldmVhbENvbnRlbnQodCkpO1xuICAgICAgICB9LCBpLnNldEF0dHJpYnV0ZShcInNyY1wiLCB0LnNyYyk7XG4gICAgICB9XG5cbiAgICAgIHNldEFzcGVjdFJhdGlvKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHQuJGNvbnRlbnQsXG4gICAgICAgICAgICAgIGkgPSB0LnJhdGlvO1xuICAgICAgICBpZiAoIWUpIHJldHVybjtcbiAgICAgICAgbGV0IHMgPSB0Ll93aWR0aCxcbiAgICAgICAgICAgIG8gPSB0Ll9oZWlnaHQ7XG5cbiAgICAgICAgaWYgKGkgfHwgcyAmJiBvKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihlLnN0eWxlLCB7XG4gICAgICAgICAgICB3aWR0aDogcyAmJiBvID8gXCIxMDAlXCIgOiBcIlwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBzICYmIG8gPyBcIjEwMCVcIiA6IFwiXCIsXG4gICAgICAgICAgICBtYXhXaWR0aDogXCJcIixcbiAgICAgICAgICAgIG1heEhlaWdodDogXCJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCB0ID0gZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgbiA9IGUub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKHMgPSBzIHx8IHQsIG8gPSBvIHx8IG4sIHMgPiB0IHx8IG8gPiBuKSB7XG4gICAgICAgICAgICBsZXQgZSA9IE1hdGgubWluKHQgLyBzLCBuIC8gbyk7XG4gICAgICAgICAgICBzICo9IGUsIG8gKj0gZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBNYXRoLmFicyhzIC8gbyAtIGkpID4gLjAxICYmIChpIDwgcyAvIG8gPyBzID0gbyAqIGkgOiBvID0gcyAvIGkpLCBPYmplY3QuYXNzaWduKGUuc3R5bGUsIHtcbiAgICAgICAgICAgIHdpZHRoOiBgJHtzfXB4YCxcbiAgICAgICAgICAgIGhlaWdodDogYCR7b31weGBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNpemVJZnJhbWUodCkge1xuICAgICAgICBjb25zdCBlID0gdC4kaWZyYW1lO1xuICAgICAgICBpZiAoIWUpIHJldHVybjtcbiAgICAgICAgbGV0IGkgPSB0Ll93aWR0aCB8fCAwLFxuICAgICAgICAgICAgcyA9IHQuX2hlaWdodCB8fCAwO1xuICAgICAgICBpICYmIHMgJiYgKHQuYXV0b1NpemUgPSAhMSk7XG4gICAgICAgIGNvbnN0IG8gPSBlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgIG4gPSBvICYmIG8uc3R5bGU7XG4gICAgICAgIGlmICghMSAhPT0gdC5wcmVsb2FkICYmICExICE9PSB0LmF1dG9TaXplICYmIG4pIHRyeSB7XG4gICAgICAgICAgY29uc3QgdCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG8pLFxuICAgICAgICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KHQucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdCh0LnBhZGRpbmdSaWdodCksXG4gICAgICAgICAgICAgICAgciA9IHBhcnNlRmxvYXQodC5wYWRkaW5nVG9wKSArIHBhcnNlRmxvYXQodC5wYWRkaW5nQm90dG9tKSxcbiAgICAgICAgICAgICAgICBoID0gZS5jb250ZW50V2luZG93LmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGwgPSBoLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaHRtbFwiKVswXSxcbiAgICAgICAgICAgICAgICBjID0gaC5ib2R5O1xuICAgICAgICAgIG4ud2lkdGggPSBcIlwiLCBjLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIiwgaSA9IGkgfHwgbC5zY3JvbGxXaWR0aCArIGEsIG4ud2lkdGggPSBgJHtpfXB4YCwgYy5zdHlsZS5vdmVyZmxvdyA9IFwiXCIsIG4uZmxleCA9IFwiMCAwIGF1dG9cIiwgbi5oZWlnaHQgPSBgJHtjLnNjcm9sbEhlaWdodH1weGAsIHMgPSBsLnNjcm9sbEhlaWdodCArIHI7XG4gICAgICAgIH0gY2F0Y2ggKHQpIHt9XG5cbiAgICAgICAgaWYgKGkgfHwgcykge1xuICAgICAgICAgIGNvbnN0IHQgPSB7XG4gICAgICAgICAgICBmbGV4OiBcIjAgMSBhdXRvXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGkgJiYgKHQud2lkdGggPSBgJHtpfXB4YCksIHMgJiYgKHQuaGVpZ2h0ID0gYCR7c31weGApLCBPYmplY3QuYXNzaWduKG4sIHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uUmVmcmVzaCh0LCBlKSB7XG4gICAgICAgIGUuc2xpZGVzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgdC4kZWwgJiYgKHQuJGlmcmFtZSAmJiB0aGlzLnJlc2l6ZUlmcmFtZSh0KSwgdC5yYXRpbyAmJiB0aGlzLnNldEFzcGVjdFJhdGlvKHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNldENvbnRlbnQodCkge1xuICAgICAgICBpZiAodCAmJiAhdC5pc0RvbSkge1xuICAgICAgICAgIHN3aXRjaCAodC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgICAgICB0aGlzLmZhbmN5Ym94LnNldENvbnRlbnQodCwgdC5zcmMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImh0bWw1dmlkZW9cIjpcbiAgICAgICAgICAgICAgdGhpcy5mYW5jeWJveC5zZXRDb250ZW50KHQsIHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSHRtbC5odG1sNXZpZGVvLnRwbFwiKS5yZXBsYWNlKC9cXHtcXHtzcmNcXH1cXH0vZ2ksIHQuc3JjKS5yZXBsYWNlKFwie3tmb3JtYXR9fVwiLCB0LmZvcm1hdCB8fCB0Lmh0bWw1dmlkZW8gJiYgdC5odG1sNXZpZGVvLmZvcm1hdCB8fCBcIlwiKS5yZXBsYWNlKFwie3twb3N0ZXJ9fVwiLCB0LnBvc3RlciB8fCB0LnRodW1iIHx8IFwiXCIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjbG9uZVwiOlxuICAgICAgICAgICAgICB0aGlzLmxvYWRJbmxpbmVDb250ZW50KHQpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImFqYXhcIjpcbiAgICAgICAgICAgICAgdGhpcy5sb2FkQWpheENvbnRlbnQodCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwicGRmXCI6XG4gICAgICAgICAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgdC5wcmVsb2FkID0gITE7XG5cbiAgICAgICAgICAgIGNhc2UgXCJpZnJhbWVcIjpcbiAgICAgICAgICAgICAgdGhpcy5sb2FkSWZyYW1lQ29udGVudCh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0LnJhdGlvICYmIHRoaXMuc2V0QXNwZWN0UmF0aW8odCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25TZWxlY3RTbGlkZSh0LCBlLCBpKSB7XG4gICAgICAgIFwicmVhZHlcIiA9PT0gdC5zdGF0ZSAmJiB0aGlzLnBsYXlWaWRlbyhpKTtcbiAgICAgIH1cblxuICAgICAgcGxheVZpZGVvKHQpIHtcbiAgICAgICAgaWYgKFwiaHRtbDV2aWRlb1wiID09PSB0LnR5cGUgJiYgdC52aWRlby5hdXRvcGxheSkgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlID0gdC4kZWwucXVlcnlTZWxlY3RvcihcInZpZGVvXCIpO1xuXG4gICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBlLnBsYXkoKTtcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdCAmJiB0LnRoZW4oKCkgPT4ge30pLmNhdGNoKHQgPT4ge1xuICAgICAgICAgICAgICBlLm11dGVkID0gITAsIGUucGxheSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh0KSB7fVxuICAgICAgICBpZiAoXCJ2aWRlb1wiICE9PSB0LnR5cGUgfHwgIXQuJGlmcmFtZSB8fCAhdC4kaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHJldHVybjtcblxuICAgICAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChcImRvbmVcIiA9PT0gdC5zdGF0ZSAmJiB0LiRpZnJhbWUgJiYgdC4kaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGxldCBlO1xuICAgICAgICAgICAgaWYgKHQuJGlmcmFtZS5pc1JlYWR5KSByZXR1cm4gdC52aWRlbyAmJiB0LnZpZGVvLmF1dG9wbGF5ICYmIChlID0gXCJ5b3V0dWJlXCIgPT0gdC52ZW5kb3IgPyB7XG4gICAgICAgICAgICAgIGV2ZW50OiBcImNvbW1hbmRcIixcbiAgICAgICAgICAgICAgZnVuYzogXCJwbGF5VmlkZW9cIlxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcInBsYXlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IFwidHJ1ZVwiXG4gICAgICAgICAgICB9KSwgdm9pZCAoZSAmJiB0LiRpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShlKSwgXCIqXCIpKTtcbiAgICAgICAgICAgIFwieW91dHViZVwiID09PSB0LnZlbmRvciAmJiAoZSA9IHtcbiAgICAgICAgICAgICAgZXZlbnQ6IFwibGlzdGVuaW5nXCIsXG4gICAgICAgICAgICAgIGlkOiB0LiRpZnJhbWUuZ2V0QXR0cmlidXRlKFwiaWRcIilcbiAgICAgICAgICAgIH0sIHQuJGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KGUpLCBcIipcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHQucG9sbGVyID0gc2V0VGltZW91dChlLCAyNTApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGUoKTtcbiAgICAgIH1cblxuICAgICAgb25VbnNlbGVjdFNsaWRlKHQsIGUsIGkpIHtcbiAgICAgICAgaWYgKFwiaHRtbDV2aWRlb1wiID09PSBpLnR5cGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaS4kZWwucXVlcnlTZWxlY3RvcihcInZpZGVvXCIpLnBhdXNlKCk7XG4gICAgICAgICAgfSBjYXRjaCAodCkge31cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzID0gITE7XG4gICAgICAgIFwidmltZW9cIiA9PSBpLnZlbmRvciA/IHMgPSB7XG4gICAgICAgICAgbWV0aG9kOiBcInBhdXNlXCIsXG4gICAgICAgICAgdmFsdWU6IFwidHJ1ZVwiXG4gICAgICAgIH0gOiBcInlvdXR1YmVcIiA9PT0gaS52ZW5kb3IgJiYgKHMgPSB7XG4gICAgICAgICAgZXZlbnQ6IFwiY29tbWFuZFwiLFxuICAgICAgICAgIGZ1bmM6IFwicGF1c2VWaWRlb1wiXG4gICAgICAgIH0pLCBzICYmIGkuJGlmcmFtZSAmJiBpLiRpZnJhbWUuY29udGVudFdpbmRvdyAmJiBpLiRpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShzKSwgXCIqXCIpLCBjbGVhclRpbWVvdXQoaS5wb2xsZXIpO1xuICAgICAgfVxuXG4gICAgICBvblJlbW92ZVNsaWRlKHQsIGUsIGkpIHtcbiAgICAgICAgaS54aHIgJiYgKGkueGhyLmFib3J0KCksIGkueGhyID0gbnVsbCksIGkuJGlmcmFtZSAmJiAoaS4kaWZyYW1lLm9ubG9hZCA9IGkuJGlmcmFtZS5vbmVycm9yID0gbnVsbCwgaS4kaWZyYW1lLnNyYyA9IFwiLy9hYm91dDpibGFua1wiLCBpLiRpZnJhbWUgPSBudWxsKTtcbiAgICAgICAgY29uc3QgcyA9IGkuJGNvbnRlbnQ7XG4gICAgICAgIFwiaW5saW5lXCIgPT09IGkudHlwZSAmJiBzICYmIChzLmNsYXNzTGlzdC5yZW1vdmUoXCJmYW5jeWJveF9fY29udGVudFwiKSwgXCJub25lXCIgIT09IHMuc3R5bGUuZGlzcGxheSAmJiAocy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpKSwgaS4kY2xvc2VCdXR0b24gJiYgKGkuJGNsb3NlQnV0dG9uLnJlbW92ZSgpLCBpLiRjbG9zZUJ1dHRvbiA9IG51bGwpO1xuICAgICAgICBjb25zdCBvID0gcyAmJiBzLiRwbGFjZUhvbGRlcjtcbiAgICAgICAgbyAmJiAoby5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzLCBvKSwgby5yZW1vdmUoKSwgcy4kcGxhY2VIb2xkZXIgPSBudWxsKTtcbiAgICAgIH1cblxuICAgICAgb25NZXNzYWdlKHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgZSA9IEpTT04ucGFyc2UodC5kYXRhKTtcblxuICAgICAgICAgIGlmIChcImh0dHBzOi8vcGxheWVyLnZpbWVvLmNvbVwiID09PSB0Lm9yaWdpbikge1xuICAgICAgICAgICAgaWYgKFwicmVhZHlcIiA9PT0gZS5ldmVudCkgZm9yIChsZXQgZSBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZmFuY3lib3hfX2lmcmFtZVwiKSkgZS5jb250ZW50V2luZG93ID09PSB0LnNvdXJjZSAmJiAoZS5pc1JlYWR5ID0gMSk7XG4gICAgICAgICAgfSBlbHNlIFwiaHR0cHM6Ly93d3cueW91dHViZS1ub2Nvb2tpZS5jb21cIiA9PT0gdC5vcmlnaW4gJiYgXCJvblJlYWR5XCIgPT09IGUuZXZlbnQgJiYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUuaWQpLmlzUmVhZHkgPSAxKTtcbiAgICAgICAgfSBjYXRjaCAodCkge31cbiAgICAgIH1cblxuICAgICAgYXR0YWNoKCkge1xuICAgICAgICB0aGlzLmZhbmN5Ym94Lm9uKHRoaXMuZXZlbnRzKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMub25NZXNzYWdlLCAhMSk7XG4gICAgICB9XG5cbiAgICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveC5vZmYodGhpcy5ldmVudHMpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5vbk1lc3NhZ2UsICExKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIFAuZGVmYXVsdHMgPSBFO1xuXG4gICAgY2xhc3MgVCB7XG4gICAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3ggPSB0O1xuXG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBbXCJvblJlYWR5XCIsIFwib25DbG9zaW5nXCIsIFwib25Eb25lXCIsIFwib25QYWdlQ2hhbmdlXCIsIFwib25DcmVhdGVTbGlkZVwiLCBcIm9uUmVtb3ZlU2xpZGVcIiwgXCJvbkltYWdlU3RhdHVzQ2hhbmdlXCJdKSB0aGlzW3RdID0gdGhpc1t0XS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgICAgIHJlYWR5OiB0aGlzLm9uUmVhZHksXG4gICAgICAgICAgY2xvc2luZzogdGhpcy5vbkNsb3NpbmcsXG4gICAgICAgICAgZG9uZTogdGhpcy5vbkRvbmUsXG4gICAgICAgICAgXCJDYXJvdXNlbC5jaGFuZ2VcIjogdGhpcy5vblBhZ2VDaGFuZ2UsXG4gICAgICAgICAgXCJDYXJvdXNlbC5jcmVhdGVTbGlkZVwiOiB0aGlzLm9uQ3JlYXRlU2xpZGUsXG4gICAgICAgICAgXCJDYXJvdXNlbC5yZW1vdmVTbGlkZVwiOiB0aGlzLm9uUmVtb3ZlU2xpZGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb25SZWFkeSgpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveC5DYXJvdXNlbC5zbGlkZXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICB0LiRlbCAmJiB0aGlzLnNldENvbnRlbnQodCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBvbkRvbmUodCwgZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUN1cnNvcihlKTtcbiAgICAgIH1cblxuICAgICAgb25DbG9zaW5nKHQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xpY2tUaW1lciksIHRoaXMuY2xpY2tUaW1lciA9IG51bGwsIHQuQ2Fyb3VzZWwuc2xpZGVzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgdC4kaW1hZ2UgJiYgKHQuc3RhdGUgPSBcImRlc3Ryb3lcIiksIHQuUGFuem9vbSAmJiB0LlBhbnpvb20uZGV0YWNoRXZlbnRzKCk7XG4gICAgICAgIH0pLCBcImNsb3NpbmdcIiA9PT0gdGhpcy5mYW5jeWJveC5zdGF0ZSAmJiB0aGlzLmNhblpvb20odC5nZXRTbGlkZSgpKSAmJiB0aGlzLnpvb21PdXQoKTtcbiAgICAgIH1cblxuICAgICAgb25DcmVhdGVTbGlkZSh0LCBlLCBpKSB7XG4gICAgICAgIFwicmVhZHlcIiA9PT0gdGhpcy5mYW5jeWJveC5zdGF0ZSAmJiB0aGlzLnNldENvbnRlbnQoaSk7XG4gICAgICB9XG5cbiAgICAgIG9uUmVtb3ZlU2xpZGUodCwgZSwgaSkge1xuICAgICAgICBpLiRpbWFnZSAmJiAoaS4kZWwuY2xhc3NMaXN0LnJlbW92ZSh0Lm9wdGlvbihcIkltYWdlLmNhblpvb21JbkNsYXNzXCIpKSwgaS4kaW1hZ2UucmVtb3ZlKCksIGkuJGltYWdlID0gbnVsbCksIGkuUGFuem9vbSAmJiAoaS5QYW56b29tLmRlc3Ryb3koKSwgaS5QYW56b29tID0gbnVsbCksIGkuJGVsICYmIGkuJGVsLmRhdGFzZXQgJiYgZGVsZXRlIGkuJGVsLmRhdGFzZXQuaW1hZ2VGaXQ7XG4gICAgICB9XG5cbiAgICAgIHNldENvbnRlbnQodCkge1xuICAgICAgICBpZiAodC5pc0RvbSB8fCB0Lmh0bWwgfHwgdC50eXBlICYmIFwiaW1hZ2VcIiAhPT0gdC50eXBlKSByZXR1cm47XG4gICAgICAgIGlmICh0LiRpbWFnZSkgcmV0dXJuO1xuICAgICAgICB0LnR5cGUgPSBcImltYWdlXCIsIHQuc3RhdGUgPSBcImxvYWRpbmdcIjtcbiAgICAgICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBpLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGUgPT4ge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIHRoaXMub25JbWFnZVN0YXR1c0NoYW5nZSh0KTtcbiAgICAgICAgfSksIGkuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9uSW1hZ2VTdGF0dXNDaGFuZ2UodCk7XG4gICAgICAgIH0pLCBpLnNyYyA9IHQuc3JjLCBpLmFsdCA9IFwiXCIsIGkuZHJhZ2dhYmxlID0gITEsIGkuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X19pbWFnZVwiKSwgdC5zcmNzZXQgJiYgaS5zZXRBdHRyaWJ1dGUoXCJzcmNzZXRcIiwgdC5zcmNzZXQpLCB0LnNpemVzICYmIGkuc2V0QXR0cmlidXRlKFwic2l6ZXNcIiwgdC5zaXplcyksIHQuJGltYWdlID0gaTtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2Uud3JhcFwiKTtcblxuICAgICAgICBpZiAocykge1xuICAgICAgICAgIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIG8uY2xhc3NMaXN0LmFkZChcInN0cmluZ1wiID09IHR5cGVvZiBzID8gcyA6IFwiZmFuY3lib3hfX2ltYWdlLXdyYXBcIiksIG8uYXBwZW5kQ2hpbGQoaSksIGUuYXBwZW5kQ2hpbGQobyksIHQuJHdyYXAgPSBvO1xuICAgICAgICB9IGVsc2UgZS5hcHBlbmRDaGlsZChpKTtcblxuICAgICAgICB0LiRlbC5kYXRhc2V0LmltYWdlRml0ID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS5maXRcIiksIHRoaXMuZmFuY3lib3guc2V0Q29udGVudCh0LCBlKSwgaS5jb21wbGV0ZSB8fCBpLmVycm9yID8gdGhpcy5vbkltYWdlU3RhdHVzQ2hhbmdlKHQpIDogdGhpcy5mYW5jeWJveC5zaG93TG9hZGluZyh0KTtcbiAgICAgIH1cblxuICAgICAgb25JbWFnZVN0YXR1c0NoYW5nZSh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0LiRpbWFnZTtcbiAgICAgICAgZSAmJiBcImxvYWRpbmdcIiA9PT0gdC5zdGF0ZSAmJiAoZS5jb21wbGV0ZSAmJiBlLm5hdHVyYWxXaWR0aCAmJiBlLm5hdHVyYWxIZWlnaHQgPyAodGhpcy5mYW5jeWJveC5oaWRlTG9hZGluZyh0KSwgXCJjb250YWluXCIgPT09IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UuZml0XCIpICYmIHRoaXMuaW5pdFNsaWRlUGFuem9vbSh0KSwgdC4kZWwuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGUgPT4gdGhpcy5vbldoZWVsKHQsIGUpLCB7XG4gICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgfSksIHQuJGNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4gdGhpcy5vbkNsaWNrKHQsIGUpLCB7XG4gICAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgICAgfSksIHRoaXMucmV2ZWFsQ29udGVudCh0KSkgOiB0aGlzLmZhbmN5Ym94LnNldEVycm9yKHQsIFwie3tJTUFHRV9FUlJPUn19XCIpKTtcbiAgICAgIH1cblxuICAgICAgaW5pdFNsaWRlUGFuem9vbSh0KSB7XG4gICAgICAgIHQuUGFuem9vbSB8fCAodC5QYW56b29tID0gbmV3IGQodC4kZWwsIGUoITAsIHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UuUGFuem9vbVwiLCB7fSksIHtcbiAgICAgICAgICB2aWV3cG9ydDogdC4kd3JhcCxcbiAgICAgICAgICBjb250ZW50OiB0LiRpbWFnZSxcbiAgICAgICAgICB3aWR0aDogdC5fd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0Ll9oZWlnaHQsXG4gICAgICAgICAgd3JhcElubmVyOiAhMSxcbiAgICAgICAgICB0ZXh0U2VsZWN0aW9uOiAhMCxcbiAgICAgICAgICB0b3VjaDogdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS50b3VjaFwiKSxcbiAgICAgICAgICBwYW5Pbmx5Wm9vbWVkOiAhMCxcbiAgICAgICAgICBjbGljazogITEsXG4gICAgICAgICAgd2hlZWw6ICExXG4gICAgICAgIH0pKSwgdC5QYW56b29tLm9uKFwic3RhcnRBbmltYXRpb25cIiwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZmFuY3lib3gudHJpZ2dlcihcIkltYWdlLnN0YXJ0QW5pbWF0aW9uXCIsIHQpO1xuICAgICAgICB9KSwgdC5QYW56b29tLm9uKFwiZW5kQW5pbWF0aW9uXCIsICgpID0+IHtcbiAgICAgICAgICBcInpvb21JblwiID09PSB0LnN0YXRlICYmIHRoaXMuZmFuY3lib3guZG9uZSh0KSwgdGhpcy5oYW5kbGVDdXJzb3IodCksIHRoaXMuZmFuY3lib3gudHJpZ2dlcihcIkltYWdlLmVuZEFuaW1hdGlvblwiLCB0KTtcbiAgICAgICAgfSksIHQuUGFuem9vbS5vbihcImFmdGVyVXBkYXRlXCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUN1cnNvcih0KSwgdGhpcy5mYW5jeWJveC50cmlnZ2VyKFwiSW1hZ2UuYWZ0ZXJVcGRhdGVcIiwgdCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV2ZWFsQ29udGVudCh0KSB7XG4gICAgICAgIG51bGwgPT09IHRoaXMuZmFuY3lib3guQ2Fyb3VzZWwucHJldlBhZ2UgJiYgdC5pbmRleCA9PT0gdGhpcy5mYW5jeWJveC5vcHRpb25zLnN0YXJ0SW5kZXggJiYgdGhpcy5jYW5ab29tKHQpID8gdGhpcy56b29tSW4oKSA6IHRoaXMuZmFuY3lib3gucmV2ZWFsQ29udGVudCh0KTtcbiAgICAgIH1cblxuICAgICAgZ2V0Wm9vbUluZm8odCkge1xuICAgICAgICBjb25zdCBlID0gdC4kdGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgIGkgPSBlLndpZHRoLFxuICAgICAgICAgICAgICBzID0gZS5oZWlnaHQsXG4gICAgICAgICAgICAgIG8gPSB0LiRjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICBuID0gby53aWR0aCxcbiAgICAgICAgICAgICAgYSA9IG8uaGVpZ2h0LFxuICAgICAgICAgICAgICByID0gby50b3AgLSBlLnRvcCxcbiAgICAgICAgICAgICAgaCA9IG8ubGVmdCAtIGUubGVmdDtcbiAgICAgICAgbGV0IGwgPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLnpvb21PcGFjaXR5XCIpO1xuICAgICAgICByZXR1cm4gXCJhdXRvXCIgPT09IGwgJiYgKGwgPSBNYXRoLmFicyhpIC8gcyAtIG4gLyBhKSA+IC4xKSwge1xuICAgICAgICAgIHRvcDogcixcbiAgICAgICAgICBsZWZ0OiBoLFxuICAgICAgICAgIHNjYWxlOiBuICYmIGkgPyBpIC8gbiA6IDEsXG4gICAgICAgICAgb3BhY2l0eTogbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjYW5ab29tKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZmFuY3lib3gsXG4gICAgICAgICAgICAgIGkgPSBlLiRjb250YWluZXI7XG4gICAgICAgIGlmICh3aW5kb3cudmlzdWFsVmlld3BvcnQgJiYgMSAhPT0gd2luZG93LnZpc3VhbFZpZXdwb3J0LnNjYWxlKSByZXR1cm4gITE7XG4gICAgICAgIGlmICh0LlBhbnpvb20gJiYgIXQuUGFuem9vbS5jb250ZW50LndpZHRoKSByZXR1cm4gITE7XG4gICAgICAgIGlmICghZS5vcHRpb24oXCJJbWFnZS56b29tXCIpIHx8IFwiY29udGFpblwiICE9PSBlLm9wdGlvbihcIkltYWdlLmZpdFwiKSkgcmV0dXJuICExO1xuICAgICAgICBjb25zdCBzID0gdC4kdGh1bWI7XG4gICAgICAgIGlmICghcyB8fCBcImxvYWRpbmdcIiA9PT0gdC5zdGF0ZSkgcmV0dXJuICExO1xuICAgICAgICBpLmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveF9fbm8tY2xpY2tcIik7XG4gICAgICAgIGNvbnN0IG8gPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgbjtcblxuICAgICAgICBpZiAodGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS5pZ25vcmVDb3ZlcmVkVGh1bWJuYWlsXCIpKSB7XG4gICAgICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoby5sZWZ0ICsgMSwgby50b3AgKyAxKSA9PT0gcyxcbiAgICAgICAgICAgICAgICBlID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChvLnJpZ2h0IC0gMSwgby5ib3R0b20gLSAxKSA9PT0gcztcbiAgICAgICAgICBuID0gdCAmJiBlO1xuICAgICAgICB9IGVsc2UgbiA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoby5sZWZ0ICsgLjUgKiBvLndpZHRoLCBvLnRvcCArIC41ICogby5oZWlnaHQpID09PSBzO1xuXG4gICAgICAgIHJldHVybiBpLmNsYXNzTGlzdC5yZW1vdmUoXCJmYW5jeWJveF9fbm8tY2xpY2tcIiksIG47XG4gICAgICB9XG5cbiAgICAgIHpvb21JbigpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuZmFuY3lib3gsXG4gICAgICAgICAgICAgIGUgPSB0LmdldFNsaWRlKCksXG4gICAgICAgICAgICAgIGkgPSBlLlBhbnpvb20sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICB0b3A6IHMsXG4gICAgICAgICAgbGVmdDogbyxcbiAgICAgICAgICBzY2FsZTogbixcbiAgICAgICAgICBvcGFjaXR5OiBhXG4gICAgICAgIH0gPSB0aGlzLmdldFpvb21JbmZvKGUpO1xuICAgICAgICB0LnRyaWdnZXIoXCJyZXZlYWxcIiwgZSksIGkucGFuVG8oe1xuICAgICAgICAgIHg6IC0xICogbyxcbiAgICAgICAgICB5OiAtMSAqIHMsXG4gICAgICAgICAgc2NhbGU6IG4sXG4gICAgICAgICAgZnJpY3Rpb246IDAsXG4gICAgICAgICAgaWdub3JlQm91bmRzOiAhMFxuICAgICAgICB9KSwgZS4kY29udGVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIiwgZS5zdGF0ZSA9IFwiem9vbUluXCIsICEwID09PSBhICYmIGkub24oXCJhZnRlclRyYW5zZm9ybVwiLCB0ID0+IHtcbiAgICAgICAgICBcInpvb21JblwiICE9PSBlLnN0YXRlICYmIFwiem9vbU91dFwiICE9PSBlLnN0YXRlIHx8ICh0LiRjb250ZW50LnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1pbigxLCAxIC0gKDEgLSB0LmNvbnRlbnQuc2NhbGUpIC8gKDEgLSBuKSkpO1xuICAgICAgICB9KSwgaS5wYW5Ubyh7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHNjYWxlOiAxLFxuICAgICAgICAgIGZyaWN0aW9uOiB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLnpvb21GcmljdGlvblwiKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgem9vbU91dCgpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuZmFuY3lib3gsXG4gICAgICAgICAgICAgIGUgPSB0LmdldFNsaWRlKCksXG4gICAgICAgICAgICAgIGkgPSBlLlBhbnpvb207XG4gICAgICAgIGlmICghaSkgcmV0dXJuO1xuICAgICAgICBlLnN0YXRlID0gXCJ6b29tT3V0XCIsIHQuc3RhdGUgPSBcImN1c3RvbUNsb3NpbmdcIiwgZS4kY2FwdGlvbiAmJiAoZS4kY2FwdGlvbi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIik7XG4gICAgICAgIGxldCBzID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS56b29tRnJpY3Rpb25cIik7XG5cbiAgICAgICAgY29uc3QgbyA9IHQgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRvcDogbyxcbiAgICAgICAgICAgIGxlZnQ6IG4sXG4gICAgICAgICAgICBzY2FsZTogYSxcbiAgICAgICAgICAgIG9wYWNpdHk6IHJcbiAgICAgICAgICB9ID0gdGhpcy5nZXRab29tSW5mbyhlKTtcbiAgICAgICAgICB0IHx8IHIgfHwgKHMgKj0gLjgyKSwgaS5wYW5Ubyh7XG4gICAgICAgICAgICB4OiAtMSAqIG4sXG4gICAgICAgICAgICB5OiAtMSAqIG8sXG4gICAgICAgICAgICBzY2FsZTogYSxcbiAgICAgICAgICAgIGZyaWN0aW9uOiBzLFxuICAgICAgICAgICAgaWdub3JlQm91bmRzOiAhMFxuICAgICAgICAgIH0pLCBzICo9IC45ODtcbiAgICAgICAgfTtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBvKSwgaS5vbmNlKFwiZW5kQW5pbWF0aW9uXCIsICgpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBvKSwgdC5kZXN0cm95KCk7XG4gICAgICAgIH0pLCBvKCk7XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZUN1cnNvcih0KSB7XG4gICAgICAgIGlmIChcImltYWdlXCIgIT09IHQudHlwZSB8fCAhdC4kZWwpIHJldHVybjtcbiAgICAgICAgY29uc3QgZSA9IHQuUGFuem9vbSxcbiAgICAgICAgICAgICAgaSA9IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UuY2xpY2tcIiwgITEsIHQpLFxuICAgICAgICAgICAgICBzID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS50b3VjaFwiKSxcbiAgICAgICAgICAgICAgbyA9IHQuJGVsLmNsYXNzTGlzdCxcbiAgICAgICAgICAgICAgbiA9IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UuY2FuWm9vbUluQ2xhc3NcIiksXG4gICAgICAgICAgICAgIGEgPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLmNhblpvb21PdXRDbGFzc1wiKTtcblxuICAgICAgICBpZiAoby5yZW1vdmUoYSksIG8ucmVtb3ZlKG4pLCBlICYmIFwidG9nZ2xlWm9vbVwiID09PSBpKSB7XG4gICAgICAgICAgZSAmJiAxID09PSBlLmNvbnRlbnQuc2NhbGUgJiYgZS5vcHRpb24oXCJtYXhTY2FsZVwiKSAtIGUuY29udGVudC5zY2FsZSA+IC4wMSA/IG8uYWRkKG4pIDogZS5jb250ZW50LnNjYWxlID4gMSAmJiAhcyAmJiBvLmFkZChhKTtcbiAgICAgICAgfSBlbHNlIFwiY2xvc2VcIiA9PT0gaSAmJiBvLmFkZChhKTtcbiAgICAgIH1cblxuICAgICAgb25XaGVlbCh0LCBlKSB7XG4gICAgICAgIGlmIChcInJlYWR5XCIgPT09IHRoaXMuZmFuY3lib3guc3RhdGUgJiYgITEgIT09IHRoaXMuZmFuY3lib3gudHJpZ2dlcihcIkltYWdlLndoZWVsXCIsIGUpKSBzd2l0Y2ggKHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2Uud2hlZWxcIikpIHtcbiAgICAgICAgICBjYXNlIFwiem9vbVwiOlxuICAgICAgICAgICAgXCJkb25lXCIgPT09IHQuc3RhdGUgJiYgdC5QYW56b29tICYmIHQuUGFuem9vbS56b29tV2l0aFdoZWVsKGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgIHRoaXMuZmFuY3lib3guY2xvc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInNsaWRlXCI6XG4gICAgICAgICAgICB0aGlzLmZhbmN5Ym94W2UuZGVsdGFZIDwgMCA/IFwicHJldlwiIDogXCJuZXh0XCJdKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25DbGljayh0LCBlKSB7XG4gICAgICAgIGlmIChcInJlYWR5XCIgIT09IHRoaXMuZmFuY3lib3guc3RhdGUpIHJldHVybjtcbiAgICAgICAgY29uc3QgaSA9IHQuUGFuem9vbTtcbiAgICAgICAgaWYgKGkgJiYgKGkuZHJhZ1Bvc2l0aW9uLm1pZFBvaW50IHx8IDAgIT09IGkuZHJhZ09mZnNldC54IHx8IDAgIT09IGkuZHJhZ09mZnNldC55IHx8IDEgIT09IGkuZHJhZ09mZnNldC5zY2FsZSkpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuZmFuY3lib3guQ2Fyb3VzZWwuUGFuem9vbS5sb2NrQXhpcykgcmV0dXJuICExO1xuXG4gICAgICAgIGNvbnN0IHMgPSBpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0b2dnbGVab29tXCI6XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCksIHQuUGFuem9vbSAmJiB0LlBhbnpvb20uem9vbVdpdGhDbGljayhlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJjbG9zZVwiOlxuICAgICAgICAgICAgICB0aGlzLmZhbmN5Ym94LmNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwibmV4dFwiOlxuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpLCB0aGlzLmZhbmN5Ym94Lm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICAgICAgIG8gPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLmNsaWNrXCIpLFxuICAgICAgICAgICAgICBuID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS5kb3VibGVDbGlja1wiKTtcblxuICAgICAgICBuID8gdGhpcy5jbGlja1RpbWVyID8gKGNsZWFyVGltZW91dCh0aGlzLmNsaWNrVGltZXIpLCB0aGlzLmNsaWNrVGltZXIgPSBudWxsLCBzKG4pKSA6IHRoaXMuY2xpY2tUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY2xpY2tUaW1lciA9IG51bGwsIHMobyk7XG4gICAgICAgIH0sIDMwMCkgOiBzKG8pO1xuICAgICAgfVxuXG4gICAgICBvblBhZ2VDaGFuZ2UodCwgZSkge1xuICAgICAgICBjb25zdCBpID0gdC5nZXRTbGlkZSgpO1xuICAgICAgICBlLnNsaWRlcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIHQuUGFuem9vbSAmJiBcImRvbmVcIiA9PT0gdC5zdGF0ZSAmJiB0LmluZGV4ICE9PSBpLmluZGV4ICYmIHQuUGFuem9vbS5wYW5Ubyh7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHNjYWxlOiAxLFxuICAgICAgICAgICAgZnJpY3Rpb246IC44XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2goKSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3gub24odGhpcy5ldmVudHMpO1xuICAgICAgfVxuXG4gICAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3gub2ZmKHRoaXMuZXZlbnRzKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIFQuZGVmYXVsdHMgPSB7XG4gICAgICBjYW5ab29tSW5DbGFzczogXCJjYW4tem9vbV9pblwiLFxuICAgICAgY2FuWm9vbU91dENsYXNzOiBcImNhbi16b29tX291dFwiLFxuICAgICAgem9vbTogITAsXG4gICAgICB6b29tT3BhY2l0eTogXCJhdXRvXCIsXG4gICAgICB6b29tRnJpY3Rpb246IC44MixcbiAgICAgIGlnbm9yZUNvdmVyZWRUaHVtYm5haWw6ICExLFxuICAgICAgdG91Y2g6ICEwLFxuICAgICAgY2xpY2s6IFwidG9nZ2xlWm9vbVwiLFxuICAgICAgZG91YmxlQ2xpY2s6IG51bGwsXG4gICAgICB3aGVlbDogXCJ6b29tXCIsXG4gICAgICBmaXQ6IFwiY29udGFpblwiLFxuICAgICAgd3JhcDogITEsXG4gICAgICBQYW56b29tOiB7XG4gICAgICAgIHJhdGlvOiAxXG4gICAgICB9XG4gICAgfTtcblxuICAgIGNsYXNzIEwge1xuICAgICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLmZhbmN5Ym94ID0gdDtcblxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgW1wib25DaGFuZ2VcIiwgXCJvbkNsb3NpbmdcIl0pIHRoaXNbdF0gPSB0aGlzW3RdLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICAgaW5pdENhcm91c2VsOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgICAgIFwiQ2Fyb3VzZWwuY2hhbmdlXCI6IHRoaXMub25DaGFuZ2UsXG4gICAgICAgICAgY2xvc2luZzogdGhpcy5vbkNsb3NpbmdcbiAgICAgICAgfSwgdGhpcy5oYXNDcmVhdGVkSGlzdG9yeSA9ICExLCB0aGlzLm9yaWdIYXNoID0gXCJcIiwgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIG9uQ2hhbmdlKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHQuQ2Fyb3VzZWw7XG4gICAgICAgIHRoaXMudGltZXIgJiYgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICBjb25zdCBpID0gbnVsbCA9PT0gZS5wcmV2UGFnZSxcbiAgICAgICAgICAgICAgcyA9IHQuZ2V0U2xpZGUoKSxcbiAgICAgICAgICAgICAgbyA9IG5ldyBVUkwoZG9jdW1lbnQuVVJMKS5oYXNoO1xuICAgICAgICBsZXQgbiA9ICExO1xuICAgICAgICBpZiAocy5zbHVnKSBuID0gXCIjXCIgKyBzLnNsdWc7ZWxzZSB7XG4gICAgICAgICAgY29uc3QgaSA9IHMuJHRyaWdnZXIgJiYgcy4kdHJpZ2dlci5kYXRhc2V0LFxuICAgICAgICAgICAgICAgIG8gPSB0Lm9wdGlvbihcInNsdWdcIikgfHwgaSAmJiBpLmZhbmN5Ym94O1xuICAgICAgICAgIG8gJiYgby5sZW5ndGggJiYgXCJ0cnVlXCIgIT09IG8gJiYgKG4gPSBcIiNcIiArIG8gKyAoZS5zbGlkZXMubGVuZ3RoID4gMSA/IFwiLVwiICsgKHMuaW5kZXggKyAxKSA6IFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpICYmICh0aGlzLm9yaWdIYXNoID0gbyAhPT0gbiA/IG8gOiBcIlwiKSwgbiAmJiBvICE9PSBuICYmICh0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5W2kgPyBcInB1c2hTdGF0ZVwiIDogXCJyZXBsYWNlU3RhdGVcIl0oe30sIGRvY3VtZW50LnRpdGxlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgbiksIGkgJiYgKHRoaXMuaGFzQ3JlYXRlZEhpc3RvcnkgPSAhMCk7XG4gICAgICAgICAgfSBjYXRjaCAodCkge31cbiAgICAgICAgfSwgMzAwKSk7XG4gICAgICB9XG5cbiAgICAgIG9uQ2xvc2luZygpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIgJiYgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpLCAhMCAhPT0gdGhpcy5oYXNTaWxlbnRDbG9zZSkgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdm9pZCB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgKHRoaXMub3JpZ0hhc2ggfHwgXCJcIikpO1xuICAgICAgICB9IGNhdGNoICh0KSB7fVxuICAgICAgfVxuXG4gICAgICBhdHRhY2godCkge1xuICAgICAgICB0Lm9uKHRoaXMuZXZlbnRzKTtcbiAgICAgIH1cblxuICAgICAgZGV0YWNoKHQpIHtcbiAgICAgICAgdC5vZmYodGhpcy5ldmVudHMpO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgc3RhcnRGcm9tVXJsKCkge1xuICAgICAgICBjb25zdCB0ID0gTC5GYW5jeWJveDtcbiAgICAgICAgaWYgKCF0IHx8IHQuZ2V0SW5zdGFuY2UoKSB8fCAhMSA9PT0gdC5kZWZhdWx0cy5IYXNoKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBoYXNoOiBlLFxuICAgICAgICAgIHNsdWc6IGksXG4gICAgICAgICAgaW5kZXg6IHNcbiAgICAgICAgfSA9IEwuZ2V0UGFyc2VkVVJMKCk7XG4gICAgICAgIGlmICghaSkgcmV0dXJuO1xuICAgICAgICBsZXQgbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXNsdWc9XCIke2V9XCJdYCk7XG4gICAgICAgIGlmIChvICYmIG8uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJjbGlja1wiLCB7XG4gICAgICAgICAgYnViYmxlczogITAsXG4gICAgICAgICAgY2FuY2VsYWJsZTogITBcbiAgICAgICAgfSkpLCB0LmdldEluc3RhbmNlKCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLWZhbmN5Ym94PVwiJHtpfVwiXWApO1xuICAgICAgICBuLmxlbmd0aCAmJiAobnVsbCA9PT0gcyAmJiAxID09PSBuLmxlbmd0aCA/IG8gPSBuWzBdIDogcyAmJiAobyA9IG5bcyAtIDFdKSwgbyAmJiBvLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2xpY2tcIiwge1xuICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBvbkhhc2hDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzbHVnOiB0LFxuICAgICAgICAgIGluZGV4OiBlXG4gICAgICAgIH0gPSBMLmdldFBhcnNlZFVSTCgpLFxuICAgICAgICAgICAgICBpID0gTC5GYW5jeWJveCxcbiAgICAgICAgICAgICAgcyA9IGkgJiYgaS5nZXRJbnN0YW5jZSgpO1xuXG4gICAgICAgIGlmIChzICYmIHMucGx1Z2lucy5IYXNoKSB7XG4gICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBzLkNhcm91c2VsO1xuICAgICAgICAgICAgaWYgKHQgPT09IHMub3B0aW9uKFwic2x1Z1wiKSkgcmV0dXJuIGkuc2xpZGVUbyhlIC0gMSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGUgb2YgaS5zbGlkZXMpIGlmIChlLnNsdWcgJiYgZS5zbHVnID09PSB0KSByZXR1cm4gaS5zbGlkZVRvKGUuaW5kZXgpO1xuXG4gICAgICAgICAgICBjb25zdCBvID0gcy5nZXRTbGlkZSgpLFxuICAgICAgICAgICAgICAgICAgbiA9IG8uJHRyaWdnZXIgJiYgby4kdHJpZ2dlci5kYXRhc2V0O1xuICAgICAgICAgICAgaWYgKG4gJiYgbi5mYW5jeWJveCA9PT0gdCkgcmV0dXJuIGkuc2xpZGVUbyhlIC0gMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcy5wbHVnaW5zLkhhc2guaGFzU2lsZW50Q2xvc2UgPSAhMCwgcy5jbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgTC5zdGFydEZyb21VcmwoKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGNyZWF0ZSh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIEwub25IYXNoQ2hhbmdlLCAhMSksIEwuc3RhcnRGcm9tVXJsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBMLkZhbmN5Ym94ID0gdCwgdiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAvY29tcGxldGV8aW50ZXJhY3RpdmV8bG9hZGVkLy50ZXN0KGRvY3VtZW50LnJlYWR5U3RhdGUpID8gZSgpIDogZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgZGVzdHJveSgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIEwub25IYXNoQ2hhbmdlLCAhMSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBnZXRQYXJzZWRVUkwoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHIoMSksXG4gICAgICAgICAgICAgIGUgPSB0LnNwbGl0KFwiLVwiKSxcbiAgICAgICAgICAgICAgaSA9IGUubGVuZ3RoID4gMSAmJiAvXlxcKz9cXGQrJC8udGVzdChlW2UubGVuZ3RoIC0gMV0pICYmIHBhcnNlSW50KGUucG9wKC0xKSwgMTApIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzaDogdCxcbiAgICAgICAgICBzbHVnOiBlLmpvaW4oXCItXCIpLFxuICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBjb25zdCBfID0ge1xuICAgICAgcGFnZVhPZmZzZXQ6IDAsXG4gICAgICBwYWdlWU9mZnNldDogMCxcbiAgICAgIGVsZW1lbnQ6ICgpID0+IGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50LFxuXG4gICAgICBhY3RpdmF0ZSh0KSB7XG4gICAgICAgIF8ucGFnZVhPZmZzZXQgPSB3aW5kb3cucGFnZVhPZmZzZXQsIF8ucGFnZVlPZmZzZXQgPSB3aW5kb3cucGFnZVlPZmZzZXQsIHQucmVxdWVzdEZ1bGxzY3JlZW4gPyB0LnJlcXVlc3RGdWxsc2NyZWVuKCkgOiB0Lm1velJlcXVlc3RGdWxsU2NyZWVuID8gdC5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpIDogdC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiA/IHQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKSA6IHQubXNSZXF1ZXN0RnVsbHNjcmVlbiAmJiB0Lm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0sXG5cbiAgICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuID8gZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKSA6IGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4gPyBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCkgOiBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbiAmJiBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGNsYXNzIEEge1xuICAgICAgY29uc3RydWN0b3IodCkge1xuICAgICAgICB0aGlzLmZhbmN5Ym94ID0gdCwgdGhpcy5hY3RpdmUgPSAhMSwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gICAgICB9XG5cbiAgICAgIHNldFRpbWVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlIHx8IHRoaXMudGltZXIpIHJldHVybjtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuZmFuY3lib3gub3B0aW9uKFwic2xpZGVzaG93LmRlbGF5XCIsIDNlMyk7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbCwgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJpbmZpbml0ZVwiKSB8fCB0aGlzLmZhbmN5Ym94LmdldFNsaWRlKCkuaW5kZXggIT09IHRoaXMuZmFuY3lib3guQ2Fyb3VzZWwuc2xpZGVzLmxlbmd0aCAtIDEgPyB0aGlzLmZhbmN5Ym94Lm5leHQoKSA6IHRoaXMuZmFuY3lib3guanVtcFRvKDAsIHtcbiAgICAgICAgICAgIGZyaWN0aW9uOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHQpO1xuICAgICAgICBsZXQgZSA9IHRoaXMuJHByb2dyZXNzO1xuICAgICAgICBlIHx8IChlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgZS5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3hfX3Byb2dyZXNzXCIpLCB0aGlzLmZhbmN5Ym94LiRjYXJvdXNlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLCB0aGlzLmZhbmN5Ym94LiRjYXJvdXNlbCksIHRoaXMuJHByb2dyZXNzID0gZSwgZS5vZmZzZXRIZWlnaHQpLCBlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke3R9bXNgLCBlLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGVYKDEpXCI7XG4gICAgICB9XG5cbiAgICAgIGNsZWFyVGltZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKSwgdGhpcy50aW1lciA9IG51bGwsIHRoaXMuJHByb2dyZXNzICYmICh0aGlzLiRwcm9ncmVzcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIlwiLCB0aGlzLiRwcm9ncmVzcy5zdHlsZS50cmFuc2Zvcm0gPSBcIlwiLCB0aGlzLiRwcm9ncmVzcy5vZmZzZXRIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgfHwgKHRoaXMuYWN0aXZlID0gITAsIHRoaXMuZmFuY3lib3guJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzLXNsaWRlc2hvd1wiKSwgXCJkb25lXCIgPT09IHRoaXMuZmFuY3lib3guZ2V0U2xpZGUoKS5zdGF0ZSAmJiB0aGlzLnNldFRpbWVyKCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSwgITEpKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gITEsIHRoaXMuY2xlYXJUaW1lcigpLCB0aGlzLmZhbmN5Ym94LiRjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcImhhcy1zbGlkZXNob3dcIiksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSwgITEpO1xuICAgICAgfVxuXG4gICAgICB0b2dnbGUoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID8gdGhpcy5kZWFjdGl2YXRlKCkgOiB0aGlzLmZhbmN5Ym94LkNhcm91c2VsLnNsaWRlcy5sZW5ndGggPiAxICYmIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGNvbnN0IHogPSB7XG4gICAgICBkaXNwbGF5OiBbXCJjb3VudGVyXCIsIFwiem9vbVwiLCBcInNsaWRlc2hvd1wiLCBcImZ1bGxzY3JlZW5cIiwgXCJ0aHVtYnNcIiwgXCJjbG9zZVwiXSxcbiAgICAgIGF1dG9FbmFibGU6ICEwLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgY291bnRlcjoge1xuICAgICAgICAgIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgICAgICAgICB0eXBlOiBcImRpdlwiLFxuICAgICAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19jb3VudGVyXCIsXG4gICAgICAgICAgaHRtbDogJzxzcGFuIGRhdGEtZmFuY3lib3gtaW5kZXg9XCJcIj48L3NwYW4+Jm5ic3A7LyZuYnNwOzxzcGFuIGRhdGEtZmFuY3lib3gtY291bnQ9XCJcIj48L3NwYW4+JyxcbiAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICB0YWJpbmRleDogLTFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZXY6IHtcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19idXR0b24tLXByZXZcIixcbiAgICAgICAgICBsYWJlbDogXCJQUkVWXCIsXG4gICAgICAgICAgaHRtbDogJzxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMTUgNGwtOCA4IDggOFwiLz48L3N2Zz4nLFxuICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgIFwiZGF0YS1mYW5jeWJveC1wcmV2XCI6IFwiXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IHtcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19idXR0b24tLW5leHRcIixcbiAgICAgICAgICBsYWJlbDogXCJORVhUXCIsXG4gICAgICAgICAgaHRtbDogJzxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNOCA0bDggOC04IDhcIi8+PC9zdmc+JyxcbiAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICBcImRhdGEtZmFuY3lib3gtbmV4dFwiOiBcIlwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmdWxsc2NyZWVuOiB7XG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBjbGFzczogXCJmYW5jeWJveF9fYnV0dG9uLS1mdWxsc2NyZWVuXCIsXG4gICAgICAgICAgbGFiZWw6IFwiVE9HR0xFX0ZVTExTQ1JFRU5cIixcbiAgICAgICAgICBodG1sOiAnPHN2ZyB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XFxuICAgICAgICAgICAgICAgIDxnPjxwYXRoIGQ9XCJNMyA4IFYzaDVcIj48L3BhdGg+PHBhdGggZD1cIk0yMSA4VjNoLTVcIj48L3BhdGg+PHBhdGggZD1cIk04IDIxSDN2LTVcIj48L3BhdGg+PHBhdGggZD1cIk0xNiAyMWg1di01XCI+PC9wYXRoPjwvZz5cXG4gICAgICAgICAgICAgICAgPGc+PHBhdGggZD1cIk03IDJ2NUgyTTE3IDJ2NWg1TTIgMTdoNXY1TTIyIDE3aC01djVcIi8+PC9nPlxcbiAgICAgICAgICAgIDwvc3ZnPicsXG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0LnByZXZlbnREZWZhdWx0KCksIF8uZWxlbWVudCgpID8gXy5kZWFjdGl2YXRlKCkgOiBfLmFjdGl2YXRlKHRoaXMuZmFuY3lib3guJGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzbGlkZXNob3c6IHtcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19idXR0b24tLXNsaWRlc2hvd1wiLFxuICAgICAgICAgIGxhYmVsOiBcIlRPR0dMRV9TTElERVNIT1dcIixcbiAgICAgICAgICBodG1sOiAnPHN2ZyB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XFxuICAgICAgICAgICAgICAgIDxnPjxwYXRoIGQ9XCJNNiA0djE2XCIvPjxwYXRoIGQ9XCJNMjAgMTJMNiAyMFwiLz48cGF0aCBkPVwiTTIwIDEyTDYgNFwiLz48L2c+XFxuICAgICAgICAgICAgICAgIDxnPjxwYXRoIGQ9XCJNNyA0djE1TTE3IDR2MTVcIi8+PC9nPlxcbiAgICAgICAgICAgIDwvc3ZnPicsXG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuU2xpZGVzaG93LnRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgem9vbToge1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgY2xhc3M6IFwiZmFuY3lib3hfX2J1dHRvbi0tem9vbVwiLFxuICAgICAgICAgIGxhYmVsOiBcIlRPR0dMRV9aT09NXCIsXG4gICAgICAgICAgaHRtbDogJzxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxjaXJjbGUgY3g9XCIxMFwiIGN5PVwiMTBcIiByPVwiN1wiPjwvY2lyY2xlPjxwYXRoIGQ9XCJNMTYgMTYgTDIxIDIxXCI+PC9zdmc+JyxcbiAgICAgICAgICBjbGljazogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLmZhbmN5Ym94LmdldFNsaWRlKCkuUGFuem9vbTtcbiAgICAgICAgICAgIGUgJiYgZS50b2dnbGVab29tKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkb3dubG9hZDoge1xuICAgICAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgICAgIGxhYmVsOiBcIkRPV05MT0FEXCIsXG4gICAgICAgICAgY2xhc3M6IFwiZmFuY3lib3hfX2J1dHRvbi0tZG93bmxvYWRcIixcbiAgICAgICAgICBodG1sOiAnPHN2ZyB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xMiAxNVYzbTAgMTJsLTQtNG00IDRsNC00TTIgMTdsLjYyIDIuNDhBMiAyIDAgMDA0LjU2IDIxaDE0Ljg4YTIgMiAwIDAwMS45NC0xLjUxTDIyIDE3XCIvPjwvc3ZnPicsXG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGh1bWJzOiB7XG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBsYWJlbDogXCJUT0dHTEVfVEhVTUJTXCIsXG4gICAgICAgICAgY2xhc3M6IFwiZmFuY3lib3hfX2J1dHRvbi0tdGh1bWJzXCIsXG4gICAgICAgICAgaHRtbDogJzxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxjaXJjbGUgY3g9XCI0XCIgY3k9XCI0XCIgcj1cIjFcIiAvPjxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiNFwiIHI9XCIxXCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDEyIDQpXCIvPjxjaXJjbGUgY3g9XCIyMFwiIGN5PVwiNFwiIHI9XCIxXCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDIwIDQpXCIvPjxjaXJjbGUgY3g9XCI0XCIgY3k9XCIxMlwiIHI9XCIxXCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDQgMTIpXCIvPjxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAxMiAxMilcIi8+PGNpcmNsZSBjeD1cIjIwXCIgY3k9XCIxMlwiIHI9XCIxXCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDIwIDEyKVwiLz48Y2lyY2xlIGN4PVwiNFwiIGN5PVwiMjBcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCA0IDIwKVwiLz48Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjIwXCIgcj1cIjFcIiB0cmFuc2Zvcm09XCJyb3RhdGUoOTAgMTIgMjApXCIvPjxjaXJjbGUgY3g9XCIyMFwiIGN5PVwiMjBcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAyMCAyMClcIi8+PC9zdmc+JyxcbiAgICAgICAgICBjbGljazogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcy5mYW5jeWJveC5wbHVnaW5zLlRodW1icztcbiAgICAgICAgICAgIGUgJiYgZS50b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiB7XG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBsYWJlbDogXCJDTE9TRVwiLFxuICAgICAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19idXR0b24tLWNsb3NlXCIsXG4gICAgICAgICAgaHRtbDogJzxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMjAgMjBMNCA0bTE2IDBMNCAyMFwiPjwvcGF0aD48L3N2Zz4nLFxuICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgIFwiZGF0YS1mYW5jeWJveC1jbG9zZVwiOiBcIlwiLFxuICAgICAgICAgICAgdGFiaW5kZXg6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2xhc3MgayB7XG4gICAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICAgIHRoaXMuZmFuY3lib3ggPSB0LCB0aGlzLiRjb250YWluZXIgPSBudWxsLCB0aGlzLnN0YXRlID0gXCJpbml0XCI7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIFtcIm9uSW5pdFwiLCBcIm9uUHJlcGFyZVwiLCBcIm9uRG9uZVwiLCBcIm9uS2V5ZG93blwiLCBcIm9uQ2xvc2luZ1wiLCBcIm9uQ2hhbmdlXCIsIFwib25TZXR0bGVcIiwgXCJvblJlZnJlc2hcIl0pIHRoaXNbdF0gPSB0aGlzW3RdLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICAgaW5pdDogdGhpcy5vbkluaXQsXG4gICAgICAgICAgcHJlcGFyZTogdGhpcy5vblByZXBhcmUsXG4gICAgICAgICAgZG9uZTogdGhpcy5vbkRvbmUsXG4gICAgICAgICAga2V5ZG93bjogdGhpcy5vbktleWRvd24sXG4gICAgICAgICAgY2xvc2luZzogdGhpcy5vbkNsb3NpbmcsXG4gICAgICAgICAgXCJDYXJvdXNlbC5jaGFuZ2VcIjogdGhpcy5vbkNoYW5nZSxcbiAgICAgICAgICBcIkNhcm91c2VsLnNldHRsZVwiOiB0aGlzLm9uU2V0dGxlLFxuICAgICAgICAgIFwiQ2Fyb3VzZWwuUGFuem9vbS50b3VjaFN0YXJ0XCI6ICgpID0+IHRoaXMub25SZWZyZXNoKCksXG4gICAgICAgICAgXCJJbWFnZS5zdGFydEFuaW1hdGlvblwiOiAodCwgZSkgPT4gdGhpcy5vblJlZnJlc2goZSksXG4gICAgICAgICAgXCJJbWFnZS5hZnRlclVwZGF0ZVwiOiAodCwgZSkgPT4gdGhpcy5vblJlZnJlc2goZSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5mYW5jeWJveC5vcHRpb24oXCJUb29sYmFyLmF1dG9FbmFibGVcIikpIHtcbiAgICAgICAgICBsZXQgdCA9ICExO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuZmFuY3lib3guaXRlbXMpIGlmIChcImltYWdlXCIgPT09IGUudHlwZSkge1xuICAgICAgICAgICAgdCA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0KSByZXR1cm4gdm9pZCAodGhpcy5zdGF0ZSA9IFwiZGlzYWJsZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJUb29sYmFyLmRpc3BsYXlcIikpIHtcbiAgICAgICAgICBpZiAoXCJjbG9zZVwiID09PSAodChlKSA/IGUuaWQgOiBlKSkge1xuICAgICAgICAgICAgdGhpcy5mYW5jeWJveC5vcHRpb25zLmNsb3NlQnV0dG9uID0gITE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25QcmVwYXJlKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5mYW5jeWJveDtcbiAgICAgICAgaWYgKFwiaW5pdFwiID09PSB0aGlzLnN0YXRlICYmICh0aGlzLmJ1aWxkKCksIHRoaXMudXBkYXRlKCksIHRoaXMuU2xpZGVzaG93ID0gbmV3IEEodCksICF0LkNhcm91c2VsLnByZXZQYWdlICYmICh0Lm9wdGlvbihcInNsaWRlc2hvdy5hdXRvU3RhcnRcIikgJiYgdGhpcy5TbGlkZXNob3cuYWN0aXZhdGUoKSwgdC5vcHRpb24oXCJmdWxsc2NyZWVuLmF1dG9TdGFydFwiKSAmJiAhXy5lbGVtZW50KCkpKSkgdHJ5IHtcbiAgICAgICAgICBfLmFjdGl2YXRlKHQuJGNvbnRhaW5lcik7XG4gICAgICAgIH0gY2F0Y2ggKHQpIHt9XG4gICAgICB9XG5cbiAgICAgIG9uRnNDaGFuZ2UoKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhfLnBhZ2VYT2Zmc2V0LCBfLnBhZ2VZT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgb25TZXR0bGUoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmZhbmN5Ym94LFxuICAgICAgICAgICAgICBlID0gdGhpcy5TbGlkZXNob3c7XG4gICAgICAgIGUgJiYgZS5pc0FjdGl2ZSgpICYmICh0LmdldFNsaWRlKCkuaW5kZXggIT09IHQuQ2Fyb3VzZWwuc2xpZGVzLmxlbmd0aCAtIDEgfHwgdC5vcHRpb24oXCJpbmZpbml0ZVwiKSA/IFwiZG9uZVwiID09PSB0LmdldFNsaWRlKCkuc3RhdGUgJiYgZS5zZXRUaW1lcigpIDogZS5kZWFjdGl2YXRlKCkpO1xuICAgICAgfVxuXG4gICAgICBvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKSwgdGhpcy5TbGlkZXNob3cgJiYgdGhpcy5TbGlkZXNob3cuaXNBY3RpdmUoKSAmJiB0aGlzLlNsaWRlc2hvdy5jbGVhclRpbWVyKCk7XG4gICAgICB9XG5cbiAgICAgIG9uRG9uZSh0LCBlKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLlNsaWRlc2hvdztcbiAgICAgICAgZS5pbmRleCA9PT0gdC5nZXRTbGlkZSgpLmluZGV4ICYmICh0aGlzLnVwZGF0ZSgpLCBpICYmIGkuaXNBY3RpdmUoKSAmJiAodC5vcHRpb24oXCJpbmZpbml0ZVwiKSB8fCBlLmluZGV4ICE9PSB0LkNhcm91c2VsLnNsaWRlcy5sZW5ndGggLSAxID8gaS5zZXRUaW1lcigpIDogaS5kZWFjdGl2YXRlKCkpKTtcbiAgICAgIH1cblxuICAgICAgb25SZWZyZXNoKHQpIHtcbiAgICAgICAgdCAmJiB0LmluZGV4ICE9PSB0aGlzLmZhbmN5Ym94LmdldFNsaWRlKCkuaW5kZXggfHwgKHRoaXMudXBkYXRlKCksICF0aGlzLlNsaWRlc2hvdyB8fCAhdGhpcy5TbGlkZXNob3cuaXNBY3RpdmUoKSB8fCB0ICYmIFwiZG9uZVwiICE9PSB0LnN0YXRlIHx8IHRoaXMuU2xpZGVzaG93LmRlYWN0aXZhdGUoKSk7XG4gICAgICB9XG5cbiAgICAgIG9uS2V5ZG93bih0LCBlLCBpKSB7XG4gICAgICAgIFwiIFwiID09PSBlICYmIHRoaXMuU2xpZGVzaG93ICYmICh0aGlzLlNsaWRlc2hvdy50b2dnbGUoKSwgaS5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICAgIH1cblxuICAgICAgb25DbG9zaW5nKCkge1xuICAgICAgICB0aGlzLlNsaWRlc2hvdyAmJiB0aGlzLlNsaWRlc2hvdy5kZWFjdGl2YXRlKCksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmdWxsc2NyZWVuY2hhbmdlXCIsIHRoaXMub25Gc0NoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZUVsZW1lbnQodCkge1xuICAgICAgICBsZXQgZTtcbiAgICAgICAgXCJkaXZcIiA9PT0gdC50eXBlID8gZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgOiAoZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIgPT09IHQudHlwZSA/IFwiYVwiIDogXCJidXR0b25cIiksIGUuY2xhc3NMaXN0LmFkZChcImNhcm91c2VsX19idXR0b25cIikpLCBlLmlubmVySFRNTCA9IHQuaHRtbCwgZS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCB0LnRhYmluZGV4IHx8IDApLCB0LmNsYXNzICYmIGUuY2xhc3NMaXN0LmFkZCguLi50LmNsYXNzLnNwbGl0KFwiIFwiKSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBpIGluIHQuYXR0cikgZS5zZXRBdHRyaWJ1dGUoaSwgdC5hdHRyW2ldKTtcblxuICAgICAgICB0LmxhYmVsICYmIGUuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdGhpcy5mYW5jeWJveC5sb2NhbGl6ZShge3ske3QubGFiZWx9fX1gKSksIHQuY2xpY2sgJiYgZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdC5jbGljay5iaW5kKHRoaXMpKSwgXCJwcmV2XCIgPT09IHQuaWQgJiYgZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWZhbmN5Ym94LXByZXZcIiwgXCJcIiksIFwibmV4dFwiID09PSB0LmlkICYmIGUuc2V0QXR0cmlidXRlKFwiZGF0YS1mYW5jeWJveC1uZXh0XCIsIFwiXCIpO1xuICAgICAgICBjb25zdCBpID0gZS5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpO1xuICAgICAgICByZXR1cm4gaSAmJiAoaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaW1nXCIpLCBpLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIiksIGkuc2V0QXR0cmlidXRlKFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSksIGU7XG4gICAgICB9XG5cbiAgICAgIGJ1aWxkKCkge1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiVG9vbGJhci5pdGVtc1wiKSxcbiAgICAgICAgICAgICAgcyA9IFt7XG4gICAgICAgICAgcG9zaXRpb246IFwibGVmdFwiLFxuICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcG9zaXRpb246IFwiY2VudGVyXCIsXG4gICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJyaWdodFwiLFxuICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICB9XSxcbiAgICAgICAgICAgICAgbyA9IHRoaXMuZmFuY3lib3gucGx1Z2lucy5UaHVtYnM7XG5cbiAgICAgICAgZm9yIChjb25zdCBuIG9mIHRoaXMuZmFuY3lib3gub3B0aW9uKFwiVG9vbGJhci5kaXNwbGF5XCIpKSB7XG4gICAgICAgICAgbGV0IGEsIHI7XG4gICAgICAgICAgaWYgKHQobikgPyAoYSA9IG4uaWQsIHIgPSBlKHt9LCBpW2FdLCBuKSkgOiAoYSA9IG4sIHIgPSBpW2FdKSwgW1wiY291bnRlclwiLCBcIm5leHRcIiwgXCJwcmV2XCIsIFwic2xpZGVzaG93XCJdLmluY2x1ZGVzKGEpICYmIHRoaXMuZmFuY3lib3guaXRlbXMubGVuZ3RoIDwgMikgY29udGludWU7XG5cbiAgICAgICAgICBpZiAoXCJmdWxsc2NyZWVuXCIgPT09IGEpIHtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQgfHwgd2luZG93LmZ1bGxTY3JlZW4pIGNvbnRpbnVlO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgdGhpcy5vbkZzQ2hhbmdlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXCJ0aHVtYnNcIiA9PT0gYSAmJiAoIW8gfHwgXCJkaXNhYmxlZFwiID09PSBvLnN0YXRlKSkgY29udGludWU7XG4gICAgICAgICAgaWYgKCFyKSBjb250aW51ZTtcbiAgICAgICAgICBsZXQgaCA9IHIucG9zaXRpb24gfHwgXCJyaWdodFwiLFxuICAgICAgICAgICAgICBsID0gcy5maW5kKHQgPT4gdC5wb3NpdGlvbiA9PT0gaCk7XG4gICAgICAgICAgbCAmJiBsLml0ZW1zLnB1c2gocik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3hfX3Rvb2xiYXJcIik7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHMpIGlmICh0Lml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIGUuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X190b29sYmFyX19pdGVtc1wiKSwgZS5jbGFzc0xpc3QuYWRkKGBmYW5jeWJveF9fdG9vbGJhcl9faXRlbXMtLSR7dC5wb3NpdGlvbn1gKTtcblxuICAgICAgICAgIGZvciAoY29uc3QgaSBvZiB0Lml0ZW1zKSBlLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlRWxlbWVudChpKSk7XG5cbiAgICAgICAgICBuLmFwcGVuZENoaWxkKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mYW5jeWJveC4kY2Fyb3VzZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobiwgdGhpcy5mYW5jeWJveC4kY2Fyb3VzZWwpLCB0aGlzLiRjb250YWluZXIgPSBuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmZhbmN5Ym94LmdldFNsaWRlKCksXG4gICAgICAgICAgICAgIGUgPSB0LmluZGV4LFxuICAgICAgICAgICAgICBpID0gdGhpcy5mYW5jeWJveC5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgIHMgPSB0LmRvd25sb2FkU3JjIHx8IChcImltYWdlXCIgIT09IHQudHlwZSB8fCB0LmVycm9yID8gbnVsbCA6IHQuc3JjKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5mYW5jeWJveC4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhLmZhbmN5Ym94X19idXR0b24tLWRvd25sb2FkXCIpKSBzID8gKHQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHQucmVtb3ZlQXR0cmlidXRlKFwidGFiaW5kZXhcIiksIHQuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBzKSwgdC5zZXRBdHRyaWJ1dGUoXCJkb3dubG9hZFwiLCBzKSwgdC5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgXCJfYmxhbmtcIikpIDogKHQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgLTEpLCB0LnJlbW92ZUF0dHJpYnV0ZShcImhyZWZcIiksIHQucmVtb3ZlQXR0cmlidXRlKFwiZG93bmxvYWRcIikpO1xuXG4gICAgICAgIGNvbnN0IG8gPSB0LlBhbnpvb20sXG4gICAgICAgICAgICAgIG4gPSBvICYmIG8ub3B0aW9uKFwibWF4U2NhbGVcIikgPiBvLm9wdGlvbihcImJhc2VTY2FsZVwiKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5mYW5jeWJveC4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZmFuY3lib3hfX2J1dHRvbi0tem9vbVwiKSkgbiA/IHQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgOiB0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpO1xuXG4gICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmZhbmN5Ym94LiRjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWZhbmN5Ym94LWluZGV4XVwiKSkgZS5pbm5lckhUTUwgPSB0LmluZGV4ICsgMTtcblxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5mYW5jeWJveC4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1mYW5jeWJveC1jb3VudF1cIikpIHQuaW5uZXJIVE1MID0gaTtcblxuICAgICAgICBpZiAoIXRoaXMuZmFuY3lib3gub3B0aW9uKFwiaW5maW5pdGVcIikpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5mYW5jeWJveC4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1mYW5jeWJveC1wcmV2XVwiKSkgMCA9PT0gZSA/IHQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIikgOiB0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuXG4gICAgICAgICAgZm9yIChjb25zdCB0IG9mIHRoaXMuZmFuY3lib3guJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZmFuY3lib3gtbmV4dF1cIikpIGUgPT09IGkgLSAxID8gdC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSA6IHQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5TbGlkZXNob3cgJiYgdGhpcy5TbGlkZXNob3cuaXNBY3RpdmUoKSAmJiB0aGlzLlNsaWRlc2hvdy5jbGVhclRpbWVyKCksIHRoaXMuJGNvbnRhaW5lciAmJiB0aGlzLiRjb250YWluZXIucmVtb3ZlKCksIHRoaXMuJGNvbnRhaW5lciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGF0dGFjaCgpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveC5vbih0aGlzLmV2ZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5mYW5jeWJveC5vZmYodGhpcy5ldmVudHMpLCB0aGlzLmNsZWFudXAoKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGsuZGVmYXVsdHMgPSB6O1xuICAgIGNvbnN0IE8gPSB7XG4gICAgICBTY3JvbGxMb2NrOiBjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICAgICB0aGlzLmZhbmN5Ym94ID0gdCwgdGhpcy52aWV3cG9ydCA9IG51bGwsIHRoaXMucGVuZGluZ1VwZGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgW1wib25SZWFkeVwiLCBcIm9uUmVzaXplXCIsIFwib25Ub3VjaHN0YXJ0XCIsIFwib25Ub3VjaG1vdmVcIl0pIHRoaXNbdF0gPSB0aGlzW3RdLmJpbmQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvblJlYWR5KCkge1xuICAgICAgICAgIGNvbnN0IHQgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQ7XG4gICAgICAgICAgdCAmJiAodGhpcy52aWV3cG9ydCA9IHQsIHRoaXMuc3RhcnRZID0gMCwgdC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpLCB0aGlzLnVwZGF0ZVZpZXdwb3J0KCkpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblRvdWNoc3RhcnQsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgICAgfSksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMub25Ub3VjaG1vdmUsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6ICExXG4gICAgICAgICAgfSksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5vbldoZWVsLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb25SZXNpemUoKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlVmlld3BvcnQoKSB7XG4gICAgICAgICAgY29uc3QgdCA9IHRoaXMuZmFuY3lib3gsXG4gICAgICAgICAgICAgICAgZSA9IHRoaXMudmlld3BvcnQsXG4gICAgICAgICAgICAgICAgaSA9IGUuc2NhbGUgfHwgMSxcbiAgICAgICAgICAgICAgICBzID0gdC4kY29udGFpbmVyO1xuICAgICAgICAgIGlmICghcykgcmV0dXJuO1xuICAgICAgICAgIGxldCBvID0gXCJcIixcbiAgICAgICAgICAgICAgbiA9IFwiXCIsXG4gICAgICAgICAgICAgIGEgPSBcIlwiO1xuICAgICAgICAgIGkgLSAxID4gLjEgJiYgKG8gPSBlLndpZHRoICogaSArIFwicHhcIiwgbiA9IGUuaGVpZ2h0ICogaSArIFwicHhcIiwgYSA9IGB0cmFuc2xhdGUzZCgke2Uub2Zmc2V0TGVmdH1weCwgJHtlLm9mZnNldFRvcH1weCwgMCkgc2NhbGUoJHsxIC8gaX0pYCksIHMuc3R5bGUud2lkdGggPSBvLCBzLnN0eWxlLmhlaWdodCA9IG4sIHMuc3R5bGUudHJhbnNmb3JtID0gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uVG91Y2hzdGFydCh0KSB7XG4gICAgICAgICAgdGhpcy5zdGFydFkgPSB0LnRvdWNoZXMgPyB0LnRvdWNoZXNbMF0uc2NyZWVuWSA6IHQuc2NyZWVuWTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uVG91Y2htb3ZlKHQpIHtcbiAgICAgICAgICBjb25zdCBlID0gdGhpcy5zdGFydFksXG4gICAgICAgICAgICAgICAgaSA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICBpZiAoIXQuY2FuY2VsYWJsZSkgcmV0dXJuO1xuICAgICAgICAgIGlmICh0LnRvdWNoZXMubGVuZ3RoID4gMSB8fCAxICE9PSBpKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgbyA9IHModC5jb21wb3NlZFBhdGgoKVswXSk7XG4gICAgICAgICAgaWYgKCFvKSByZXR1cm4gdm9pZCB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgY29uc3QgbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG8pLFxuICAgICAgICAgICAgICAgIGEgPSBwYXJzZUludChuLmdldFByb3BlcnR5VmFsdWUoXCJoZWlnaHRcIiksIDEwKSxcbiAgICAgICAgICAgICAgICByID0gdC50b3VjaGVzID8gdC50b3VjaGVzWzBdLnNjcmVlblkgOiB0LnNjcmVlblksXG4gICAgICAgICAgICAgICAgaCA9IGUgPD0gciAmJiAwID09PSBvLnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICBsID0gZSA+PSByICYmIG8uc2Nyb2xsSGVpZ2h0IC0gby5zY3JvbGxUb3AgPT09IGE7XG4gICAgICAgICAgKGggfHwgbCkgJiYgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgb25XaGVlbCh0KSB7XG4gICAgICAgICAgcyh0LmNvbXBvc2VkUGF0aCgpWzBdKSB8fCB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhbnVwKCkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1VwZGF0ZSAmJiAoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5wZW5kaW5nVXBkYXRlKSwgdGhpcy5wZW5kaW5nVXBkYXRlID0gbnVsbCk7XG4gICAgICAgICAgY29uc3QgdCA9IHRoaXMudmlld3BvcnQ7XG4gICAgICAgICAgdCAmJiAodC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpLCB0aGlzLnZpZXdwb3J0ID0gbnVsbCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLm9uVG91Y2hzdGFydCwgITEpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uVG91Y2htb3ZlLCAhMSksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5vbldoZWVsLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0YWNoKCkge1xuICAgICAgICAgIHRoaXMuZmFuY3lib3gub24oXCJpbml0TGF5b3V0XCIsIHRoaXMub25SZWFkeSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRhY2goKSB7XG4gICAgICAgICAgdGhpcy5mYW5jeWJveC5vZmYoXCJpbml0TGF5b3V0XCIsIHRoaXMub25SZWFkeSksIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB9XG5cbiAgICAgIH0sXG4gICAgICBUaHVtYnM6IEMsXG4gICAgICBIdG1sOiBQLFxuICAgICAgVG9vbGJhcjogayxcbiAgICAgIEltYWdlOiBULFxuICAgICAgSGFzaDogTFxuICAgIH07XG4gICAgY29uc3QgTSA9IHtcbiAgICAgIHN0YXJ0SW5kZXg6IDAsXG4gICAgICBwcmVsb2FkOiAxLFxuICAgICAgaW5maW5pdGU6ICEwLFxuICAgICAgc2hvd0NsYXNzOiBcImZhbmN5Ym94LXpvb21JblVwXCIsXG4gICAgICBoaWRlQ2xhc3M6IFwiZmFuY3lib3gtZmFkZU91dFwiLFxuICAgICAgYW5pbWF0ZWQ6ICEwLFxuICAgICAgaGlkZVNjcm9sbGJhcjogITAsXG4gICAgICBwYXJlbnRFbDogbnVsbCxcbiAgICAgIG1haW5DbGFzczogbnVsbCxcbiAgICAgIGF1dG9Gb2N1czogITAsXG4gICAgICB0cmFwRm9jdXM6ICEwLFxuICAgICAgcGxhY2VGb2N1c0JhY2s6ICEwLFxuICAgICAgY2xpY2s6IFwiY2xvc2VcIixcbiAgICAgIGNsb3NlQnV0dG9uOiBcImluc2lkZVwiLFxuICAgICAgZHJhZ1RvQ2xvc2U6ICEwLFxuICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgRXNjYXBlOiBcImNsb3NlXCIsXG4gICAgICAgIERlbGV0ZTogXCJjbG9zZVwiLFxuICAgICAgICBCYWNrc3BhY2U6IFwiY2xvc2VcIixcbiAgICAgICAgUGFnZVVwOiBcIm5leHRcIixcbiAgICAgICAgUGFnZURvd246IFwicHJldlwiLFxuICAgICAgICBBcnJvd1VwOiBcIm5leHRcIixcbiAgICAgICAgQXJyb3dEb3duOiBcInByZXZcIixcbiAgICAgICAgQXJyb3dSaWdodDogXCJuZXh0XCIsXG4gICAgICAgIEFycm93TGVmdDogXCJwcmV2XCJcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZToge1xuICAgICAgICBjbG9zZUJ1dHRvbjogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB0YWJpbmRleD1cIi0xXCI+PHBhdGggZD1cIk0yMCAyMEw0IDRtMTYgMEw0IDIwXCIvPjwvc3ZnPicsXG4gICAgICAgIHNwaW5uZXI6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiB2aWV3Qm94PVwiMjUgMjUgNTAgNTBcIiB0YWJpbmRleD1cIi0xXCI+PGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCIyMFwiLz48L3N2Zz4nLFxuICAgICAgICBtYWluOiBudWxsXG4gICAgICB9LFxuICAgICAgbDEwbjoge1xuICAgICAgICBDTE9TRTogXCJDbG9zZVwiLFxuICAgICAgICBORVhUOiBcIk5leHRcIixcbiAgICAgICAgUFJFVjogXCJQcmV2aW91c1wiLFxuICAgICAgICBNT0RBTDogXCJZb3UgY2FuIGNsb3NlIHRoaXMgbW9kYWwgY29udGVudCB3aXRoIHRoZSBFU0Mga2V5XCIsXG4gICAgICAgIEVSUk9SOiBcIlNvbWV0aGluZyBXZW50IFdyb25nLCBQbGVhc2UgVHJ5IEFnYWluIExhdGVyXCIsXG4gICAgICAgIElNQUdFX0VSUk9SOiBcIkltYWdlIE5vdCBGb3VuZFwiLFxuICAgICAgICBFTEVNRU5UX05PVF9GT1VORDogXCJIVE1MIEVsZW1lbnQgTm90IEZvdW5kXCIsXG4gICAgICAgIEFKQVhfTk9UX0ZPVU5EOiBcIkVycm9yIExvYWRpbmcgQUpBWCA6IE5vdCBGb3VuZFwiLFxuICAgICAgICBBSkFYX0ZPUkJJRERFTjogXCJFcnJvciBMb2FkaW5nIEFKQVggOiBGb3JiaWRkZW5cIixcbiAgICAgICAgSUZSQU1FX0VSUk9SOiBcIkVycm9yIExvYWRpbmcgUGFnZVwiLFxuICAgICAgICBUT0dHTEVfWk9PTTogXCJUb2dnbGUgem9vbSBsZXZlbFwiLFxuICAgICAgICBUT0dHTEVfVEhVTUJTOiBcIlRvZ2dsZSB0aHVtYm5haWxzXCIsXG4gICAgICAgIFRPR0dMRV9TTElERVNIT1c6IFwiVG9nZ2xlIHNsaWRlc2hvd1wiLFxuICAgICAgICBUT0dHTEVfRlVMTFNDUkVFTjogXCJUb2dnbGUgZnVsbC1zY3JlZW4gbW9kZVwiLFxuICAgICAgICBET1dOTE9BRDogXCJEb3dubG9hZFwiXG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgICBJID0gbmV3IE1hcCgpO1xuICAgIGxldCBGID0gMDtcblxuICAgIGNsYXNzIFIgZXh0ZW5kcyBsIHtcbiAgICAgIGNvbnN0cnVjdG9yKHQsIGkgPSB7fSkge1xuICAgICAgICB0ID0gdC5tYXAodCA9PiAodC53aWR0aCAmJiAodC5fd2lkdGggPSB0LndpZHRoKSwgdC5oZWlnaHQgJiYgKHQuX2hlaWdodCA9IHQuaGVpZ2h0KSwgdCkpLCBzdXBlcihlKCEwLCB7fSwgTSwgaSkpLCB0aGlzLmJpbmRIYW5kbGVycygpLCB0aGlzLnN0YXRlID0gXCJpbml0XCIsIHRoaXMuc2V0SXRlbXModCksIHRoaXMuYXR0YWNoUGx1Z2lucyhSLlBsdWdpbnMpLCB0aGlzLnRyaWdnZXIoXCJpbml0XCIpLCAhMCA9PT0gdGhpcy5vcHRpb24oXCJoaWRlU2Nyb2xsYmFyXCIpICYmIHRoaXMuaGlkZVNjcm9sbGJhcigpLCB0aGlzLmluaXRMYXlvdXQoKSwgdGhpcy5pbml0Q2Fyb3VzZWwoKSwgdGhpcy5hdHRhY2hFdmVudHMoKSwgSS5zZXQodGhpcy5pZCwgdGhpcyksIHRoaXMudHJpZ2dlcihcInByZXBhcmVcIiksIHRoaXMuc3RhdGUgPSBcInJlYWR5XCIsIHRoaXMudHJpZ2dlcihcInJlYWR5XCIpLCB0aGlzLiRjb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJmYWxzZVwiKSwgdGhpcy5vcHRpb24oXCJ0cmFwRm9jdXNcIikgJiYgdGhpcy5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBvcHRpb24odCwgLi4uZSkge1xuICAgICAgICBjb25zdCBpID0gdGhpcy5nZXRTbGlkZSgpO1xuICAgICAgICBsZXQgcyA9IGkgPyBpW3RdIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBzID8gKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcyAmJiAocyA9IHMuY2FsbCh0aGlzLCB0aGlzLCAuLi5lKSksIHMpIDogc3VwZXIub3B0aW9uKHQsIC4uLmUpO1xuICAgICAgfVxuXG4gICAgICBiaW5kSGFuZGxlcnMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBbXCJvbk1vdXNlZG93blwiLCBcIm9uS2V5ZG93blwiLCBcIm9uQ2xpY2tcIiwgXCJvbkZvY3VzXCIsIFwib25DcmVhdGVTbGlkZVwiLCBcIm9uU2V0dGxlXCIsIFwib25Ub3VjaE1vdmVcIiwgXCJvblRvdWNoRW5kXCIsIFwib25UcmFuc2Zvcm1cIl0pIHRoaXNbdF0gPSB0aGlzW3RdLmJpbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2Vkb3duKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbktleWRvd24sICEwKSwgdGhpcy5vcHRpb24oXCJ0cmFwRm9jdXNcIikgJiYgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMub25Gb2N1cywgITApLCB0aGlzLiRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25DbGljayk7XG4gICAgICB9XG5cbiAgICAgIGRldGFjaEV2ZW50cygpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2Vkb3duKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbktleWRvd24sICEwKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMub25Gb2N1cywgITApLCB0aGlzLiRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25DbGljayk7XG4gICAgICB9XG5cbiAgICAgIGluaXRMYXlvdXQoKSB7XG4gICAgICAgIHRoaXMuJHJvb3QgPSB0aGlzLm9wdGlvbihcInBhcmVudEVsXCIpIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIGxldCB0ID0gdGhpcy5vcHRpb24oXCJ0ZW1wbGF0ZS5tYWluXCIpO1xuICAgICAgICB0ICYmICh0aGlzLiRyb290Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCB0aGlzLmxvY2FsaXplKHQpKSwgdGhpcy4kY29udGFpbmVyID0gdGhpcy4kcm9vdC5xdWVyeVNlbGVjdG9yKFwiLmZhbmN5Ym94X19jb250YWluZXJcIikpLCB0aGlzLiRjb250YWluZXIgfHwgKHRoaXMuJGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHRoaXMuJHJvb3QuYXBwZW5kQ2hpbGQodGhpcy4kY29udGFpbmVyKSksIHRoaXMuJGNvbnRhaW5lci5vbnNjcm9sbCA9ICgpID0+ICh0aGlzLiRjb250YWluZXIuc2Nyb2xsTGVmdCA9IDAsICExKSwgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19jb250YWluZXJcIixcbiAgICAgICAgICByb2xlOiBcImRpYWxvZ1wiLFxuICAgICAgICAgIHRhYkluZGV4OiBcIi0xXCIsXG4gICAgICAgICAgXCJhcmlhLW1vZGFsXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsXG4gICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMubG9jYWxpemUoXCJ7e01PREFMfX1cIilcbiAgICAgICAgfSkuZm9yRWFjaCh0ID0+IHRoaXMuJGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoLi4udCkpLCB0aGlzLm9wdGlvbihcImFuaW1hdGVkXCIpICYmIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaXMtYW5pbWF0ZWRcIiksIHRoaXMuJGJhY2tkcm9wID0gdGhpcy4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuZmFuY3lib3hfX2JhY2tkcm9wXCIpLCB0aGlzLiRiYWNrZHJvcCB8fCAodGhpcy4kYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB0aGlzLiRiYWNrZHJvcC5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3hfX2JhY2tkcm9wXCIpLCB0aGlzLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy4kYmFja2Ryb3ApKSwgdGhpcy4kY2Fyb3VzZWwgPSB0aGlzLiRjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5mYW5jeWJveF9fY2Fyb3VzZWxcIiksIHRoaXMuJGNhcm91c2VsIHx8ICh0aGlzLiRjYXJvdXNlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHRoaXMuJGNhcm91c2VsLmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveF9fY2Fyb3VzZWxcIiksIHRoaXMuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLiRjYXJvdXNlbCkpLCB0aGlzLiRjb250YWluZXIuRmFuY3lib3ggPSB0aGlzLCB0aGlzLmlkID0gdGhpcy4kY29udGFpbmVyLmdldEF0dHJpYnV0ZShcImlkXCIpLCB0aGlzLmlkIHx8ICh0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkIHx8ICsrRiwgdGhpcy4kY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiZmFuY3lib3gtXCIgKyB0aGlzLmlkKSk7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbihcIm1haW5DbGFzc1wiKTtcbiAgICAgICAgcmV0dXJuIGUgJiYgdGhpcy4kY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4uZS5zcGxpdChcIiBcIikpLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIndpdGgtZmFuY3lib3hcIiksIHRoaXMudHJpZ2dlcihcImluaXRMYXlvdXRcIiksIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHNldEl0ZW1zKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0KSB7XG4gICAgICAgICAgY29uc3QgdCA9IGkuJHRyaWdnZXI7XG5cbiAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgY29uc3QgZSA9IHQuZGF0YXNldCB8fCB7fTtcbiAgICAgICAgICAgIGkuc3JjID0gZS5zcmMgfHwgdC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpIHx8IGkuc3JjLCBpLnR5cGUgPSBlLnR5cGUgfHwgaS50eXBlLCAhaS5zcmMgJiYgdCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgKGkuc3JjID0gdC5jdXJyZW50U3JjIHx8IGkuJHRyaWdnZXIuc3JjKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcyA9IGkuJHRodW1iO1xuXG4gICAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgICBsZXQgdCA9IGkuJHRyaWdnZXIgJiYgaS4kdHJpZ2dlci5vcmlnVGFyZ2V0O1xuICAgICAgICAgICAgdCAmJiAocyA9IHQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ID8gdCA6IHQucXVlcnlTZWxlY3RvcihcImltZzpub3QoW2FyaWEtaGlkZGVuXSlcIikpLCAhcyAmJiBpLiR0cmlnZ2VyICYmIChzID0gaS4kdHJpZ2dlciBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgPyBpLiR0cmlnZ2VyIDogaS4kdHJpZ2dlci5xdWVyeVNlbGVjdG9yKFwiaW1nOm5vdChbYXJpYS1oaWRkZW5dKVwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaS4kdGh1bWIgPSBzIHx8IG51bGw7XG4gICAgICAgICAgbGV0IG8gPSBpLnRodW1iO1xuICAgICAgICAgICFvICYmIHMgJiYgKG8gPSBzLmN1cnJlbnRTcmMgfHwgcy5zcmMsICFvICYmIHMuZGF0YXNldCAmJiAobyA9IHMuZGF0YXNldC5sYXp5U3JjIHx8IHMuZGF0YXNldC5zcmMpKSwgbyB8fCBcImltYWdlXCIgIT09IGkudHlwZSB8fCAobyA9IGkuc3JjKSwgaS50aHVtYiA9IG8gfHwgbnVsbCwgaS5jYXB0aW9uID0gaS5jYXB0aW9uIHx8IFwiXCIsIGUucHVzaChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXRlbXMgPSBlO1xuICAgICAgfVxuXG4gICAgICBpbml0Q2Fyb3VzZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNhcm91c2VsID0gbmV3IHkodGhpcy4kY2Fyb3VzZWwsIGUoITAsIHt9LCB7XG4gICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgICAgIHZpZXdwb3J0OiBcImZhbmN5Ym94X192aWV3cG9ydFwiLFxuICAgICAgICAgICAgdHJhY2s6IFwiZmFuY3lib3hfX3RyYWNrXCIsXG4gICAgICAgICAgICBzbGlkZTogXCJmYW5jeWJveF9fc2xpZGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGV4dFNlbGVjdGlvbjogITAsXG4gICAgICAgICAgcHJlbG9hZDogdGhpcy5vcHRpb24oXCJwcmVsb2FkXCIpLFxuICAgICAgICAgIGZyaWN0aW9uOiAuODgsXG4gICAgICAgICAgc2xpZGVzOiB0aGlzLml0ZW1zLFxuICAgICAgICAgIGluaXRpYWxQYWdlOiB0aGlzLm9wdGlvbnMuc3RhcnRJbmRleCxcbiAgICAgICAgICBzbGlkZXNQZXJQYWdlOiAxLFxuICAgICAgICAgIGluZmluaXRlWDogdGhpcy5vcHRpb24oXCJpbmZpbml0ZVwiKSxcbiAgICAgICAgICBpbmZpbml0ZVk6ICEwLFxuICAgICAgICAgIGwxMG46IHRoaXMub3B0aW9uKFwibDEwblwiKSxcbiAgICAgICAgICBEb3RzOiAhMSxcbiAgICAgICAgICBOYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBjbGFzc05hbWVzOiB7XG4gICAgICAgICAgICAgIG1haW46IFwiZmFuY3lib3hfX25hdlwiLFxuICAgICAgICAgICAgICBidXR0b246IFwiY2Fyb3VzZWxfX2J1dHRvblwiLFxuICAgICAgICAgICAgICBuZXh0OiBcImlzLW5leHRcIixcbiAgICAgICAgICAgICAgcHJldjogXCJpcy1wcmV2XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFBhbnpvb206IHtcbiAgICAgICAgICAgIHRleHRTZWxlY3Rpb246ICEwLFxuICAgICAgICAgICAgcGFuT25seVpvb21lZDogKCkgPT4gdGhpcy5DYXJvdXNlbCAmJiB0aGlzLkNhcm91c2VsLnBhZ2VzICYmIHRoaXMuQ2Fyb3VzZWwucGFnZXMubGVuZ3RoIDwgMiAmJiAhdGhpcy5vcHRpb24oXCJkcmFnVG9DbG9zZVwiKSxcbiAgICAgICAgICAgIGxvY2tBeGlzOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLkNhcm91c2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHQgPSBcInhcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb24oXCJkcmFnVG9DbG9zZVwiKSAmJiAodCArPSBcInlcIiksIHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcIipcIjogKHQsIC4uLmUpID0+IHRoaXMudHJpZ2dlcihgQ2Fyb3VzZWwuJHt0fWAsIC4uLmUpLFxuICAgICAgICAgICAgaW5pdDogdCA9PiB0aGlzLkNhcm91c2VsID0gdCxcbiAgICAgICAgICAgIGNyZWF0ZVNsaWRlOiB0aGlzLm9uQ3JlYXRlU2xpZGUsXG4gICAgICAgICAgICBzZXR0bGU6IHRoaXMub25TZXR0bGVcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMub3B0aW9uKFwiQ2Fyb3VzZWxcIikpKSwgdGhpcy5vcHRpb24oXCJkcmFnVG9DbG9zZVwiKSAmJiB0aGlzLkNhcm91c2VsLlBhbnpvb20ub24oe1xuICAgICAgICAgIHRvdWNoTW92ZTogdGhpcy5vblRvdWNoTW92ZSxcbiAgICAgICAgICBhZnRlclRyYW5zZm9ybTogdGhpcy5vblRyYW5zZm9ybSxcbiAgICAgICAgICB0b3VjaEVuZDogdGhpcy5vblRvdWNoRW5kXG4gICAgICAgIH0pLCB0aGlzLnRyaWdnZXIoXCJpbml0Q2Fyb3VzZWxcIiksIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG9uQ3JlYXRlU2xpZGUodCwgZSkge1xuICAgICAgICBsZXQgaSA9IGUuY2FwdGlvbiB8fCBcIlwiO1xuXG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRoaXMub3B0aW9ucy5jYXB0aW9uICYmIChpID0gdGhpcy5vcHRpb25zLmNhcHRpb24uY2FsbCh0aGlzLCB0aGlzLCB0aGlzLkNhcm91c2VsLCBlKSksIFwic3RyaW5nXCIgPT0gdHlwZW9mIGkgJiYgaS5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgICAgICBzID0gYGZhbmN5Ym94X19jYXB0aW9uXyR7dGhpcy5pZH1fJHtlLmluZGV4fWA7XG4gICAgICAgICAgdC5jbGFzc05hbWUgPSBcImZhbmN5Ym94X19jYXB0aW9uXCIsIHQuaW5uZXJIVE1MID0gaSwgdC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzKSwgZS4kY2FwdGlvbiA9IGUuJGVsLmFwcGVuZENoaWxkKHQpLCBlLiRlbC5jbGFzc0xpc3QuYWRkKFwiaGFzLWNhcHRpb25cIiksIGUuJGVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvblNldHRsZSgpIHtcbiAgICAgICAgdGhpcy5vcHRpb24oXCJhdXRvRm9jdXNcIikgJiYgdGhpcy5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBvbkZvY3VzKHQpIHtcbiAgICAgICAgdGhpcy5pc1RvcG1vc3QoKSAmJiB0aGlzLmZvY3VzKHQpO1xuICAgICAgfVxuXG4gICAgICBvbkNsaWNrKHQpIHtcbiAgICAgICAgaWYgKHQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgICBsZXQgZSA9IHQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICAgIGlmIChlLm1hdGNoZXMoXCJbZGF0YS1mYW5jeWJveC1jbG9zZV1cIikpIHJldHVybiB0LnByZXZlbnREZWZhdWx0KCksIHZvaWQgUi5jbG9zZSghMSwgdCk7XG4gICAgICAgIGlmIChlLm1hdGNoZXMoXCJbZGF0YS1mYW5jeWJveC1uZXh0XVwiKSkgcmV0dXJuIHQucHJldmVudERlZmF1bHQoKSwgdm9pZCBSLm5leHQoKTtcbiAgICAgICAgaWYgKGUubWF0Y2hlcyhcIltkYXRhLWZhbmN5Ym94LXByZXZdXCIpKSByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpLCB2b2lkIFIucHJldigpO1xuICAgICAgICBjb25zdCBpID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIGlmIChpLmNsb3Nlc3QoXCJbY29udGVudGVkaXRhYmxlXVwiKSkgcmV0dXJuO1xuICAgICAgICAgIGUubWF0Y2hlcyh4KSB8fCBpLmJsdXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLmNsb3Nlc3QoXCIuZmFuY3lib3hfX2NvbnRlbnRcIikpIHJldHVybjtcbiAgICAgICAgaWYgKGdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCkubGVuZ3RoKSByZXR1cm47XG4gICAgICAgIGlmICghMSA9PT0gdGhpcy50cmlnZ2VyKFwiY2xpY2tcIiwgdCkpIHJldHVybjtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9uKFwiY2xpY2tcIikpIHtcbiAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIm5leHRcIjpcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uVG91Y2hNb3ZlKCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5nZXRTbGlkZSgpLlBhbnpvb207XG4gICAgICAgIHJldHVybiAhdCB8fCAxID09PSB0LmNvbnRlbnQuc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIG9uVG91Y2hFbmQodCkge1xuICAgICAgICBjb25zdCBlID0gdC5kcmFnT2Zmc2V0Lnk7XG4gICAgICAgIE1hdGguYWJzKGUpID49IDE1MCB8fCBNYXRoLmFicyhlKSA+PSAzNSAmJiB0LmRyYWdPZmZzZXQudGltZSA8IDM1MCA/ICh0aGlzLm9wdGlvbihcImhpZGVDbGFzc1wiKSAmJiAodGhpcy5nZXRTbGlkZSgpLmhpZGVDbGFzcyA9IFwiZmFuY3lib3gtdGhyb3dPdXRcIiArICh0LmNvbnRlbnQueSA8IDAgPyBcIlVwXCIgOiBcIkRvd25cIikpLCB0aGlzLmNsb3NlKCkpIDogXCJ5XCIgPT09IHQubG9ja0F4aXMgJiYgdC5wYW5Ubyh7XG4gICAgICAgICAgeTogMFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgb25UcmFuc2Zvcm0odCkge1xuICAgICAgICBpZiAodGhpcy4kYmFja2Ryb3ApIHtcbiAgICAgICAgICBjb25zdCBlID0gTWF0aC5hYnModC5jb250ZW50LnkpLFxuICAgICAgICAgICAgICAgIGkgPSBlIDwgMSA/IFwiXCIgOiBNYXRoLm1heCguMzMsIE1hdGgubWluKDEsIDEgLSBlIC8gdC5jb250ZW50LmZpdEhlaWdodCAqIDEuNSkpO1xuICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tZmFuY3lib3gtdHNcIiwgaSA/IFwiMHNcIiA6IFwiXCIpLCB0aGlzLiRjb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLWZhbmN5Ym94LW9wYWNpdHlcIiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25Nb3VzZWRvd24oKSB7XG4gICAgICAgIFwicmVhZHlcIiA9PT0gdGhpcy5zdGF0ZSAmJiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJpcy11c2luZy1tb3VzZVwiKTtcbiAgICAgIH1cblxuICAgICAgb25LZXlkb3duKHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVG9wbW9zdCgpKSByZXR1cm47XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImlzLXVzaW5nLW1vdXNlXCIpO1xuICAgICAgICBjb25zdCBlID0gdC5rZXksXG4gICAgICAgICAgICAgIGkgPSB0aGlzLm9wdGlvbihcImtleWJvYXJkXCIpO1xuICAgICAgICBpZiAoIWkgfHwgdC5jdHJsS2V5IHx8IHQuYWx0S2V5IHx8IHQuc2hpZnRLZXkpIHJldHVybjtcbiAgICAgICAgY29uc3QgcyA9IHQuY29tcG9zZWRQYXRoKClbMF0sXG4gICAgICAgICAgICAgIG8gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LFxuICAgICAgICAgICAgICBuID0gbyAmJiBvLmNvbnRhaW5zKFwiY2Fyb3VzZWxfX2J1dHRvblwiKTtcblxuICAgICAgICBpZiAoXCJFc2NhcGVcIiAhPT0gZSAmJiAhbikge1xuICAgICAgICAgIGlmICh0LnRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSB8fCAtMSAhPT0gW1wiQlVUVE9OXCIsIFwiVEVYVEFSRUFcIiwgXCJPUFRJT05cIiwgXCJJTlBVVFwiLCBcIlNFTEVDVFwiLCBcIlZJREVPXCJdLmluZGV4T2Yocy5ub2RlTmFtZSkpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghMSA9PT0gdGhpcy50cmlnZ2VyKFwia2V5ZG93blwiLCBlLCB0KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBhID0gaVtlXTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0aGlzW2FdICYmIHRoaXNbYV0oKTtcbiAgICAgIH1cblxuICAgICAgZ2V0U2xpZGUoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLkNhcm91c2VsO1xuICAgICAgICBpZiAoIXQpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBlID0gbnVsbCA9PT0gdC5wYWdlID8gdC5vcHRpb24oXCJpbml0aWFsUGFnZVwiKSA6IHQucGFnZSxcbiAgICAgICAgICAgICAgaSA9IHQucGFnZXMgfHwgW107XG4gICAgICAgIHJldHVybiBpLmxlbmd0aCAmJiBpW2VdID8gaVtlXS5zbGlkZXNbMF0gOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmb2N1cyh0KSB7XG4gICAgICAgIGlmIChSLmlnbm9yZUZvY3VzQ2hhbmdlKSByZXR1cm47XG4gICAgICAgIGlmIChbXCJpbml0XCIsIFwiY2xvc2luZ1wiLCBcImN1c3RvbUNsb3NpbmdcIiwgXCJkZXN0cm95XCJdLmluZGV4T2YodGhpcy5zdGF0ZSkgPiAtMSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlID0gdGhpcy4kY29udGFpbmVyLFxuICAgICAgICAgICAgICBpID0gdGhpcy5nZXRTbGlkZSgpLFxuICAgICAgICAgICAgICBzID0gXCJkb25lXCIgPT09IGkuc3RhdGUgPyBpLiRlbCA6IG51bGw7XG4gICAgICAgIGlmIChzICYmIHMuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHJldHVybjtcbiAgICAgICAgdCAmJiB0LnByZXZlbnREZWZhdWx0KCksIFIuaWdub3JlRm9jdXNDaGFuZ2UgPSAhMDtcbiAgICAgICAgY29uc3QgbyA9IEFycmF5LmZyb20oZS5xdWVyeVNlbGVjdG9yQWxsKHgpKTtcbiAgICAgICAgbGV0IG4sXG4gICAgICAgICAgICBhID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgdCBvZiBvKSB7XG4gICAgICAgICAgY29uc3QgZSA9IHQub2Zmc2V0UGFyZW50LFxuICAgICAgICAgICAgICAgIGkgPSBzICYmIHMuY29udGFpbnModCksXG4gICAgICAgICAgICAgICAgbyA9ICF0aGlzLkNhcm91c2VsLiR2aWV3cG9ydC5jb250YWlucyh0KTtcbiAgICAgICAgICBlICYmIChpIHx8IG8pID8gKGEucHVzaCh0KSwgdm9pZCAwICE9PSB0LmRhdGFzZXQub3JpZ1RhYmluZGV4ICYmICh0LnRhYkluZGV4ID0gdC5kYXRhc2V0Lm9yaWdUYWJpbmRleCwgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLW9yaWctdGFiaW5kZXhcIikpLCAodC5oYXNBdHRyaWJ1dGUoXCJhdXRvRm9jdXNcIikgfHwgIW4gJiYgaSAmJiAhdC5jbGFzc0xpc3QuY29udGFpbnMoXCJjYXJvdXNlbF9fYnV0dG9uXCIpKSAmJiAobiA9IHQpKSA6ICh0LmRhdGFzZXQub3JpZ1RhYmluZGV4ID0gdm9pZCAwID09PSB0LmRhdGFzZXQub3JpZ1RhYmluZGV4ID8gdC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSA6IHQuZGF0YXNldC5vcmlnVGFiaW5kZXgsIHQudGFiSW5kZXggPSAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ID8gYS5pbmRleE9mKHQudGFyZ2V0KSA+IC0xID8gdGhpcy5sYXN0Rm9jdXMgPSB0LnRhcmdldCA6IHRoaXMubGFzdEZvY3VzID09PSBlID8gdyhhW2EubGVuZ3RoIC0gMV0pIDogdyhlKSA6IHRoaXMub3B0aW9uKFwiYXV0b0ZvY3VzXCIpICYmIG4gPyB3KG4pIDogYS5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIDwgMCAmJiB3KGUpLCB0aGlzLmxhc3RGb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsIFIuaWdub3JlRm9jdXNDaGFuZ2UgPSAhMTtcbiAgICAgIH1cblxuICAgICAgaGlkZVNjcm9sbGJhcigpIHtcbiAgICAgICAgaWYgKCF2KSByZXR1cm47XG4gICAgICAgIGNvbnN0IHQgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxcbiAgICAgICAgICAgICAgZSA9IFwiZmFuY3lib3gtc3R5bGUtbm9zY3JvbGxcIjtcbiAgICAgICAgbGV0IGkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKTtcbiAgICAgICAgaSB8fCB0ID4gMCAmJiAoaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSwgaS5pZCA9IGUsIGkudHlwZSA9IFwidGV4dC9jc3NcIiwgaS5pbm5lckhUTUwgPSBgLmNvbXBlbnNhdGUtZm9yLXNjcm9sbGJhciB7cGFkZGluZy1yaWdodDogJHt0fXB4O31gLCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoaSksIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcImNvbXBlbnNhdGUtZm9yLXNjcm9sbGJhclwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldmVhbFNjcm9sbGJhcigpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFwiY29tcGVuc2F0ZS1mb3Itc2Nyb2xsYmFyXCIpO1xuICAgICAgICBjb25zdCB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmYW5jeWJveC1zdHlsZS1ub3Njcm9sbFwiKTtcbiAgICAgICAgdCAmJiB0LnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBjbGVhckNvbnRlbnQodCkge1xuICAgICAgICB0aGlzLkNhcm91c2VsLnRyaWdnZXIoXCJyZW1vdmVTbGlkZVwiLCB0KSwgdC4kY29udGVudCAmJiAodC4kY29udGVudC5yZW1vdmUoKSwgdC4kY29udGVudCA9IG51bGwpLCB0LiRjbG9zZUJ1dHRvbiAmJiAodC4kY2xvc2VCdXR0b24ucmVtb3ZlKCksIHQuJGNsb3NlQnV0dG9uID0gbnVsbCksIHQuX2NsYXNzTmFtZSAmJiB0LiRlbC5jbGFzc0xpc3QucmVtb3ZlKHQuX2NsYXNzTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHNldENvbnRlbnQodCwgZSwgaSA9IHt9KSB7XG4gICAgICAgIGxldCBzO1xuICAgICAgICBjb25zdCBvID0gdC4kZWw7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIFtcImltZ1wiLCBcImlmcmFtZVwiLCBcInZpZGVvXCIsIFwiYXVkaW9cIl0uaW5kZXhPZihlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpID4gLTEgPyAocyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHMuYXBwZW5kQ2hpbGQoZSkpIDogcyA9IGU7ZWxzZSB7XG4gICAgICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGUpO1xuICAgICAgICAgIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBzLmFwcGVuZENoaWxkKHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0LmZpbHRlciAmJiAhdC5lcnJvciAmJiAocyA9IHMucXVlcnlTZWxlY3Rvcih0LmZpbHRlcikpLCBzIGluc3RhbmNlb2YgRWxlbWVudCkgcmV0dXJuIHQuX2NsYXNzTmFtZSA9IGBoYXMtJHtpLnN1ZmZpeCB8fCB0LnR5cGUgfHwgXCJ1bmtub3duXCJ9YCwgby5jbGFzc0xpc3QuYWRkKHQuX2NsYXNzTmFtZSksIHMuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X19jb250ZW50XCIpLCBcIm5vbmVcIiAhPT0gcy5zdHlsZS5kaXNwbGF5ICYmIFwibm9uZVwiICE9PSBnZXRDb21wdXRlZFN0eWxlKHMpLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpIHx8IChzLnN0eWxlLmRpc3BsYXkgPSB0LmRpc3BsYXkgfHwgdGhpcy5vcHRpb24oXCJkZWZhdWx0RGlzcGxheVwiKSB8fCBcImZsZXhcIiksIHQuaWQgJiYgcy5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0LmlkKSwgdC4kY29udGVudCA9IHMsIG8ucHJlcGVuZChzKSwgdGhpcy5tYW5hZ2VDbG9zZUJ1dHRvbih0KSwgXCJsb2FkaW5nXCIgIT09IHQuc3RhdGUgJiYgdGhpcy5yZXZlYWxDb250ZW50KHQpLCBzO1xuICAgICAgICB0aGlzLnNldEVycm9yKHQsIFwie3tFTEVNRU5UX05PVF9GT1VORH19XCIpO1xuICAgICAgfVxuXG4gICAgICBtYW5hZ2VDbG9zZUJ1dHRvbih0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB2b2lkIDAgPT09IHQuY2xvc2VCdXR0b24gPyB0aGlzLm9wdGlvbihcImNsb3NlQnV0dG9uXCIpIDogdC5jbG9zZUJ1dHRvbjtcbiAgICAgICAgaWYgKCFlIHx8IFwidG9wXCIgPT09IGUgJiYgdGhpcy4kY2xvc2VCdXR0b24pIHJldHVybjtcbiAgICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIGkuY2xhc3NMaXN0LmFkZChcImNhcm91c2VsX19idXR0b25cIiwgXCJpcy1jbG9zZVwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCB0aGlzLm9wdGlvbnMubDEwbi5DTE9TRSksIGkuaW5uZXJIVE1MID0gdGhpcy5vcHRpb24oXCJ0ZW1wbGF0ZS5jbG9zZUJ1dHRvblwiKSwgaS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdCA9PiB0aGlzLmNsb3NlKHQpKSwgXCJpbnNpZGVcIiA9PT0gZSA/ICh0LiRjbG9zZUJ1dHRvbiAmJiB0LiRjbG9zZUJ1dHRvbi5yZW1vdmUoKSwgdC4kY2xvc2VCdXR0b24gPSB0LiRjb250ZW50LmFwcGVuZENoaWxkKGkpKSA6IHRoaXMuJGNsb3NlQnV0dG9uID0gdGhpcy4kY29udGFpbmVyLmluc2VydEJlZm9yZShpLCB0aGlzLiRjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHJldmVhbENvbnRlbnQodCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJyZXZlYWxcIiwgdCksIHQuJGNvbnRlbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XG4gICAgICAgIGxldCBlID0gITE7XG4gICAgICAgIHQuZXJyb3IgfHwgXCJsb2FkaW5nXCIgPT09IHQuc3RhdGUgfHwgbnVsbCAhPT0gdGhpcy5DYXJvdXNlbC5wcmV2UGFnZSB8fCB0LmluZGV4ICE9PSB0aGlzLm9wdGlvbnMuc3RhcnRJbmRleCB8fCAoZSA9IHZvaWQgMCA9PT0gdC5zaG93Q2xhc3MgPyB0aGlzLm9wdGlvbihcInNob3dDbGFzc1wiKSA6IHQuc2hvd0NsYXNzKSwgZSA/ICh0LnN0YXRlID0gXCJhbmltYXRpbmdcIiwgdGhpcy5hbmltYXRlQ1NTKHQuJGNvbnRlbnQsIGUsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRvbmUodCk7XG4gICAgICAgIH0pKSA6IHRoaXMuZG9uZSh0KTtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0ZUNTUyh0LCBlLCBpKSB7XG4gICAgICAgIGlmICh0ICYmIHQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJhbmltYXRpb25lbmRcIiwge1xuICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgICAgIH0pKSwgIXQgfHwgIWUpIHJldHVybiB2b2lkIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGkgJiYgaSgpKTtcblxuICAgICAgICBjb25zdCBzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICBvLmN1cnJlbnRUYXJnZXQgPT09IHRoaXMgJiYgKHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBzKSwgaSAmJiBpKCksIHQuY2xhc3NMaXN0LnJlbW92ZShlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIHMpLCB0LmNsYXNzTGlzdC5hZGQoZSk7XG4gICAgICB9XG5cbiAgICAgIGRvbmUodCkge1xuICAgICAgICB0LnN0YXRlID0gXCJkb25lXCIsIHRoaXMudHJpZ2dlcihcImRvbmVcIiwgdCk7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmdldFNsaWRlKCk7XG4gICAgICAgIGUgJiYgdC5pbmRleCA9PT0gZS5pbmRleCAmJiB0aGlzLm9wdGlvbihcImF1dG9Gb2N1c1wiKSAmJiB0aGlzLmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIHNldEVycm9yKHQsIGUpIHtcbiAgICAgICAgdC5lcnJvciA9IGUsIHRoaXMuaGlkZUxvYWRpbmcodCksIHRoaXMuY2xlYXJDb250ZW50KHQpO1xuICAgICAgICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaS5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3gtZXJyb3JcIiksIGkuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZShlIHx8IFwiPHA+e3tFUlJPUn19PC9wPlwiKSwgdGhpcy5zZXRDb250ZW50KHQsIGksIHtcbiAgICAgICAgICBzdWZmaXg6IFwiZXJyb3JcIlxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2hvd0xvYWRpbmcodCkge1xuICAgICAgICB0LnN0YXRlID0gXCJsb2FkaW5nXCIsIHQuJGVsLmNsYXNzTGlzdC5hZGQoXCJpcy1sb2FkaW5nXCIpO1xuICAgICAgICBsZXQgZSA9IHQuJGVsLnF1ZXJ5U2VsZWN0b3IoXCIuZmFuY3lib3hfX3NwaW5uZXJcIik7XG4gICAgICAgIGUgfHwgKGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBlLmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveF9fc3Bpbm5lclwiKSwgZS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbihcInRlbXBsYXRlLnNwaW5uZXJcIiksIGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLkNhcm91c2VsLlBhbnpvb20udmVsb2NpdHkgfHwgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KSwgdC4kZWwucHJlcGVuZChlKSk7XG4gICAgICB9XG5cbiAgICAgIGhpZGVMb2FkaW5nKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHQuJGVsICYmIHQuJGVsLnF1ZXJ5U2VsZWN0b3IoXCIuZmFuY3lib3hfX3NwaW5uZXJcIik7XG4gICAgICAgIGUgJiYgKGUucmVtb3ZlKCksIHQuJGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1sb2FkaW5nXCIpKSwgXCJsb2FkaW5nXCIgPT09IHQuc3RhdGUgJiYgKHRoaXMudHJpZ2dlcihcImxvYWRcIiwgdCksIHQuc3RhdGUgPSBcInJlYWR5XCIpO1xuICAgICAgfVxuXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5DYXJvdXNlbDtcbiAgICAgICAgdCAmJiB0LnBhZ2VzLmxlbmd0aCA+IDEgJiYgdC5zbGlkZU5leHQoKTtcbiAgICAgIH1cblxuICAgICAgcHJldigpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuQ2Fyb3VzZWw7XG4gICAgICAgIHQgJiYgdC5wYWdlcy5sZW5ndGggPiAxICYmIHQuc2xpZGVQcmV2KCk7XG4gICAgICB9XG5cbiAgICAgIGp1bXBUbyguLi50KSB7XG4gICAgICAgIHRoaXMuQ2Fyb3VzZWwgJiYgdGhpcy5DYXJvdXNlbC5zbGlkZVRvKC4uLnQpO1xuICAgICAgfVxuXG4gICAgICBpc0Nsb3NpbmcoKSB7XG4gICAgICAgIHJldHVybiBbXCJjbG9zaW5nXCIsIFwiY3VzdG9tQ2xvc2luZ1wiLCBcImRlc3Ryb3lcIl0uaW5jbHVkZXModGhpcy5zdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlzVG9wbW9zdCgpIHtcbiAgICAgICAgcmV0dXJuIFIuZ2V0SW5zdGFuY2UoKS5pZCA9PSB0aGlzLmlkO1xuICAgICAgfVxuXG4gICAgICBjbG9zZSh0KSB7XG4gICAgICAgIGlmICh0ICYmIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5pc0Nsb3NpbmcoKSkgcmV0dXJuO1xuICAgICAgICBpZiAoITEgPT09IHRoaXMudHJpZ2dlcihcInNob3VsZENsb3NlXCIsIHQpKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID0gXCJjbG9zaW5nXCIsIHRoaXMuQ2Fyb3VzZWwuUGFuem9vbS5kZXN0cm95KCksIHRoaXMuZGV0YWNoRXZlbnRzKCksIHRoaXMudHJpZ2dlcihcImNsb3NpbmdcIiwgdCksIFwiZGVzdHJveVwiID09PSB0aGlzLnN0YXRlKSByZXR1cm47XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIiksIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaXMtY2xvc2luZ1wiKTtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZ2V0U2xpZGUoKTtcblxuICAgICAgICBpZiAodGhpcy5DYXJvdXNlbC5zbGlkZXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICB0LiRjb250ZW50ICYmIHQuaW5kZXggIT09IGUuaW5kZXggJiYgdGhpcy5DYXJvdXNlbC50cmlnZ2VyKFwicmVtb3ZlU2xpZGVcIiwgdCk7XG4gICAgICAgIH0pLCBcImNsb3NpbmdcIiA9PT0gdGhpcy5zdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHQgPSB2b2lkIDAgPT09IGUuaGlkZUNsYXNzID8gdGhpcy5vcHRpb24oXCJoaWRlQ2xhc3NcIikgOiBlLmhpZGVDbGFzcztcbiAgICAgICAgICB0aGlzLmFuaW1hdGVDU1MoZS4kY29udGVudCwgdCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgfSwgITApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmIChcImRlc3Ryb3lcIiA9PT0gdGhpcy5zdGF0ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJkZXN0cm95XCIsIHRoaXMudHJpZ2dlcihcImRlc3Ryb3lcIik7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbihcInBsYWNlRm9jdXNCYWNrXCIpID8gdGhpcy5vcHRpb24oXCJ0cmlnZ2VyVGFyZ2V0XCIsIHRoaXMuZ2V0U2xpZGUoKS4kdHJpZ2dlcikgOiBudWxsO1xuICAgICAgICB0aGlzLkNhcm91c2VsLmRlc3Ryb3koKSwgdGhpcy5kZXRhY2hQbHVnaW5zKCksIHRoaXMuQ2Fyb3VzZWwgPSBudWxsLCB0aGlzLm9wdGlvbnMgPSB7fSwgdGhpcy5ldmVudHMgPSB7fSwgdGhpcy4kY29udGFpbmVyLnJlbW92ZSgpLCB0aGlzLiRjb250YWluZXIgPSB0aGlzLiRiYWNrZHJvcCA9IHRoaXMuJGNhcm91c2VsID0gbnVsbCwgdCAmJiB3KHQpLCBJLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICAgICAgY29uc3QgZSA9IFIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgZSA/IGUuZm9jdXMoKSA6IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIndpdGgtZmFuY3lib3hcIiksIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImlzLXVzaW5nLW1vdXNlXCIpLCB0aGlzLnJldmVhbFNjcm9sbGJhcigpKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIHNob3codCwgZSA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUih0LCBlKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGZyb21FdmVudCh0LCBlID0ge30pIHtcbiAgICAgICAgaWYgKHQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgICBpZiAodC5idXR0b24gJiYgMCAhPT0gdC5idXR0b24pIHJldHVybjtcbiAgICAgICAgaWYgKHQuY3RybEtleSB8fCB0Lm1ldGFLZXkgfHwgdC5zaGlmdEtleSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBpID0gdC5jb21wb3NlZFBhdGgoKVswXTtcbiAgICAgICAgbGV0IHMsXG4gICAgICAgICAgICBvLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIGEgPSBpO1xuXG4gICAgICAgIGlmICgoYS5tYXRjaGVzKFwiW2RhdGEtZmFuY3lib3gtdHJpZ2dlcl1cIikgfHwgKGEgPSBhLmNsb3Nlc3QoXCJbZGF0YS1mYW5jeWJveC10cmlnZ2VyXVwiKSkpICYmIChlLnRyaWdnZXJUYXJnZXQgPSBhLCBzID0gYSAmJiBhLmRhdGFzZXQgJiYgYS5kYXRhc2V0LmZhbmN5Ym94VHJpZ2dlciksIHMpIHtcbiAgICAgICAgICBjb25zdCB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtZmFuY3lib3g9XCIke3N9XCJdYCksXG4gICAgICAgICAgICAgICAgZSA9IHBhcnNlSW50KGEuZGF0YXNldC5mYW5jeWJveEluZGV4LCAxMCkgfHwgMDtcbiAgICAgICAgICBhID0gdC5sZW5ndGggPyB0W2VdIDogYTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFycmF5LmZyb20oUi5vcGVuZXJzLmtleXMoKSkucmV2ZXJzZSgpLnNvbWUoZSA9PiB7XG4gICAgICAgICAgbiA9IGEgfHwgaTtcbiAgICAgICAgICBsZXQgcyA9ICExO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG4gaW5zdGFuY2VvZiBFbGVtZW50ICYmIChcInN0cmluZ1wiID09IHR5cGVvZiBlIHx8IGUgaW5zdGFuY2VvZiBTdHJpbmcpICYmIChzID0gbi5tYXRjaGVzKGUpIHx8IChuID0gbi5jbG9zZXN0KGUpKSk7XG4gICAgICAgICAgfSBjYXRjaCAodCkge31cblxuICAgICAgICAgIHJldHVybiAhIXMgJiYgKHQucHJldmVudERlZmF1bHQoKSwgbyA9IGUsICEwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByID0gITE7XG5cbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICBlLmV2ZW50ID0gdCwgZS50YXJnZXQgPSBuLCBuLm9yaWdUYXJnZXQgPSBpLCByID0gUi5mcm9tT3BlbmVyKG8sIGUpO1xuICAgICAgICAgIGNvbnN0IHMgPSBSLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgcyAmJiBcInJlYWR5XCIgPT09IHMuc3RhdGUgJiYgdC5kZXRhaWwgJiYgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiaXMtdXNpbmctbW91c2VcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGZyb21PcGVuZXIodCwgaSA9IHt9KSB7XG4gICAgICAgIGxldCBzID0gW10sXG4gICAgICAgICAgICBvID0gaS5zdGFydEluZGV4IHx8IDAsXG4gICAgICAgICAgICBuID0gaS50YXJnZXQgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgYSA9IHZvaWQgMCAhPT0gKGkgPSBlKHt9LCBpLCBSLm9wZW5lcnMuZ2V0KHQpKSkuZ3JvdXBBbGwgJiYgaS5ncm91cEFsbCxcbiAgICAgICAgICAgICAgciA9IHZvaWQgMCA9PT0gaS5ncm91cEF0dHIgPyBcImRhdGEtZmFuY3lib3hcIiA6IGkuZ3JvdXBBdHRyLFxuICAgICAgICAgICAgICBoID0gciAmJiBuID8gbi5nZXRBdHRyaWJ1dGUoYCR7cn1gKSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKCFuIHx8IGggfHwgYSkge1xuICAgICAgICAgIGNvbnN0IGUgPSBpLnJvb3QgfHwgKG4gPyBuLmdldFJvb3ROb2RlKCkgOiBkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICBzID0gW10uc2xpY2UuY2FsbChlLnF1ZXJ5U2VsZWN0b3JBbGwodCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gJiYgIWEgJiYgKHMgPSBoID8gcy5maWx0ZXIodCA9PiB0LmdldEF0dHJpYnV0ZShgJHtyfWApID09PSBoKSA6IFtuXSksICFzLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICBjb25zdCBsID0gUi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICByZXR1cm4gIShsICYmIHMuaW5kZXhPZihsLm9wdGlvbnMuJHRyaWdnZXIpID4gLTEpICYmIChvID0gbiA/IHMuaW5kZXhPZihuKSA6IG8sIHMgPSBzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGNvbnN0IGUgPSBbXCJmYWxzZVwiLCBcIjBcIiwgXCJub1wiLCBcIm51bGxcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgICAgICAgICAgICAgaSA9IFtcInRydWVcIiwgXCIxXCIsIFwieWVzXCJdLFxuICAgICAgICAgICAgICAgIHMgPSBPYmplY3QuYXNzaWduKHt9LCB0LmRhdGFzZXQpLFxuICAgICAgICAgICAgICAgIG8gPSB7fTtcblxuICAgICAgICAgIGZvciAobGV0IFt0LCBuXSBvZiBPYmplY3QuZW50cmllcyhzKSkgaWYgKFwiZmFuY3lib3hcIiAhPT0gdCkgaWYgKFwid2lkdGhcIiA9PT0gdCB8fCBcImhlaWdodFwiID09PSB0KSBvW2BfJHt0fWBdID0gbjtlbHNlIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBuIHx8IG4gaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YobikgPiAtMSkgb1t0XSA9ICExO2Vsc2UgaWYgKGkuaW5kZXhPZihvW3RdKSA+IC0xKSBvW3RdID0gITA7ZWxzZSB0cnkge1xuICAgICAgICAgICAgICBvW3RdID0gSlNPTi5wYXJzZShuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgb1t0XSA9IG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIG9bdF0gPSBuO1xuXG4gICAgICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIChvLiR0cmlnZ2VyID0gdCksIG87XG4gICAgICAgIH0pLCBuZXcgUihzLCBlKHt9LCBpLCB7XG4gICAgICAgICAgc3RhcnRJbmRleDogbyxcbiAgICAgICAgICAkdHJpZ2dlcjogblxuICAgICAgICB9KSkpO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgYmluZCh0LCBlID0ge30pIHtcbiAgICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBSLmZyb21FdmVudCwgITEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdiAmJiAoUi5vcGVuZXJzLnNpemUgfHwgKC9jb21wbGV0ZXxpbnRlcmFjdGl2ZXxsb2FkZWQvLnRlc3QoZG9jdW1lbnQucmVhZHlTdGF0ZSkgPyBpKCkgOiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBpKSksIFIub3BlbmVycy5zZXQodCwgZSkpO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgdW5iaW5kKHQpIHtcbiAgICAgICAgUi5vcGVuZXJzLmRlbGV0ZSh0KSwgUi5vcGVuZXJzLnNpemUgfHwgUi5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBkZXN0cm95KCkge1xuICAgICAgICBsZXQgdDtcblxuICAgICAgICBmb3IgKDsgdCA9IFIuZ2V0SW5zdGFuY2UoKTspIHQuZGVzdHJveSgpO1xuXG4gICAgICAgIFIub3BlbmVycyA9IG5ldyBNYXAoKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgUi5mcm9tRXZlbnQsICExKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICAgICAgaWYgKHQpIHJldHVybiBJLmdldCh0KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oSS52YWx1ZXMoKSkucmV2ZXJzZSgpLmZpbmQodCA9PiAhdC5pc0Nsb3NpbmcoKSAmJiB0KSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICBzdGF0aWMgY2xvc2UodCA9ICEwLCBlKSB7XG4gICAgICAgIGlmICh0KSBmb3IgKGNvbnN0IHQgb2YgSS52YWx1ZXMoKSkgdC5jbG9zZShlKTtlbHNlIHtcbiAgICAgICAgICBjb25zdCB0ID0gUi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgIHQgJiYgdC5jbG9zZShlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0aWMgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgdCA9IFIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdCAmJiB0Lm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGljIHByZXYoKSB7XG4gICAgICAgIGNvbnN0IHQgPSBSLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHQgJiYgdC5wcmV2KCk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBSLnZlcnNpb24gPSBcIjQuMC4zMVwiLCBSLmRlZmF1bHRzID0gTSwgUi5vcGVuZXJzID0gbmV3IE1hcCgpLCBSLlBsdWdpbnMgPSBPLCBSLmJpbmQoXCJbZGF0YS1mYW5jeWJveF1cIik7XG5cbiAgICBmb3IgKGNvbnN0IFt0LCBlXSBvZiBPYmplY3QuZW50cmllcyhSLlBsdWdpbnMgfHwge30pKSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUuY3JlYXRlICYmIGUuY3JlYXRlKFIpO1xuXG4gICAgdmFyIHdwY2Y3RWxtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLndwY2Y3Jyk7XG5cbiAgICBpZiAod3BjZjdFbG0pIHtcbiAgICAgIHdwY2Y3RWxtLmFkZEV2ZW50TGlzdGVuZXIoJ3dwY2Y3bWFpbHNlbnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgIGNsb3NlKCk7XG4gICAgICB9LCBmYWxzZSk7XG4gICAgICB3cGNmN0VsbS5hZGRFdmVudExpc3RlbmVyKCd3cGNmN3N1Ym1pdCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnc3VibWl0dGVkJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRldGFpbC5hcGlSZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgUi5zaG93KFt7XG4gICAgICAgICAgc3JjOiBldmVudC5kZXRhaWwuYXBpUmVzcG9uc2UubWVzc2FnZSxcbiAgICAgICAgICB0eXBlOiBcImh0bWxcIlxuICAgICAgICB9XSk7XG4gICAgICB9LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIG5vdWlzbGlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgICBmYWN0b3J5KGV4cG9ydHMpIDtcbiAgICB9KShjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAgICAgZXhwb3J0cy5QaXBzTW9kZSA9IHZvaWQgMDtcblxuICAgICAgKGZ1bmN0aW9uIChQaXBzTW9kZSkge1xuICAgICAgICBQaXBzTW9kZVtcIlJhbmdlXCJdID0gXCJyYW5nZVwiO1xuICAgICAgICBQaXBzTW9kZVtcIlN0ZXBzXCJdID0gXCJzdGVwc1wiO1xuICAgICAgICBQaXBzTW9kZVtcIlBvc2l0aW9uc1wiXSA9IFwicG9zaXRpb25zXCI7XG4gICAgICAgIFBpcHNNb2RlW1wiQ291bnRcIl0gPSBcImNvdW50XCI7XG4gICAgICAgIFBpcHNNb2RlW1wiVmFsdWVzXCJdID0gXCJ2YWx1ZXNcIjtcbiAgICAgIH0pKGV4cG9ydHMuUGlwc01vZGUgfHwgKGV4cG9ydHMuUGlwc01vZGUgPSB7fSkpO1xuXG4gICAgICBleHBvcnRzLlBpcHNUeXBlID0gdm9pZCAwO1xuXG4gICAgICAoZnVuY3Rpb24gKFBpcHNUeXBlKSB7XG4gICAgICAgIFBpcHNUeXBlW1BpcHNUeXBlW1wiTm9uZVwiXSA9IC0xXSA9IFwiTm9uZVwiO1xuICAgICAgICBQaXBzVHlwZVtQaXBzVHlwZVtcIk5vVmFsdWVcIl0gPSAwXSA9IFwiTm9WYWx1ZVwiO1xuICAgICAgICBQaXBzVHlwZVtQaXBzVHlwZVtcIkxhcmdlVmFsdWVcIl0gPSAxXSA9IFwiTGFyZ2VWYWx1ZVwiO1xuICAgICAgICBQaXBzVHlwZVtQaXBzVHlwZVtcIlNtYWxsVmFsdWVcIl0gPSAyXSA9IFwiU21hbGxWYWx1ZVwiO1xuICAgICAgfSkoZXhwb3J0cy5QaXBzVHlwZSB8fCAoZXhwb3J0cy5QaXBzVHlwZSA9IHt9KSk7IC8vcmVnaW9uIEhlbHBlciBNZXRob2RzXG5cblxuICAgICAgZnVuY3Rpb24gaXNWYWxpZEZvcm1hdHRlcihlbnRyeSkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZFBhcnRpYWxGb3JtYXR0ZXIoZW50cnkpICYmIHR5cGVvZiBlbnRyeS5mcm9tID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGVudHJ5KSB7XG4gICAgICAgIC8vIHBhcnRpYWwgZm9ybWF0dGVycyBvbmx5IG5lZWQgYSB0byBmdW5jdGlvbiBhbmQgbm90IGEgZnJvbSBmdW5jdGlvblxuICAgICAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBlbnRyeS50byA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsKSB7XG4gICAgICAgIGVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gQmluZGFibGUgdmVyc2lvblxuXG5cbiAgICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSAvLyBSZW1vdmVzIGR1cGxpY2F0ZXMgZnJvbSBhbiBhcnJheS5cblxuXG4gICAgICBmdW5jdGlvbiB1bmlxdWUoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHJldHVybiAhdGhpc1thXSA/IHRoaXNbYV0gPSB0cnVlIDogZmFsc2U7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH0gLy8gUm91bmQgYSB2YWx1ZSB0byB0aGUgY2xvc2VzdCAndG8nLlxuXG5cbiAgICAgIGZ1bmN0aW9uIGNsb3Nlc3QodmFsdWUsIHRvKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gdG8pICogdG87XG4gICAgICB9IC8vIEN1cnJlbnQgcG9zaXRpb24gb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQuXG5cblxuICAgICAgZnVuY3Rpb24gb2Zmc2V0KGVsZW0sIG9yaWVudGF0aW9uKSB7XG4gICAgICAgIHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGdldFBhZ2VPZmZzZXQoZG9jKTsgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNvbnRhaW5zIGxlZnQgc2Nyb2xsIGluIENocm9tZSBvbiBBbmRyb2lkLlxuICAgICAgICAvLyBJIGhhdmVuJ3QgZm91bmQgYSBmZWF0dXJlIGRldGVjdGlvbiB0aGF0IHByb3ZlcyB0aGlzLiBXb3JzdCBjYXNlXG4gICAgICAgIC8vIHNjZW5hcmlvIG9uIG1pcy1tYXRjaDogdGhlICd0YXAnIGZlYXR1cmUgb24gaG9yaXpvbnRhbCBzbGlkZXJzIGJyZWFrcy5cblxuICAgICAgICBpZiAoL3dlYmtpdC4qQ2hyb21lLipNb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgcGFnZU9mZnNldC54ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcmllbnRhdGlvbiA/IHJlY3QudG9wICsgcGFnZU9mZnNldC55IC0gZG9jRWxlbS5jbGllbnRUb3AgOiByZWN0LmxlZnQgKyBwYWdlT2Zmc2V0LnggLSBkb2NFbGVtLmNsaWVudExlZnQ7XG4gICAgICB9IC8vIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgbnVtZXJpY2FsLlxuXG5cbiAgICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oYSkgJiYgaXNGaW5pdGUoYSk7XG4gICAgICB9IC8vIFNldHMgYSBjbGFzcyBhbmQgcmVtb3ZlcyBpdCBhZnRlciBbZHVyYXRpb25dIG1zLlxuXG5cbiAgICAgIGZ1bmN0aW9uIGFkZENsYXNzRm9yKGVsZW1lbnQsIGNsYXNzTmFtZSwgZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBMaW1pdHMgYSB2YWx1ZSB0byAwIC0gMTAwXG5cblxuICAgICAgZnVuY3Rpb24gbGltaXQoYSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oYSwgMTAwKSwgMCk7XG4gICAgICB9IC8vIFdyYXBzIGEgdmFyaWFibGUgYXMgYW4gYXJyYXksIGlmIGl0IGlzbid0IG9uZSB5ZXQuXG4gICAgICAvLyBOb3RlIHRoYXQgYW4gaW5wdXQgYXJyYXkgaXMgcmV0dXJuZWQgYnkgcmVmZXJlbmNlIVxuXG5cbiAgICAgIGZ1bmN0aW9uIGFzQXJyYXkoYSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XG4gICAgICB9IC8vIENvdW50cyBkZWNpbWFsc1xuXG5cbiAgICAgIGZ1bmN0aW9uIGNvdW50RGVjaW1hbHMobnVtU3RyKSB7XG4gICAgICAgIG51bVN0ciA9IFN0cmluZyhudW1TdHIpO1xuICAgICAgICB2YXIgcGllY2VzID0gbnVtU3RyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHBpZWNlcy5sZW5ndGggPiAxID8gcGllY2VzWzFdLmxlbmd0aCA6IDA7XG4gICAgICB9IC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNhZGRfY2xhc3NcblxuXG4gICAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QgJiYgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20vI3JlbW92ZV9jbGFzc1xuXG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCAmJiAhL1xccy8udGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXnxcXFxcYilcIiArIGNsYXNzTmFtZS5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXFxcYnwkKVwiLCBcImdpXCIpLCBcIiBcIik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaHR0cHM6Ly9wbGFpbmpzLmNvbS9qYXZhc2NyaXB0L2F0dHJpYnV0ZXMvYWRkaW5nLXJlbW92aW5nLWFuZC10ZXN0aW5nLWZvci1jbGFzc2VzLTkvXG5cblxuICAgICAgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0ID8gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkgOiBuZXcgUmVnRXhwKFwiXFxcXGJcIiArIGNsYXNzTmFtZSArIFwiXFxcXGJcIikudGVzdChlbC5jbGFzc05hbWUpO1xuICAgICAgfSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3Njcm9sbFkjTm90ZXNcblxuXG4gICAgICBmdW5jdGlvbiBnZXRQYWdlT2Zmc2V0KGRvYykge1xuICAgICAgICB2YXIgc3VwcG9ydFBhZ2VPZmZzZXQgPSB3aW5kb3cucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGlzQ1NTMUNvbXBhdCA9IChkb2MuY29tcGF0TW9kZSB8fCBcIlwiKSA9PT0gXCJDU1MxQ29tcGF0XCI7XG4gICAgICAgIHZhciB4ID0gc3VwcG9ydFBhZ2VPZmZzZXQgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiBpc0NTUzFDb21wYXQgPyBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgOiBkb2MuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgeSA9IHN1cHBvcnRQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogaXNDU1MxQ29tcGF0ID8gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBkb2MuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgICB9IC8vIHdlIHByb3ZpZGUgYSBmdW5jdGlvbiB0byBjb21wdXRlIGNvbnN0YW50cyBpbnN0ZWFkXG4gICAgICAvLyBvZiBhY2Nlc3Npbmcgd2luZG93LiogYXMgc29vbiBhcyB0aGUgbW9kdWxlIG5lZWRzIGl0XG4gICAgICAvLyBzbyB0aGF0IHdlIGRvIG5vdCBjb21wdXRlIGFueXRoaW5nIGlmIG5vdCBuZWVkZWRcblxuXG4gICAgICBmdW5jdGlvbiBnZXRBY3Rpb25zKCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGV2ZW50cyB0byBiaW5kLiBJRTExIGltcGxlbWVudHMgcG9pbnRlckV2ZW50cyB3aXRob3V0XG4gICAgICAgIC8vIGEgcHJlZml4LCB3aGljaCBicmVha3MgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBJRTEwIGltcGxlbWVudGF0aW9uLlxuICAgICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCA/IHtcbiAgICAgICAgICBzdGFydDogXCJwb2ludGVyZG93blwiLFxuICAgICAgICAgIG1vdmU6IFwicG9pbnRlcm1vdmVcIixcbiAgICAgICAgICBlbmQ6IFwicG9pbnRlcnVwXCJcbiAgICAgICAgfSA6IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCA/IHtcbiAgICAgICAgICBzdGFydDogXCJNU1BvaW50ZXJEb3duXCIsXG4gICAgICAgICAgbW92ZTogXCJNU1BvaW50ZXJNb3ZlXCIsXG4gICAgICAgICAgZW5kOiBcIk1TUG9pbnRlclVwXCJcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBzdGFydDogXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiLFxuICAgICAgICAgIG1vdmU6IFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLFxuICAgICAgICAgIGVuZDogXCJtb3VzZXVwIHRvdWNoZW5kXCJcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWRcbiAgICAgIC8vIElzc3VlICM3ODVcblxuXG4gICAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1Bhc3NpdmUoKSB7XG4gICAgICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBvcHRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0U3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuQ1NTICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuICAgICAgfSAvL2VuZHJlZ2lvblxuICAgICAgLy9yZWdpb24gUmFuZ2UgQ2FsY3VsYXRpb25cbiAgICAgIC8vIERldGVybWluZSB0aGUgc2l6ZSBvZiBhIHN1Yi1yYW5nZSBpbiByZWxhdGlvbiB0byBhIGZ1bGwgcmFuZ2UuXG5cblxuICAgICAgZnVuY3Rpb24gc3ViUmFuZ2VSYXRpbyhwYSwgcGIpIHtcbiAgICAgICAgcmV0dXJuIDEwMCAvIChwYiAtIHBhKTtcbiAgICAgIH0gLy8gKHBlcmNlbnRhZ2UpIEhvdyBtYW55IHBlcmNlbnQgaXMgdGhpcyB2YWx1ZSBvZiB0aGlzIHJhbmdlP1xuXG5cbiAgICAgIGZ1bmN0aW9uIGZyb21QZXJjZW50YWdlKHJhbmdlLCB2YWx1ZSwgc3RhcnRSYW5nZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgKiAxMDAgLyAocmFuZ2Vbc3RhcnRSYW5nZSArIDFdIC0gcmFuZ2Vbc3RhcnRSYW5nZV0pO1xuICAgICAgfSAvLyAocGVyY2VudGFnZSkgV2hlcmUgaXMgdGhpcyB2YWx1ZSBvbiB0aGlzIHJhbmdlP1xuXG5cbiAgICAgIGZ1bmN0aW9uIHRvUGVyY2VudGFnZShyYW5nZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZyb21QZXJjZW50YWdlKHJhbmdlLCByYW5nZVswXSA8IDAgPyB2YWx1ZSArIE1hdGguYWJzKHJhbmdlWzBdKSA6IHZhbHVlIC0gcmFuZ2VbMF0sIDApO1xuICAgICAgfSAvLyAodmFsdWUpIEhvdyBtdWNoIGlzIHRoaXMgcGVyY2VudGFnZSBvbiB0aGlzIHJhbmdlP1xuXG5cbiAgICAgIGZ1bmN0aW9uIGlzUGVyY2VudGFnZShyYW5nZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICogKHJhbmdlWzFdIC0gcmFuZ2VbMF0pIC8gMTAwICsgcmFuZ2VbMF07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEoodmFsdWUsIGFycikge1xuICAgICAgICB2YXIgaiA9IDE7XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlID49IGFycltqXSkge1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqO1xuICAgICAgfSAvLyAocGVyY2VudGFnZSkgSW5wdXQgYSB2YWx1ZSwgZmluZCB3aGVyZSwgb24gYSBzY2FsZSBvZiAwLTEwMCwgaXQgYXBwbGllcy5cblxuXG4gICAgICBmdW5jdGlvbiB0b1N0ZXBwaW5nKHhWYWwsIHhQY3QsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSB4VmFsLnNsaWNlKC0xKVswXSkge1xuICAgICAgICAgIHJldHVybiAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhWYWwpO1xuICAgICAgICB2YXIgdmEgPSB4VmFsW2ogLSAxXTtcbiAgICAgICAgdmFyIHZiID0geFZhbFtqXTtcbiAgICAgICAgdmFyIHBhID0geFBjdFtqIC0gMV07XG4gICAgICAgIHZhciBwYiA9IHhQY3Rbal07XG4gICAgICAgIHJldHVybiBwYSArIHRvUGVyY2VudGFnZShbdmEsIHZiXSwgdmFsdWUpIC8gc3ViUmFuZ2VSYXRpbyhwYSwgcGIpO1xuICAgICAgfSAvLyAodmFsdWUpIElucHV0IGEgcGVyY2VudGFnZSwgZmluZCB3aGVyZSBpdCBpcyBvbiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxuXG5cbiAgICAgIGZ1bmN0aW9uIGZyb21TdGVwcGluZyh4VmFsLCB4UGN0LCB2YWx1ZSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyByYW5nZSBncm91cCB0aGF0IGZpdHMgMTAwXG4gICAgICAgIGlmICh2YWx1ZSA+PSAxMDApIHtcbiAgICAgICAgICByZXR1cm4geFZhbC5zbGljZSgtMSlbMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhQY3QpO1xuICAgICAgICB2YXIgdmEgPSB4VmFsW2ogLSAxXTtcbiAgICAgICAgdmFyIHZiID0geFZhbFtqXTtcbiAgICAgICAgdmFyIHBhID0geFBjdFtqIC0gMV07XG4gICAgICAgIHZhciBwYiA9IHhQY3Rbal07XG4gICAgICAgIHJldHVybiBpc1BlcmNlbnRhZ2UoW3ZhLCB2Yl0sICh2YWx1ZSAtIHBhKSAqIHN1YlJhbmdlUmF0aW8ocGEsIHBiKSk7XG4gICAgICB9IC8vIChwZXJjZW50YWdlKSBHZXQgdGhlIHN0ZXAgdGhhdCBhcHBsaWVzIGF0IGEgY2VydGFpbiB2YWx1ZS5cblxuXG4gICAgICBmdW5jdGlvbiBnZXRTdGVwKHhQY3QsIHhTdGVwcywgc25hcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAxMDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhQY3QpO1xuICAgICAgICB2YXIgYSA9IHhQY3RbaiAtIDFdO1xuICAgICAgICB2YXIgYiA9IHhQY3Rbal07IC8vIElmICdzbmFwJyBpcyBzZXQsIHN0ZXBzIGFyZSB1c2VkIGFzIGZpeGVkIHBvaW50cyBvbiB0aGUgc2xpZGVyLlxuXG4gICAgICAgIGlmIChzbmFwKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBwb3NpdGlvbiwgYSBvciBiLlxuICAgICAgICAgIGlmICh2YWx1ZSAtIGEgPiAoYiAtIGEpIC8gMikge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXhTdGVwc1tqIC0gMV0pIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geFBjdFtqIC0gMV0gKyBjbG9zZXN0KHZhbHVlIC0geFBjdFtqIC0gMV0sIHhTdGVwc1tqIC0gMV0pO1xuICAgICAgfSAvL2VuZHJlZ2lvblxuICAgICAgLy9yZWdpb24gU3BlY3RydW1cblxuXG4gICAgICB2YXIgU3BlY3RydW0gPVxuICAgICAgLyoqIEBjbGFzcyAqL1xuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTcGVjdHJ1bShlbnRyeSwgc25hcCwgc2luZ2xlU3RlcCkge1xuICAgICAgICAgIHRoaXMueFBjdCA9IFtdO1xuICAgICAgICAgIHRoaXMueFZhbCA9IFtdO1xuICAgICAgICAgIHRoaXMueFN0ZXBzID0gW107XG4gICAgICAgICAgdGhpcy54TnVtU3RlcHMgPSBbXTtcbiAgICAgICAgICB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwID0gW107XG4gICAgICAgICAgdGhpcy54U3RlcHMgPSBbc2luZ2xlU3RlcCB8fCBmYWxzZV07XG4gICAgICAgICAgdGhpcy54TnVtU3RlcHMgPSBbZmFsc2VdO1xuICAgICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XG4gICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgIHZhciBvcmRlcmVkID0gW107IC8vIE1hcCB0aGUgb2JqZWN0IGtleXMgdG8gYW4gYXJyYXkuXG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIG9yZGVyZWQucHVzaChbYXNBcnJheShlbnRyeVtpbmRleF0pLCBpbmRleF0pO1xuICAgICAgICAgIH0pOyAvLyBTb3J0IGFsbCBlbnRyaWVzIGJ5IHZhbHVlIChudW1lcmljIHNvcnQpLlxuXG4gICAgICAgICAgb3JkZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYVswXVswXSAtIGJbMF1bMF07XG4gICAgICAgICAgfSk7IC8vIENvbnZlcnQgYWxsIGVudHJpZXMgdG8gc3VicmFuZ2VzLlxuXG4gICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgb3JkZXJlZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRW50cnlQb2ludChvcmRlcmVkW2luZGV4XVsxXSwgb3JkZXJlZFtpbmRleF1bMF0pO1xuICAgICAgICAgIH0gLy8gU3RvcmUgdGhlIGFjdHVhbCBzdGVwIHZhbHVlcy5cbiAgICAgICAgICAvLyB4U3RlcHMgaXMgc29ydGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHhQY3QgYW5kIHhWYWwuXG5cblxuICAgICAgICAgIHRoaXMueE51bVN0ZXBzID0gdGhpcy54U3RlcHMuc2xpY2UoMCk7IC8vIENvbnZlcnQgYWxsIG51bWVyaWMgc3RlcHMgdG8gdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHN1YnJhbmdlIHRoZXkgcmVwcmVzZW50LlxuXG4gICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy54TnVtU3RlcHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN0ZXBQb2ludChpbmRleCwgdGhpcy54TnVtU3RlcHNbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2VzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy54TnVtU3RlcHMubGVuZ3RoIC0gMTsgaW5kZXgrKykge1xuICAgICAgICAgICAgZGlzdGFuY2VzW2luZGV4XSA9IGZyb21QZXJjZW50YWdlKHRoaXMueFZhbCwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGlzdGFuY2VzO1xuICAgICAgICB9OyAvLyBDYWxjdWxhdGUgdGhlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugb3ZlciB0aGUgd2hvbGUgc2NhbGUgb2YgcmFuZ2VzLlxuICAgICAgICAvLyBkaXJlY3Rpb246IDAgPSBiYWNrd2FyZHMgLyAxID0gZm9yd2FyZHNcblxuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXRBYnNvbHV0ZURpc3RhbmNlID0gZnVuY3Rpb24gKHZhbHVlLCBkaXN0YW5jZXMsIGRpcmVjdGlvbikge1xuICAgICAgICAgIHZhciB4UGN0X2luZGV4ID0gMDsgLy8gQ2FsY3VsYXRlIHJhbmdlIHdoZXJlIHRvIHN0YXJ0IGNhbGN1bGF0aW9uXG5cbiAgICAgICAgICBpZiAodmFsdWUgPCB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB3aGlsZSAodmFsdWUgPiB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdKSB7XG4gICAgICAgICAgICAgIHhQY3RfaW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB4UGN0X2luZGV4ID0gdGhpcy54UGN0Lmxlbmd0aCAtIDI7XG4gICAgICAgICAgfSAvLyBJZiBsb29raW5nIGJhY2t3YXJkcyBhbmQgdGhlIHZhbHVlIGlzIGV4YWN0bHkgYXQgYSByYW5nZSBzZXBhcmF0b3IgdGhlbiBsb29rIG9uZSByYW5nZSBmdXJ0aGVyXG5cblxuICAgICAgICAgIGlmICghZGlyZWN0aW9uICYmIHZhbHVlID09PSB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdKSB7XG4gICAgICAgICAgICB4UGN0X2luZGV4Kys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGlzdGFuY2VzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0X2ZhY3RvcjtcbiAgICAgICAgICB2YXIgcmVzdF9mYWN0b3IgPSAxO1xuICAgICAgICAgIHZhciByZXN0X3JlbF9kaXN0YW5jZSA9IGRpc3RhbmNlc1t4UGN0X2luZGV4XTtcbiAgICAgICAgICB2YXIgcmFuZ2VfcGN0ID0gMDtcbiAgICAgICAgICB2YXIgcmVsX3JhbmdlX2Rpc3RhbmNlID0gMDtcbiAgICAgICAgICB2YXIgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSAwO1xuICAgICAgICAgIHZhciByYW5nZV9jb3VudGVyID0gMDsgLy8gQ2FsY3VsYXRlIHdoYXQgcGFydCBvZiB0aGUgc3RhcnQgcmFuZ2UgdGhlIHZhbHVlIGlzXG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBzdGFydF9mYWN0b3IgPSAodmFsdWUgLSB0aGlzLnhQY3RbeFBjdF9pbmRleF0pIC8gKHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0gLSB0aGlzLnhQY3RbeFBjdF9pbmRleF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydF9mYWN0b3IgPSAodGhpcy54UGN0W3hQY3RfaW5kZXggKyAxXSAtIHZhbHVlKSAvICh0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdIC0gdGhpcy54UGN0W3hQY3RfaW5kZXhdKTtcbiAgICAgICAgICB9IC8vIERvIHVudGlsIHRoZSBjb21wbGV0ZSBkaXN0YW5jZSBhY3Jvc3MgcmFuZ2VzIGlzIGNhbGN1bGF0ZWRcblxuXG4gICAgICAgICAgd2hpbGUgKHJlc3RfcmVsX2Rpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwZXJjZW50YWdlIG9mIHRvdGFsIHJhbmdlXG4gICAgICAgICAgICByYW5nZV9wY3QgPSB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDEgKyByYW5nZV9jb3VudGVyXSAtIHRoaXMueFBjdFt4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl07IC8vIERldGVjdCBpZiB0aGUgbWFyZ2luLCBwYWRkaW5nIG9yIGxpbWl0IGlzIGxhcmdlciB0aGVuIHRoZSBjdXJyZW50IHJhbmdlIGFuZCBjYWxjdWxhdGVcblxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlc1t4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl0gKiByZXN0X2ZhY3RvciArIDEwMCAtIHN0YXJ0X2ZhY3RvciAqIDEwMCA+IDEwMCkge1xuICAgICAgICAgICAgICAvLyBJZiBsYXJnZXIgdGhlbiB0YWtlIHRoZSBwZXJjZW50dWFsIGRpc3RhbmNlIG9mIHRoZSB3aG9sZSByYW5nZVxuICAgICAgICAgICAgICByZWxfcmFuZ2VfZGlzdGFuY2UgPSByYW5nZV9wY3QgKiBzdGFydF9mYWN0b3I7IC8vIFJlc3QgZmFjdG9yIG9mIHJlbGF0aXZlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugc3RpbGwgdG8gYmUgY2FsY3VsYXRlZFxuXG4gICAgICAgICAgICAgIHJlc3RfZmFjdG9yID0gKHJlc3RfcmVsX2Rpc3RhbmNlIC0gMTAwICogc3RhcnRfZmFjdG9yKSAvIGRpc3RhbmNlc1t4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl07IC8vIFNldCBzdGFydCBmYWN0b3IgdG8gMSBhcyBmb3IgbmV4dCByYW5nZSBpdCBkb2VzIG5vdCBhcHBseS5cblxuICAgICAgICAgICAgICBzdGFydF9mYWN0b3IgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gSWYgc21hbGxlciBvciBlcXVhbCB0aGVuIHRha2UgdGhlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugb2YgdGhlIGNhbGN1bGF0ZSBwZXJjZW50dWFsIHBhcnQgb2YgdGhhdCByYW5nZVxuICAgICAgICAgICAgICByZWxfcmFuZ2VfZGlzdGFuY2UgPSBkaXN0YW5jZXNbeFBjdF9pbmRleCArIHJhbmdlX2NvdW50ZXJdICogcmFuZ2VfcGN0IC8gMTAwICogcmVzdF9mYWN0b3I7IC8vIE5vIHJlc3QgbGVmdCBhcyB0aGUgcmVzdCBmaXRzIGluIGN1cnJlbnQgcmFuZ2VcblxuICAgICAgICAgICAgICByZXN0X2ZhY3RvciA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSBhYnNfZGlzdGFuY2VfY291bnRlciAtIHJlbF9yYW5nZV9kaXN0YW5jZTsgLy8gTGltaXQgcmFuZ2UgdG8gZmlyc3QgcmFuZ2Ugd2hlbiBkaXN0YW5jZSBiZWNvbWVzIG91dHNpZGUgb2YgbWluaW11bSByYW5nZVxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLnhQY3QubGVuZ3RoICsgcmFuZ2VfY291bnRlciA+PSAxKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VfY291bnRlci0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhYnNfZGlzdGFuY2VfY291bnRlciA9IGFic19kaXN0YW5jZV9jb3VudGVyICsgcmVsX3JhbmdlX2Rpc3RhbmNlOyAvLyBMaW1pdCByYW5nZSB0byBsYXN0IHJhbmdlIHdoZW4gZGlzdGFuY2UgYmVjb21lcyBvdXRzaWRlIG9mIG1heGltdW0gcmFuZ2VcblxuICAgICAgICAgICAgICBpZiAodGhpcy54UGN0Lmxlbmd0aCAtIHJhbmdlX2NvdW50ZXIgPj0gMSkge1xuICAgICAgICAgICAgICAgIHJhbmdlX2NvdW50ZXIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBSZXN0IG9mIHJlbGF0aXZlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugc3RpbGwgdG8gYmUgY2FsY3VsYXRlZFxuXG5cbiAgICAgICAgICAgIHJlc3RfcmVsX2Rpc3RhbmNlID0gZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXSAqIHJlc3RfZmFjdG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZSArIGFic19kaXN0YW5jZV9jb3VudGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS50b1N0ZXBwaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b1N0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5mcm9tU3RlcHBpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbVN0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmdldFN0ZXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldFN0ZXAodGhpcy54UGN0LCB0aGlzLnhTdGVwcywgdGhpcy5zbmFwLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXREZWZhdWx0U3RlcCA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNEb3duLCBzaXplKSB7XG4gICAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpOyAvLyBXaGVuIGF0IHRoZSB0b3Agb3Igc3RlcHBpbmcgZG93biwgbG9vayBhdCB0aGUgcHJldmlvdXMgc3ViLXJhbmdlXG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IDEwMCB8fCBpc0Rvd24gJiYgdmFsdWUgPT09IHRoaXMueFBjdFtqIC0gMV0pIHtcbiAgICAgICAgICAgIGogPSBNYXRoLm1heChqIC0gMSwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICh0aGlzLnhWYWxbal0gLSB0aGlzLnhWYWxbaiAtIDFdKSAvIHNpemU7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmdldE5lYXJieVN0ZXBzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGVwQmVmb3JlOiB7XG4gICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHRoaXMueFZhbFtqIC0gMl0sXG4gICAgICAgICAgICAgIHN0ZXA6IHRoaXMueE51bVN0ZXBzW2ogLSAyXSxcbiAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaiAtIDJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpc1N0ZXA6IHtcbiAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2ogLSAxXSxcbiAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbaiAtIDFdLFxuICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqIC0gMV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGVwQWZ0ZXI6IHtcbiAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2pdLFxuICAgICAgICAgICAgICBzdGVwOiB0aGlzLnhOdW1TdGVwc1tqXSxcbiAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbal1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5jb3VudFN0ZXBEZWNpbWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RlcERlY2ltYWxzID0gdGhpcy54TnVtU3RlcHMubWFwKGNvdW50RGVjaW1hbHMpO1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBzdGVwRGVjaW1hbHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5oYXNOb1NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMueFZhbFswXSA9PT0gdGhpcy54VmFsW3RoaXMueFZhbC5sZW5ndGggLSAxXTtcbiAgICAgICAgfTsgLy8gT3V0c2lkZSB0ZXN0aW5nXG5cblxuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0ZXAodGhpcy50b1N0ZXBwaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmhhbmRsZUVudHJ5UG9pbnQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHBlcmNlbnRhZ2U7IC8vIENvdmVydCBtaW4vbWF4IHN5bnRheCB0byAwIGFuZCAxMDAuXG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAxMDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KGluZGV4KTtcbiAgICAgICAgICB9IC8vIENoZWNrIGZvciBjb3JyZWN0IGlucHV0LlxuXG5cbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYyhwZXJjZW50YWdlKSB8fCAhaXNOdW1lcmljKHZhbHVlWzBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3JhbmdlJyB2YWx1ZSBpc24ndCBudW1lcmljLlwiKTtcbiAgICAgICAgICB9IC8vIFN0b3JlIHZhbHVlcy5cblxuXG4gICAgICAgICAgdGhpcy54UGN0LnB1c2gocGVyY2VudGFnZSk7XG4gICAgICAgICAgdGhpcy54VmFsLnB1c2godmFsdWVbMF0pO1xuICAgICAgICAgIHZhciB2YWx1ZTEgPSBOdW1iZXIodmFsdWVbMV0pOyAvLyBOYU4gd2lsbCBldmFsdWF0ZSB0byBmYWxzZSB0b28sIGJ1dCB0byBrZWVwXG4gICAgICAgICAgLy8gbG9nZ2luZyBjbGVhciwgc2V0IHN0ZXAgZXhwbGljaXRseS4gTWFrZSBzdXJlXG4gICAgICAgICAgLy8gbm90IHRvIG92ZXJyaWRlIHRoZSAnc3RlcCcgc2V0dGluZyB3aXRoIGZhbHNlLlxuXG4gICAgICAgICAgaWYgKCFwZXJjZW50YWdlKSB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlMSkpIHtcbiAgICAgICAgICAgICAgdGhpcy54U3RlcHNbMF0gPSB2YWx1ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueFN0ZXBzLnB1c2goaXNOYU4odmFsdWUxKSA/IGZhbHNlIDogdmFsdWUxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwLnB1c2goMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmhhbmRsZVN0ZXBQb2ludCA9IGZ1bmN0aW9uIChpLCBuKSB7XG4gICAgICAgICAgLy8gSWdub3JlICdmYWxzZScgc3RlcHBpbmcuXG4gICAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcblxuXG4gICAgICAgICAgaWYgKHRoaXMueFZhbFtpXSA9PT0gdGhpcy54VmFsW2kgKyAxXSkge1xuICAgICAgICAgICAgdGhpcy54U3RlcHNbaV0gPSB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2ldID0gdGhpcy54VmFsW2ldO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gRmFjdG9yIHRvIHJhbmdlIHJhdGlvXG5cblxuICAgICAgICAgIHRoaXMueFN0ZXBzW2ldID0gZnJvbVBlcmNlbnRhZ2UoW3RoaXMueFZhbFtpXSwgdGhpcy54VmFsW2kgKyAxXV0sIG4sIDApIC8gc3ViUmFuZ2VSYXRpbyh0aGlzLnhQY3RbaV0sIHRoaXMueFBjdFtpICsgMV0pO1xuICAgICAgICAgIHZhciB0b3RhbFN0ZXBzID0gKHRoaXMueFZhbFtpICsgMV0gLSB0aGlzLnhWYWxbaV0pIC8gdGhpcy54TnVtU3RlcHNbaV07XG4gICAgICAgICAgdmFyIGhpZ2hlc3RTdGVwID0gTWF0aC5jZWlsKE51bWJlcih0b3RhbFN0ZXBzLnRvRml4ZWQoMykpIC0gMSk7XG4gICAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnhWYWxbaV0gKyB0aGlzLnhOdW1TdGVwc1tpXSAqIGhpZ2hlc3RTdGVwO1xuICAgICAgICAgIHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaV0gPSBzdGVwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBTcGVjdHJ1bTtcbiAgICAgIH0oKTsgLy9lbmRyZWdpb25cbiAgICAgIC8vcmVnaW9uIE9wdGlvbnNcblxuICAgICAgLypcdEV2ZXJ5IGlucHV0IG9wdGlvbiBpcyB0ZXN0ZWQgYW5kIHBhcnNlZC4gVGhpcyB3aWxsIHByZXZlbnRcbiAgICAgICAgICBlbmRsZXNzIHZhbGlkYXRpb24gaW4gaW50ZXJuYWwgbWV0aG9kcy4gVGhlc2UgdGVzdHMgYXJlXG4gICAgICAgICAgc3RydWN0dXJlZCB3aXRoIGFuIGl0ZW0gZm9yIGV2ZXJ5IG9wdGlvbiBhdmFpbGFibGUuIEFuXG4gICAgICAgICAgb3B0aW9uIGNhbiBiZSBtYXJrZWQgYXMgcmVxdWlyZWQgYnkgc2V0dGluZyB0aGUgJ3InIGZsYWcuXG4gICAgICAgICAgVGhlIHRlc3RpbmcgZnVuY3Rpb24gaXMgcHJvdmlkZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICAgICAgICAgIC0gVGhlIHByb3ZpZGVkIHZhbHVlIGZvciB0aGUgb3B0aW9uO1xuICAgICAgICAgICAgICAtIEEgcmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9iamVjdDtcbiAgICAgICAgICAgICAgLSBUaGUgbmFtZSBmb3IgdGhlIG9wdGlvbjtcbiAgICAgICAgICAgVGhlIHRlc3RpbmcgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSB3aGVuIGFuIGVycm9yIGlzIGRldGVjdGVkLFxuICAgICAgICAgIG9yIHRydWUgd2hlbiBldmVyeXRoaW5nIGlzIE9LLiBJdCBjYW4gYWxzbyBtb2RpZnkgdGhlIG9wdGlvblxuICAgICAgICAgIG9iamVjdCwgdG8gbWFrZSBzdXJlIGFsbCB2YWx1ZXMgY2FuIGJlIGNvcnJlY3RseSBsb29wZWQgZWxzZXdoZXJlLiAqL1xuICAgICAgLy9yZWdpb24gRGVmYXVsdHNcblxuXG4gICAgICB2YXIgZGVmYXVsdEZvcm1hdHRlciA9IHtcbiAgICAgICAgdG86IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHZhbHVlLnRvRml4ZWQoMik7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb206IE51bWJlclxuICAgICAgfTtcbiAgICAgIHZhciBjc3NDbGFzc2VzID0ge1xuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIGJhc2U6IFwiYmFzZVwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIGhhbmRsZTogXCJoYW5kbGVcIixcbiAgICAgICAgaGFuZGxlTG93ZXI6IFwiaGFuZGxlLWxvd2VyXCIsXG4gICAgICAgIGhhbmRsZVVwcGVyOiBcImhhbmRsZS11cHBlclwiLFxuICAgICAgICB0b3VjaEFyZWE6IFwidG91Y2gtYXJlYVwiLFxuICAgICAgICBob3Jpem9udGFsOiBcImhvcml6b250YWxcIixcbiAgICAgICAgdmVydGljYWw6IFwidmVydGljYWxcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJiYWNrZ3JvdW5kXCIsXG4gICAgICAgIGNvbm5lY3Q6IFwiY29ubmVjdFwiLFxuICAgICAgICBjb25uZWN0czogXCJjb25uZWN0c1wiLFxuICAgICAgICBsdHI6IFwibHRyXCIsXG4gICAgICAgIHJ0bDogXCJydGxcIixcbiAgICAgICAgdGV4dERpcmVjdGlvbkx0cjogXCJ0eHQtZGlyLWx0clwiLFxuICAgICAgICB0ZXh0RGlyZWN0aW9uUnRsOiBcInR4dC1kaXItcnRsXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZHJhZzogXCJzdGF0ZS1kcmFnXCIsXG4gICAgICAgIHRhcDogXCJzdGF0ZS10YXBcIixcbiAgICAgICAgYWN0aXZlOiBcImFjdGl2ZVwiLFxuICAgICAgICB0b29sdGlwOiBcInRvb2x0aXBcIixcbiAgICAgICAgcGlwczogXCJwaXBzXCIsXG4gICAgICAgIHBpcHNIb3Jpem9udGFsOiBcInBpcHMtaG9yaXpvbnRhbFwiLFxuICAgICAgICBwaXBzVmVydGljYWw6IFwicGlwcy12ZXJ0aWNhbFwiLFxuICAgICAgICBtYXJrZXI6IFwibWFya2VyXCIsXG4gICAgICAgIG1hcmtlckhvcml6b250YWw6IFwibWFya2VyLWhvcml6b250YWxcIixcbiAgICAgICAgbWFya2VyVmVydGljYWw6IFwibWFya2VyLXZlcnRpY2FsXCIsXG4gICAgICAgIG1hcmtlck5vcm1hbDogXCJtYXJrZXItbm9ybWFsXCIsXG4gICAgICAgIG1hcmtlckxhcmdlOiBcIm1hcmtlci1sYXJnZVwiLFxuICAgICAgICBtYXJrZXJTdWI6IFwibWFya2VyLXN1YlwiLFxuICAgICAgICB2YWx1ZTogXCJ2YWx1ZVwiLFxuICAgICAgICB2YWx1ZUhvcml6b250YWw6IFwidmFsdWUtaG9yaXpvbnRhbFwiLFxuICAgICAgICB2YWx1ZVZlcnRpY2FsOiBcInZhbHVlLXZlcnRpY2FsXCIsXG4gICAgICAgIHZhbHVlTm9ybWFsOiBcInZhbHVlLW5vcm1hbFwiLFxuICAgICAgICB2YWx1ZUxhcmdlOiBcInZhbHVlLWxhcmdlXCIsXG4gICAgICAgIHZhbHVlU3ViOiBcInZhbHVlLXN1YlwiXG4gICAgICB9OyAvLyBOYW1lc3BhY2VzIG9mIGludGVybmFsIGV2ZW50IGxpc3RlbmVyc1xuXG4gICAgICB2YXIgSU5URVJOQUxfRVZFTlRfTlMgPSB7XG4gICAgICAgIHRvb2x0aXBzOiBcIi5fX3Rvb2x0aXBzXCIsXG4gICAgICAgIGFyaWE6IFwiLl9fYXJpYVwiXG4gICAgICB9OyAvL2VuZHJlZ2lvblxuXG4gICAgICBmdW5jdGlvbiB0ZXN0U3RlcChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdzdGVwJyBpcyBub3QgbnVtZXJpYy5cIik7XG4gICAgICAgIH0gLy8gVGhlIHN0ZXAgb3B0aW9uIGNhbiBzdGlsbCBiZSB1c2VkIHRvIHNldCBzdGVwcGluZ1xuICAgICAgICAvLyBmb3IgbGluZWFyIHNsaWRlcnMuIE92ZXJ3cml0dGVuIGlmIHNldCBpbiAncmFuZ2UnLlxuXG5cbiAgICAgICAgcGFyc2VkLnNpbmdsZVN0ZXAgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkUGFnZU11bHRpcGxpZXIocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAna2V5Ym9hcmRQYWdlTXVsdGlwbGllcicgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkUGFnZU11bHRpcGxpZXIgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkTXVsdGlwbGllcihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdrZXlib2FyZE11bHRpcGxpZXInIGlzIG5vdCBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5rZXlib2FyZE11bHRpcGxpZXIgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkRGVmYXVsdFN0ZXAocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAna2V5Ym9hcmREZWZhdWx0U3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkRGVmYXVsdFN0ZXAgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdFJhbmdlKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gRmlsdGVyIGluY29ycmVjdCBpbnB1dC5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdyYW5nZScgaXMgbm90IGFuIG9iamVjdC5cIik7XG4gICAgICAgIH0gLy8gQ2F0Y2ggbWlzc2luZyBzdGFydCBvciBlbmQuXG5cblxuICAgICAgICBpZiAoZW50cnkubWluID09PSB1bmRlZmluZWQgfHwgZW50cnkubWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBNaXNzaW5nICdtaW4nIG9yICdtYXgnIGluICdyYW5nZScuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLnNwZWN0cnVtID0gbmV3IFNwZWN0cnVtKGVudHJ5LCBwYXJzZWQuc25hcCB8fCBmYWxzZSwgcGFyc2VkLnNpbmdsZVN0ZXApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0U3RhcnQocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBlbnRyeSA9IGFzQXJyYXkoZW50cnkpOyAvLyBWYWxpZGF0ZSBpbnB1dC4gVmFsdWVzIGFyZW4ndCB0ZXN0ZWQsIGFzIHRoZSBwdWJsaWMgLnZhbCBtZXRob2RcbiAgICAgICAgLy8gd2lsbCBhbHdheXMgcHJvdmlkZSBhIHZhbGlkIGxvY2F0aW9uLlxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyeSkgfHwgIWVudHJ5Lmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdzdGFydCcgb3B0aW9uIGlzIGluY29ycmVjdC5cIik7XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIG51bWJlciBvZiBoYW5kbGVzLlxuXG5cbiAgICAgICAgcGFyc2VkLmhhbmRsZXMgPSBlbnRyeS5sZW5ndGg7IC8vIFdoZW4gdGhlIHNsaWRlciBpcyBpbml0aWFsaXplZCwgdGhlIC52YWwgbWV0aG9kIHdpbGxcbiAgICAgICAgLy8gYmUgY2FsbGVkIHdpdGggdGhlIHN0YXJ0IG9wdGlvbnMuXG5cbiAgICAgICAgcGFyc2VkLnN0YXJ0ID0gZW50cnk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RTbmFwKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnc25hcCcgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcbiAgICAgICAgfSAvLyBFbmZvcmNlIDEwMCUgc3RlcHBpbmcgd2l0aGluIHN1YnJhbmdlcy5cblxuXG4gICAgICAgIHBhcnNlZC5zbmFwID0gZW50cnk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RBbmltYXRlKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnYW5pbWF0ZScgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcbiAgICAgICAgfSAvLyBFbmZvcmNlIDEwMCUgc3RlcHBpbmcgd2l0aGluIHN1YnJhbmdlcy5cblxuXG4gICAgICAgIHBhcnNlZC5hbmltYXRlID0gZW50cnk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RBbmltYXRpb25EdXJhdGlvbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnYW5pbWF0aW9uRHVyYXRpb24nIG9wdGlvbiBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5hbmltYXRpb25EdXJhdGlvbiA9IGVudHJ5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0Q29ubmVjdChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIHZhciBjb25uZWN0ID0gW2ZhbHNlXTtcbiAgICAgICAgdmFyIGk7IC8vIE1hcCBsZWdhY3kgb3B0aW9uc1xuXG4gICAgICAgIGlmIChlbnRyeSA9PT0gXCJsb3dlclwiKSB7XG4gICAgICAgICAgZW50cnkgPSBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5ID09PSBcInVwcGVyXCIpIHtcbiAgICAgICAgICBlbnRyeSA9IFtmYWxzZSwgdHJ1ZV07XG4gICAgICAgIH0gLy8gSGFuZGxlIGJvb2xlYW4gb3B0aW9uc1xuXG5cbiAgICAgICAgaWYgKGVudHJ5ID09PSB0cnVlIHx8IGVudHJ5ID09PSBmYWxzZSkge1xuICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25uZWN0LnB1c2goZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbm5lY3QucHVzaChmYWxzZSk7XG4gICAgICAgIH0gLy8gUmVqZWN0IGludmFsaWQgaW5wdXRcbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZW50cnkpIHx8ICFlbnRyeS5sZW5ndGggfHwgZW50cnkubGVuZ3RoICE9PSBwYXJzZWQuaGFuZGxlcyArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnY29ubmVjdCcgb3B0aW9uIGRvZXNuJ3QgbWF0Y2ggaGFuZGxlIGNvdW50LlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25uZWN0ID0gZW50cnk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQuY29ubmVjdCA9IGNvbm5lY3Q7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RPcmllbnRhdGlvbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIFNldCBvcmllbnRhdGlvbiB0byBhbiBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFzeVxuICAgICAgICAvLyBhcnJheSBzZWxlY3Rpb24uXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcbiAgICAgICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0TWFyZ2luKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ21hcmdpbicgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH0gLy8gSXNzdWUgIzU4MlxuXG5cbiAgICAgICAgaWYgKGVudHJ5ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLm1hcmdpbiA9IHBhcnNlZC5zcGVjdHJ1bS5nZXREaXN0YW5jZShlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RMaW1pdChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdsaW1pdCcgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQubGltaXQgPSBwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnkpO1xuXG4gICAgICAgIGlmICghcGFyc2VkLmxpbWl0IHx8IHBhcnNlZC5oYW5kbGVzIDwgMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdsaW1pdCcgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIG9uIGxpbmVhciBzbGlkZXJzIHdpdGggMiBvciBtb3JlIGhhbmRsZXMuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RQYWRkaW5nKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgdmFyIGluZGV4O1xuXG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSAmJiAhQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbnVtZXJpYyBvciBhcnJheSBvZiBleGFjdGx5IDIgbnVtYmVycy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkgJiYgIShlbnRyeS5sZW5ndGggPT09IDIgfHwgaXNOdW1lcmljKGVudHJ5WzBdKSB8fCBpc051bWVyaWMoZW50cnlbMV0pKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBudW1lcmljIG9yIGFycmF5IG9mIGV4YWN0bHkgMiBudW1iZXJzLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICBlbnRyeSA9IFtlbnRyeSwgZW50cnldO1xuICAgICAgICB9IC8vICdnZXREaXN0YW5jZScgcmV0dXJucyBmYWxzZSBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgICAgICBwYXJzZWQucGFkZGluZyA9IFtwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnlbMF0pLCBwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnlbMV0pXTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXJzZWQuc3BlY3RydW0ueE51bVN0ZXBzLmxlbmd0aCAtIDE7IGluZGV4KyspIHtcbiAgICAgICAgICAvLyBsYXN0IFwicmFuZ2VcIiBjYW4ndCBjb250YWluIHN0ZXAgc2l6ZSBhcyBpdCBpcyBwdXJlbHkgYW4gZW5kcG9pbnQuXG4gICAgICAgICAgaWYgKHBhcnNlZC5wYWRkaW5nWzBdW2luZGV4XSA8IDAgfHwgcGFyc2VkLnBhZGRpbmdbMV1baW5kZXhdIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyKHMpLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxQYWRkaW5nID0gZW50cnlbMF0gKyBlbnRyeVsxXTtcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSBwYXJzZWQuc3BlY3RydW0ueFZhbFswXTtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHBhcnNlZC5zcGVjdHJ1bS54VmFsW3BhcnNlZC5zcGVjdHJ1bS54VmFsLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmICh0b3RhbFBhZGRpbmcgLyAobGFzdFZhbHVlIC0gZmlyc3RWYWx1ZSkgPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IG5vdCBleGNlZWQgMTAwJSBvZiB0aGUgcmFuZ2UuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3REaXJlY3Rpb24ocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBTZXQgZGlyZWN0aW9uIGFzIGEgbnVtZXJpY2FsIHZhbHVlIGZvciBlYXN5IHBhcnNpbmcuXG4gICAgICAgIC8vIEludmVydCBjb25uZWN0aW9uIGZvciBSVEwgc2xpZGVycywgc28gdGhhdCB0aGUgcHJvcGVyXG4gICAgICAgIC8vIGhhbmRsZXMgZ2V0IHRoZSBjb25uZWN0L2JhY2tncm91bmQgY2xhc3Nlcy5cbiAgICAgICAgc3dpdGNoIChlbnRyeSkge1xuICAgICAgICAgIGNhc2UgXCJsdHJcIjpcbiAgICAgICAgICAgIHBhcnNlZC5kaXIgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwicnRsXCI6XG4gICAgICAgICAgICBwYXJzZWQuZGlyID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdkaXJlY3Rpb24nIG9wdGlvbiB3YXMgbm90IHJlY29nbml6ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RCZWhhdmlvdXIocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGlucHV0IGlzIGEgc3RyaW5nLlxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2JlaGF2aW91cicgbXVzdCBiZSBhIHN0cmluZyBjb250YWluaW5nIG9wdGlvbnMuXCIpO1xuICAgICAgICB9IC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgYW55IGtleXdvcmRzLlxuICAgICAgICAvLyBOb25lIGFyZSByZXF1aXJlZC5cblxuXG4gICAgICAgIHZhciB0YXAgPSBlbnRyeS5pbmRleE9mKFwidGFwXCIpID49IDA7XG4gICAgICAgIHZhciBkcmFnID0gZW50cnkuaW5kZXhPZihcImRyYWdcIikgPj0gMDtcbiAgICAgICAgdmFyIGZpeGVkID0gZW50cnkuaW5kZXhPZihcImZpeGVkXCIpID49IDA7XG4gICAgICAgIHZhciBzbmFwID0gZW50cnkuaW5kZXhPZihcInNuYXBcIikgPj0gMDtcbiAgICAgICAgdmFyIGhvdmVyID0gZW50cnkuaW5kZXhPZihcImhvdmVyXCIpID49IDA7XG4gICAgICAgIHZhciB1bmNvbnN0cmFpbmVkID0gZW50cnkuaW5kZXhPZihcInVuY29uc3RyYWluZWRcIikgPj0gMDtcbiAgICAgICAgdmFyIGRyYWdBbGwgPSBlbnRyeS5pbmRleE9mKFwiZHJhZy1hbGxcIikgPj0gMDtcbiAgICAgICAgdmFyIHNtb290aFN0ZXBzID0gZW50cnkuaW5kZXhPZihcInNtb290aC1zdGVwc1wiKSA+PSAwO1xuXG4gICAgICAgIGlmIChmaXhlZCkge1xuICAgICAgICAgIGlmIChwYXJzZWQuaGFuZGxlcyAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2ZpeGVkJyBiZWhhdmlvdXIgbXVzdCBiZSB1c2VkIHdpdGggMiBoYW5kbGVzXCIpO1xuICAgICAgICAgIH0gLy8gVXNlIG1hcmdpbiB0byBlbmZvcmNlIGZpeGVkIHN0YXRlXG5cblxuICAgICAgICAgIHRlc3RNYXJnaW4ocGFyc2VkLCBwYXJzZWQuc3RhcnRbMV0gLSBwYXJzZWQuc3RhcnRbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuY29uc3RyYWluZWQgJiYgKHBhcnNlZC5tYXJnaW4gfHwgcGFyc2VkLmxpbWl0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICd1bmNvbnN0cmFpbmVkJyBiZWhhdmlvdXIgY2Fubm90IGJlIHVzZWQgd2l0aCBtYXJnaW4gb3IgbGltaXRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQuZXZlbnRzID0ge1xuICAgICAgICAgIHRhcDogdGFwIHx8IHNuYXAsXG4gICAgICAgICAgZHJhZzogZHJhZyxcbiAgICAgICAgICBkcmFnQWxsOiBkcmFnQWxsLFxuICAgICAgICAgIHNtb290aFN0ZXBzOiBzbW9vdGhTdGVwcyxcbiAgICAgICAgICBmaXhlZDogZml4ZWQsXG4gICAgICAgICAgc25hcDogc25hcCxcbiAgICAgICAgICBob3ZlcjogaG92ZXIsXG4gICAgICAgICAgdW5jb25zdHJhaW5lZDogdW5jb25zdHJhaW5lZFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0VG9vbHRpcHMocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5ID09PSB0cnVlIHx8IGlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGVudHJ5KSkge1xuICAgICAgICAgIHBhcnNlZC50b29sdGlwcyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudHJ5ID0gYXNBcnJheShlbnRyeSk7XG5cbiAgICAgICAgICBpZiAoZW50cnkubGVuZ3RoICE9PSBwYXJzZWQuaGFuZGxlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogbXVzdCBwYXNzIGEgZm9ybWF0dGVyIGZvciBhbGwgaGFuZGxlcy5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciAhPT0gXCJib29sZWFuXCIgJiYgIWlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3Rvb2x0aXBzJyBtdXN0IGJlIHBhc3NlZCBhIGZvcm1hdHRlciBvciAnZmFsc2UnLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXJzZWQudG9vbHRpcHMgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0SGFuZGxlQXR0cmlidXRlcyhwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogbXVzdCBwYXNzIGEgYXR0cmlidXRlcyBmb3IgYWxsIGhhbmRsZXMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmhhbmRsZUF0dHJpYnV0ZXMgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdEFyaWFGb3JtYXQocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdhcmlhRm9ybWF0JyByZXF1aXJlcyAndG8nIG1ldGhvZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQuYXJpYUZvcm1hdCA9IGVudHJ5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0Rm9ybWF0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRm9ybWF0dGVyKGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdmb3JtYXQnIHJlcXVpcmVzICd0bycgYW5kICdmcm9tJyBtZXRob2RzLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5mb3JtYXQgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkU3VwcG9ydChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2tleWJvYXJkU3VwcG9ydCcgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5rZXlib2FyZFN1cHBvcnQgPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGVzdERvY3VtZW50RWxlbWVudChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYWR2YW5jZWQgb3B0aW9uLiBQYXNzZWQgdmFsdWVzIGFyZSB1c2VkIHdpdGhvdXQgdmFsaWRhdGlvbi5cbiAgICAgICAgcGFyc2VkLmRvY3VtZW50RWxlbWVudCA9IGVudHJ5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0Q3NzUHJlZml4KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIiAmJiBlbnRyeSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnY3NzUHJlZml4JyBtdXN0IGJlIGEgc3RyaW5nIG9yIGBmYWxzZWAuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmNzc1ByZWZpeCA9IGVudHJ5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXN0Q3NzQ2xhc3NlcyhwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnY3NzQ2xhc3NlcycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQuY3NzUHJlZml4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXMgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3Nlc1trZXldID0gcGFyc2VkLmNzc1ByZWZpeCArIGVudHJ5W2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXMgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBUZXN0IGFsbCBkZXZlbG9wZXIgc2V0dGluZ3MgYW5kIHBhcnNlIHRvIGFzc3VtcHRpb24tc2FmZSB2YWx1ZXMuXG5cblxuICAgICAgZnVuY3Rpb24gdGVzdE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICAvLyBUbyBwcm92ZSBhIGZpeCBmb3IgIzUzNywgZnJlZXplIG9wdGlvbnMgaGVyZS5cbiAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBpcyBtb2RpZmllZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICAgIC8vIE9iamVjdC5mcmVlemUob3B0aW9ucyk7XG4gICAgICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICAgICAgbWFyZ2luOiBudWxsLFxuICAgICAgICAgIGxpbWl0OiBudWxsLFxuICAgICAgICAgIHBhZGRpbmc6IG51bGwsXG4gICAgICAgICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogMzAwLFxuICAgICAgICAgIGFyaWFGb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXIsXG4gICAgICAgICAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0dGVyXG4gICAgICAgIH07IC8vIFRlc3RzIGFyZSBleGVjdXRlZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgcHJlc2VudGVkIGhlcmUuXG5cbiAgICAgICAgdmFyIHRlc3RzID0ge1xuICAgICAgICAgIHN0ZXA6IHtcbiAgICAgICAgICAgIHI6IGZhbHNlLFxuICAgICAgICAgICAgdDogdGVzdFN0ZXBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleWJvYXJkUGFnZU11bHRpcGxpZXI6IHtcbiAgICAgICAgICAgIHI6IGZhbHNlLFxuICAgICAgICAgICAgdDogdGVzdEtleWJvYXJkUGFnZU11bHRpcGxpZXJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleWJvYXJkTXVsdGlwbGllcjoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0S2V5Ym9hcmRNdWx0aXBsaWVyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXlib2FyZERlZmF1bHRTdGVwOiB7XG4gICAgICAgICAgICByOiBmYWxzZSxcbiAgICAgICAgICAgIHQ6IHRlc3RLZXlib2FyZERlZmF1bHRTdGVwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgcjogdHJ1ZSxcbiAgICAgICAgICAgIHQ6IHRlc3RTdGFydFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29ubmVjdDoge1xuICAgICAgICAgICAgcjogdHJ1ZSxcbiAgICAgICAgICAgIHQ6IHRlc3RDb25uZWN0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXJlY3Rpb246IHtcbiAgICAgICAgICAgIHI6IHRydWUsXG4gICAgICAgICAgICB0OiB0ZXN0RGlyZWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbmFwOiB7XG4gICAgICAgICAgICByOiBmYWxzZSxcbiAgICAgICAgICAgIHQ6IHRlc3RTbmFwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbmltYXRlOiB7XG4gICAgICAgICAgICByOiBmYWxzZSxcbiAgICAgICAgICAgIHQ6IHRlc3RBbmltYXRlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0QW5pbWF0aW9uRHVyYXRpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICByOiB0cnVlLFxuICAgICAgICAgICAgdDogdGVzdFJhbmdlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcmllbnRhdGlvbjoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0T3JpZW50YXRpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hcmdpbjoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0TWFyZ2luXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsaW1pdDoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0TGltaXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIHI6IGZhbHNlLFxuICAgICAgICAgICAgdDogdGVzdFBhZGRpbmdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJlaGF2aW91cjoge1xuICAgICAgICAgICAgcjogdHJ1ZSxcbiAgICAgICAgICAgIHQ6IHRlc3RCZWhhdmlvdXJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFyaWFGb3JtYXQ6IHtcbiAgICAgICAgICAgIHI6IGZhbHNlLFxuICAgICAgICAgICAgdDogdGVzdEFyaWFGb3JtYXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0Rm9ybWF0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwczoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0VG9vbHRpcHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleWJvYXJkU3VwcG9ydDoge1xuICAgICAgICAgICAgcjogdHJ1ZSxcbiAgICAgICAgICAgIHQ6IHRlc3RLZXlib2FyZFN1cHBvcnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRvY3VtZW50RWxlbWVudDoge1xuICAgICAgICAgICAgcjogZmFsc2UsXG4gICAgICAgICAgICB0OiB0ZXN0RG9jdW1lbnRFbGVtZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjc3NQcmVmaXg6IHtcbiAgICAgICAgICAgIHI6IHRydWUsXG4gICAgICAgICAgICB0OiB0ZXN0Q3NzUHJlZml4XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjc3NDbGFzc2VzOiB7XG4gICAgICAgICAgICByOiB0cnVlLFxuICAgICAgICAgICAgdDogdGVzdENzc0NsYXNzZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhbmRsZUF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHI6IGZhbHNlLFxuICAgICAgICAgICAgdDogdGVzdEhhbmRsZUF0dHJpYnV0ZXNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICBjb25uZWN0OiBmYWxzZSxcbiAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgICAgYmVoYXZpb3VyOiBcInRhcFwiLFxuICAgICAgICAgIG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgICBrZXlib2FyZFN1cHBvcnQ6IHRydWUsXG4gICAgICAgICAgY3NzUHJlZml4OiBcIm5vVWktXCIsXG4gICAgICAgICAgY3NzQ2xhc3NlczogY3NzQ2xhc3NlcyxcbiAgICAgICAgICBrZXlib2FyZFBhZ2VNdWx0aXBsaWVyOiA1LFxuICAgICAgICAgIGtleWJvYXJkTXVsdGlwbGllcjogMSxcbiAgICAgICAgICBrZXlib2FyZERlZmF1bHRTdGVwOiAxMFxuICAgICAgICB9OyAvLyBBcmlhRm9ybWF0IGRlZmF1bHRzIHRvIHJlZ3VsYXIgZm9ybWF0LCBpZiBhbnkuXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICYmICFvcHRpb25zLmFyaWFGb3JtYXQpIHtcbiAgICAgICAgICBvcHRpb25zLmFyaWFGb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcbiAgICAgICAgfSAvLyBSdW4gYWxsIG9wdGlvbnMgdGhyb3VnaCBhIHRlc3RpbmcgbWVjaGFuaXNtIHRvIGVuc3VyZSBjb3JyZWN0XG4gICAgICAgIC8vIGlucHV0LiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCBvcHRpb25zIG1pZ2h0IGdldCBtb2RpZmllZCB0b1xuICAgICAgICAvLyBiZSBoYW5kbGVkIHByb3Blcmx5LiBFLmcuIHdyYXBwaW5nIGludGVnZXJzIGluIGFycmF5cy5cblxuXG4gICAgICAgIE9iamVjdC5rZXlzKHRlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIG9wdGlvbiBpc24ndCBzZXQsIGJ1dCBpdCBpcyByZXF1aXJlZCwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgaWYgKCFpc1NldChvcHRpb25zW25hbWVdKSAmJiBkZWZhdWx0c1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGVzdHNbbmFtZV0ucikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnXCIgKyBuYW1lICsgXCInIGlzIHJlcXVpcmVkLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRlc3RzW25hbWVdLnQocGFyc2VkLCAhaXNTZXQob3B0aW9uc1tuYW1lXSkgPyBkZWZhdWx0c1tuYW1lXSA6IG9wdGlvbnNbbmFtZV0pO1xuICAgICAgICB9KTsgLy8gRm9yd2FyZCBwaXBzIG9wdGlvbnNcblxuICAgICAgICBwYXJzZWQucGlwcyA9IG9wdGlvbnMucGlwczsgLy8gQWxsIHJlY2VudCBicm93c2VycyBhY2NlcHQgdW5wcmVmaXhlZCB0cmFuc2Zvcm0uXG4gICAgICAgIC8vIFdlIG5lZWQgLW1zLSBmb3IgSUU5IGFuZCAtd2Via2l0LSBmb3Igb2xkZXIgQW5kcm9pZDtcbiAgICAgICAgLy8gQXNzdW1lIHVzZSBvZiAtd2Via2l0LSBpZiB1bnByZWZpeGVkIGFuZCAtbXMtIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICAgICAvLyBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PXRyYW5zZm9ybXMyZFxuXG4gICAgICAgIHZhciBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG1zUHJlZml4ID0gZC5zdHlsZS5tc1RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbm9QcmVmaXggPSBkLnN0eWxlLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJzZWQudHJhbnNmb3JtUnVsZSA9IG5vUHJlZml4ID8gXCJ0cmFuc2Zvcm1cIiA6IG1zUHJlZml4ID8gXCJtc1RyYW5zZm9ybVwiIDogXCJ3ZWJraXRUcmFuc2Zvcm1cIjsgLy8gUGlwcyBkb24ndCBtb3ZlLCBzbyB3ZSBjYW4gcGxhY2UgdGhlbSB1c2luZyBsZWZ0L3RvcC5cblxuICAgICAgICB2YXIgc3R5bGVzID0gW1tcImxlZnRcIiwgXCJ0b3BcIl0sIFtcInJpZ2h0XCIsIFwiYm90dG9tXCJdXTtcbiAgICAgICAgcGFyc2VkLnN0eWxlID0gc3R5bGVzW3BhcnNlZC5kaXJdW3BhcnNlZC5vcnRdO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfSAvL2VuZHJlZ2lvblxuXG5cbiAgICAgIGZ1bmN0aW9uIHNjb3BlKHRhcmdldCwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xuICAgICAgICB2YXIgc3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgPSBnZXRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSgpO1xuICAgICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gc3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgJiYgZ2V0U3VwcG9ydHNQYXNzaXZlKCk7IC8vIEFsbCB2YXJpYWJsZXMgbG9jYWwgdG8gJ3Njb3BlJyBhcmUgcHJlZml4ZWQgd2l0aCAnc2NvcGVfJ1xuICAgICAgICAvLyBTbGlkZXIgRE9NIE5vZGVzXG5cbiAgICAgICAgdmFyIHNjb3BlX1RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdmFyIHNjb3BlX0Jhc2U7XG4gICAgICAgIHZhciBzY29wZV9IYW5kbGVzO1xuICAgICAgICB2YXIgc2NvcGVfQ29ubmVjdHM7XG4gICAgICAgIHZhciBzY29wZV9QaXBzO1xuICAgICAgICB2YXIgc2NvcGVfVG9vbHRpcHM7IC8vIFNsaWRlciBzdGF0ZSB2YWx1ZXNcblxuICAgICAgICB2YXIgc2NvcGVfU3BlY3RydW0gPSBvcHRpb25zLnNwZWN0cnVtO1xuICAgICAgICB2YXIgc2NvcGVfVmFsdWVzID0gW107XG4gICAgICAgIHZhciBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHNjb3BlX0hhbmRsZU51bWJlcnMgPSBbXTtcbiAgICAgICAgdmFyIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCA9IDA7XG4gICAgICAgIHZhciBzY29wZV9FdmVudHMgPSB7fTsgLy8gRG9jdW1lbnQgTm9kZXNcblxuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIHNjb3BlX0RvY3VtZW50RWxlbWVudCA9IG9wdGlvbnMuZG9jdW1lbnRFbGVtZW50IHx8IHNjb3BlX0RvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdmFyIHNjb3BlX0JvZHkgPSBzY29wZV9Eb2N1bWVudC5ib2R5OyAvLyBGb3IgaG9yaXpvbnRhbCBzbGlkZXJzIGluIHN0YW5kYXJkIGx0ciBkb2N1bWVudHMsXG4gICAgICAgIC8vIG1ha2UgLm5vVWktb3JpZ2luIG92ZXJmbG93IHRvIHRoZSBsZWZ0IHNvIHRoZSBkb2N1bWVudCBkb2Vzbid0IHNjcm9sbC5cblxuICAgICAgICB2YXIgc2NvcGVfRGlyT2Zmc2V0ID0gc2NvcGVfRG9jdW1lbnQuZGlyID09PSBcInJ0bFwiIHx8IG9wdGlvbnMub3J0ID09PSAxID8gMCA6IDEwMDsgLy8gQ3JlYXRlcyBhIG5vZGUsIGFkZHMgaXQgdG8gdGFyZ2V0LCByZXR1cm5zIHRoZSBuZXcgbm9kZS5cblxuICAgICAgICBmdW5jdGlvbiBhZGROb2RlVG8oYWRkVGFyZ2V0LCBjbGFzc05hbWUpIHtcbiAgICAgICAgICB2YXIgZGl2ID0gc2NvcGVfRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGRpdiwgY2xhc3NOYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRUYXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgICByZXR1cm4gZGl2O1xuICAgICAgICB9IC8vIEFwcGVuZCBhIG9yaWdpbiB0byB0aGUgYmFzZVxuXG5cbiAgICAgICAgZnVuY3Rpb24gYWRkT3JpZ2luKGJhc2UsIGhhbmRsZU51bWJlcikge1xuICAgICAgICAgIHZhciBvcmlnaW4gPSBhZGROb2RlVG8oYmFzZSwgb3B0aW9ucy5jc3NDbGFzc2VzLm9yaWdpbik7XG4gICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZE5vZGVUbyhvcmlnaW4sIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGUpO1xuICAgICAgICAgIGFkZE5vZGVUbyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50b3VjaEFyZWEpO1xuICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWhhbmRsZVwiLCBTdHJpbmcoaGFuZGxlTnVtYmVyKSk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5rZXlib2FyZFN1cHBvcnQpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXhcbiAgICAgICAgICAgIC8vIDAgPSBmb2N1c2FibGUgYW5kIHJlYWNoYWJsZVxuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICAgICAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50S2V5ZG93bihldmVudCwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmhhbmRsZUF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXNfMSA9IG9wdGlvbnMuaGFuZGxlQXR0cmlidXRlc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGF0dHJpYnV0ZXNfMVthdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic2xpZGVyXCIpO1xuICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIG9wdGlvbnMub3J0ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIpO1xuXG4gICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlTG93ZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlTnVtYmVyID09PSBvcHRpb25zLmhhbmRsZXMgLSAxKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGVVcHBlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICAgICAgfSAvLyBJbnNlcnQgbm9kZXMgZm9yIGNvbm5lY3QgZWxlbWVudHNcblxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZENvbm5lY3QoYmFzZSwgYWRkKSB7XG4gICAgICAgICAgaWYgKCFhZGQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWRkTm9kZVRvKGJhc2UsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5jb25uZWN0KTtcbiAgICAgICAgfSAvLyBBZGQgaGFuZGxlcyB0byB0aGUgc2xpZGVyIGJhc2UuXG5cblxuICAgICAgICBmdW5jdGlvbiBhZGRFbGVtZW50cyhjb25uZWN0T3B0aW9ucywgYmFzZSkge1xuICAgICAgICAgIHZhciBjb25uZWN0QmFzZSA9IGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdHMpO1xuICAgICAgICAgIHNjb3BlX0hhbmRsZXMgPSBbXTtcbiAgICAgICAgICBzY29wZV9Db25uZWN0cyA9IFtdO1xuICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChjb25uZWN0QmFzZSwgY29ubmVjdE9wdGlvbnNbMF0pKTsgLy8gWzo6OjpPPT09PU89PT09Tz09PT1dXG4gICAgICAgICAgLy8gY29ubmVjdE9wdGlvbnMgPSBbMCwgMSwgMSwgMV1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5oYW5kbGVzOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEtlZXAgYSBsaXN0IG9mIGFsbCBhZGRlZCBoYW5kbGVzLlxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5wdXNoKGFkZE9yaWdpbihiYXNlLCBpKSk7XG4gICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzW2ldID0gaTtcbiAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChjb25uZWN0QmFzZSwgY29ubmVjdE9wdGlvbnNbaSArIDFdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEluaXRpYWxpemUgYSBzaW5nbGUgc2xpZGVyLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gYWRkU2xpZGVyKGFkZFRhcmdldCkge1xuICAgICAgICAgIC8vIEFwcGx5IGNsYXNzZXMgYW5kIGRhdGEgdG8gdGhlIHRhcmdldC5cbiAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXJnZXQpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyID09PSAwKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5sdHIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5ydGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLm9ydCA9PT0gMCkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuaG9yaXpvbnRhbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZlcnRpY2FsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGV4dERpcmVjdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoYWRkVGFyZ2V0KS5kaXJlY3Rpb247XG5cbiAgICAgICAgICBpZiAodGV4dERpcmVjdGlvbiA9PT0gXCJydGxcIikge1xuICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGV4dERpcmVjdGlvblJ0bCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRleHREaXJlY3Rpb25MdHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhZGROb2RlVG8oYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuYmFzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRUb29sdGlwKGhhbmRsZSwgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLnRvb2x0aXBzIHx8ICFvcHRpb25zLnRvb2x0aXBzW2hhbmRsZU51bWJlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWRkTm9kZVRvKGhhbmRsZS5maXJzdENoaWxkLCBvcHRpb25zLmNzc0NsYXNzZXMudG9vbHRpcCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1NsaWRlckRpc2FibGVkKCkge1xuICAgICAgICAgIHJldHVybiBzY29wZV9UYXJnZXQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gICAgICAgIH0gLy8gRGlzYWJsZSB0aGUgc2xpZGVyIGRyYWdnaW5nIGlmIGFueSBoYW5kbGUgaXMgZGlzYWJsZWRcblxuXG4gICAgICAgIGZ1bmN0aW9uIGlzSGFuZGxlRGlzYWJsZWQoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlT3JpZ2luLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVG9vbHRpcHMoKSB7XG4gICAgICAgICAgaWYgKHNjb3BlX1Rvb2x0aXBzKSB7XG4gICAgICAgICAgICByZW1vdmVFdmVudChcInVwZGF0ZVwiICsgSU5URVJOQUxfRVZFTlRfTlMudG9vbHRpcHMpO1xuICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMuZm9yRWFjaChmdW5jdGlvbiAodG9vbHRpcCkge1xuICAgICAgICAgICAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodG9vbHRpcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUaGUgdG9vbHRpcHMgb3B0aW9uIGlzIGEgc2hvcnRoYW5kIGZvciB1c2luZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cblxuICAgICAgICBmdW5jdGlvbiB0b29sdGlwcygpIHtcbiAgICAgICAgICByZW1vdmVUb29sdGlwcygpOyAvLyBUb29sdGlwcyBhcmUgYWRkZWQgd2l0aCBvcHRpb25zLnRvb2x0aXBzIGluIG9yaWdpbmFsIG9yZGVyLlxuXG4gICAgICAgICAgc2NvcGVfVG9vbHRpcHMgPSBzY29wZV9IYW5kbGVzLm1hcChhZGRUb29sdGlwKTtcbiAgICAgICAgICBiaW5kRXZlbnQoXCJ1cGRhdGVcIiArIElOVEVSTkFMX0VWRU5UX05TLnRvb2x0aXBzLCBmdW5jdGlvbiAodmFsdWVzLCBoYW5kbGVOdW1iZXIsIHVuZW5jb2RlZCkge1xuICAgICAgICAgICAgaWYgKCFzY29wZV9Ub29sdGlwcyB8fCAhb3B0aW9ucy50b29sdGlwcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY29wZV9Ub29sdGlwc1toYW5kbGVOdW1iZXJdID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHZhbHVlc1toYW5kbGVOdW1iZXJdO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdLnRvKHVuZW5jb2RlZFtoYW5kbGVOdW1iZXJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHNbaGFuZGxlTnVtYmVyXS5pbm5lckhUTUwgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFyaWEoKSB7XG4gICAgICAgICAgcmVtb3ZlRXZlbnQoXCJ1cGRhdGVcIiArIElOVEVSTkFMX0VWRU5UX05TLmFyaWEpO1xuICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZVwiICsgSU5URVJOQUxfRVZFTlRfTlMuYXJpYSwgZnVuY3Rpb24gKHZhbHVlcywgaGFuZGxlTnVtYmVyLCB1bmVuY29kZWQsIHRhcCwgcG9zaXRpb25zKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgQXJpYSBWYWx1ZXMgZm9yIGFsbCBoYW5kbGVzLCBhcyBhIGNoYW5nZSBpbiBvbmUgY2hhbmdlcyBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIHRoZSBuZXh0LlxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2NvcGVfSGFuZGxlc1tpbmRleF07XG4gICAgICAgICAgICAgIHZhciBtaW4gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaW5kZXgsIDAsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICB2YXIgbWF4ID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGluZGV4LCAxMDAsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICB2YXIgbm93ID0gcG9zaXRpb25zW2luZGV4XTsgLy8gRm9ybWF0dGVkIHZhbHVlIGZvciBkaXNwbGF5XG5cbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBTdHJpbmcob3B0aW9ucy5hcmlhRm9ybWF0LnRvKHVuZW5jb2RlZFtpbmRleF0pKTsgLy8gTWFwIHRvIHNsaWRlciByYW5nZSB2YWx1ZXNcblxuICAgICAgICAgICAgICBtaW4gPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobWluKS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICBtYXggPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobWF4KS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICBub3cgPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobm93KS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1pblwiLCBtaW4pO1xuICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1heFwiLCBtYXgpO1xuICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiLCBub3cpO1xuICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZXRleHRcIiwgdGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwKHBpcHMpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIHJhbmdlLlxuICAgICAgICAgIGlmIChwaXBzLm1vZGUgPT09IGV4cG9ydHMuUGlwc01vZGUuUmFuZ2UgfHwgcGlwcy5tb2RlID09PSBleHBvcnRzLlBpcHNNb2RlLlN0ZXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0ueFZhbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGlwcy5tb2RlID09PSBleHBvcnRzLlBpcHNNb2RlLkNvdW50KSB7XG4gICAgICAgICAgICBpZiAocGlwcy52YWx1ZXMgPCAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICd2YWx1ZXMnICg+PSAyKSByZXF1aXJlZCBmb3IgbW9kZSAnY291bnQnLlwiKTtcbiAgICAgICAgICAgIH0gLy8gRGl2aWRlIDAgLSAxMDAgaW4gJ2NvdW50JyBwYXJ0cy5cblxuXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBwaXBzLnZhbHVlcyAtIDE7XG4gICAgICAgICAgICB2YXIgc3ByZWFkID0gMTAwIC8gaW50ZXJ2YWw7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107IC8vIExpc3QgdGhlc2UgcGFydHMgYW5kIGhhdmUgdGhlbSBoYW5kbGVkIGFzICdwb3NpdGlvbnMnLlxuXG4gICAgICAgICAgICB3aGlsZSAoaW50ZXJ2YWwtLSkge1xuICAgICAgICAgICAgICB2YWx1ZXNbaW50ZXJ2YWxdID0gaW50ZXJ2YWwgKiBzcHJlYWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gbWFwVG9SYW5nZSh2YWx1ZXMsIHBpcHMuc3RlcHBlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBpcHMubW9kZSA9PT0gZXhwb3J0cy5QaXBzTW9kZS5Qb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIE1hcCBhbGwgcGVyY2VudGFnZXMgdG8gb24tcmFuZ2UgdmFsdWVzLlxuICAgICAgICAgICAgcmV0dXJuIG1hcFRvUmFuZ2UocGlwcy52YWx1ZXMsIHBpcHMuc3RlcHBlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBpcHMubW9kZSA9PT0gZXhwb3J0cy5QaXBzTW9kZS5WYWx1ZXMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBtdXN0IGJlIHN0ZXBwZWQsIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHBlcmNlbnRhZ2UgZmlyc3QuXG4gICAgICAgICAgICBpZiAocGlwcy5zdGVwcGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwaXBzLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwZXJjZW50YWdlLCBhcHBseSBzdGVwLCByZXR1cm4gdG8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodmFsdWUpKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSAvLyBPdGhlcndpc2UsIHdlIGNhbiBzaW1wbHkgdXNlIHRoZSB2YWx1ZXMuXG5cblxuICAgICAgICAgICAgcmV0dXJuIHBpcHMudmFsdWVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbXTsgLy8gcGlwcy5tb2RlID0gbmV2ZXJcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1hcFRvUmFuZ2UodmFsdWVzLCBzdGVwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHN0ZXBwZWQgPyBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3ByZWFkKHBpcHMpIHtcbiAgICAgICAgICBmdW5jdGlvbiBzYWZlSW5jcmVtZW50KHZhbHVlLCBpbmNyZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIGZsb2F0aW5nIHBvaW50IHZhcmlhbmNlIGJ5IGRyb3BwaW5nIHRoZSBzbWFsbGVzdCBkZWNpbWFsIHBsYWNlcy5cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoKHZhbHVlICsgaW5jcmVtZW50KS50b0ZpeGVkKDcpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZ3JvdXAgPSBnZXRHcm91cChwaXBzKTtcbiAgICAgICAgICB2YXIgaW5kZXhlcyA9IHt9O1xuICAgICAgICAgIHZhciBmaXJzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsWzBdO1xuICAgICAgICAgIHZhciBsYXN0SW5SYW5nZSA9IHNjb3BlX1NwZWN0cnVtLnhWYWxbc2NvcGVfU3BlY3RydW0ueFZhbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgaWdub3JlRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgaWdub3JlTGFzdCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBwcmV2UGN0ID0gMDsgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZ3JvdXAsIHNvcnQgaXQgYW5kIGZpbHRlciBhd2F5IGFsbCBkdXBsaWNhdGVzLlxuXG4gICAgICAgICAgZ3JvdXAgPSB1bmlxdWUoZ3JvdXAuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgfSkpOyAvLyBNYWtlIHN1cmUgdGhlIHJhbmdlIHN0YXJ0cyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50LlxuXG4gICAgICAgICAgaWYgKGdyb3VwWzBdICE9PSBmaXJzdEluUmFuZ2UpIHtcbiAgICAgICAgICAgIGdyb3VwLnVuc2hpZnQoZmlyc3RJblJhbmdlKTtcbiAgICAgICAgICAgIGlnbm9yZUZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIExpa2V3aXNlIGZvciB0aGUgbGFzdCBvbmUuXG5cblxuICAgICAgICAgIGlmIChncm91cFtncm91cC5sZW5ndGggLSAxXSAhPT0gbGFzdEluUmFuZ2UpIHtcbiAgICAgICAgICAgIGdyb3VwLnB1c2gobGFzdEluUmFuZ2UpO1xuICAgICAgICAgICAgaWdub3JlTGFzdCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGVwIGFuZCB0aGUgbG93ZXIgKyB1cHBlciBwb3NpdGlvbnMuXG4gICAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIHE7XG4gICAgICAgICAgICB2YXIgbG93ID0gY3VycmVudDtcbiAgICAgICAgICAgIHZhciBoaWdoID0gZ3JvdXBbaW5kZXggKyAxXTtcbiAgICAgICAgICAgIHZhciBuZXdQY3Q7XG4gICAgICAgICAgICB2YXIgcGN0RGlmZmVyZW5jZTtcbiAgICAgICAgICAgIHZhciBwY3RQb3M7XG4gICAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICAgIHZhciBzdGVwcztcbiAgICAgICAgICAgIHZhciByZWFsU3RlcHM7XG4gICAgICAgICAgICB2YXIgc3RlcFNpemU7XG4gICAgICAgICAgICB2YXIgaXNTdGVwcyA9IHBpcHMubW9kZSA9PT0gZXhwb3J0cy5QaXBzTW9kZS5TdGVwczsgLy8gV2hlbiB1c2luZyAnc3RlcHMnIG1vZGUsIHVzZSB0aGUgcHJvdmlkZWQgc3RlcHMuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlJ2xsIHN0ZXAgb24gdG8gdGhlIG5leHQgc3VicmFuZ2UuXG5cbiAgICAgICAgICAgIGlmIChpc1N0ZXBzKSB7XG4gICAgICAgICAgICAgIHN0ZXAgPSBzY29wZV9TcGVjdHJ1bS54TnVtU3RlcHNbaW5kZXhdO1xuICAgICAgICAgICAgfSAvLyBEZWZhdWx0IHRvIGEgJ2Z1bGwnIHN0ZXAuXG5cblxuICAgICAgICAgICAgaWYgKCFzdGVwKSB7XG4gICAgICAgICAgICAgIHN0ZXAgPSBoaWdoIC0gbG93O1xuICAgICAgICAgICAgfSAvLyBJZiBoaWdoIGlzIHVuZGVmaW5lZCB3ZSBhcmUgYXQgdGhlIGxhc3Qgc3VicmFuZ2UuIE1ha2Ugc3VyZSBpdCBpdGVyYXRlcyBvbmNlICgjMTA4OClcblxuXG4gICAgICAgICAgICBpZiAoaGlnaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGhpZ2ggPSBsb3c7XG4gICAgICAgICAgICB9IC8vIE1ha2Ugc3VyZSBzdGVwIGlzbid0IDAsIHdoaWNoIHdvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3AgKCM2NTQpXG5cblxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KHN0ZXAsIDAuMDAwMDAwMSk7IC8vIEZpbmQgYWxsIHN0ZXBzIGluIHRoZSBzdWJyYW5nZS5cblxuICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IGhpZ2g7IGkgPSBzYWZlSW5jcmVtZW50KGksIHN0ZXApKSB7XG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcGVyY2VudGFnZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgc3RlcCxcbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzaXplIGZvciB0aGUgc3VicmFuZ2UuXG4gICAgICAgICAgICAgIG5ld1BjdCA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcoaSk7XG4gICAgICAgICAgICAgIHBjdERpZmZlcmVuY2UgPSBuZXdQY3QgLSBwcmV2UGN0O1xuICAgICAgICAgICAgICBzdGVwcyA9IHBjdERpZmZlcmVuY2UgLyAocGlwcy5kZW5zaXR5IHx8IDEpO1xuICAgICAgICAgICAgICByZWFsU3RlcHMgPSBNYXRoLnJvdW5kKHN0ZXBzKTsgLy8gVGhpcyByYXRpbyByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgcGVyY2VudGFnZS1zcGFjZSBhIHBvaW50IGluZGljYXRlcy5cbiAgICAgICAgICAgICAgLy8gRm9yIGEgZGVuc2l0eSAxIHRoZSBwb2ludHMvcGVyY2VudGFnZSA9IDEuIEZvciBkZW5zaXR5IDIsIHRoYXQgcGVyY2VudGFnZSBuZWVkcyB0byBiZSByZS1kaXZpZGVkLlxuICAgICAgICAgICAgICAvLyBSb3VuZCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgdG8gYW4gZXZlbiBudW1iZXIsIHRoZW4gZGl2aWRlIGJ5IHR3b1xuICAgICAgICAgICAgICAvLyB0byBzcHJlYWQgdGhlIG9mZnNldCBvbiBib3RoIHNpZGVzIG9mIHRoZSByYW5nZS5cblxuICAgICAgICAgICAgICBzdGVwU2l6ZSA9IHBjdERpZmZlcmVuY2UgLyByZWFsU3RlcHM7IC8vIERpdmlkZSBhbGwgcG9pbnRzIGV2ZW5seSwgYWRkaW5nIHRoZSBjb3JyZWN0IG51bWJlciB0byB0aGlzIHN1YnJhbmdlLlxuICAgICAgICAgICAgICAvLyBSdW4gdXAgdG8gPD0gc28gdGhhdCAxMDAlIGdldHMgYSBwb2ludCwgZXZlbnQgaWYgaWdub3JlTGFzdCBpcyBzZXQuXG5cbiAgICAgICAgICAgICAgZm9yIChxID0gMTsgcSA8PSByZWFsU3RlcHM7IHEgKz0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSByYXRpbyBiZXR3ZWVuIHRoZSByb3VuZGVkIHZhbHVlIGFuZCB0aGUgYWN0dWFsIHNpemUgbWlnaHQgYmUgfjElIG9mZi5cbiAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IHRoZSBwZXJjZW50YWdlIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIHBvaW50c1xuICAgICAgICAgICAgICAgIC8vIHBlciBzdWJyYW5nZS4gZGVuc2l0eSA9IDEgd2lsbCByZXN1bHQgaW4gMTAwIHBvaW50cyBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBmdWxsIHJhbmdlLCAyIGZvciA1MCwgNCBmb3IgMjUsIGV0Yy5cbiAgICAgICAgICAgICAgICBwY3RQb3MgPSBwcmV2UGN0ICsgcSAqIHN0ZXBTaXplO1xuICAgICAgICAgICAgICAgIGluZGV4ZXNbcGN0UG9zLnRvRml4ZWQoNSldID0gW3Njb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhwY3RQb3MpLCAwXTtcbiAgICAgICAgICAgICAgfSAvLyBEZXRlcm1pbmUgdGhlIHBvaW50IHR5cGUuXG5cblxuICAgICAgICAgICAgICB0eXBlID0gZ3JvdXAuaW5kZXhPZihpKSA+IC0xID8gZXhwb3J0cy5QaXBzVHlwZS5MYXJnZVZhbHVlIDogaXNTdGVwcyA/IGV4cG9ydHMuUGlwc1R5cGUuU21hbGxWYWx1ZSA6IGV4cG9ydHMuUGlwc1R5cGUuTm9WYWx1ZTsgLy8gRW5mb3JjZSB0aGUgJ2lnbm9yZUZpcnN0JyBvcHRpb24gYnkgb3ZlcndyaXRpbmcgdGhlIHR5cGUgZm9yIDAuXG5cbiAgICAgICAgICAgICAgaWYgKCFpbmRleCAmJiBpZ25vcmVGaXJzdCAmJiBpICE9PSBoaWdoKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IDA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIShpID09PSBoaWdoICYmIGlnbm9yZUxhc3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgJ3R5cGUnIG9mIHRoaXMgcG9pbnQuIDAgPSBwbGFpbiwgMSA9IHJlYWwgdmFsdWUsIDIgPSBzdGVwIHZhbHVlLlxuICAgICAgICAgICAgICAgIGluZGV4ZXNbbmV3UGN0LnRvRml4ZWQoNSldID0gW2ksIHR5cGVdO1xuICAgICAgICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcGVyY2VudGFnZSBjb3VudC5cblxuXG4gICAgICAgICAgICAgIHByZXZQY3QgPSBuZXdQY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRNYXJraW5nKHNwcmVhZCwgZmlsdGVyRnVuYywgZm9ybWF0dGVyKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcblxuICAgICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGVfRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICB2YXIgdmFsdWVTaXplQ2xhc3NlcyA9IChfYSA9IHt9LCBfYVtleHBvcnRzLlBpcHNUeXBlLk5vbmVdID0gXCJcIiwgX2FbZXhwb3J0cy5QaXBzVHlwZS5Ob1ZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZU5vcm1hbCwgX2FbZXhwb3J0cy5QaXBzVHlwZS5MYXJnZVZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZUxhcmdlLCBfYVtleHBvcnRzLlBpcHNUeXBlLlNtYWxsVmFsdWVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlU3ViLCBfYSk7XG4gICAgICAgICAgdmFyIG1hcmtlclNpemVDbGFzc2VzID0gKF9iID0ge30sIF9iW2V4cG9ydHMuUGlwc1R5cGUuTm9uZV0gPSBcIlwiLCBfYltleHBvcnRzLlBpcHNUeXBlLk5vVmFsdWVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlck5vcm1hbCwgX2JbZXhwb3J0cy5QaXBzVHlwZS5MYXJnZVZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJMYXJnZSwgX2JbZXhwb3J0cy5QaXBzVHlwZS5TbWFsbFZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJTdWIsIF9iKTtcbiAgICAgICAgICB2YXIgdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlSG9yaXpvbnRhbCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlVmVydGljYWxdO1xuICAgICAgICAgIHZhciBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlckhvcml6b250YWwsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJWZXJ0aWNhbF07XG4gICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHMpO1xuICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIG9wdGlvbnMub3J0ID09PSAwID8gb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNIb3Jpem9udGFsIDogb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNWZXJ0aWNhbCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRDbGFzc2VzKHR5cGUsIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIGEgPSBzb3VyY2UgPT09IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZTtcbiAgICAgICAgICAgIHZhciBvcmllbnRhdGlvbkNsYXNzZXMgPSBhID8gdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgOiBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXM7XG4gICAgICAgICAgICB2YXIgc2l6ZUNsYXNzZXMgPSBhID8gdmFsdWVTaXplQ2xhc3NlcyA6IG1hcmtlclNpemVDbGFzc2VzO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSArIFwiIFwiICsgb3JpZW50YXRpb25DbGFzc2VzW29wdGlvbnMub3J0XSArIFwiIFwiICsgc2l6ZUNsYXNzZXNbdHlwZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYWRkU3ByZWFkKG9mZnNldCwgdmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgZnVuY3Rpb24sIGlmIGl0IGlzIHNldC5cbiAgICAgICAgICAgIHR5cGUgPSBmaWx0ZXJGdW5jID8gZmlsdGVyRnVuYyh2YWx1ZSwgdHlwZSkgOiB0eXBlO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5QaXBzVHlwZS5Ob25lKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gLy8gQWRkIGEgbWFya2VyIGZvciBldmVyeSBwb2ludFxuXG5cbiAgICAgICAgICAgIHZhciBub2RlID0gYWRkTm9kZVRvKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gZ2V0Q2xhc3Nlcyh0eXBlLCBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyKTtcbiAgICAgICAgICAgIG5vZGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSBvZmZzZXQgKyBcIiVcIjsgLy8gVmFsdWVzIGFyZSBvbmx5IGFwcGVuZGVkIGZvciBwb2ludHMgbWFya2VkICcxJyBvciAnMicuXG5cbiAgICAgICAgICAgIGlmICh0eXBlID4gZXhwb3J0cy5QaXBzVHlwZS5Ob1ZhbHVlKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBhZGROb2RlVG8oZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGdldENsYXNzZXModHlwZSwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlKTtcbiAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgICBub2RlLnN0eWxlW29wdGlvbnMuc3R5bGVdID0gb2Zmc2V0ICsgXCIlXCI7XG4gICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gU3RyaW5nKGZvcm1hdHRlci50byh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQXBwZW5kIGFsbCBwb2ludHMuXG5cblxuICAgICAgICAgIE9iamVjdC5rZXlzKHNwcmVhZCkuZm9yRWFjaChmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICBhZGRTcHJlYWQob2Zmc2V0LCBzcHJlYWRbb2Zmc2V0XVswXSwgc3ByZWFkW29mZnNldF1bMV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlUGlwcygpIHtcbiAgICAgICAgICBpZiAoc2NvcGVfUGlwcykge1xuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudChzY29wZV9QaXBzKTtcbiAgICAgICAgICAgIHNjb3BlX1BpcHMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBpcHMocGlwcykge1xuICAgICAgICAgIC8vIEZpeCAjNjY5XG4gICAgICAgICAgcmVtb3ZlUGlwcygpO1xuICAgICAgICAgIHZhciBzcHJlYWQgPSBnZW5lcmF0ZVNwcmVhZChwaXBzKTtcbiAgICAgICAgICB2YXIgZmlsdGVyID0gcGlwcy5maWx0ZXI7XG4gICAgICAgICAgdmFyIGZvcm1hdCA9IHBpcHMuZm9ybWF0IHx8IHtcbiAgICAgICAgICAgIHRvOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLnJvdW5kKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzY29wZV9QaXBzID0gc2NvcGVfVGFyZ2V0LmFwcGVuZENoaWxkKGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXIsIGZvcm1hdCkpO1xuICAgICAgICAgIHJldHVybiBzY29wZV9QaXBzO1xuICAgICAgICB9IC8vIFNob3J0aGFuZCBmb3IgYmFzZSBkaW1lbnNpb25zLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gYmFzZVNpemUoKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSBzY29wZV9CYXNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHZhciBhbHQgPSBcIm9mZnNldFwiICsgW1wiV2lkdGhcIiwgXCJIZWlnaHRcIl1bb3B0aW9ucy5vcnRdO1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLm9ydCA9PT0gMCA/IHJlY3Qud2lkdGggfHwgc2NvcGVfQmFzZVthbHRdIDogcmVjdC5oZWlnaHQgfHwgc2NvcGVfQmFzZVthbHRdO1xuICAgICAgICB9IC8vIEhhbmRsZXIgZm9yIGF0dGFjaGluZyBldmVudHMgdHJvdWdoIGEgcHJveHkuXG5cblxuICAgICAgICBmdW5jdGlvbiBhdHRhY2hFdmVudChldmVudHMsIGVsZW1lbnQsIGNhbGxiYWNrLCBkYXRhKSB7XG4gICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byAnZmlsdGVyJyBldmVudHMgdG8gdGhlIHNsaWRlci5cbiAgICAgICAgICAvLyBlbGVtZW50IGlzIGEgbm9kZSwgbm90IGEgbm9kZUxpc3RcbiAgICAgICAgICB2YXIgbWV0aG9kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGZpeEV2ZW50KGV2ZW50LCBkYXRhLnBhZ2VPZmZzZXQsIGRhdGEudGFyZ2V0IHx8IGVsZW1lbnQpOyAvLyBmaXhFdmVudCByZXR1cm5zIGZhbHNlIGlmIHRoaXMgZXZlbnQgaGFzIGEgZGlmZmVyZW50IHRhcmdldFxuICAgICAgICAgICAgLy8gd2hlbiBoYW5kbGluZyAobXVsdGktKSB0b3VjaCBldmVudHM7XG5cbiAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IC8vIGRvTm90UmVqZWN0IGlzIHBhc3NlZCBieSBhbGwgZW5kIGV2ZW50cyB0byBtYWtlIHN1cmUgcmVsZWFzZWQgdG91Y2hlc1xuICAgICAgICAgICAgLy8gYXJlIG5vdCByZWplY3RlZCwgbGVhdmluZyB0aGUgc2xpZGVyIFwic3R1Y2tcIiB0byB0aGUgY3Vyc29yO1xuXG5cbiAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgJiYgIWRhdGEuZG9Ob3RSZWplY3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyBTdG9wIGlmIGFuIGFjdGl2ZSAndGFwJyB0cmFuc2l0aW9uIGlzIHRha2luZyBwbGFjZS5cblxuXG4gICAgICAgICAgICBpZiAoaGFzQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwKSAmJiAhZGF0YS5kb05vdFJlamVjdCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcblxuXG4gICAgICAgICAgICBpZiAoZXZlbnRzID09PSBhY3Rpb25zLnN0YXJ0ICYmIGUuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9ucyA+IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XG5cblxuICAgICAgICAgICAgaWYgKGRhdGEuaG92ZXIgJiYgZS5idXR0b25zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gLy8gJ3N1cHBvcnRzUGFzc2l2ZScgaXMgb25seSB0cnVlIGlmIGEgYnJvd3NlciBhbHNvIHN1cHBvcnRzIHRvdWNoLWFjdGlvbjogbm9uZSBpbiBDU1MuXG4gICAgICAgICAgICAvLyBpT1Mgc2FmYXJpIGRvZXMgbm90LCBzbyBpdCBkb2Vzbid0IGdldCB0byBiZW5lZml0IGZyb20gcGFzc2l2ZSBzY3JvbGxpbmcuIGlPUyBkb2VzIHN1cHBvcnRcbiAgICAgICAgICAgIC8vIHRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uLCBidXQgdGhhdCBhbGxvd3MgcGFubmluZywgd2hpY2ggYnJlYWtzXG4gICAgICAgICAgICAvLyBzbGlkZXJzIGFmdGVyIHpvb21pbmcvb24gbm9uLXJlc3BvbnNpdmUgcGFnZXMuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzMxMTJcblxuXG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRzUGFzc2l2ZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUuY2FsY1BvaW50ID0gZS5wb2ludHNbb3B0aW9ucy5vcnRdOyAvLyBDYWxsIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIGV2ZW50IFsgYW5kIGFkZGl0aW9uYWwgZGF0YSBdLlxuXG4gICAgICAgICAgICBjYWxsYmFjayhlLCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIG1ldGhvZHMgPSBbXTsgLy8gQmluZCBhIGNsb3N1cmUgb24gdGhlIHRhcmdldCBmb3IgZXZlcnkgZXZlbnQgdHlwZS5cblxuICAgICAgICAgIGV2ZW50cy5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBtZXRob2QsIHN1cHBvcnRzUGFzc2l2ZSA/IHtcbiAgICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgICAgfSA6IGZhbHNlKTtcbiAgICAgICAgICAgIG1ldGhvZHMucHVzaChbZXZlbnROYW1lLCBtZXRob2RdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kcztcbiAgICAgICAgfSAvLyBQcm92aWRlIGEgY2xlYW4gZXZlbnQgd2l0aCBzdGFuZGFyZGl6ZWQgb2Zmc2V0IHZhbHVlcy5cblxuXG4gICAgICAgIGZ1bmN0aW9uIGZpeEV2ZW50KGUsIHBhZ2VPZmZzZXQsIGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgLy8gRmlsdGVyIHRoZSBldmVudCB0byByZWdpc3RlciB0aGUgdHlwZSwgd2hpY2ggY2FuIGJlXG4gICAgICAgICAgLy8gdG91Y2gsIG1vdXNlIG9yIHBvaW50ZXIuIE9mZnNldCBjaGFuZ2VzIG5lZWQgdG8gYmVcbiAgICAgICAgICAvLyBtYWRlIG9uIGFuIGV2ZW50IHNwZWNpZmljIGJhc2lzLlxuICAgICAgICAgIHZhciB0b3VjaCA9IGUudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPT09IDA7XG4gICAgICAgICAgdmFyIG1vdXNlID0gZS50eXBlLmluZGV4T2YoXCJtb3VzZVwiKSA9PT0gMDtcbiAgICAgICAgICB2YXIgcG9pbnRlciA9IGUudHlwZS5pbmRleE9mKFwicG9pbnRlclwiKSA9PT0gMDtcbiAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgdmFyIHkgPSAwOyAvLyBJRTEwIGltcGxlbWVudGVkIHBvaW50ZXIgZXZlbnRzIHdpdGggYSBwcmVmaXg7XG5cbiAgICAgICAgICBpZiAoZS50eXBlLmluZGV4T2YoXCJNU1BvaW50ZXJcIikgPT09IDApIHtcbiAgICAgICAgICAgIHBvaW50ZXIgPSB0cnVlO1xuICAgICAgICAgIH0gLy8gRXJyb25lb3VzIGV2ZW50cyBzZWVtIHRvIGJlIHBhc3NlZCBpbiBvY2Nhc2lvbmFsbHkgb24gaU9TL2lQYWRPUyBhZnRlciB1c2VyIGZpbmlzaGVzIGludGVyYWN0aW5nIHdpdGhcbiAgICAgICAgICAvLyB0aGUgc2xpZGVyLiBUaGV5IGFwcGVhciB0byBiZSBvZiB0eXBlIE1vdXNlRXZlbnQsIHlldCB0aGV5IGRvbid0IGhhdmUgdXN1YWwgcHJvcGVydGllcyBzZXQuIElnbm9yZVxuICAgICAgICAgIC8vIGV2ZW50cyB0aGF0IGhhdmUgbm8gdG91Y2hlcyBvciBidXR0b25zIGFzc29jaWF0ZWQgd2l0aCB0aGVtLiAoIzEwNTcsICMxMDc5LCAjMTA5NSlcblxuXG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJtb3VzZWRvd25cIiAmJiAhZS5idXR0b25zICYmICFlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IC8vIFRoZSBvbmx5IHRoaW5nIG9uZSBoYW5kbGUgc2hvdWxkIGJlIGNvbmNlcm5lZCBhYm91dCBpcyB0aGUgdG91Y2hlcyB0aGF0IG9yaWdpbmF0ZWQgb24gdG9wIG9mIGl0LlxuXG5cbiAgICAgICAgICBpZiAodG91Y2gpIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIHRvdWNoIG9yaWdpbmF0ZWQgb24gdGhlIHRhcmdldC5cbiAgICAgICAgICAgIHZhciBpc1RvdWNoT25UYXJnZXQgPSBmdW5jdGlvbiAoY2hlY2tUb3VjaCkge1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gY2hlY2tUb3VjaC50YXJnZXQ7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQgPT09IGV2ZW50VGFyZ2V0IHx8IGV2ZW50VGFyZ2V0LmNvbnRhaW5zKHRhcmdldCkgfHwgZS5jb21wb3NlZCAmJiBlLmNvbXBvc2VkUGF0aCgpLnNoaWZ0KCkgPT09IGV2ZW50VGFyZ2V0O1xuICAgICAgICAgICAgfTsgLy8gSW4gdGhlIGNhc2Ugb2YgdG91Y2hzdGFydCBldmVudHMsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXJlIGlzIHN0aWxsIG5vIG1vcmUgdGhhbiBvbmVcbiAgICAgICAgICAgIC8vIHRvdWNoIG9uIHRoZSB0YXJnZXQgc28gd2UgbG9vayBhbW9uZ3N0IGFsbCB0b3VjaGVzLlxuXG5cbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiKSB7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXRUb3VjaGVzID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGUudG91Y2hlcywgaXNUb3VjaE9uVGFyZ2V0KTsgLy8gRG8gbm90IHN1cHBvcnQgbW9yZSB0aGFuIG9uZSB0b3VjaCBwZXIgaGFuZGxlLlxuXG4gICAgICAgICAgICAgIGlmICh0YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB4ID0gdGFyZ2V0VG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgICAgeSA9IHRhcmdldFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJbiB0aGUgb3RoZXIgY2FzZXMsIGZpbmQgb24gY2hhbmdlZFRvdWNoZXMgaXMgZW5vdWdoLlxuICAgICAgICAgICAgICB2YXIgdGFyZ2V0VG91Y2ggPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGUuY2hhbmdlZFRvdWNoZXMsIGlzVG91Y2hPblRhcmdldCk7IC8vIENhbmNlbCBpZiB0aGUgdGFyZ2V0IHRvdWNoIGhhcyBub3QgbW92ZWQuXG5cbiAgICAgICAgICAgICAgaWYgKCF0YXJnZXRUb3VjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHggPSB0YXJnZXRUb3VjaC5wYWdlWDtcbiAgICAgICAgICAgICAgeSA9IHRhcmdldFRvdWNoLnBhZ2VZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhZ2VPZmZzZXQgPSBwYWdlT2Zmc2V0IHx8IGdldFBhZ2VPZmZzZXQoc2NvcGVfRG9jdW1lbnQpO1xuXG4gICAgICAgICAgaWYgKG1vdXNlIHx8IHBvaW50ZXIpIHtcbiAgICAgICAgICAgIHggPSBlLmNsaWVudFggKyBwYWdlT2Zmc2V0Lng7XG4gICAgICAgICAgICB5ID0gZS5jbGllbnRZICsgcGFnZU9mZnNldC55O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUucGFnZU9mZnNldCA9IHBhZ2VPZmZzZXQ7XG4gICAgICAgICAgZS5wb2ludHMgPSBbeCwgeV07XG4gICAgICAgICAgZS5jdXJzb3IgPSBtb3VzZSB8fCBwb2ludGVyOyAvLyBGaXggIzQzNVxuXG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0gLy8gVHJhbnNsYXRlIGEgY29vcmRpbmF0ZSBpbiB0aGUgZG9jdW1lbnQgdG8gYSBwZXJjZW50YWdlIG9uIHRoZSBzbGlkZXJcblxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGNQb2ludFRvUGVyY2VudGFnZShjYWxjUG9pbnQpIHtcbiAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjYWxjUG9pbnQgLSBvZmZzZXQoc2NvcGVfQmFzZSwgb3B0aW9ucy5vcnQpO1xuICAgICAgICAgIHZhciBwcm9wb3NhbCA9IGxvY2F0aW9uICogMTAwIC8gYmFzZVNpemUoKTsgLy8gQ2xhbXAgcHJvcG9zYWwgYmV0d2VlbiAwJSBhbmQgMTAwJVxuICAgICAgICAgIC8vIE91dC1vZi1ib3VuZCBjb29yZGluYXRlcyBtYXkgb2NjdXIgd2hlbiAubm9VaS1iYXNlIHBzZXVkby1lbGVtZW50c1xuICAgICAgICAgIC8vIGFyZSB1c2VkIChlLmcuIGNvbnRhaW5lZCBoYW5kbGVzIGZlYXR1cmUpXG5cbiAgICAgICAgICBwcm9wb3NhbCA9IGxpbWl0KHByb3Bvc2FsKTtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBwcm9wb3NhbCA6IHByb3Bvc2FsO1xuICAgICAgICB9IC8vIEZpbmQgaGFuZGxlIGNsb3Nlc3QgdG8gYSBjZXJ0YWluIHBlcmNlbnRhZ2Ugb24gdGhlIHNsaWRlclxuXG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShjbGlja2VkUG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgc21hbGxlc3REaWZmZXJlbmNlID0gMTAwO1xuICAgICAgICAgIHZhciBoYW5kbGVOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIERpc2FibGVkIGhhbmRsZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgIGlmIChpc0hhbmRsZURpc2FibGVkKGluZGV4KSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoYW5kbGVQb3NpdGlvbiA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgZGlmZmVyZW5jZVdpdGhUaGlzSGFuZGxlID0gTWF0aC5hYnMoaGFuZGxlUG9zaXRpb24gLSBjbGlja2VkUG9zaXRpb24pOyAvLyBJbml0aWFsIHN0YXRlXG5cbiAgICAgICAgICAgIHZhciBjbGlja0F0RWRnZSA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA9PT0gMTAwICYmIHNtYWxsZXN0RGlmZmVyZW5jZSA9PT0gMTAwOyAvLyBEaWZmZXJlbmNlIHdpdGggdGhpcyBoYW5kbGUgaXMgc21hbGxlciB0aGFuIHRoZSBwcmV2aW91c2x5IGNoZWNrZWQgaGFuZGxlXG5cbiAgICAgICAgICAgIHZhciBpc0Nsb3NlciA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA8IHNtYWxsZXN0RGlmZmVyZW5jZTtcbiAgICAgICAgICAgIHZhciBpc0Nsb3NlckFmdGVyID0gZGlmZmVyZW5jZVdpdGhUaGlzSGFuZGxlIDw9IHNtYWxsZXN0RGlmZmVyZW5jZSAmJiBjbGlja2VkUG9zaXRpb24gPiBoYW5kbGVQb3NpdGlvbjtcblxuICAgICAgICAgICAgaWYgKGlzQ2xvc2VyIHx8IGlzQ2xvc2VyQWZ0ZXIgfHwgY2xpY2tBdEVkZ2UpIHtcbiAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyID0gaW5kZXg7XG4gICAgICAgICAgICAgIHNtYWxsZXN0RGlmZmVyZW5jZSA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlTnVtYmVyO1xuICAgICAgICB9IC8vIEZpcmUgJ2VuZCcgd2hlbiBhIG1vdXNlIG9yIHBlbiBsZWF2ZXMgdGhlIGRvY3VtZW50LlxuXG5cbiAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRMZWF2ZShldmVudCwgZGF0YSkge1xuICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBcIm1vdXNlb3V0XCIgJiYgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkhUTUxcIiAmJiBldmVudC5yZWxhdGVkVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudEVuZChldmVudCwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEhhbmRsZSBtb3ZlbWVudCBvbiBkb2N1bWVudCBmb3IgaGFuZGxlIGFuZCByYW5nZSBkcmFnLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRNb3ZlKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgLy8gRml4ICM0OThcbiAgICAgICAgICAvLyBDaGVjayB2YWx1ZSBvZiAuYnV0dG9ucyBpbiAnc3RhcnQnIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFMTAgbW9iaWxlIChkYXRhLmJ1dHRvbnNQcm9wZXJ0eSkuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy85MjcwMDUvbW9iaWxlLWllMTAtd2luZG93cy1waG9uZS1idXR0b25zLXByb3BlcnR5LW9mLXBvaW50ZXJtb3ZlLWV2ZW50LWFsd2F5cy16ZXJvXG4gICAgICAgICAgLy8gSUU5IGhhcyAuYnV0dG9ucyBhbmQgLndoaWNoIHplcm8gb24gbW91c2Vtb3ZlLlxuICAgICAgICAgIC8vIEZpcmVmb3ggYnJlYWtzIHRoZSBzcGVjIE1ETiBkZWZpbmVzLlxuICAgICAgICAgIGlmIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKFwiTVNJRSA5XCIpID09PSAtMSAmJiBldmVudC5idXR0b25zID09PSAwICYmIGRhdGEuYnV0dG9uc1Byb3BlcnR5ICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRFbmQoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgIH0gLy8gQ2hlY2sgaWYgd2UgYXJlIG1vdmluZyB1cCBvciBkb3duXG5cblxuICAgICAgICAgIHZhciBtb3ZlbWVudCA9IChvcHRpb25zLmRpciA/IC0xIDogMSkgKiAoZXZlbnQuY2FsY1BvaW50IC0gZGF0YS5zdGFydENhbGNQb2ludCk7IC8vIENvbnZlcnQgdGhlIG1vdmVtZW50IGludG8gYSBwZXJjZW50YWdlIG9mIHRoZSBzbGlkZXIgd2lkdGgvaGVpZ2h0XG5cbiAgICAgICAgICB2YXIgcHJvcG9zYWwgPSBtb3ZlbWVudCAqIDEwMCAvIGRhdGEuYmFzZVNpemU7XG4gICAgICAgICAgbW92ZUhhbmRsZXMobW92ZW1lbnQgPiAwLCBwcm9wb3NhbCwgZGF0YS5sb2NhdGlvbnMsIGRhdGEuaGFuZGxlTnVtYmVycywgZGF0YS5jb25uZWN0KTtcbiAgICAgICAgfSAvLyBVbmJpbmQgbW92ZSBldmVudHMgb24gZG9jdW1lbnQsIGNhbGwgY2FsbGJhY2tzLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRFbmQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAvLyBUaGUgaGFuZGxlIGlzIG5vIGxvbmdlciBhY3RpdmUsIHNvIHJlbW92ZSB0aGUgY2xhc3MuXG4gICAgICAgICAgaWYgKGRhdGEuaGFuZGxlKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhkYXRhLmhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XG4gICAgICAgICAgICBzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgLT0gMTtcbiAgICAgICAgICB9IC8vIFVuYmluZCB0aGUgbW92ZSBhbmQgZW5kIGV2ZW50cywgd2hpY2ggYXJlIGFkZGVkIG9uICdzdGFydCcuXG5cblxuICAgICAgICAgIGRhdGEubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHNjb3BlX0RvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNbMF0sIGNbMV0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGRyYWdnaW5nIGNsYXNzLlxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZyk7XG4gICAgICAgICAgICBzZXRaaW5kZXgoKTsgLy8gUmVtb3ZlIGN1cnNvciBzdHlsZXMgYW5kIHRleHQtc2VsZWN0aW9uIGV2ZW50cyBib3VuZCB0byB0aGUgYm9keS5cblxuICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xuICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICAgIHNjb3BlX0JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5ldmVudHMuc21vb3RoU3RlcHMpIHtcbiAgICAgICAgICAgIGRhdGEuaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0sIHRydWUsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGEuaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJjaGFuZ2VcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwiZW5kXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gQmluZCBtb3ZlIGV2ZW50cyBvbiBkb2N1bWVudC5cblxuXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50U3RhcnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgZXZlbnQgaWYgYW55IGhhbmRsZSBpcyBkaXNhYmxlZFxuICAgICAgICAgIGlmIChkYXRhLmhhbmRsZU51bWJlcnMuc29tZShpc0hhbmRsZURpc2FibGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoYW5kbGU7XG5cbiAgICAgICAgICBpZiAoZGF0YS5oYW5kbGVOdW1iZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbZGF0YS5oYW5kbGVOdW1iZXJzWzBdXTtcbiAgICAgICAgICAgIGhhbmRsZSA9IGhhbmRsZU9yaWdpbi5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCArPSAxOyAvLyBNYXJrIHRoZSBoYW5kbGUgYXMgJ2FjdGl2ZScgc28gaXQgY2FuIGJlIHN0eWxlZC5cblxuICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuYWN0aXZlKTtcbiAgICAgICAgICB9IC8vIEEgZHJhZyBzaG91bGQgbmV2ZXIgcHJvcGFnYXRlIHVwIHRvIHRoZSAndGFwJyBldmVudC5cblxuXG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFJlY29yZCB0aGUgZXZlbnQgbGlzdGVuZXJzLlxuXG4gICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdOyAvLyBBdHRhY2ggdGhlIG1vdmUgYW5kIGVuZCBldmVudHMuXG5cbiAgICAgICAgICB2YXIgbW92ZUV2ZW50ID0gYXR0YWNoRXZlbnQoYWN0aW9ucy5tb3ZlLCBzY29wZV9Eb2N1bWVudEVsZW1lbnQsIGV2ZW50TW92ZSwge1xuICAgICAgICAgICAgLy8gVGhlIGV2ZW50IHRhcmdldCBoYXMgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHByb3BhZ2F0ZSB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgd2Uga2VlcFxuICAgICAgICAgICAgLy8gcmVseWluZyBvbiBpdCB0byBleHRyYWN0IHRhcmdldCB0b3VjaGVzLlxuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgICAgIGNvbm5lY3Q6IGRhdGEuY29ubmVjdCxcbiAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgc3RhcnRDYWxjUG9pbnQ6IGV2ZW50LmNhbGNQb2ludCxcbiAgICAgICAgICAgIGJhc2VTaXplOiBiYXNlU2l6ZSgpLFxuICAgICAgICAgICAgcGFnZU9mZnNldDogZXZlbnQucGFnZU9mZnNldCxcbiAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVycyxcbiAgICAgICAgICAgIGJ1dHRvbnNQcm9wZXJ0eTogZXZlbnQuYnV0dG9ucyxcbiAgICAgICAgICAgIGxvY2F0aW9uczogc2NvcGVfTG9jYXRpb25zLnNsaWNlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBhdHRhY2hFdmVudChhY3Rpb25zLmVuZCwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBldmVudEVuZCwge1xuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXG4gICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgb3V0RXZlbnQgPSBhdHRhY2hFdmVudChcIm1vdXNlb3V0XCIsIHNjb3BlX0RvY3VtZW50RWxlbWVudCwgZG9jdW1lbnRMZWF2ZSwge1xuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXG4gICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcbiAgICAgICAgICB9KTsgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgcHVzaGVkIHRoZSBsaXN0ZW5lcnMgaW4gdGhlIGxpc3RlbmVyIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRpbmdcbiAgICAgICAgICAvLyBhIG5ldyBvbmUgYXMgaXQgaGFzIGFscmVhZHkgYmVlbiBwYXNzZWQgdG8gdGhlIGV2ZW50IGhhbmRsZXJzLlxuXG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2guYXBwbHkobGlzdGVuZXJzLCBtb3ZlRXZlbnQuY29uY2F0KGVuZEV2ZW50LCBvdXRFdmVudCkpOyAvLyBUZXh0IHNlbGVjdGlvbiBpc24ndCBhbiBpc3N1ZSBvbiB0b3VjaCBkZXZpY2VzLFxuICAgICAgICAgIC8vIHNvIGFkZGluZyBjdXJzb3Igc3R5bGVzIGNhbiBiZSBza2lwcGVkLlxuXG4gICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xuICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgJ0knIGN1cnNvciBhbmQgZXh0ZW5kIHRoZSByYW5nZS1kcmFnIGN1cnNvci5cbiAgICAgICAgICAgIHNjb3BlX0JvZHkuc3R5bGUuY3Vyc29yID0gZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjsgLy8gTWFyayB0aGUgdGFyZ2V0IHdpdGggYSBkcmFnZ2luZyBzdGF0ZS5cblxuICAgICAgICAgICAgaWYgKHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBhZGRDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnKTtcbiAgICAgICAgICAgIH0gLy8gUHJldmVudCB0ZXh0IHNlbGVjdGlvbiB3aGVuIGRyYWdnaW5nIHRoZSBoYW5kbGVzLlxuICAgICAgICAgICAgLy8gSW4gbm9VaVNsaWRlciA8PSA5LjIuMCwgdGhpcyB3YXMgaGFuZGxlZCBieSBjYWxsaW5nIHByZXZlbnREZWZhdWx0IG9uIG1vdXNlL3RvdWNoIHN0YXJ0L21vdmUsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBzY3JvbGwgYmxvY2tpbmcuIFRoZSBzZWxlY3RzdGFydCBldmVudCBpcyBzdXBwb3J0ZWQgYnkgRmlyZUZveCBzdGFydGluZyBmcm9tIHZlcnNpb24gNTIsXG4gICAgICAgICAgICAvLyBtZWFuaW5nIHRoZSBvbmx5IGhvbGRvdXQgaXMgaU9TIFNhZmFyaS4gVGhpcyBkb2Vzbid0IG1hdHRlcjogdGV4dCBzZWxlY3Rpb24gaXNuJ3QgdHJpZ2dlcmVkIHRoZXJlLlxuICAgICAgICAgICAgLy8gVGhlICdjdXJzb3InIGZsYWcgaXMgZmFsc2UuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXNlbGVjdHN0YXJ0XG5cblxuICAgICAgICAgICAgc2NvcGVfQm9keS5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgcHJldmVudERlZmF1bHQsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJzdGFydFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIE1vdmUgY2xvc2VzdCBoYW5kbGUgdG8gdGFwcGVkIGxvY2F0aW9uLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRUYXAoZXZlbnQpIHtcbiAgICAgICAgICAvLyBUaGUgdGFwIGV2ZW50IHNob3VsZG4ndCBwcm9wYWdhdGUgdXBcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB2YXIgcHJvcG9zYWwgPSBjYWxjUG9pbnRUb1BlcmNlbnRhZ2UoZXZlbnQuY2FsY1BvaW50KTtcbiAgICAgICAgICB2YXIgaGFuZGxlTnVtYmVyID0gZ2V0Q2xvc2VzdEhhbmRsZShwcm9wb3NhbCk7IC8vIFRhY2tsZSB0aGUgY2FzZSB0aGF0IGFsbCBoYW5kbGVzIGFyZSAnZGlzYWJsZWQnLlxuXG4gICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIEZsYWcgdGhlIHNsaWRlciBhcyBpdCBpcyBub3cgaW4gYSB0cmFuc2l0aW9uYWwgc3RhdGUuXG4gICAgICAgICAgLy8gVHJhbnNpdGlvbiB0YWtlcyBhIGNvbmZpZ3VyYWJsZSBhbW91bnQgb2YgbXMgKGRlZmF1bHQgMzAwKS4gUmUtZW5hYmxlIHRoZSBzbGlkZXIgYWZ0ZXIgdGhhdC5cblxuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICBhZGRDbGFzc0ZvcihzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXAsIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHByb3Bvc2FsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBzZXRaaW5kZXgoKTtcbiAgICAgICAgICBmaXJlRXZlbnQoXCJzbGlkZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJjaGFuZ2VcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldmVudFN0YXJ0KGV2ZW50LCB7XG4gICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IFtoYW5kbGVOdW1iZXJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRmlyZXMgYSAnaG92ZXInIGV2ZW50IGZvciBhIGhvdmVyZWQgbW91c2UvcGVuIHBvc2l0aW9uLlxuXG5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRIb3ZlcihldmVudCkge1xuICAgICAgICAgIHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xuICAgICAgICAgIHZhciB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAocHJvcG9zYWwpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XG4gICAgICAgICAgT2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXRFdmVudCkge1xuICAgICAgICAgICAgaWYgKFwiaG92ZXJcIiA9PT0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdKSB7XG4gICAgICAgICAgICAgIHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjb3BlX1NlbGYsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gSGFuZGxlcyBrZXlkb3duIG9uIGZvY3VzZWQgaGFuZGxlc1xuICAgICAgICAvLyBEb24ndCBtb3ZlIHRoZSBkb2N1bWVudCB3aGVuIHByZXNzaW5nIGFycm93IGtleXMgb24gZm9jdXNlZCBoYW5kbGVzXG5cblxuICAgICAgICBmdW5jdGlvbiBldmVudEtleWRvd24oZXZlbnQsIGhhbmRsZU51bWJlcikge1xuICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgfHwgaXNIYW5kbGVEaXNhYmxlZChoYW5kbGVOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhvcml6b250YWxLZXlzID0gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdO1xuICAgICAgICAgIHZhciB2ZXJ0aWNhbEtleXMgPSBbXCJEb3duXCIsIFwiVXBcIl07XG4gICAgICAgICAgdmFyIGxhcmdlU3RlcEtleXMgPSBbXCJQYWdlRG93blwiLCBcIlBhZ2VVcFwiXTtcbiAgICAgICAgICB2YXIgZWRnZUtleXMgPSBbXCJIb21lXCIsIFwiRW5kXCJdO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyICYmICFvcHRpb25zLm9ydCkge1xuICAgICAgICAgICAgLy8gT24gYW4gcmlnaHQtdG8tbGVmdCBzbGlkZXIsIHRoZSBsZWZ0IGFuZCByaWdodCBrZXlzIGFjdCBpbnZlcnRlZFxuICAgICAgICAgICAgaG9yaXpvbnRhbEtleXMucmV2ZXJzZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vcnQgJiYgIW9wdGlvbnMuZGlyKSB7XG4gICAgICAgICAgICAvLyBPbiBhIHRvcC10by1ib3R0b20gc2xpZGVyLCB0aGUgdXAgYW5kIGRvd24ga2V5cyBhY3QgaW52ZXJ0ZWRcbiAgICAgICAgICAgIHZlcnRpY2FsS2V5cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsYXJnZVN0ZXBLZXlzLnJldmVyc2UoKTtcbiAgICAgICAgICB9IC8vIFN0cmlwIFwiQXJyb3dcIiBmb3IgSUUgY29tcGF0aWJpbGl0eS4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5XG5cblxuICAgICAgICAgIHZhciBrZXkgPSBldmVudC5rZXkucmVwbGFjZShcIkFycm93XCIsIFwiXCIpO1xuICAgICAgICAgIHZhciBpc0xhcmdlRG93biA9IGtleSA9PT0gbGFyZ2VTdGVwS2V5c1swXTtcbiAgICAgICAgICB2YXIgaXNMYXJnZVVwID0ga2V5ID09PSBsYXJnZVN0ZXBLZXlzWzFdO1xuICAgICAgICAgIHZhciBpc0Rvd24gPSBrZXkgPT09IHZlcnRpY2FsS2V5c1swXSB8fCBrZXkgPT09IGhvcml6b250YWxLZXlzWzBdIHx8IGlzTGFyZ2VEb3duO1xuICAgICAgICAgIHZhciBpc1VwID0ga2V5ID09PSB2ZXJ0aWNhbEtleXNbMV0gfHwga2V5ID09PSBob3Jpem9udGFsS2V5c1sxXSB8fCBpc0xhcmdlVXA7XG4gICAgICAgICAgdmFyIGlzTWluID0ga2V5ID09PSBlZGdlS2V5c1swXTtcbiAgICAgICAgICB2YXIgaXNNYXggPSBrZXkgPT09IGVkZ2VLZXlzWzFdO1xuXG4gICAgICAgICAgaWYgKCFpc0Rvd24gJiYgIWlzVXAgJiYgIWlzTWluICYmICFpc01heCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgdG87XG5cbiAgICAgICAgICBpZiAoaXNVcCB8fCBpc0Rvd24pIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBpc0Rvd24gPyAwIDogMTtcbiAgICAgICAgICAgIHZhciBzdGVwcyA9IGdldE5leHRTdGVwc0ZvckhhbmRsZShoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBzdGVwc1tkaXJlY3Rpb25dOyAvLyBBdCB0aGUgZWRnZSBvZiBhIHNsaWRlciwgZG8gbm90aGluZ1xuXG4gICAgICAgICAgICBpZiAoc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IC8vIE5vIHN0ZXAgc2V0LCB1c2UgdGhlIGRlZmF1bHQgb2YgMTAlIG9mIHRoZSBzdWItcmFuZ2VcblxuXG4gICAgICAgICAgICBpZiAoc3RlcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc3RlcCA9IHNjb3BlX1NwZWN0cnVtLmdldERlZmF1bHRTdGVwKHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdLCBpc0Rvd24sIG9wdGlvbnMua2V5Ym9hcmREZWZhdWx0U3RlcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0xhcmdlVXAgfHwgaXNMYXJnZURvd24pIHtcbiAgICAgICAgICAgICAgc3RlcCAqPSBvcHRpb25zLmtleWJvYXJkUGFnZU11bHRpcGxpZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGVwICo9IG9wdGlvbnMua2V5Ym9hcmRNdWx0aXBsaWVyO1xuICAgICAgICAgICAgfSAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcblxuXG4gICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoc3RlcCwgMC4wMDAwMDAxKTsgLy8gRGVjcmVtZW50IGZvciBkb3duIHN0ZXBzXG5cbiAgICAgICAgICAgIHN0ZXAgPSAoaXNEb3duID8gLTEgOiAxKSAqIHN0ZXA7XG4gICAgICAgICAgICB0byA9IHNjb3BlX1ZhbHVlc1toYW5kbGVOdW1iZXJdICsgc3RlcDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF4KSB7XG4gICAgICAgICAgICAvLyBFbmQga2V5XG4gICAgICAgICAgICB0byA9IG9wdGlvbnMuc3BlY3RydW0ueFZhbFtvcHRpb25zLnNwZWN0cnVtLnhWYWwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhvbWUga2V5XG4gICAgICAgICAgICB0byA9IG9wdGlvbnMuc3BlY3RydW0ueFZhbFswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHRvKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgZmlyZUV2ZW50KFwic2xpZGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICBmaXJlRXZlbnQoXCJjaGFuZ2VcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gQXR0YWNoIGV2ZW50cyB0byBzZXZlcmFsIHNsaWRlciBwYXJ0cy5cblxuXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRTbGlkZXJFdmVudHMoYmVoYXZpb3VyKSB7XG4gICAgICAgICAgLy8gQXR0YWNoIHRoZSBzdGFuZGFyZCBkcmFnIGV2ZW50IHRvIHRoZSBoYW5kbGVzLlxuICAgICAgICAgIGlmICghYmVoYXZpb3VyLmZpeGVkKSB7XG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGFyZSBvbmx5IGJvdW5kIHRvIHRoZSB2aXN1YWwgaGFuZGxlXG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQsIG5vdCB0aGUgJ3JlYWwnIG9yaWdpbiBlbGVtZW50LlxuICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBoYW5kbGUuY2hpbGRyZW5bMF0sIGV2ZW50U3RhcnQsIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBbaW5kZXhdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBBdHRhY2ggdGhlIHRhcCBldmVudCB0byB0aGUgc2xpZGVyIGJhc2UuXG5cblxuICAgICAgICAgIGlmIChiZWhhdmlvdXIudGFwKSB7XG4gICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBzY29wZV9CYXNlLCBldmVudFRhcCwge30pO1xuICAgICAgICAgIH0gLy8gRmlyZSBob3ZlciBldmVudHNcblxuXG4gICAgICAgICAgaWYgKGJlaGF2aW91ci5ob3Zlcikge1xuICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5tb3ZlLCBzY29wZV9CYXNlLCBldmVudEhvdmVyLCB7XG4gICAgICAgICAgICAgIGhvdmVyOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIE1ha2UgdGhlIHJhbmdlIGRyYWdnYWJsZS5cblxuXG4gICAgICAgICAgaWYgKGJlaGF2aW91ci5kcmFnKSB7XG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb25uZWN0LCBpbmRleCkge1xuICAgICAgICAgICAgICBpZiAoY29ubmVjdCA9PT0gZmFsc2UgfHwgaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHNjb3BlX0Nvbm5lY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaGFuZGxlQmVmb3JlID0gc2NvcGVfSGFuZGxlc1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgICB2YXIgaGFuZGxlQWZ0ZXIgPSBzY29wZV9IYW5kbGVzW2luZGV4XTtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50SG9sZGVycyA9IFtjb25uZWN0XTtcbiAgICAgICAgICAgICAgdmFyIGhhbmRsZXNUb0RyYWcgPSBbaGFuZGxlQmVmb3JlLCBoYW5kbGVBZnRlcl07XG4gICAgICAgICAgICAgIHZhciBoYW5kbGVOdW1iZXJzVG9EcmFnID0gW2luZGV4IC0gMSwgaW5kZXhdO1xuICAgICAgICAgICAgICBhZGRDbGFzcyhjb25uZWN0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZ2dhYmxlKTsgLy8gV2hlbiB0aGUgcmFuZ2UgaXMgZml4ZWQsIHRoZSBlbnRpcmUgcmFuZ2UgY2FuXG4gICAgICAgICAgICAgIC8vIGJlIGRyYWdnZWQgYnkgdGhlIGhhbmRsZXMuIFRoZSBoYW5kbGUgaW4gdGhlIGZpcnN0XG4gICAgICAgICAgICAgIC8vIG9yaWdpbiB3aWxsIHByb3BhZ2F0ZSB0aGUgc3RhcnQgZXZlbnQgdXB3YXJkLFxuICAgICAgICAgICAgICAvLyBidXQgaXQgbmVlZHMgdG8gYmUgYm91bmQgbWFudWFsbHkgb24gdGhlIG90aGVyLlxuXG4gICAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuZml4ZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudEhvbGRlcnMucHVzaChoYW5kbGVCZWZvcmUuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVycy5wdXNoKGhhbmRsZUFmdGVyLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuZHJhZ0FsbCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXNUb0RyYWcgPSBzY29wZV9IYW5kbGVzO1xuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnNUb0RyYWcgPSBzY29wZV9IYW5kbGVOdW1iZXJzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgZXZlbnRIb2xkZXIsIGV2ZW50U3RhcnQsIHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZXM6IGhhbmRsZXNUb0RyYWcsXG4gICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBoYW5kbGVOdW1iZXJzVG9EcmFnLFxuICAgICAgICAgICAgICAgICAgY29ubmVjdDogY29ubmVjdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBBdHRhY2ggYW4gZXZlbnQgdG8gdGhpcyBzbGlkZXIsIHBvc3NpYmx5IGluY2x1ZGluZyBhIG5hbWVzcGFjZVxuXG5cbiAgICAgICAgZnVuY3Rpb24gYmluZEV2ZW50KG5hbWVzcGFjZWRFdmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XSA9IHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdIHx8IFtdO1xuICAgICAgICAgIHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdLnB1c2goY2FsbGJhY2spOyAvLyBJZiB0aGUgZXZlbnQgYm91bmQgaXMgJ3VwZGF0ZSwnIGZpcmUgaXQgaW1tZWRpYXRlbHkgZm9yIGFsbCBoYW5kbGVzLlxuXG4gICAgICAgICAgaWYgKG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF0gPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbiAoYSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzSW50ZXJuYWxOYW1lc3BhY2UobmFtZXNwYWNlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gSU5URVJOQUxfRVZFTlRfTlMuYXJpYSB8fCBuYW1lc3BhY2UgPT09IElOVEVSTkFMX0VWRU5UX05TLnRvb2x0aXBzO1xuICAgICAgICB9IC8vIFVuZG8gYXR0YWNobWVudCBvZiBldmVudFxuXG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnQobmFtZXNwYWNlZEV2ZW50KSB7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gbmFtZXNwYWNlZEV2ZW50ICYmIG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF07XG4gICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGV2ZW50ID8gbmFtZXNwYWNlZEV2ZW50LnN1YnN0cmluZyhldmVudC5sZW5ndGgpIDogbmFtZXNwYWNlZEV2ZW50O1xuICAgICAgICAgIE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoYmluZCkge1xuICAgICAgICAgICAgdmFyIHRFdmVudCA9IGJpbmQuc3BsaXQoXCIuXCIpWzBdO1xuICAgICAgICAgICAgdmFyIHROYW1lc3BhY2UgPSBiaW5kLnN1YnN0cmluZyh0RXZlbnQubGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKCghZXZlbnQgfHwgZXZlbnQgPT09IHRFdmVudCkgJiYgKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSB0TmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgICAvLyBvbmx5IGRlbGV0ZSBwcm90ZWN0ZWQgaW50ZXJuYWwgZXZlbnQgaWYgaW50ZW50aW9uYWxcbiAgICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsTmFtZXNwYWNlKHROYW1lc3BhY2UpIHx8IG5hbWVzcGFjZSA9PT0gdE5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY29wZV9FdmVudHNbYmluZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBFeHRlcm5hbCBldmVudCBoYW5kbGluZ1xuXG5cbiAgICAgICAgZnVuY3Rpb24gZmlyZUV2ZW50KGV2ZW50TmFtZSwgaGFuZGxlTnVtYmVyLCB0YXApIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldEV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgc2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoIC8vIFVzZSB0aGUgc2xpZGVyIHB1YmxpYyBBUEkgYXMgdGhlIHNjb3BlICgndGhpcycpXG4gICAgICAgICAgICAgICAgc2NvcGVfU2VsZiwgLy8gUmV0dXJuIHZhbHVlcyBhcyBhcnJheSwgc28gYXJnXzFbYXJnXzJdIGlzIGFsd2F5cyB2YWxpZC5cbiAgICAgICAgICAgICAgICBzY29wZV9WYWx1ZXMubWFwKG9wdGlvbnMuZm9ybWF0LnRvKSwgLy8gSGFuZGxlIGluZGV4LCAwIG9yIDFcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXIsIC8vIFVuLWZvcm1hdHRlZCBzbGlkZXIgdmFsdWVzXG4gICAgICAgICAgICAgICAgc2NvcGVfVmFsdWVzLnNsaWNlKCksIC8vIEV2ZW50IGlzIGZpcmVkIGJ5IHRhcCwgdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgICAgICAgIHRhcCB8fCBmYWxzZSwgLy8gTGVmdCBvZmZzZXQgb2YgdGhlIGhhbmRsZSwgaW4gcmVsYXRpb24gdG8gdGhlIHNsaWRlclxuICAgICAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpLCAvLyBhZGQgdGhlIHNsaWRlciBwdWJsaWMgQVBJIHRvIGFuIGFjY2Vzc2libGUgcGFyYW1ldGVyIHdoZW4gdGhpcyBpcyB1bmF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIHNjb3BlX1NlbGYpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBTcGxpdCBvdXQgdGhlIGhhbmRsZSBwb3NpdGlvbmluZyBsb2dpYyBzbyB0aGUgTW92ZSBldmVudCBjYW4gdXNlIGl0LCB0b29cblxuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrSGFuZGxlUG9zaXRpb24ocmVmZXJlbmNlLCBoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkLCBnZXRWYWx1ZSwgc21vb3RoU3RlcHMpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2U7IC8vIEZvciBzbGlkZXJzIHdpdGggbXVsdGlwbGUgaGFuZGxlcywgbGltaXQgbW92ZW1lbnQgdG8gdGhlIG90aGVyIGhhbmRsZS5cbiAgICAgICAgICAvLyBBcHBseSB0aGUgbWFyZ2luIG9wdGlvbiBieSBhZGRpbmcgaXQgdG8gdGhlIGhhbmRsZSBwb3NpdGlvbnMuXG5cbiAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmICFvcHRpb25zLmV2ZW50cy51bmNvbnN0cmFpbmVkKSB7XG4gICAgICAgICAgICBpZiAobG9va0JhY2t3YXJkICYmIGhhbmRsZU51bWJlciA+IDApIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSwgb3B0aW9ucy5tYXJnaW4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9va0ZvcndhcmQgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gc2NvcGVfU3BlY3RydW0uZ2V0QWJzb2x1dGVEaXN0YW5jZShyZWZlcmVuY2VbaGFuZGxlTnVtYmVyICsgMV0sIG9wdGlvbnMubWFyZ2luLCB0cnVlKTtcbiAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gVGhlIGxpbWl0IG9wdGlvbiBoYXMgdGhlIG9wcG9zaXRlIGVmZmVjdCwgbGltaXRpbmcgaGFuZGxlcyB0byBhXG4gICAgICAgICAgLy8gbWF4aW11bSBkaXN0YW5jZSBmcm9tIGFub3RoZXIuIExpbWl0IG11c3QgYmUgPiAwLCBhcyBvdGhlcndpc2VcbiAgICAgICAgICAvLyBoYW5kbGVzIHdvdWxkIGJlIHVubW92YWJsZS5cblxuXG4gICAgICAgICAgaWYgKHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSAmJiBvcHRpb25zLmxpbWl0KSB7XG4gICAgICAgICAgICBpZiAobG9va0JhY2t3YXJkICYmIGhhbmRsZU51bWJlciA+IDApIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSwgb3B0aW9ucy5saW1pdCwgZmFsc2UpO1xuICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSwgb3B0aW9ucy5saW1pdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFRoZSBwYWRkaW5nIG9wdGlvbiBrZWVwcyB0aGUgaGFuZGxlcyBhIGNlcnRhaW4gZGlzdGFuY2UgZnJvbSB0aGVcbiAgICAgICAgICAvLyBlZGdlcyBvZiB0aGUgc2xpZGVyLiBQYWRkaW5nIG11c3QgYmUgPiAwLlxuXG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gc2NvcGVfU3BlY3RydW0uZ2V0QWJzb2x1dGVEaXN0YW5jZSgwLCBvcHRpb25zLnBhZGRpbmdbMF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKDEwMCwgb3B0aW9ucy5wYWRkaW5nWzFdLCB0cnVlKTtcbiAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghc21vb3RoU3RlcHMpIHtcbiAgICAgICAgICAgIHRvID0gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCh0byk7XG4gICAgICAgICAgfSAvLyBMaW1pdCBwZXJjZW50YWdlIHRvIHRoZSAwIC0gMTAwIHJhbmdlXG5cblxuICAgICAgICAgIHRvID0gbGltaXQodG8pOyAvLyBSZXR1cm4gZmFsc2UgaWYgaGFuZGxlIGNhbid0IG1vdmVcblxuICAgICAgICAgIGlmICh0byA9PT0gcmVmZXJlbmNlW2hhbmRsZU51bWJlcl0gJiYgIWdldFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9IC8vIFVzZXMgc2xpZGVyIG9yaWVudGF0aW9uIHRvIGNyZWF0ZSBDU1MgcnVsZXMuIGEgPSBiYXNlIHZhbHVlO1xuXG5cbiAgICAgICAgZnVuY3Rpb24gaW5SdWxlT3JkZXIodiwgYSkge1xuICAgICAgICAgIHZhciBvID0gb3B0aW9ucy5vcnQ7XG4gICAgICAgICAgcmV0dXJuIChvID8gYSA6IHYpICsgXCIsIFwiICsgKG8gPyB2IDogYSk7XG4gICAgICAgIH0gLy8gTW92ZXMgaGFuZGxlKHMpIGJ5IGEgcGVyY2VudGFnZVxuICAgICAgICAvLyAoYm9vbCwgJSB0byBtb3ZlLCBbJSB3aGVyZSBoYW5kbGUgc3RhcnRlZCwgLi4uXSwgW2luZGV4IGluIHNjb3BlX0hhbmRsZXMsIC4uLl0pXG5cblxuICAgICAgICBmdW5jdGlvbiBtb3ZlSGFuZGxlcyh1cHdhcmQsIHByb3Bvc2FsLCBsb2NhdGlvbnMsIGhhbmRsZU51bWJlcnMsIGNvbm5lY3QpIHtcbiAgICAgICAgICB2YXIgcHJvcG9zYWxzID0gbG9jYXRpb25zLnNsaWNlKCk7IC8vIFN0b3JlIGZpcnN0IGhhbmRsZSBub3csIHNvIHdlIHN0aWxsIGhhdmUgaXQgaW4gY2FzZSBoYW5kbGVOdW1iZXJzIGlzIHJldmVyc2VkXG5cbiAgICAgICAgICB2YXIgZmlyc3RIYW5kbGUgPSBoYW5kbGVOdW1iZXJzWzBdO1xuICAgICAgICAgIHZhciBzbW9vdGhTdGVwcyA9IG9wdGlvbnMuZXZlbnRzLnNtb290aFN0ZXBzO1xuICAgICAgICAgIHZhciBiID0gWyF1cHdhcmQsIHVwd2FyZF07XG4gICAgICAgICAgdmFyIGYgPSBbdXB3YXJkLCAhdXB3YXJkXTsgLy8gQ29weSBoYW5kbGVOdW1iZXJzIHNvIHdlIGRvbid0IGNoYW5nZSB0aGUgZGF0YXNldFxuXG4gICAgICAgICAgaGFuZGxlTnVtYmVycyA9IGhhbmRsZU51bWJlcnMuc2xpY2UoKTsgLy8gQ2hlY2sgdG8gc2VlIHdoaWNoIGhhbmRsZSBpcyAnbGVhZGluZycuXG4gICAgICAgICAgLy8gSWYgdGhhdCBvbmUgY2FuJ3QgbW92ZSB0aGUgc2Vjb25kIGNhbid0IGVpdGhlci5cblxuICAgICAgICAgIGlmICh1cHdhcmQpIHtcbiAgICAgICAgICAgIGhhbmRsZU51bWJlcnMucmV2ZXJzZSgpO1xuICAgICAgICAgIH0gLy8gU3RlcCAxOiBnZXQgdGhlIG1heGltdW0gcGVyY2VudGFnZSB0aGF0IGFueSBvZiB0aGUgaGFuZGxlcyBjYW4gbW92ZVxuXG5cbiAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZU51bWJlciwgbykge1xuICAgICAgICAgICAgICB2YXIgdG8gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHByb3Bvc2FscywgaGFuZGxlTnVtYmVyLCBwcm9wb3NhbHNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLCBiW29dLCBmW29dLCBmYWxzZSwgc21vb3RoU3RlcHMpOyAvLyBTdG9wIGlmIG9uZSBvZiB0aGUgaGFuZGxlcyBjYW4ndCBtb3ZlLlxuXG4gICAgICAgICAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9wb3NhbCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcG9zYWwgPSB0byAtIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdID0gdG87XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdXNpbmcgb25lIGhhbmRsZSwgY2hlY2sgYmFja3dhcmQgQU5EIGZvcndhcmRcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGIgPSBmID0gW3RydWVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGF0ZSA9IGZhbHNlOyAvLyBTdGVwIDI6IFRyeSB0byBzZXQgdGhlIGhhbmRsZXMgd2l0aCB0aGUgZm91bmQgcGVyY2VudGFnZVxuXG4gICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIsIG8pIHtcbiAgICAgICAgICAgIHN0YXRlID0gc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgbG9jYXRpb25zW2hhbmRsZU51bWJlcl0gKyBwcm9wb3NhbCwgYltvXSwgZltvXSwgZmFsc2UsIHNtb290aFN0ZXBzKSB8fCBzdGF0ZTtcbiAgICAgICAgICB9KTsgLy8gU3RlcCAzOiBJZiBhIGhhbmRsZSBtb3ZlZCwgZmlyZSBldmVudHNcblxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9KTsgLy8gSWYgdGFyZ2V0IGlzIGEgY29ubmVjdCwgdGhlbiBmaXJlIGRyYWcgZXZlbnRcblxuICAgICAgICAgICAgaWYgKGNvbm5lY3QgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZpcmVFdmVudChcImRyYWdcIiwgZmlyc3RIYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUYWtlcyBhIGJhc2UgdmFsdWUgYW5kIGFuIG9mZnNldC4gVGhpcyBvZmZzZXQgaXMgdXNlZCBmb3IgdGhlIGNvbm5lY3QgYmFyIHNpemUuXG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIGRlc2lnbiBmb3IgdGhpcyBmZWF0dXJlLCB0aGUgb3JpZ2luIGVsZW1lbnQgd2FzIDElIHdpZGUuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIGEgcm91bmRpbmcgYnVnIGluIENocm9tZSBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGZlYXR1cmVcbiAgICAgICAgLy8gaW4gdGhpcyBtYW5uZXI6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTc5ODIyM1xuXG5cbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBhIC0gYiA6IGE7XG4gICAgICAgIH0gLy8gVXBkYXRlcyBzY29wZV9Mb2NhdGlvbnMgYW5kIHNjb3BlX1ZhbHVlcywgdXBkYXRlcyB2aXN1YWwgc3RhdGVcblxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUhhbmRsZVBvc2l0aW9uKGhhbmRsZU51bWJlciwgdG8pIHtcbiAgICAgICAgICAvLyBVcGRhdGUgbG9jYXRpb25zLlxuICAgICAgICAgIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID0gdG87IC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIHRoZSBzbGlkZXIgc3RlcHBpbmcvcmFuZ2UuXG5cbiAgICAgICAgICBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XG4gICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKHRvLCAwKSAtIHNjb3BlX0Rpck9mZnNldDtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRlUnVsZSA9IFwidHJhbnNsYXRlKFwiICsgaW5SdWxlT3JkZXIodHJhbnNsYXRpb24gKyBcIiVcIiwgXCIwXCIpICsgXCIpXCI7XG4gICAgICAgICAgc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLnN0eWxlW29wdGlvbnMudHJhbnNmb3JtUnVsZV0gPSB0cmFuc2xhdGVSdWxlO1xuICAgICAgICAgIHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICB1cGRhdGVDb25uZWN0KGhhbmRsZU51bWJlciArIDEpO1xuICAgICAgICB9IC8vIEhhbmRsZXMgYmVmb3JlIHRoZSBzbGlkZXIgbWlkZGxlIGFyZSBzdGFja2VkIGxhdGVyID0gaGlnaGVyLFxuICAgICAgICAvLyBIYW5kbGVzIGFmdGVyIHRoZSBtaWRkbGUgbGF0ZXIgaXMgbG93ZXJcbiAgICAgICAgLy8gW1s3XSBbOF0gLi4uLi4uLi4uLiB8IC4uLi4uLi4uLi4gWzVdIFs0XVxuXG5cbiAgICAgICAgZnVuY3Rpb24gc2V0WmluZGV4KCkge1xuICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgZGlyID0gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0gPiA1MCA/IC0xIDogMTtcbiAgICAgICAgICAgIHZhciB6SW5kZXggPSAzICsgKHNjb3BlX0hhbmRsZXMubGVuZ3RoICsgZGlyICogaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoekluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBUZXN0IHN1Z2dlc3RlZCB2YWx1ZXMgYW5kIGFwcGx5IG1hcmdpbiwgc3RlcC5cbiAgICAgICAgLy8gaWYgZXhhY3RJbnB1dCBpcyB0cnVlLCBkb24ndCBydW4gY2hlY2tIYW5kbGVQb3NpdGlvbiwgdGhlbiB0aGUgaGFuZGxlIGNhbiBiZSBwbGFjZWQgaW4gYmV0d2VlbiBzdGVwcyAoIzQzNilcblxuXG4gICAgICAgIGZ1bmN0aW9uIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkLCBleGFjdElucHV0LCBzbW9vdGhTdGVwcykge1xuICAgICAgICAgIGlmICghZXhhY3RJbnB1dCkge1xuICAgICAgICAgICAgdG8gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaGFuZGxlTnVtYmVyLCB0bywgbG9va0JhY2t3YXJkLCBsb29rRm9yd2FyZCwgZmFsc2UsIHNtb290aFN0ZXBzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG8gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0byk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gVXBkYXRlcyBzdHlsZSBhdHRyaWJ1dGUgZm9yIGNvbm5lY3Qgbm9kZXNcblxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3QoaW5kZXgpIHtcbiAgICAgICAgICAvLyBTa2lwIGNvbm5lY3RzIHNldCB0byBmYWxzZVxuICAgICAgICAgIGlmICghc2NvcGVfQ29ubmVjdHNbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICAgIHZhciBoID0gMTAwO1xuXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICBsID0gc2NvcGVfTG9jYXRpb25zW2luZGV4IC0gMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSBzY29wZV9Db25uZWN0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBoID0gc2NvcGVfTG9jYXRpb25zW2luZGV4XTtcbiAgICAgICAgICB9IC8vIFdlIHVzZSB0d28gcnVsZXM6XG4gICAgICAgICAgLy8gJ3RyYW5zbGF0ZScgdG8gY2hhbmdlIHRoZSBsZWZ0L3RvcCBvZmZzZXQ7XG4gICAgICAgICAgLy8gJ3NjYWxlJyB0byBjaGFuZ2UgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50O1xuICAgICAgICAgIC8vIEFzIHRoZSBlbGVtZW50IGhhcyBhIHdpZHRoIG9mIDEwMCUsIGEgdHJhbnNsYXRpb24gb2YgMTAwJSBpcyBlcXVhbCB0byAxMDAlIG9mIHRoZSBwYXJlbnQgKC5ub1VpLWJhc2UpXG5cblxuICAgICAgICAgIHZhciBjb25uZWN0V2lkdGggPSBoIC0gbDtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRlUnVsZSA9IFwidHJhbnNsYXRlKFwiICsgaW5SdWxlT3JkZXIodHJhbnNmb3JtRGlyZWN0aW9uKGwsIGNvbm5lY3RXaWR0aCkgKyBcIiVcIiwgXCIwXCIpICsgXCIpXCI7XG4gICAgICAgICAgdmFyIHNjYWxlUnVsZSA9IFwic2NhbGUoXCIgKyBpblJ1bGVPcmRlcihjb25uZWN0V2lkdGggLyAxMDAsIFwiMVwiKSArIFwiKVwiO1xuICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzW2luZGV4XS5zdHlsZVtvcHRpb25zLnRyYW5zZm9ybVJ1bGVdID0gdHJhbnNsYXRlUnVsZSArIFwiIFwiICsgc2NhbGVSdWxlO1xuICAgICAgICB9IC8vIFBhcnNlcyB2YWx1ZSBwYXNzZWQgdG8gLnNldCBtZXRob2QuIFJldHVybnMgY3VycmVudCB2YWx1ZSBpZiBub3QgcGFyc2UtYWJsZS5cblxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVUb1ZhbHVlKHRvLCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIHdpdGggbnVsbCBpbmRpY2F0ZXMgYW4gJ2lnbm9yZScuXG4gICAgICAgICAgLy8gSW5wdXR0aW5nICdmYWxzZScgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAodG8gPT09IG51bGwgfHwgdG8gPT09IGZhbHNlIHx8IHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICB9IC8vIElmIGEgZm9ybWF0dGVkIG51bWJlciB3YXMgcGFzc2VkLCBhdHRlbXB0IHRvIGRlY29kZSBpdC5cblxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdG8gPSBTdHJpbmcodG8pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvID0gb3B0aW9ucy5mb3JtYXQuZnJvbSh0byk7XG5cbiAgICAgICAgICBpZiAodG8gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodG8pO1xuICAgICAgICAgIH0gLy8gSWYgcGFyc2luZyB0aGUgbnVtYmVyIGZhaWxlZCwgdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxuXG5cbiAgICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzTmFOKHRvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfSAvLyBTZXQgdGhlIHNsaWRlciB2YWx1ZS5cblxuXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU2V0KGlucHV0LCBmaXJlU2V0RXZlbnQsIGV4YWN0SW5wdXQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzID0gYXNBcnJheShpbnB1dCk7XG4gICAgICAgICAgdmFyIGlzSW5pdCA9IHNjb3BlX0xvY2F0aW9uc1swXSA9PT0gdW5kZWZpbmVkOyAvLyBFdmVudCBmaXJlcyBieSBkZWZhdWx0XG5cbiAgICAgICAgICBmaXJlU2V0RXZlbnQgPSBmaXJlU2V0RXZlbnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmaXJlU2V0RXZlbnQ7IC8vIEFuaW1hdGlvbiBpcyBvcHRpb25hbC5cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGluaXRpYWwgdmFsdWVzIHdlcmUgc2V0IGJlZm9yZSB1c2luZyBhbmltYXRlZCBwbGFjZW1lbnQuXG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlICYmICFpc0luaXQpIHtcbiAgICAgICAgICAgIGFkZENsYXNzRm9yKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgfSAvLyBGaXJzdCBwYXNzLCB3aXRob3V0IGxvb2tBaGVhZCBidXQgd2l0aCBsb29rQmFja3dhcmQuIFZhbHVlcyBhcmUgc2V0IGZyb20gbGVmdCB0byByaWdodC5cblxuXG4gICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlc1toYW5kbGVOdW1iZXJdLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCBmYWxzZSwgZXhhY3RJbnB1dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGkgPSBzY29wZV9IYW5kbGVOdW1iZXJzLmxlbmd0aCA9PT0gMSA/IDAgOiAxOyAvLyBTcHJlYWQgaGFuZGxlcyBldmVubHkgYWNyb3NzIHRoZSBzbGlkZXIgaWYgdGhlIHJhbmdlIGhhcyBubyBzaXplIChtaW49bWF4KVxuXG4gICAgICAgICAgaWYgKGlzSW5pdCAmJiBzY29wZV9TcGVjdHJ1bS5oYXNOb1NpemUoKSkge1xuICAgICAgICAgICAgZXhhY3RJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnNbMF0gPSAwO1xuXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHZhciBzcGFjZV8xID0gMTAwIC8gKHNjb3BlX0hhbmRsZU51bWJlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0gPSBoYW5kbGVOdW1iZXIgKiBzcGFjZV8xO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFNlY29uZGFyeSBwYXNzZXMuIE5vdyB0aGF0IGFsbCBiYXNlIHZhbHVlcyBhcmUgc2V0LCBhcHBseSBjb25zdHJhaW50cy5cbiAgICAgICAgICAvLyBJdGVyYXRlIGFsbCBoYW5kbGVzIHRvIGVuc3VyZSBjb25zdHJhaW50cyBhcmUgYXBwbGllZCBmb3IgdGhlIGVudGlyZSBzbGlkZXIgKElzc3VlICMxMDA5KVxuXG5cbiAgICAgICAgICBmb3IgKDsgaSA8IHNjb3BlX0hhbmRsZU51bWJlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdLCB0cnVlLCB0cnVlLCBleGFjdElucHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFppbmRleCgpO1xuICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTsgLy8gRmlyZSB0aGUgZXZlbnQgb25seSBmb3IgaGFuZGxlcyB0aGF0IHJlY2VpdmVkIGEgbmV3IHZhbHVlLCBhcyBwZXIgIzU3OVxuXG4gICAgICAgICAgICBpZiAodmFsdWVzW2hhbmRsZU51bWJlcl0gIT09IG51bGwgJiYgZmlyZVNldEV2ZW50KSB7XG4gICAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIFJlc2V0IHNsaWRlciB0byBpbml0aWFsIHZhbHVlc1xuXG5cbiAgICAgICAgZnVuY3Rpb24gdmFsdWVSZXNldChmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0LCBmaXJlU2V0RXZlbnQpO1xuICAgICAgICB9IC8vIFNldCB2YWx1ZSBmb3IgYSBzaW5nbGUgaGFuZGxlXG5cblxuICAgICAgICBmdW5jdGlvbiB2YWx1ZVNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHZhbHVlLCBmaXJlU2V0RXZlbnQsIGV4YWN0SW5wdXQpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgbnVtZXJpYyBpbnB1dFxuICAgICAgICAgIGhhbmRsZU51bWJlciA9IE51bWJlcihoYW5kbGVOdW1iZXIpO1xuXG4gICAgICAgICAgaWYgKCEoaGFuZGxlTnVtYmVyID49IDAgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBpbnZhbGlkIGhhbmRsZSBudW1iZXIsIGdvdDogXCIgKyBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgIH0gLy8gTG9vayBib3RoIGJhY2t3YXJkIGFuZCBmb3J3YXJkLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRoaXMgaGFuZGxlIHRvIFwicHVzaFwiIG90aGVyIGhhbmRsZXMgKCM5NjApO1xuICAgICAgICAgIC8vIFRoZSBleGFjdElucHV0IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGlnbm9yZSBzbGlkZXIgc3RlcHBpbmcgKCM0MzYpXG5cblxuICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCB0cnVlLCBleGFjdElucHV0KTtcbiAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcblxuICAgICAgICAgIGlmIChmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBHZXQgdGhlIHNsaWRlciB2YWx1ZS5cblxuXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlR2V0KHVuZW5jb2RlZCkge1xuICAgICAgICAgIGlmICh1bmVuY29kZWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdW5lbmNvZGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVuZW5jb2RlZCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGEgY29weSBvZiB0aGUgcmF3IHZhbHVlc1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1ZhbHVlcy5sZW5ndGggPT09IDEgPyBzY29wZV9WYWx1ZXNbMF0gOiBzY29wZV9WYWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbHVlcyA9IHNjb3BlX1ZhbHVlcy5tYXAob3B0aW9ucy5mb3JtYXQudG8pOyAvLyBJZiBvbmx5IG9uZSBoYW5kbGUgaXMgdXNlZCwgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxuXG4gICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfSAvLyBSZW1vdmVzIGNsYXNzZXMgZnJvbSB0aGUgcm9vdCBhbmQgZW1wdGllcyBpdC5cblxuXG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHByb3RlY3RlZCBpbnRlcm5hbCBsaXN0ZW5lcnNcbiAgICAgICAgICByZW1vdmVFdmVudChJTlRFUk5BTF9FVkVOVF9OUy5hcmlhKTtcbiAgICAgICAgICByZW1vdmVFdmVudChJTlRFUk5BTF9FVkVOVF9OUy50b29sdGlwcyk7XG4gICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5jc3NDbGFzc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzW2tleV0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgd2hpbGUgKHNjb3BlX1RhcmdldC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBzY29wZV9UYXJnZXQucmVtb3ZlQ2hpbGQoc2NvcGVfVGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSBzY29wZV9UYXJnZXQubm9VaVNsaWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHRTdGVwc0ZvckhhbmRsZShoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICB2YXIgbmVhcmJ5U3RlcHMgPSBzY29wZV9TcGVjdHJ1bS5nZXROZWFyYnlTdGVwcyhsb2NhdGlvbik7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgdmFyIGluY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XG4gICAgICAgICAgdmFyIGRlY3JlbWVudCA9IG51bGw7IC8vIElmIHNuYXBwZWQsIGRpcmVjdGx5IHVzZSBkZWZpbmVkIHN0ZXAgdmFsdWVcblxuICAgICAgICAgIGlmIChvcHRpb25zLnNuYXApIHtcbiAgICAgICAgICAgIHJldHVybiBbdmFsdWUgLSBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLnN0YXJ0VmFsdWUgfHwgbnVsbCwgbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgLSB2YWx1ZSB8fCBudWxsXTtcbiAgICAgICAgICB9IC8vIElmIHRoZSBuZXh0IHZhbHVlIGluIHRoaXMgc3RlcCBtb3ZlcyBpbnRvIHRoZSBuZXh0IHN0ZXAsXG4gICAgICAgICAgLy8gdGhlIGluY3JlbWVudCBpcyB0aGUgc3RhcnQgb2YgdGhlIG5leHQgc3RlcCAtIHRoZSBjdXJyZW50IHZhbHVlXG5cblxuICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgKyBpbmNyZW1lbnQgPiBuZWFyYnlTdGVwcy5zdGVwQWZ0ZXIuc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBuZWFyYnlTdGVwcy5zdGVwQWZ0ZXIuc3RhcnRWYWx1ZSAtIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gSWYgdGhlIHZhbHVlIGlzIGJleW9uZCB0aGUgc3RhcnRpbmcgcG9pbnRcblxuXG4gICAgICAgICAgaWYgKHZhbHVlID4gbmVhcmJ5U3RlcHMudGhpc1N0ZXAuc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgZGVjcmVtZW50ID0gbmVhcmJ5U3RlcHMudGhpc1N0ZXAuc3RlcDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuc3RlcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlY3JlbWVudCA9IGZhbHNlO1xuICAgICAgICAgIH0gLy8gSWYgYSBoYW5kbGUgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgc3RlcCwgaXQgYWx3YXlzIHN0ZXBzIGJhY2sgaW50byB0aGUgcHJldmlvdXMgc3RlcCBmaXJzdFxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVjcmVtZW50ID0gdmFsdWUgLSBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLmhpZ2hlc3RTdGVwO1xuICAgICAgICAgIH0gLy8gTm93LCBpZiBhdCB0aGUgc2xpZGVyIGVkZ2VzLCB0aGVyZSBpcyBubyBpbi9kZWNyZW1lbnRcblxuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uID09PSAxMDApIHtcbiAgICAgICAgICAgIGluY3JlbWVudCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChsb2NhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgZGVjcmVtZW50ID0gbnVsbDtcbiAgICAgICAgICB9IC8vIEFzIHBlciAjMzkxLCB0aGUgY29tcGFyaXNvbiBmb3IgdGhlIGRlY3JlbWVudCBzdGVwIGNhbiBoYXZlIHNvbWUgcm91bmRpbmcgaXNzdWVzLlxuXG5cbiAgICAgICAgICB2YXIgc3RlcERlY2ltYWxzID0gc2NvcGVfU3BlY3RydW0uY291bnRTdGVwRGVjaW1hbHMoKTsgLy8gUm91bmQgcGVyICMzOTFcblxuICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IG51bGwgJiYgaW5jcmVtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaW5jcmVtZW50ID0gTnVtYmVyKGluY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkZWNyZW1lbnQgIT09IG51bGwgJiYgZGVjcmVtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVjcmVtZW50ID0gTnVtYmVyKGRlY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbZGVjcmVtZW50LCBpbmNyZW1lbnRdO1xuICAgICAgICB9IC8vIEdldCB0aGUgY3VycmVudCBzdGVwIHNpemUgZm9yIHRoZSBzbGlkZXIuXG5cblxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0U3RlcHMoKSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlX0hhbmRsZU51bWJlcnMubWFwKGdldE5leHRTdGVwc0ZvckhhbmRsZSk7XG4gICAgICAgIH0gLy8gVXBkYXRhYmxlOiBtYXJnaW4sIGxpbWl0LCBwYWRkaW5nLCBzdGVwLCByYW5nZSwgYW5pbWF0ZSwgc25hcFxuXG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhvcHRpb25zVG9VcGRhdGUsIGZpcmVTZXRFdmVudCkge1xuICAgICAgICAgIC8vIFNwZWN0cnVtIGlzIGNyZWF0ZWQgdXNpbmcgdGhlIHJhbmdlLCBzbmFwLCBkaXJlY3Rpb24gYW5kIHN0ZXAgb3B0aW9ucy5cbiAgICAgICAgICAvLyAnc25hcCcgYW5kICdzdGVwJyBjYW4gYmUgdXBkYXRlZC5cbiAgICAgICAgICAvLyBJZiAnc25hcCcgYW5kICdzdGVwJyBhcmUgbm90IHBhc3NlZCwgdGhleSBzaG91bGQgcmVtYWluIHVuY2hhbmdlZC5cbiAgICAgICAgICB2YXIgdiA9IHZhbHVlR2V0KCk7XG4gICAgICAgICAgdmFyIHVwZGF0ZUFibGUgPSBbXCJtYXJnaW5cIiwgXCJsaW1pdFwiLCBcInBhZGRpbmdcIiwgXCJyYW5nZVwiLCBcImFuaW1hdGVcIiwgXCJzbmFwXCIsIFwic3RlcFwiLCBcImZvcm1hdFwiLCBcInBpcHNcIiwgXCJ0b29sdGlwc1wiXTsgLy8gT25seSBjaGFuZ2Ugb3B0aW9ucyB0aGF0IHdlJ3JlIGFjdHVhbGx5IHBhc3NlZCB0byB1cGRhdGUuXG5cbiAgICAgICAgICB1cGRhdGVBYmxlLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB1bmRlZmluZWQuIG51bGwgcmVtb3ZlcyB0aGUgdmFsdWUuXG4gICAgICAgICAgICBpZiAob3B0aW9uc1RvVXBkYXRlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxPcHRpb25zW25hbWVdID0gb3B0aW9uc1RvVXBkYXRlW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBuZXdPcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zKTsgLy8gTG9hZCBuZXcgb3B0aW9ucyBpbnRvIHRoZSBzbGlkZXIgc3RhdGVcblxuICAgICAgICAgIHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNUb1VwZGF0ZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSBuZXdPcHRpb25zW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNjb3BlX1NwZWN0cnVtID0gbmV3T3B0aW9ucy5zcGVjdHJ1bTsgLy8gTGltaXQsIG1hcmdpbiBhbmQgcGFkZGluZyBkZXBlbmQgb24gdGhlIHNwZWN0cnVtIGJ1dCBhcmUgc3RvcmVkIG91dHNpZGUgb2YgaXQuICgjNjc3KVxuXG4gICAgICAgICAgb3B0aW9ucy5tYXJnaW4gPSBuZXdPcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICBvcHRpb25zLmxpbWl0ID0gbmV3T3B0aW9ucy5saW1pdDtcbiAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBuZXdPcHRpb25zLnBhZGRpbmc7IC8vIFVwZGF0ZSBwaXBzLCByZW1vdmVzIGV4aXN0aW5nLlxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMucGlwcykge1xuICAgICAgICAgICAgcGlwcyhvcHRpb25zLnBpcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVQaXBzKCk7XG4gICAgICAgICAgfSAvLyBVcGRhdGUgdG9vbHRpcHMsIHJlbW92ZXMgZXhpc3RpbmcuXG5cblxuICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXBzKSB7XG4gICAgICAgICAgICB0b29sdGlwcygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVUb29sdGlwcygpO1xuICAgICAgICAgIH0gLy8gSW52YWxpZGF0ZSB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBzbyB2YWx1ZVNldCBmb3JjZXMgYW4gdXBkYXRlLlxuXG5cbiAgICAgICAgICBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcbiAgICAgICAgICB2YWx1ZVNldChpc1NldChvcHRpb25zVG9VcGRhdGUuc3RhcnQpID8gb3B0aW9uc1RvVXBkYXRlLnN0YXJ0IDogdiwgZmlyZVNldEV2ZW50KTtcbiAgICAgICAgfSAvLyBJbml0aWFsaXphdGlvbiBzdGVwc1xuXG5cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBTbGlkZXIoKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBiYXNlIGVsZW1lbnQsIGluaXRpYWxpemUgSFRNTCBhbmQgc2V0IGNsYXNzZXMuXG4gICAgICAgICAgLy8gQWRkIGhhbmRsZXMgYW5kIGNvbm5lY3QgZWxlbWVudHMuXG4gICAgICAgICAgc2NvcGVfQmFzZSA9IGFkZFNsaWRlcihzY29wZV9UYXJnZXQpO1xuICAgICAgICAgIGFkZEVsZW1lbnRzKG9wdGlvbnMuY29ubmVjdCwgc2NvcGVfQmFzZSk7IC8vIEF0dGFjaCB1c2VyIGV2ZW50cy5cblxuICAgICAgICAgIGJpbmRTbGlkZXJFdmVudHMob3B0aW9ucy5ldmVudHMpOyAvLyBVc2UgdGhlIHB1YmxpYyB2YWx1ZSBtZXRob2QgdG8gc2V0IHRoZSBzdGFydCB2YWx1ZXMuXG5cbiAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0KTtcblxuICAgICAgICAgIGlmIChvcHRpb25zLnBpcHMpIHtcbiAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwcykge1xuICAgICAgICAgICAgdG9vbHRpcHMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcmlhKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR1cFNsaWRlcigpO1xuICAgICAgICB2YXIgc2NvcGVfU2VsZiA9IHtcbiAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgICAgIHN0ZXBzOiBnZXROZXh0U3RlcHMsXG4gICAgICAgICAgb246IGJpbmRFdmVudCxcbiAgICAgICAgICBvZmY6IHJlbW92ZUV2ZW50LFxuICAgICAgICAgIGdldDogdmFsdWVHZXQsXG4gICAgICAgICAgc2V0OiB2YWx1ZVNldCxcbiAgICAgICAgICBzZXRIYW5kbGU6IHZhbHVlU2V0SGFuZGxlLFxuICAgICAgICAgIHJlc2V0OiB2YWx1ZVJlc2V0LFxuICAgICAgICAgIC8vIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZywgZG9uJ3QgdXNlIHRoaXMgaW4geW91ciBhcHBsaWNhdGlvbi5cbiAgICAgICAgICBfX21vdmVIYW5kbGVzOiBmdW5jdGlvbiAodXB3YXJkLCBwcm9wb3NhbCwgaGFuZGxlTnVtYmVycykge1xuICAgICAgICAgICAgbW92ZUhhbmRsZXModXB3YXJkLCBwcm9wb3NhbCwgc2NvcGVfTG9jYXRpb25zLCBoYW5kbGVOdW1iZXJzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wdGlvbnM6IG9yaWdpbmFsT3B0aW9ucyxcbiAgICAgICAgICB1cGRhdGVPcHRpb25zOiB1cGRhdGVPcHRpb25zLFxuICAgICAgICAgIHRhcmdldDogc2NvcGVfVGFyZ2V0LFxuICAgICAgICAgIHJlbW92ZVBpcHM6IHJlbW92ZVBpcHMsXG4gICAgICAgICAgcmVtb3ZlVG9vbHRpcHM6IHJlbW92ZVRvb2x0aXBzLFxuICAgICAgICAgIGdldFBvc2l0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0VG9vbHRpcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9Ub29sdGlwcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldE9yaWdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9IYW5kbGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGlwczogcGlwcyAvLyBJc3N1ZSAjNTk0XG5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNjb3BlX1NlbGY7XG4gICAgICB9IC8vIFJ1biB0aGUgc3RhbmRhcmQgaW5pdGlhbGl6ZXJcblxuXG4gICAgICBmdW5jdGlvbiBpbml0aWFsaXplKHRhcmdldCwgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQubm9kZU5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBjcmVhdGUgcmVxdWlyZXMgYSBzaW5nbGUgZWxlbWVudCwgZ290OiBcIiArIHRhcmdldCk7XG4gICAgICAgIH0gLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cblxuXG4gICAgICAgIGlmICh0YXJnZXQubm9VaVNsaWRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6IFNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cIik7XG4gICAgICAgIH0gLy8gVGVzdCB0aGUgb3B0aW9ucyBhbmQgY3JlYXRlIHRoZSBzbGlkZXIgZW52aXJvbm1lbnQ7XG5cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRlc3RPcHRpb25zKG9yaWdpbmFsT3B0aW9ucyk7XG4gICAgICAgIHZhciBhcGkgPSBzY29wZSh0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucyk7XG4gICAgICAgIHRhcmdldC5ub1VpU2xpZGVyID0gYXBpO1xuICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm91aXNsaWRlciA9IHtcbiAgICAgICAgLy8gRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLCBkb24ndCB1c2UgdGhpcyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAgICBfX3NwZWN0cnVtOiBTcGVjdHJ1bSxcbiAgICAgICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgY2xhc3NlcywgYWxsb3dzIGdsb2JhbCBjaGFuZ2VzLlxuICAgICAgICAvLyBVc2UgdGhlIGNzc0NsYXNzZXMgb3B0aW9uIGZvciBjaGFuZ2VzIHRvIG9uZSBzbGlkZXIuXG4gICAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXMsXG4gICAgICAgIGNyZWF0ZTogaW5pdGlhbGl6ZVxuICAgICAgfTtcbiAgICAgIGV4cG9ydHMuY3JlYXRlID0gaW5pdGlhbGl6ZTtcbiAgICAgIGV4cG9ydHMuY3NzQ2xhc3NlcyA9IGNzc0NsYXNzZXM7XG4gICAgICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IG5vdWlzbGlkZXI7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBub1VpU2xpZGVyID0gdW53cmFwRXhwb3J0cyhub3Vpc2xpZGVyKTtcblxuICAgIC8qKlxyXG4gICAgICogaW1wb3J0IG1haW4gRmFzaGlvbiBTbGlkZXIgZnVuY3Rpb25cclxuICAgICAqL1xuXG4gICAgLyplbmQgb2YgaW5sdWRlcyovXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCByZWFkeSk7XG5cbiAgICBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgIC8qKlxyXG4gICAgICAgKiBGYXNoaW9uIFNsaWRlciBlbGVtZW50XHJcbiAgICAgICAqL1xuICAgICAgY29uc3Qgc2xpZGVyRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZmFzaGlvbi1zbGlkZXInKTtcbiAgICAgIC8qKlxyXG4gICAgICAgKiBJbml0IEZhc2hpb24gU2xpZGVyXHJcbiAgICAgICAqXHJcbiAgICAgICAqIGFyZ3VtZW50OiBwYXNzIC5mYXNoaW9uLXNsaWRlciBlbGVtZW50XHJcbiAgICAgICAqL1xuXG4gICAgICBjcmVhdGVGYXNoaW9uU2xpZGVyKHNsaWRlckVsKTsgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICAgbGV0IGJ1cmdlckJ0bnMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5idXJnZXJcIildO1xuICAgICAgbGV0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYm9keVwiKTtcbiAgICAgIGxldCBodG1sID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWxcIik7XG5cbiAgICAgIGZvciAoY29uc3QgYnVyZ2VyQnRuIG9mIGJ1cmdlckJ0bnMpIHtcbiAgICAgICAgYnVyZ2VyQnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYm9keS5jbGFzc0xpc3QudG9nZ2xlKFwiYWN0aXZlXCIpO1xuICAgICAgICAgIGh0bWwuY2xhc3NMaXN0LnRvZ2dsZShcImFjdGl2ZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucHJpc2Utc2xpZGVyJykpIHtcbiAgICAgICAgbGV0IHNsaWRlclByaXNlID0gbmV3IFN3aXBlcihcIi5wcmlzZS1zbGlkZXJcIiwge1xuICAgICAgICAgIG1vZHVsZXM6IFtOYXZpZ2F0aW9uLCBBdXRvcGxheV0sXG4gICAgICAgICAgd2F0Y2hPdmVyZmxvdzogdHJ1ZSxcbiAgICAgICAgICBzcGVlZDogODAwLFxuICAgICAgICAgIG9ic2VydmVyOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVQYXJlbnRzOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVTbGlkZUNoaWxkcmVuOiB0cnVlLFxuICAgICAgICAgIGdyYWJDdXJzb3I6IHRydWUsXG4gICAgICAgICAgbmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgbmV4dEVsOiBcIi5wbGFucy1uYXZpZ2F0aW9uIC5idXR0b24tbmV4dFwiLFxuICAgICAgICAgICAgcHJldkVsOiBcIi5wbGFucy1uYXZpZ2F0aW9uIC5idXR0b24tcHJldlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdXRvcGxheToge1xuICAgICAgICAgICAgZGVsYXk6IDI1MDAsXG4gICAgICAgICAgICBkaXNhYmxlT25JbnRlcmFjdGlvbjogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvcGxheS5zdG9wKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvcGxheS5zdGFydCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnJlYWtwb2ludHM6IHtcbiAgICAgICAgICAgIDMyMDoge1xuICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLjM1LFxuICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDE1LFxuICAgICAgICAgICAgICBjZW50ZXJlZFNsaWRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgbG9vcDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDYzOToge1xuICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDE1LFxuICAgICAgICAgICAgICBjZW50ZXJlZFNsaWRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgbG9vcDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDc2ODoge1xuICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDMwLFxuICAgICAgICAgICAgICBjZW50ZXJlZFNsaWRlczogZmFsc2UsXG4gICAgICAgICAgICAgIGxvb3A6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxMDI0OiB7XG4gICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDIsXG4gICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMzAsXG4gICAgICAgICAgICAgIGNlbnRlcmVkU2xpZGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbG9vcDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxMjgwOiB7XG4gICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMzBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJldmlld3Mtc2xpZGVyJykpIHtcbiAgICAgICAgbGV0IHNsaWRlclJldmlldyA9IG5ldyBTd2lwZXIoXCIucmV2aWV3cy1zbGlkZXJcIiwge1xuICAgICAgICAgIG1vZHVsZXM6IFtOYXZpZ2F0aW9uLCBBdXRvcGxheV0sXG4gICAgICAgICAgd2F0Y2hPdmVyZmxvdzogdHJ1ZSxcbiAgICAgICAgICBzcGVlZDogODAwLFxuICAgICAgICAgIG9ic2VydmVyOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVQYXJlbnRzOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVTbGlkZUNoaWxkcmVuOiB0cnVlLFxuICAgICAgICAgIGdyYWJDdXJzb3I6IHRydWUsXG4gICAgICAgICAgbmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgbmV4dEVsOiBcIi5yZXZpZXdzLW5hdmlnYXRpb24gLmJ1dHRvbi1uZXh0XCIsXG4gICAgICAgICAgICBwcmV2RWw6IFwiLnJldmlld3MtbmF2aWdhdGlvbiAuYnV0dG9uLXByZXZcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXV0b3BsYXk6IHtcbiAgICAgICAgICAgIGRlbGF5OiAyNTAwLFxuICAgICAgICAgICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b3BsYXkuc3RvcCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b3BsYXkuc3RhcnQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGJyZWFrcG9pbnRzOiB7XG4gICAgICAgICAgICAzMjA6IHtcbiAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMS4zNSxcbiAgICAgICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxNSxcbiAgICAgICAgICAgICAgY2VudGVyZWRTbGlkZXM6IHRydWUsXG4gICAgICAgICAgICAgIGxvb3A6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA2Mzk6IHtcbiAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMixcbiAgICAgICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxNSxcbiAgICAgICAgICAgICAgY2VudGVyZWRTbGlkZXM6IGZhbHNlLFxuICAgICAgICAgICAgICBsb29wOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTAyNDoge1xuICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAzLFxuICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDMwLFxuICAgICAgICAgICAgICBjZW50ZXJlZFNsaWRlczogZmFsc2UsXG4gICAgICAgICAgICAgIGxvb3A6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTI4MDoge1xuICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAzLFxuICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDYwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLXN3aXBlcicpKSB7XG4gICAgICAgIGxldCBwYWdlU3dpcGVyID0gbmV3IFN3aXBlcihcIi5wYWdlLXN3aXBlclwiLCB7XG4gICAgICAgICAgbW9kdWxlczogW1BhZ2luYXRpb24sIFNjcm9sbGJhciwgZnJlZU1vZGUsIE1vdXNld2hlZWxdLFxuICAgICAgICAgIHdyYXBwZXJDbGFzczogXCJwYWdlX193cmFwcGVyXCIsXG4gICAgICAgICAgc2xpZGVDbGFzczogXCJwYWdlX19zY3JlZW5cIixcbiAgICAgICAgICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogJ2F1dG8nLFxuICAgICAgICAgIG1vdXNld2hlZWw6IHtcbiAgICAgICAgICAgIHNlbnNpdGl2aXRpOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbml0OiBmYWxzZSxcbiAgICAgICAgICB3YXRjaE92ZXJmbG93OiB0cnVlLFxuICAgICAgICAgIHNwZWVkOiA4MDAsXG4gICAgICAgICAgb2JzZXJ2ZXI6IHRydWUsXG4gICAgICAgICAgb2JzZXJ2ZVBhcmVudHM6IHRydWUsXG4gICAgICAgICAgb2JzZXJ2ZVNsaWRlQ2hpbGRyZW46IHRydWUsXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2V0U2Nyb2xsVHlwZSgpO1xuICAgICAgICAgICAgICBzY3JlZW5Db250ZW50UGFnZ2luZygpO1xuICAgICAgICAgICAgICBoaWRlVG9Ub3BCdG4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2V0U2Nyb2xsVHlwZSgpO1xuICAgICAgICAgICAgICBzY3JlZW5Db250ZW50UGFnZ2luZygpO1xuICAgICAgICAgICAgICBzZXRXaWR0aFBhZ2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlckluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaGlkZVRvVG9wQnRuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY3JvbGxiYXI6IHtcbiAgICAgICAgICAgIGVsOiAnLnBhZ2VfX3Njcm9sbCcsXG4gICAgICAgICAgICBkcmFnQ2xhc3M6ICdwYWdlX19kcmFnLXNjcm9sbCcsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYWdlU3dpcGVyLmluaXQoKTtcblxuICAgICAgICBmdW5jdGlvbiBzZXRTY3JvbGxUeXBlKCkge1xuICAgICAgICAgIGxldCB3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2VfX3dyYXBwZXInKTtcbiAgICAgICAgICBsZXQgcGFnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21haW4ucGFnZScpO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdfZnJlZScpKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ19mcmVlJyk7XG4gICAgICAgICAgICBwYWdlLmNsYXNzTGlzdC5yZW1vdmUoJ19mcmVlJyk7XG4gICAgICAgICAgICBwYWdlU3dpcGVyLnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhZ2VTd2lwZXIuc2xpZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgcGFnZVNsaWRlID0gcGFnZVN3aXBlci5zbGlkZXNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgcGFnZVNsaWRlQ29udGVudCA9IHBhZ2VTbGlkZS5xdWVyeVNlbGVjdG9yKCcuc2NyZWVuX19jb250ZW50Jyk7XG5cbiAgICAgICAgICAgIGlmIChwYWdlU2xpZGVDb250ZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhZ2VTbGlkZUNvbnRlbnRIZWlnaHQgPSBwYWdlU2xpZGVDb250ZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgICBpZiAocGFnZVNsaWRlQ29udGVudEhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBhZ2VTbGlkZUNvbnRlbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBhZ2VTbGlkZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnX2ZyZWUnKTtcbiAgICAgICAgICAgICAgICBwYWdlLmNsYXNzTGlzdC5hZGQoJ19mcmVlJyk7XG4gICAgICAgICAgICAgICAgcGFnZVN3aXBlci5wYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gMTkyMCB8fCB3aW5kb3cuaW5uZXJIZWlnaHQgPD0gNzY3KSB7XG4gICAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnX2ZyZWUnKTtcbiAgICAgICAgICAgICAgcGFnZS5jbGFzc0xpc3QuYWRkKCdfZnJlZScpO1xuICAgICAgICAgICAgICBwYWdlU3dpcGVyLnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRXaWR0aFBhZ2UoKSB7XG4gICAgICAgICAgbGV0IHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cbiAgICAgICAgICBpZiAod2luZG93V2lkdGggPCAxMjgwKSB7XG4gICAgICAgICAgICBwYWdlU3dpcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFnZVN3aXBlci5pbml0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2NyZWVuQ29udGVudFBhZ2dpbmcoKSB7XG4gICAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZV9fd3JhcHBlcicpO1xuICAgICAgICAgIGxldCBoZWFkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkZXInKTtcbiAgICAgICAgICBsZXQgc2NyZWVuQ29udGVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc2NyZWVuX19jb250ZW50Jyk7XG4gICAgICAgICAgbGV0IGhlYWRlckhlaWdodCA9IGhlYWRlci5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHNjcmVlbkNvbnRlbnQgb2Ygc2NyZWVuQ29udGVudHMpIHtcbiAgICAgICAgICAgIGlmICghd3JhcHBlci5jbGFzc0xpc3QuY29udGFpbnMoJ19mcmVlJykpIHtcbiAgICAgICAgICAgICAgc2NyZWVuQ29udGVudC5zdHlsZS5wYWRkaW5nVG9wID0gaGVhZGVySGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNjcmVlbkNvbnRlbnQuc3R5bGUucGFkZGluZ1RvcCA9ICcwcHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b1RvcFBhZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG8tdG9wLXBhZ2UnKTtcblxuICAgICAgICBpZiAodG9Ub3BQYWdlKSB7XG4gICAgICAgICAgdG9Ub3BQYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICBwYWdlU3dpcGVyLnNsaWRlVG8oMCwgODAwKTtcblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDwgMTI3OSkge1xuICAgICAgICAgICAgICBsZXQgYm9keSA9ICdib2R5JztcbiAgICAgICAgICAgICAgc2Nyb2xsVG9CbG9jayhlLCBib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhZ2VTd2lwZXIub24oJ3NsaWRlQ2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGhpZGVUb1RvcEJ0bigpO1xuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGUgPT4ge1xuICAgICAgICAgIGhpZGVUb1RvcEJ0bigpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBoaWRlVG9Ub3BCdG4oKSB7XG4gICAgICAgICAgbGV0IGFjdGl2ZUluZGV4U2xpZGUgPSBwYWdlU3dpcGVyLmFjdGl2ZUluZGV4O1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZUluZGV4U2xpZGUgPT09IDApIHtcbiAgICAgICAgICAgIGxldCB0b1RvcFBhZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG8tdG9wLXBhZ2UnKTtcbiAgICAgICAgICAgIHRvVG9wUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b1RvcFBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc2Nyb2xsIHJpb1xuXG5cbiAgICAgIGxldCB0b1RvcFBhZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG8tdG9wLXBhZ2UnKTtcblxuICAgICAgaWYgKHRvVG9wUGFnZSAmJiAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2Utc3dpcGVyJykpIHtcbiAgICAgICAgdG9Ub3BQYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgbGV0IGJvZHkgPSAnYm9keSc7XG4gICAgICAgICAgc2Nyb2xsVG9CbG9jayhlLCBib2R5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNjcm9sbFRvQmxvY2soZSwgaWQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcbiAgICAgICAgICBibG9jazogJ3N0YXJ0J1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gc2Nyb2xsIHJpbyBlbmRcblxuXG4gICAgICB2YXIgaXNJT1MgPSAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG4gICAgICBpZiAoaXNJT1MpIHtcbiAgICAgICAgbGV0IHZpZGVvcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy52aWRlbycpO1xuICAgICAgICB2aWRlb3MuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICB2YXIgY2FudmFzVmlkZW8gPSBuZXcgQ2FudmFzVmlkZW9QbGF5ZXIoe1xuICAgICAgICAgICAgdmlkZW9TZWxlY3RvcjogJyMnICsgZS5nZXRBdHRyaWJ1dGUoJ2lkJykgKyAnIC52aWRlb19fdmlkZW8nLFxuICAgICAgICAgICAgY2FudmFzU2VsZWN0b3I6ICcjJyArIGUuZ2V0QXR0cmlidXRlKCdpZCcpICsgJyAudmlkZW9fX2NhbnZhcycsXG4gICAgICAgICAgICB0aW1lbGluZVNlbGVjdG9yOiBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgICAgICAgICAgbWFrZUxvb3A6IHRydWUsXG4gICAgICAgICAgICBwYXVzZU9uQ2xpY2s6IGZhbHNlLFxuICAgICAgICAgICAgYXVkaW86IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIEhUTUw1IHZpZGVvXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy52aWRlb19fY2FudmFzJylbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH0gLy8gc2NyZW5uIHByb2Nlc3NcblxuXG4gICAgICBsZXQgd29ya0l0ZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLndvcmstaXRlbXMgLml0ZW0nKTtcbiAgICAgIGxldCBwYWdlU2NyZWVuUHJvY2VzcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlX19zY3JlZW4tLXByb2Nlc3MnKTtcbiAgICAgIGxldCBkZWxleSA9IDIwMDtcblxuICAgICAgaWYgKHBhZ2VTY3JlZW5Qcm9jZXNzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFuaW1TY3JlblByb2Nlc3MoKSB7XG4gICAgICAgICAgd29ya0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IGRlbGV5ICsgJ21zJztcbiAgICAgICAgICAgIGRlbGV5ICs9IDEwMDtcblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDwgMTAyNCkge1xuICAgICAgICAgICAgICBpdGVtLnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IDAgKyAnbXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbVNjcmVuUHJvY2VzcygpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xuICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8IDEwMjQpIHtcbiAgICAgICAgICAgIGxldCB3b3JrSXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcud29yay1pdGVtcyAuaXRlbScpO1xuICAgICAgICAgICAgd29ya0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgIGl0ZW0uc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gMCArICdtcyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV5ID0gMjAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCArIDEwMCA+PSBvZmZzZXQocGFnZVNjcmVlblByb2Nlc3MpKSB7XG4gICAgICAgICAgICBwYWdlU2NyZWVuUHJvY2Vzcy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUtYW5pbScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWdlU2NyZWVuUHJvY2Vzcy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUtYW5pbScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gb2Zmc2V0KGVsKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgcmV0dXJuIHJlY3QudG9wICsgc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNoZWNrYm94IGlucHV0XG5cblxuICAgICAgbGV0IGlucHV0Q2hlY2tib3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbdHlwZT1cImNoZWNrYm94XCJdJyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDaGVja2JveC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaW5wdXRDaGVja2JveFtpXTtcbiAgICAgICAgYWRkQ2xhc3NUb0xhYmVsKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGUgPT4ge1xuICAgICAgICAgIGxldCB0YXJnZXRFbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgICAgICAgYWRkQ2xhc3NUb0xhYmVsKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkQ2xhc3NUb0xhYmVsKGlucHV0KSB7XG4gICAgICAgIGxldCBwYXJlbnRMYWJlbCA9IGlucHV0LmNsb3Nlc3QoJ2xhYmVsJyk7XG5cbiAgICAgICAgaWYgKGlucHV0LmNoZWNrZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBwYXJlbnRMYWJlbC5jbGFzc0xpc3QuYWRkKCdjaGVja2VkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50TGFiZWwuY2xhc3NMaXN0LnJlbW92ZSgnY2hlY2tlZCcpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNoZWNrYm94IGlucHV0IGVuZFxuICAgICAgLy8gcmVxdWlyZWQgaW5wdXRcblxuXG4gICAgICBsZXQgaW5wdXRSZXF1aXJlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy53cGNmNy12YWxpZGF0ZXMtYXMtcmVxdWlyZWQnKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpbnB1dFJlcXVpcmVkW2ldO1xuICAgICAgICBsZXQgcGFyZW50RmllbGRzZXQgPSBlbGVtZW50LmNsb3Nlc3QoJ2ZpZWxkc2V0Jyk7XG5cbiAgICAgICAgaWYgKHBhcmVudEZpZWxkc2V0KSB7XG4gICAgICAgICAgcGFyZW50RmllbGRzZXQuY2xhc3NMaXN0LmFkZCgncmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyByZXF1aXJlZCBpbnB1dCBlbmRcbiAgICAgIC8vIHJhbmdlIGlucHV0XG5cblxuICAgICAgdmFyIHBpcHNSYW5nZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNwaXBzLXJhbmdlJyk7XG5cbiAgICAgIGlmIChwaXBzUmFuZ2UpIHtcbiAgICAgICAgcGlwc1JhbmdlLmZvckVhY2gocmFuZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgICAnbWluJzogWzEsIDFdLFxuICAgICAgICAgICAgJzExLjExJSc6IFsyLCAxXSxcbiAgICAgICAgICAgICcyMi4yMiUnOiBbMywgMV0sXG4gICAgICAgICAgICAnMzMuMzMlJzogWzQsIDFdLFxuICAgICAgICAgICAgJzQ0LjQ0JSc6IFs1LCAxXSxcbiAgICAgICAgICAgICc1NS41NSUnOiBbNiwgMV0sXG4gICAgICAgICAgICAnNjYuNjYlJzogWzcsIDFdLFxuICAgICAgICAgICAgJzc3Ljc3JSc6IFs4LCAxXSxcbiAgICAgICAgICAgICc4OC44OCUnOiBbOSwgMV0sXG4gICAgICAgICAgICAnbWF4JzogWzEwLCAxXVxuICAgICAgICAgIH07XG4gICAgICAgICAgbm9VaVNsaWRlci5jcmVhdGUocmFuZ2VFbGVtZW50LCB7XG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGNvbm5lY3Q6ICdsb3dlcicsXG4gICAgICAgICAgICBzdGVwOiAxLFxuICAgICAgICAgICAgcGlwczoge1xuICAgICAgICAgICAgICBtb2RlOiAncmFuZ2UnLFxuICAgICAgICAgICAgICBkZW5zaXR5OiAnbm9uZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByYW5nZUVsZW1lbnQubm9VaVNsaWRlci5vbigndXBkYXRlJywgZnVuY3Rpb24gKHZhbHVlcywgaGFuZGxlKSB7XG4gICAgICAgICAgICBsZXQgcGlwc1JhbmdlRmllbGRzZXQgPSByYW5nZUVsZW1lbnQuY2xvc2VzdCgnZmllbGRzZXQnKTtcbiAgICAgICAgICAgIGxldCBwaXBzUmFuZ2VJbnB1dCA9IHBpcHNSYW5nZUZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3IoJyNwaXBzLXJhbmdlLWlucHV0Jyk7XG4gICAgICAgICAgICBwaXBzUmFuZ2VJbnB1dC52YWx1ZSA9IE1hdGgucm91bmQodmFsdWVzW2hhbmRsZV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gcmFuZ2UgaW5wdXQgZW5kXG5cblxuICAgICAgQU9TLmluaXQoKTtcblxuXG4gICAgICBjb25zdCBzcG9sbGVyc0FycmF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc3BvbGxlcnNdJyk7XG5cbiAgICAgIGlmIChzcG9sbGVyc0FycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8g0J/QvtC70YPRh9C10L3QuNC1INC+0LHRi9GH0L3Ri9GFINGB0LvQvtC50LvQtdGA0L7QslxuICAgICAgICBjb25zdCBzcG9sbGVyc1JlZ3VsYXIgPSBBcnJheS5mcm9tKHNwb2xsZXJzQXJyYXkpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaW5kZXgsIHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gIWl0ZW0uZGF0YXNldC5zcG9sbGVycy5zcGxpdChcIixcIilbMF07XG4gICAgICAgIH0pOyAvLyDQmNC90LjRhtC40LDQu9C40LfQsNGG0LjRjyDQvtCx0YvRh9C90YvRhSDRgdC70L7QudC70LXRgNC+0LJcblxuICAgICAgICBpZiAoc3BvbGxlcnNSZWd1bGFyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpbml0U3BvbGxlcnMoc3BvbGxlcnNSZWd1bGFyKTtcbiAgICAgICAgfSAvLyDQn9C+0LvRg9GH0LXQvdC40LUg0YHQu9C+0LnQu9C10YDQvtCyINGBINC80LXQtNC40LAg0LfQsNC/0YDQvtGB0LDQvNC4XG5cblxuICAgICAgICBjb25zdCBzcG9sbGVyc01lZGlhID0gQXJyYXkuZnJvbShzcG9sbGVyc0FycmF5KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4LCBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YXNldC5zcG9sbGVycy5zcGxpdChcIixcIilbMF07XG4gICAgICAgIH0pOyAvLyDQmNC90LjRhtC40LDQu9C40LfQsNGG0LjRjyDRgdC70L7QudC70LXRgNC+0LIg0YEg0LzQtdC00LjQsCDQt9Cw0L/RgNC+0YHQsNC80LhcblxuICAgICAgICBpZiAoc3BvbGxlcnNNZWRpYS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgYnJlYWtwb2ludHNBcnJheSA9IFtdO1xuICAgICAgICAgIHNwb2xsZXJzTWVkaWEuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGl0ZW0uZGF0YXNldC5zcG9sbGVycztcbiAgICAgICAgICAgIGNvbnN0IGJyZWFrcG9pbnQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc0FycmF5ID0gcGFyYW1zLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIGJyZWFrcG9pbnQudmFsdWUgPSBwYXJhbXNBcnJheVswXTtcbiAgICAgICAgICAgIGJyZWFrcG9pbnQudHlwZSA9IHBhcmFtc0FycmF5WzFdID8gcGFyYW1zQXJyYXlbMV0udHJpbSgpIDogXCJtYXhcIjtcbiAgICAgICAgICAgIGJyZWFrcG9pbnQuaXRlbSA9IGl0ZW07XG4gICAgICAgICAgICBicmVha3BvaW50c0FycmF5LnB1c2goYnJlYWtwb2ludCk7XG4gICAgICAgICAgfSk7IC8vINCf0L7Qu9GD0YfQsNC10Lwg0YPQvdC40LrQsNC70YzQvdGL0LUg0LHRgNC10LnQutC/0L7QuNC90YLRi1xuXG4gICAgICAgICAgbGV0IG1lZGlhUXVlcmllcyA9IGJyZWFrcG9pbnRzQXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gJygnICsgaXRlbS50eXBlICsgXCItd2lkdGg6IFwiICsgaXRlbS52YWx1ZSArIFwicHgpLFwiICsgaXRlbS52YWx1ZSArICcsJyArIGl0ZW0udHlwZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtZWRpYVF1ZXJpZXMgPSBtZWRpYVF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG4gICAgICAgICAgfSk7IC8vINCg0LDQsdC+0YLQsNC10Lwg0YEg0LrQsNC20LTRi9C8INCx0YDQtdC50LrQv9C+0LjQvdGC0L7QvFxuXG4gICAgICAgICAgbWVkaWFRdWVyaWVzLmZvckVhY2goYnJlYWtwb2ludCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXNBcnJheSA9IGJyZWFrcG9pbnQuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgY29uc3QgbWVkaWFCcmVha3BvaW50ID0gcGFyYW1zQXJyYXlbMV07XG4gICAgICAgICAgICBjb25zdCBtZWRpYVR5cGUgPSBwYXJhbXNBcnJheVsyXTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoTWVkaWEgPSB3aW5kb3cubWF0Y2hNZWRpYShwYXJhbXNBcnJheVswXSk7IC8vINCe0LHRitC10LrRgtGLINGBINC90YPQttC90YvQvNC4INGD0YHQu9C+0LLQuNGP0LzQuFxuXG4gICAgICAgICAgICBjb25zdCBzcG9sbGVyc0FycmF5ID0gYnJlYWtwb2ludHNBcnJheS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IG1lZGlhQnJlYWtwb2ludCAmJiBpdGVtLnR5cGUgPT09IG1lZGlhVHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTsgLy8g0KHQvtCx0YvRgtC40LVcblxuICAgICAgICAgICAgbWF0Y2hNZWRpYS5hZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGluaXRTcG9sbGVycyhzcG9sbGVyc0FycmF5LCBtYXRjaE1lZGlhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5pdFNwb2xsZXJzKHNwb2xsZXJzQXJyYXksIG1hdGNoTWVkaWEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vINCY0L3QuNGG0LjQsNC70LjQt9Cw0YbQuNGPXG5cblxuICAgICAgICBmdW5jdGlvbiBpbml0U3BvbGxlcnMoc3BvbGxlcnNBcnJheSwgbWF0Y2hNZWRpYSA9IGZhbHNlKSB7XG4gICAgICAgICAgc3BvbGxlcnNBcnJheS5mb3JFYWNoKHNwb2xsZXJzQmxvY2sgPT4ge1xuICAgICAgICAgICAgc3BvbGxlcnNCbG9jayA9IG1hdGNoTWVkaWEgPyBzcG9sbGVyc0Jsb2NrLml0ZW0gOiBzcG9sbGVyc0Jsb2NrO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hNZWRpYS5tYXRjaGVzIHx8ICFtYXRjaE1lZGlhKSB7XG4gICAgICAgICAgICAgIHNwb2xsZXJzQmxvY2suY2xhc3NMaXN0LmFkZCgnX2luaXQnKTtcbiAgICAgICAgICAgICAgaW5pdFNwb2xsZXJCb2R5KHNwb2xsZXJzQmxvY2spO1xuICAgICAgICAgICAgICBzcG9sbGVyc0Jsb2NrLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzZXRTcG9sbGVyQWN0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNwb2xsZXJzQmxvY2suY2xhc3NMaXN0LnJlbW92ZSgnX2luaXQnKTtcbiAgICAgICAgICAgICAgaW5pdFNwb2xsZXJCb2R5KHNwb2xsZXJzQmxvY2ssIGZhbHNlKTtcbiAgICAgICAgICAgICAgc3BvbGxlcnNCbG9jay5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgc2V0U3BvbGxlckFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8g0KDQsNCx0L7RgtCwINGBINC60L7QvdGC0LXQvdGC0L7QvFxuXG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFNwb2xsZXJCb2R5KHNwb2xsZXJzQmxvY2ssIGhpZGVTcG9sbGVyQm9keSA9IHRydWUpIHtcbiAgICAgICAgICBjb25zdCBzcG9sbGVyVGl0bGVzID0gc3BvbGxlcnNCbG9jay5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zcG9sbGVyXScpO1xuXG4gICAgICAgICAgaWYgKHNwb2xsZXJUaXRsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3BvbGxlclRpdGxlcy5mb3JFYWNoKHNwb2xsZXJUaXRsZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChoaWRlU3BvbGxlckJvZHkpIHtcbiAgICAgICAgICAgICAgICBzcG9sbGVyVGl0bGUucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzcG9sbGVyVGl0bGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdfYWN0aXZlJykpIHtcbiAgICAgICAgICAgICAgICAgIHNwb2xsZXJUaXRsZS5uZXh0RWxlbWVudFNpYmxpbmcuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BvbGxlclRpdGxlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICAgICAgICBzcG9sbGVyVGl0bGUubmV4dEVsZW1lbnRTaWJsaW5nLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRTcG9sbGVyQWN0aW9uKGUpIHtcbiAgICAgICAgICBjb25zdCBlbCA9IGUudGFyZ2V0O1xuXG4gICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zcG9sbGVyJykgfHwgZWwuY2xvc2VzdCgnW2RhdGEtc3BvbGxlcl0nKSkge1xuICAgICAgICAgICAgY29uc3Qgc3BvbGxlclRpdGxlID0gZWwuaGFzQXR0cmlidXRlKCdkYXRhLXNwb2xsZXInKSA/IGVsIDogZWwuY2xvc2VzdCgnW2RhdGEtc3BvbGxlcl0nKTtcbiAgICAgICAgICAgIGNvbnN0IHNwb2xsZXJzQmxvY2sgPSBzcG9sbGVyVGl0bGUuY2xvc2VzdCgnW2RhdGEtc3BvbGxlcnNdJyk7XG4gICAgICAgICAgICBjb25zdCBvbmVTcG9sbGVyID0gc3BvbGxlcnNCbG9jay5oYXNBdHRyaWJ1dGUoJ2RhdGEtb25lLXNwb2xsZXInKSA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKCFzcG9sbGVyc0Jsb2NrLnF1ZXJ5U2VsZWN0b3JBbGwoJy5fc2xpZGUnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKG9uZVNwb2xsZXIgJiYgIXNwb2xsZXJUaXRsZS5jbGFzc0xpc3QuY29udGFpbnMoJ19hY3RpdmUnKSkge1xuICAgICAgICAgICAgICAgIGhpZGVTcG9sbGVyc0JvZHkoc3BvbGxlcnNCbG9jayk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzcG9sbGVyVGl0bGUuY2xhc3NMaXN0LnRvZ2dsZSgnX2FjdGl2ZScpO1xuXG4gICAgICAgICAgICAgIF9zbGlkZVRvZ2dsZShzcG9sbGVyVGl0bGUubmV4dEVsZW1lbnRTaWJsaW5nLCA1MDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGlkZVNwb2xsZXJzQm9keShzcG9sbGVyc0Jsb2NrKSB7XG4gICAgICAgICAgY29uc3Qgc3BvbGxlckFjdGl2ZVRpdGxlID0gc3BvbGxlcnNCbG9jay5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zcG9sbGVyXS5fYWN0aXZlJyk7XG5cbiAgICAgICAgICBpZiAoc3BvbGxlckFjdGl2ZVRpdGxlKSB7XG4gICAgICAgICAgICBzcG9sbGVyQWN0aXZlVGl0bGUuY2xhc3NMaXN0LnJlbW92ZSgnX2FjdGl2ZScpO1xuXG4gICAgICAgICAgICBfc2xpZGVVcChzcG9sbGVyQWN0aXZlVGl0bGUubmV4dEVsZW1lbnRTaWJsaW5nLCA1MDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvL1NsaWRlVG9nZ2xlXG5cblxuICAgICAgbGV0IF9zbGlkZVVwID0gKHRhcmdldCwgZHVyYXRpb24gPSA1MDApID0+IHtcbiAgICAgICAgaWYgKCF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdfc2xpZGUnKSkge1xuICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKCdfc2xpZGUnKTtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ2hlaWdodCwgbWFyZ2luLCBwYWRkaW5nJztcbiAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gKyAnbXMnO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSB0YXJnZXQub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICB0YXJnZXQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSAwO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5wYWRkaW5nVG9wID0gMDtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLm1hcmdpblRvcCA9IDA7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLm1hcmdpbkJvdHRvbSA9IDA7XG4gICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGFyZ2V0LmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2hlaWdodCcpO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwYWRkaW5nLXRvcCcpO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwYWRkaW5nLWJvdHRvbScpO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdtYXJnaW4tdG9wJyk7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ21hcmdpbi1ib3R0b20nKTtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbi1kdXJhdGlvbicpO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uLXByb3BlcnR5Jyk7XG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnX3NsaWRlJyk7XG4gICAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBsZXQgX3NsaWRlRG93biA9ICh0YXJnZXQsIGR1cmF0aW9uID0gNTAwKSA9PiB7XG4gICAgICAgIGlmICghdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnX3NsaWRlJykpIHtcbiAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnX3NsaWRlJyk7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0LmhpZGRlbikge1xuICAgICAgICAgICAgdGFyZ2V0LmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBoZWlnaHQgPSB0YXJnZXQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSAwO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5wYWRkaW5nVG9wID0gMDtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLm1hcmdpblRvcCA9IDA7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLm1hcmdpbkJvdHRvbSA9IDA7XG4gICAgICAgICAgdGFyZ2V0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gXCJoZWlnaHQsIG1hcmdpbiwgcGFkZGluZ1wiO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiArICdtcyc7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwYWRkaW5nLXRvcCcpO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncGFkZGluZy1ib3R0b20nKTtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ21hcmdpbi10b3AnKTtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ21hcmdpbi1ib3R0b20nKTtcbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2hlaWdodCcpO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdvdmVyZmxvdycpO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uLWR1cmF0aW9uJyk7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zaXRpb24tcHJvcGVydHknKTtcbiAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdfc2xpZGUnKTtcbiAgICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGxldCBfc2xpZGVUb2dnbGUgPSAodGFyZ2V0LCBkdXJhdGlvbiA9IDUwMCkgPT4ge1xuICAgICAgICBpZiAodGFyZ2V0LmhpZGRlbikge1xuICAgICAgICAgIHJldHVybiBfc2xpZGVEb3duKHRhcmdldCwgZHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfc2xpZGVVcCh0YXJnZXQsIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTsgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgICAvKlxyXG4gICAgICDQlNC70Y8g0YDQvtC00LjRgtC10LvRjyDRgdC70L7QudC70LXRgNC+0LIg0L/QuNGI0LXQvCDQsNGC0YDQuNCx0YPRgiBkYXRhLXNwb2xsZXJzXHJcbiAgICAgINCU0LvRjyDQt9Cw0LPQvtC70L7QstC60L7QsiDRgdC70L7QudC70LXRgNC+0LIg0L/QuNGI0LXQvCDQsNGC0YDQuNCx0YPRgiBkYXRhLXNwb2xsZXJcclxuICAgICAg0JXRgdC70Lgg0L3Rg9C20L3QviDQstC60LvRjtGH0LDRgtGMXFzQstGL0LrQu9GO0YfQsNGC0Ywg0YDQsNCx0L7RgtGDINGB0L/QvtC50LvQtdGA0L7QsiDQvdCwINGA0LDQt9C90YvRhSDRgNCw0LfQvNC10YDQsNGFINGN0LrRgNCw0L3QvtCyXHJcbiAgICAgINC/0LjRiNC10Lwg0L/QsNGA0LDQvNC10YLRgNGLINGI0LjRgNC40L3RiyDQuCDRgtC40L/QsCDQsdGA0LXQudC60L/QvtC40L3RgtCwLlxyXG4gICAgICDQndCw0L/RgNC40LzQtdGAOlxyXG4gICAgICBkYXRhLXNwb2xsZXJzPVwiOTkyLG1heFwiIC0g0YHQv9C+0LnQu9C10YDRiyDQsdGD0LTRg9GCINGA0LDQsdC+0YLQsNGC0Ywg0YLQvtC70YzQutC+INC90LAg0Y3QutGA0LDQvdCw0YUg0LzQtdC90YzRiNC1INC40LvQuCDRgNCw0LLQvdC+IDk5MnB4XHJcbiAgICAgIGRhdGEtc3BvbGxlcnM9XCI3NjgsbWluXCIgLSDRgdC/0L7QudC70LXRgNGLINCx0YPQtNGD0YIg0YDQsNCx0L7RgtCw0YLRjCDRgtC+0LvRjNC60L4g0L3QsCDRjdC60YDQsNC90LDRhSDQsdC+0LvRjNGI0LUg0LjQu9C4INGA0LDQstC90L4gNzY4cHhcclxuICAgICAgXG4gICAgICDQldGB0LvQuCDQvdGD0LbQvdC+INGH0YLQviDQsdGLINCyINCx0LvQvtC60LUg0L7RgtC60YDRi9Cy0LDQu9GB0Y8g0LHQvtC70YzQutC+INC+0LTQuNC9INGB0LvQvtC50LvQtdGAINC00L7QsdCw0LLQu9GP0LXQvCDQsNGC0YDQuNCx0YPRgiBkYXRhLW9uZS1zcG9sbGVyXHJcbiAgICAgICovXG5cbiAgICB9XG5cbn0pKSk7XG4iXSwiZmlsZSI6Im1haW4uanMifQ==
