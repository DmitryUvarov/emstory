(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define('jquery360Min', factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.jquery360Min = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var jquery3_6_0_min = createCommonjsModule(function (module) {
	/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */
	!function (e, t) {

	  module.exports = e.document ? t(e, !0) : function (e) {
	    if (!e.document) throw new Error("jQuery requires a window with a document");
	    return t(e);
	  } ;
	}("undefined" != typeof window ? window : commonjsGlobal, function (C, e) {

	  var t = [],
	      r = Object.getPrototypeOf,
	      s = t.slice,
	      g = t.flat ? function (e) {
	    return t.flat.call(e);
	  } : function (e) {
	    return t.concat.apply([], e);
	  },
	      u = t.push,
	      i = t.indexOf,
	      n = {},
	      o = n.toString,
	      v = n.hasOwnProperty,
	      a = v.toString,
	      l = a.call(Object),
	      y = {},
	      m = function (e) {
	    return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item;
	  },
	      x = function (e) {
	    return null != e && e === e.window;
	  },
	      E = C.document,
	      c = {
	    type: !0,
	    src: !0,
	    nonce: !0,
	    noModule: !0
	  };

	  function b(e, t, n) {
	    var r,
	        i,
	        o = (n = n || E).createElement("script");
	    if (o.text = e, t) for (r in c) (i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i);
	    n.head.appendChild(o).parentNode.removeChild(o);
	  }

	  function w(e) {
	    return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e;
	  }

	  var f = "3.6.0",
	      S = function (e, t) {
	    return new S.fn.init(e, t);
	  };

	  function p(e) {
	    var t = !!e && "length" in e && e.length,
	        n = w(e);
	    return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e);
	  }

	  S.fn = S.prototype = {
	    jquery: f,
	    constructor: S,
	    length: 0,
	    toArray: function () {
	      return s.call(this);
	    },
	    get: function (e) {
	      return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e];
	    },
	    pushStack: function (e) {
	      var t = S.merge(this.constructor(), e);
	      return t.prevObject = this, t;
	    },
	    each: function (e) {
	      return S.each(this, e);
	    },
	    map: function (n) {
	      return this.pushStack(S.map(this, function (e, t) {
	        return n.call(e, t, e);
	      }));
	    },
	    slice: function () {
	      return this.pushStack(s.apply(this, arguments));
	    },
	    first: function () {
	      return this.eq(0);
	    },
	    last: function () {
	      return this.eq(-1);
	    },
	    even: function () {
	      return this.pushStack(S.grep(this, function (e, t) {
	        return (t + 1) % 2;
	      }));
	    },
	    odd: function () {
	      return this.pushStack(S.grep(this, function (e, t) {
	        return t % 2;
	      }));
	    },
	    eq: function (e) {
	      var t = this.length,
	          n = +e + (e < 0 ? t : 0);
	      return this.pushStack(0 <= n && n < t ? [this[n]] : []);
	    },
	    end: function () {
	      return this.prevObject || this.constructor();
	    },
	    push: u,
	    sort: t.sort,
	    splice: t.splice
	  }, S.extend = S.fn.extend = function () {
	    var e,
	        t,
	        n,
	        r,
	        i,
	        o,
	        a = arguments[0] || {},
	        s = 1,
	        u = arguments.length,
	        l = !1;

	    for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++) if (null != (e = arguments[s])) for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r));

	    return a;
	  }, S.extend({
	    expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
	    isReady: !0,
	    error: function (e) {
	      throw new Error(e);
	    },
	    noop: function () {},
	    isPlainObject: function (e) {
	      var t, n;
	      return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof (n = v.call(t, "constructor") && t.constructor) && a.call(n) === l);
	    },
	    isEmptyObject: function (e) {
	      var t;

	      for (t in e) return !1;

	      return !0;
	    },
	    globalEval: function (e, t, n) {
	      b(e, {
	        nonce: t && t.nonce
	      }, n);
	    },
	    each: function (e, t) {
	      var n,
	          r = 0;

	      if (p(e)) {
	        for (n = e.length; r < n; r++) if (!1 === t.call(e[r], r, e[r])) break;
	      } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break;

	      return e;
	    },
	    makeArray: function (e, t) {
	      var n = t || [];
	      return null != e && (p(Object(e)) ? S.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n;
	    },
	    inArray: function (e, t, n) {
	      return null == t ? -1 : i.call(t, e, n);
	    },
	    merge: function (e, t) {
	      for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r];

	      return e.length = i, e;
	    },
	    grep: function (e, t, n) {
	      for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i) !== a && r.push(e[i]);

	      return r;
	    },
	    map: function (e, t, n) {
	      var r,
	          i,
	          o = 0,
	          a = [];
	      if (p(e)) for (r = e.length; o < r; o++) null != (i = t(e[o], o, n)) && a.push(i);else for (o in e) null != (i = t(e[o], o, n)) && a.push(i);
	      return g(a);
	    },
	    guid: 1,
	    support: y
	  }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {
	    n["[object " + t + "]"] = t.toLowerCase();
	  });

	  var d = function (n) {
	    var e,
	        d,
	        b,
	        o,
	        i,
	        h,
	        f,
	        g,
	        w,
	        u,
	        l,
	        T,
	        C,
	        a,
	        E,
	        v,
	        s,
	        c,
	        y,
	        S = "sizzle" + 1 * new Date(),
	        p = n.document,
	        k = 0,
	        r = 0,
	        m = ue(),
	        x = ue(),
	        A = ue(),
	        N = ue(),
	        j = function (e, t) {
	      return e === t && (l = !0), 0;
	    },
	        D = {}.hasOwnProperty,
	        t = [],
	        q = t.pop,
	        L = t.push,
	        H = t.push,
	        O = t.slice,
	        P = function (e, t) {
	      for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;

	      return -1;
	    },
	        R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	        M = "[\\x20\\t\\r\\n\\f]",
	        I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
	        W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]",
	        F = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)",
	        B = new RegExp(M + "+", "g"),
	        $ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
	        _ = new RegExp("^" + M + "*," + M + "*"),
	        z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
	        U = new RegExp(M + "|>"),
	        X = new RegExp(F),
	        V = new RegExp("^" + I + "$"),
	        G = {
	      ID: new RegExp("^#(" + I + ")"),
	      CLASS: new RegExp("^\\.(" + I + ")"),
	      TAG: new RegExp("^(" + I + "|[*])"),
	      ATTR: new RegExp("^" + W),
	      PSEUDO: new RegExp("^" + F),
	      CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"),
	      bool: new RegExp("^(?:" + R + ")$", "i"),
	      needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i")
	    },
	        Y = /HTML$/i,
	        Q = /^(?:input|select|textarea|button)$/i,
	        J = /^h\d$/i,
	        K = /^[^{]+\{\s*\[native \w/,
	        Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	        ee = /[+~]/,
	        te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"),
	        ne = function (e, t) {
	      var n = "0x" + e.slice(1) - 65536;
	      return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320));
	    },
	        re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	        ie = function (e, t) {
	      return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e;
	    },
	        oe = function () {
	      T();
	    },
	        ae = be(function (e) {
	      return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase();
	    }, {
	      dir: "parentNode",
	      next: "legend"
	    });

	    try {
	      H.apply(t = O.call(p.childNodes), p.childNodes), t[p.childNodes.length].nodeType;
	    } catch (e) {
	      H = {
	        apply: t.length ? function (e, t) {
	          L.apply(e, O.call(t));
	        } : function (e, t) {
	          var n = e.length,
	              r = 0;

	          while (e[n++] = t[r++]);

	          e.length = n - 1;
	        }
	      };
	    }

	    function se(t, e, n, r) {
	      var i,
	          o,
	          a,
	          s,
	          u,
	          l,
	          c,
	          f = e && e.ownerDocument,
	          p = e ? e.nodeType : 9;
	      if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n;

	      if (!r && (T(e), e = e || C, E)) {
	        if (11 !== p && (u = Z.exec(t))) if (i = u[1]) {
	          if (9 === p) {
	            if (!(a = e.getElementById(i))) return n;
	            if (a.id === i) return n.push(a), n;
	          } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n;
	        } else {
	          if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n;
	          if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n;
	        }

	        if (d.qsa && !N[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) {
	          if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) {
	            (f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = S)), o = (l = h(t)).length;

	            while (o--) l[o] = (s ? "#" + s : ":scope") + " " + xe(l[o]);

	            c = l.join(",");
	          }

	          try {
	            return H.apply(n, f.querySelectorAll(c)), n;
	          } catch (e) {
	            N(t, !0);
	          } finally {
	            s === S && e.removeAttribute("id");
	          }
	        }
	      }

	      return g(t.replace($, "$1"), e, n, r);
	    }

	    function ue() {
	      var r = [];
	      return function e(t, n) {
	        return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n;
	      };
	    }

	    function le(e) {
	      return e[S] = !0, e;
	    }

	    function ce(e) {
	      var t = C.createElement("fieldset");

	      try {
	        return !!e(t);
	      } catch (e) {
	        return !1;
	      } finally {
	        t.parentNode && t.parentNode.removeChild(t), t = null;
	      }
	    }

	    function fe(e, t) {
	      var n = e.split("|"),
	          r = n.length;

	      while (r--) b.attrHandle[n[r]] = t;
	    }

	    function pe(e, t) {
	      var n = t && e,
	          r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
	      if (r) return r;
	      if (n) while (n = n.nextSibling) if (n === t) return -1;
	      return e ? 1 : -1;
	    }

	    function de(t) {
	      return function (e) {
	        return "input" === e.nodeName.toLowerCase() && e.type === t;
	      };
	    }

	    function he(n) {
	      return function (e) {
	        var t = e.nodeName.toLowerCase();
	        return ("input" === t || "button" === t) && e.type === n;
	      };
	    }

	    function ge(t) {
	      return function (e) {
	        return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t;
	      };
	    }

	    function ve(a) {
	      return le(function (o) {
	        return o = +o, le(function (e, t) {
	          var n,
	              r = a([], e.length, o),
	              i = r.length;

	          while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n]));
	        });
	      });
	    }

	    function ye(e) {
	      return e && "undefined" != typeof e.getElementsByTagName && e;
	    }

	    for (e in d = se.support = {}, i = se.isXML = function (e) {
	      var t = e && e.namespaceURI,
	          n = e && (e.ownerDocument || e).documentElement;
	      return !Y.test(t || n && n.nodeName || "HTML");
	    }, T = se.setDocument = function (e) {
	      var t,
	          n,
	          r = e ? e.ownerDocument || e : p;
	      return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.scope = ce(function (e) {
	        return a.appendChild(e).appendChild(C.createElement("div")), "undefined" != typeof e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length;
	      }), d.attributes = ce(function (e) {
	        return e.className = "i", !e.getAttribute("className");
	      }), d.getElementsByTagName = ce(function (e) {
	        return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length;
	      }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function (e) {
	        return a.appendChild(e).id = S, !C.getElementsByName || !C.getElementsByName(S).length;
	      }), d.getById ? (b.filter.ID = function (e) {
	        var t = e.replace(te, ne);
	        return function (e) {
	          return e.getAttribute("id") === t;
	        };
	      }, b.find.ID = function (e, t) {
	        if ("undefined" != typeof t.getElementById && E) {
	          var n = t.getElementById(e);
	          return n ? [n] : [];
	        }
	      }) : (b.filter.ID = function (e) {
	        var n = e.replace(te, ne);
	        return function (e) {
	          var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
	          return t && t.value === n;
	        };
	      }, b.find.ID = function (e, t) {
	        if ("undefined" != typeof t.getElementById && E) {
	          var n,
	              r,
	              i,
	              o = t.getElementById(e);

	          if (o) {
	            if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
	            i = t.getElementsByName(e), r = 0;

	            while (o = i[r++]) if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
	          }

	          return [];
	        }
	      }), b.find.TAG = d.getElementsByTagName ? function (e, t) {
	        return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0;
	      } : function (e, t) {
	        var n,
	            r = [],
	            i = 0,
	            o = t.getElementsByTagName(e);

	        if ("*" === e) {
	          while (n = o[i++]) 1 === n.nodeType && r.push(n);

	          return r;
	        }

	        return o;
	      }, b.find.CLASS = d.getElementsByClassName && function (e, t) {
	        if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e);
	      }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function (e) {
	        var t;
	        a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + S + "-]").length || v.push("~="), (t = C.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + S + "+*").length || v.push(".#.+[+~]"), e.querySelectorAll("\\\f"), v.push("[\\r\\n\\f]");
	      }), ce(function (e) {
	        e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
	        var t = C.createElement("input");
	        t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:");
	      })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) {
	        d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", F);
	      }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function (e, t) {
	        var n = 9 === e.nodeType ? e.documentElement : e,
	            r = t && t.parentNode;
	        return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
	      } : function (e, t) {
	        if (t) while (t = t.parentNode) if (t === e) return !0;
	        return !1;
	      }, j = t ? function (e, t) {
	        if (e === t) return l = !0, 0;
	        var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
	        return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1);
	      } : function (e, t) {
	        if (e === t) return l = !0, 0;
	        var n,
	            r = 0,
	            i = e.parentNode,
	            o = t.parentNode,
	            a = [e],
	            s = [t];
	        if (!i || !o) return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0;
	        if (i === o) return pe(e, t);
	        n = e;

	        while (n = n.parentNode) a.unshift(n);

	        n = t;

	        while (n = n.parentNode) s.unshift(n);

	        while (a[r] === s[r]) r++;

	        return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ? 1 : 0;
	      }), C;
	    }, se.matches = function (e, t) {
	      return se(e, null, null, t);
	    }, se.matchesSelector = function (e, t) {
	      if (T(e), d.matchesSelector && E && !N[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try {
	        var n = c.call(e, t);
	        if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n;
	      } catch (e) {
	        N(t, !0);
	      }
	      return 0 < se(t, C, null, [e]).length;
	    }, se.contains = function (e, t) {
	      return (e.ownerDocument || e) != C && T(e), y(e, t);
	    }, se.attr = function (e, t) {
	      (e.ownerDocument || e) != C && T(e);
	      var n = b.attrHandle[t.toLowerCase()],
	          r = n && D.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0;
	      return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
	    }, se.escape = function (e) {
	      return (e + "").replace(re, ie);
	    }, se.error = function (e) {
	      throw new Error("Syntax error, unrecognized expression: " + e);
	    }, se.uniqueSort = function (e) {
	      var t,
	          n = [],
	          r = 0,
	          i = 0;

	      if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(j), l) {
	        while (t = e[i++]) t === e[i] && (r = n.push(i));

	        while (r--) e.splice(n[r], 1);
	      }

	      return u = null, e;
	    }, o = se.getText = function (e) {
	      var t,
	          n = "",
	          r = 0,
	          i = e.nodeType;

	      if (i) {
	        if (1 === i || 9 === i || 11 === i) {
	          if ("string" == typeof e.textContent) return e.textContent;

	          for (e = e.firstChild; e; e = e.nextSibling) n += o(e);
	        } else if (3 === i || 4 === i) return e.nodeValue;
	      } else while (t = e[r++]) n += o(t);

	      return n;
	    }, (b = se.selectors = {
	      cacheLength: 50,
	      createPseudo: le,
	      match: G,
	      attrHandle: {},
	      find: {},
	      relative: {
	        ">": {
	          dir: "parentNode",
	          first: !0
	        },
	        " ": {
	          dir: "parentNode"
	        },
	        "+": {
	          dir: "previousSibling",
	          first: !0
	        },
	        "~": {
	          dir: "previousSibling"
	        }
	      },
	      preFilter: {
	        ATTR: function (e) {
	          return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);
	        },
	        CHILD: function (e) {
	          return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e;
	        },
	        PSEUDO: function (e) {
	          var t,
	              n = !e[6] && e[2];
	          return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3));
	        }
	      },
	      filter: {
	        TAG: function (e) {
	          var t = e.replace(te, ne).toLowerCase();
	          return "*" === e ? function () {
	            return !0;
	          } : function (e) {
	            return e.nodeName && e.nodeName.toLowerCase() === t;
	          };
	        },
	        CLASS: function (e) {
	          var t = m[e + " "];
	          return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && m(e, function (e) {
	            return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "");
	          });
	        },
	        ATTR: function (n, r, i) {
	          return function (e) {
	            var t = se.attr(e, n);
	            return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-"));
	          };
	        },
	        CHILD: function (h, e, t, g, v) {
	          var y = "nth" !== h.slice(0, 3),
	              m = "last" !== h.slice(-4),
	              x = "of-type" === e;
	          return 1 === g && 0 === v ? function (e) {
	            return !!e.parentNode;
	          } : function (e, t, n) {
	            var r,
	                i,
	                o,
	                a,
	                s,
	                u,
	                l = y !== m ? "nextSibling" : "previousSibling",
	                c = e.parentNode,
	                f = x && e.nodeName.toLowerCase(),
	                p = !n && !x,
	                d = !1;

	            if (c) {
	              if (y) {
	                while (l) {
	                  a = e;

	                  while (a = a[l]) if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1;

	                  u = l = "only" === h && !u && "nextSibling";
	                }

	                return !0;
	              }

	              if (u = [m ? c.firstChild : c.lastChild], m && p) {
	                d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2], a = s && c.childNodes[s];

	                while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if (1 === a.nodeType && ++d && a === e) {
	                  i[h] = [k, s, d];
	                  break;
	                }
	              } else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d) while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [k, d]), a === e)) break;

	              return (d -= v) === g || d % g == 0 && 0 <= d / g;
	            }
	          };
	        },
	        PSEUDO: function (e, o) {
	          var t,
	              a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
	          return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function (e, t) {
	            var n,
	                r = a(e, o),
	                i = r.length;

	            while (i--) e[n = P(e, r[i])] = !(t[n] = r[i]);
	          }) : function (e) {
	            return a(e, 0, t);
	          }) : a;
	        }
	      },
	      pseudos: {
	        not: le(function (e) {
	          var r = [],
	              i = [],
	              s = f(e.replace($, "$1"));
	          return s[S] ? le(function (e, t, n, r) {
	            var i,
	                o = s(e, null, r, []),
	                a = e.length;

	            while (a--) (i = o[a]) && (e[a] = !(t[a] = i));
	          }) : function (e, t, n) {
	            return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop();
	          };
	        }),
	        has: le(function (t) {
	          return function (e) {
	            return 0 < se(t, e).length;
	          };
	        }),
	        contains: le(function (t) {
	          return t = t.replace(te, ne), function (e) {
	            return -1 < (e.textContent || o(e)).indexOf(t);
	          };
	        }),
	        lang: le(function (n) {
	          return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(), function (e) {
	            var t;

	            do {
	              if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-");
	            } while ((e = e.parentNode) && 1 === e.nodeType);

	            return !1;
	          };
	        }),
	        target: function (e) {
	          var t = n.location && n.location.hash;
	          return t && t.slice(1) === e.id;
	        },
	        root: function (e) {
	          return e === a;
	        },
	        focus: function (e) {
	          return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
	        },
	        enabled: ge(!1),
	        disabled: ge(!0),
	        checked: function (e) {
	          var t = e.nodeName.toLowerCase();
	          return "input" === t && !!e.checked || "option" === t && !!e.selected;
	        },
	        selected: function (e) {
	          return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected;
	        },
	        empty: function (e) {
	          for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;

	          return !0;
	        },
	        parent: function (e) {
	          return !b.pseudos.empty(e);
	        },
	        header: function (e) {
	          return J.test(e.nodeName);
	        },
	        input: function (e) {
	          return Q.test(e.nodeName);
	        },
	        button: function (e) {
	          var t = e.nodeName.toLowerCase();
	          return "input" === t && "button" === e.type || "button" === t;
	        },
	        text: function (e) {
	          var t;
	          return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());
	        },
	        first: ve(function () {
	          return [0];
	        }),
	        last: ve(function (e, t) {
	          return [t - 1];
	        }),
	        eq: ve(function (e, t, n) {
	          return [n < 0 ? n + t : n];
	        }),
	        even: ve(function (e, t) {
	          for (var n = 0; n < t; n += 2) e.push(n);

	          return e;
	        }),
	        odd: ve(function (e, t) {
	          for (var n = 1; n < t; n += 2) e.push(n);

	          return e;
	        }),
	        lt: ve(function (e, t, n) {
	          for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;) e.push(r);

	          return e;
	        }),
	        gt: ve(function (e, t, n) {
	          for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r);

	          return e;
	        })
	      }
	    }).pseudos.nth = b.pseudos.eq, {
	      radio: !0,
	      checkbox: !0,
	      file: !0,
	      password: !0,
	      image: !0
	    }) b.pseudos[e] = de(e);

	    for (e in {
	      submit: !0,
	      reset: !0
	    }) b.pseudos[e] = he(e);

	    function me() {}

	    function xe(e) {
	      for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;

	      return r;
	    }

	    function be(s, e, t) {
	      var u = e.dir,
	          l = e.next,
	          c = l || u,
	          f = t && "parentNode" === c,
	          p = r++;
	      return e.first ? function (e, t, n) {
	        while (e = e[u]) if (1 === e.nodeType || f) return s(e, t, n);

	        return !1;
	      } : function (e, t, n) {
	        var r,
	            i,
	            o,
	            a = [k, p];

	        if (n) {
	          while (e = e[u]) if ((1 === e.nodeType || f) && s(e, t, n)) return !0;
	        } else while (e = e[u]) if (1 === e.nodeType || f) if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e;else {
	          if ((r = i[c]) && r[0] === k && r[1] === p) return a[2] = r[2];
	          if ((i[c] = a)[2] = s(e, t, n)) return !0;
	        }

	        return !1;
	      };
	    }

	    function we(i) {
	      return 1 < i.length ? function (e, t, n) {
	        var r = i.length;

	        while (r--) if (!i[r](e, t, n)) return !1;

	        return !0;
	      } : i[0];
	    }

	    function Te(e, t, n, r, i) {
	      for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++) (o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));

	      return a;
	    }

	    function Ce(d, h, g, v, y, e) {
	      return v && !v[S] && (v = Ce(v)), y && !y[S] && (y = Ce(y, e)), le(function (e, t, n, r) {
	        var i,
	            o,
	            a,
	            s = [],
	            u = [],
	            l = t.length,
	            c = e || function (e, t, n) {
	          for (var r = 0, i = t.length; r < i; r++) se(e, t[r], n);

	          return n;
	        }(h || "*", n.nodeType ? [n] : n, []),
	            f = !d || !e && h ? c : Te(c, s, d, n, r),
	            p = g ? y || (e ? d : l || v) ? [] : t : f;

	        if (g && g(f, p, n, r), v) {
	          i = Te(p, u), v(i, [], n, r), o = i.length;

	          while (o--) (a = i[o]) && (p[u[o]] = !(f[u[o]] = a));
	        }

	        if (e) {
	          if (y || d) {
	            if (y) {
	              i = [], o = p.length;

	              while (o--) (a = p[o]) && i.push(f[o] = a);

	              y(null, p = [], i, r);
	            }

	            o = p.length;

	            while (o--) (a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a));
	          }
	        } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p);
	      });
	    }

	    function Ee(e) {
	      for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function (e) {
	        return e === i;
	      }, a, !0), l = be(function (e) {
	        return -1 < P(i, e);
	      }, a, !0), c = [function (e, t, n) {
	        var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n));
	        return i = null, r;
	      }]; s < r; s++) if (t = b.relative[e[s].type]) c = [be(we(c), t)];else {
	        if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) {
	          for (n = ++s; n < r; n++) if (b.relative[e[n].type]) break;

	          return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({
	            value: " " === e[s - 2].type ? "*" : ""
	          })).replace($, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e));
	        }

	        c.push(t);
	      }

	      return we(c);
	    }

	    return me.prototype = b.filters = b.pseudos, b.setFilters = new me(), h = se.tokenize = function (e, t) {
	      var n,
	          r,
	          i,
	          o,
	          a,
	          s,
	          u,
	          l = x[e + " "];
	      if (l) return t ? 0 : l.slice(0);
	      a = e, s = [], u = b.preFilter;

	      while (a) {
	        for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({
	          value: n,
	          type: r[0].replace($, " ")
	        }), a = a.slice(n.length)), b.filter) !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({
	          value: n,
	          type: o,
	          matches: r
	        }), a = a.slice(n.length));

	        if (!n) break;
	      }

	      return t ? a.length : a ? se.error(e) : x(e, s).slice(0);
	    }, f = se.compile = function (e, t) {
	      var n,
	          v,
	          y,
	          m,
	          x,
	          r,
	          i = [],
	          o = [],
	          a = A[e + " "];

	      if (!a) {
	        t || (t = h(e)), n = t.length;

	        while (n--) (a = Ee(t[n]))[S] ? i.push(a) : o.push(a);

	        (a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function (e, t, n, r, i) {
	          var o,
	              a,
	              s,
	              u = 0,
	              l = "0",
	              c = e && [],
	              f = [],
	              p = w,
	              d = e || x && b.find.TAG("*", i),
	              h = k += null == p ? 1 : Math.random() || .1,
	              g = d.length;

	          for (i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++) {
	            if (x && o) {
	              a = 0, t || o.ownerDocument == C || (T(o), n = !E);

	              while (s = v[a++]) if (s(o, t || C, n)) {
	                r.push(o);
	                break;
	              }

	              i && (k = h);
	            }

	            m && ((o = !s && o) && u--, e && c.push(o));
	          }

	          if (u += l, m && l !== u) {
	            a = 0;

	            while (s = y[a++]) s(c, f, t, n);

	            if (e) {
	              if (0 < u) while (l--) c[l] || f[l] || (f[l] = q.call(r));
	              f = Te(f);
	            }

	            H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r);
	          }

	          return i && (k = h, w = p), c;
	        }, m ? le(r) : r))).selector = e;
	      }

	      return a;
	    }, g = se.select = function (e, t, n, r) {
	      var i,
	          o,
	          a,
	          s,
	          u,
	          l = "function" == typeof e && e,
	          c = !r && h(e = l.selector || e);

	      if (n = n || [], 1 === c.length) {
	        if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) {
	          if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n;
	          l && (t = t.parentNode), e = e.slice(o.shift().value.length);
	        }

	        i = G.needsContext.test(e) ? 0 : o.length;

	        while (i--) {
	          if (a = o[i], b.relative[s = a.type]) break;

	          if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) {
	            if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n;
	            break;
	          }
	        }
	      }

	      return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n;
	    }, d.sortStable = S.split("").sort(j).join("") === S, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function (e) {
	      return 1 & e.compareDocumentPosition(C.createElement("fieldset"));
	    }), ce(function (e) {
	      return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href");
	    }) || fe("type|href|height|width", function (e, t, n) {
	      if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
	    }), d.attributes && ce(function (e) {
	      return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value");
	    }) || fe("value", function (e, t, n) {
	      if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
	    }), ce(function (e) {
	      return null == e.getAttribute("disabled");
	    }) || fe(R, function (e, t, n) {
	      var r;
	      if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
	    }), se;
	  }(C);

	  S.find = d, S.expr = d.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape;

	  var h = function (e, t, n) {
	    var r = [],
	        i = void 0 !== n;

	    while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) {
	      if (i && S(e).is(n)) break;
	      r.push(e);
	    }

	    return r;
	  },
	      T = function (e, t) {
	    for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);

	    return n;
	  },
	      k = S.expr.match.needsContext;

	  function A(e, t) {
	    return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
	  }

	  var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

	  function j(e, n, r) {
	    return m(n) ? S.grep(e, function (e, t) {
	      return !!n.call(e, t, e) !== r;
	    }) : n.nodeType ? S.grep(e, function (e) {
	      return e === n !== r;
	    }) : "string" != typeof n ? S.grep(e, function (e) {
	      return -1 < i.call(n, e) !== r;
	    }) : S.filter(n, e, r);
	  }

	  S.filter = function (e, t, n) {
	    var r = t[0];
	    return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [r] : [] : S.find.matches(e, S.grep(t, function (e) {
	      return 1 === e.nodeType;
	    }));
	  }, S.fn.extend({
	    find: function (e) {
	      var t,
	          n,
	          r = this.length,
	          i = this;
	      if ("string" != typeof e) return this.pushStack(S(e).filter(function () {
	        for (t = 0; t < r; t++) if (S.contains(i[t], this)) return !0;
	      }));

	      for (n = this.pushStack([]), t = 0; t < r; t++) S.find(e, i[t], n);

	      return 1 < r ? S.uniqueSort(n) : n;
	    },
	    filter: function (e) {
	      return this.pushStack(j(this, e || [], !1));
	    },
	    not: function (e) {
	      return this.pushStack(j(this, e || [], !0));
	    },
	    is: function (e) {
	      return !!j(this, "string" == typeof e && k.test(e) ? S(e) : e || [], !1).length;
	    }
	  });
	  var D,
	      q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
	  (S.fn.init = function (e, t, n) {
	    var r, i;
	    if (!e) return this;

	    if (n = n || D, "string" == typeof e) {
	      if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);

	      if (r[1]) {
	        if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t)) for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
	        return this;
	      }

	      return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this;
	    }

	    return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this);
	  }).prototype = S.fn, D = S(E);
	  var L = /^(?:parents|prev(?:Until|All))/,
	      H = {
	    children: !0,
	    contents: !0,
	    next: !0,
	    prev: !0
	  };

	  function O(e, t) {
	    while ((e = e[t]) && 1 !== e.nodeType);

	    return e;
	  }

	  S.fn.extend({
	    has: function (e) {
	      var t = S(e, this),
	          n = t.length;
	      return this.filter(function () {
	        for (var e = 0; e < n; e++) if (S.contains(this, t[e])) return !0;
	      });
	    },
	    closest: function (e, t) {
	      var n,
	          r = 0,
	          i = this.length,
	          o = [],
	          a = "string" != typeof e && S(e);
	      if (!k.test(e)) for (; r < i; r++) for (n = this[r]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) {
	        o.push(n);
	        break;
	      }
	      return this.pushStack(1 < o.length ? S.uniqueSort(o) : o);
	    },
	    index: function (e) {
	      return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
	    },
	    add: function (e, t) {
	      return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t))));
	    },
	    addBack: function (e) {
	      return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
	    }
	  }), S.each({
	    parent: function (e) {
	      var t = e.parentNode;
	      return t && 11 !== t.nodeType ? t : null;
	    },
	    parents: function (e) {
	      return h(e, "parentNode");
	    },
	    parentsUntil: function (e, t, n) {
	      return h(e, "parentNode", n);
	    },
	    next: function (e) {
	      return O(e, "nextSibling");
	    },
	    prev: function (e) {
	      return O(e, "previousSibling");
	    },
	    nextAll: function (e) {
	      return h(e, "nextSibling");
	    },
	    prevAll: function (e) {
	      return h(e, "previousSibling");
	    },
	    nextUntil: function (e, t, n) {
	      return h(e, "nextSibling", n);
	    },
	    prevUntil: function (e, t, n) {
	      return h(e, "previousSibling", n);
	    },
	    siblings: function (e) {
	      return T((e.parentNode || {}).firstChild, e);
	    },
	    children: function (e) {
	      return T(e.firstChild);
	    },
	    contents: function (e) {
	      return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes));
	    }
	  }, function (r, i) {
	    S.fn[r] = function (e, t) {
	      var n = S.map(this, i, e);
	      return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = S.filter(t, n)), 1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n);
	    };
	  });
	  var P = /[^\x20\t\r\n\f]+/g;

	  function R(e) {
	    return e;
	  }

	  function M(e) {
	    throw e;
	  }

	  function I(e, t, n, r) {
	    var i;

	    try {
	      e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r));
	    } catch (e) {
	      n.apply(void 0, [e]);
	    }
	  }

	  S.Callbacks = function (r) {
	    var e, n;
	    r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(P) || [], function (e, t) {
	      n[t] = !0;
	    }), n) : S.extend({}, r);

	    var i,
	        t,
	        o,
	        a,
	        s = [],
	        u = [],
	        l = -1,
	        c = function () {
	      for (a = a || r.once, o = i = !0; u.length; l = -1) {
	        t = u.shift();

	        while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1);
	      }

	      r.memory || (t = !1), i = !1, a && (s = t ? [] : "");
	    },
	        f = {
	      add: function () {
	        return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) {
	          S.each(e, function (e, t) {
	            m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t);
	          });
	        }(arguments), t && !i && c()), this;
	      },
	      remove: function () {
	        return S.each(arguments, function (e, t) {
	          var n;

	          while (-1 < (n = S.inArray(t, s, n))) s.splice(n, 1), n <= l && l--;
	        }), this;
	      },
	      has: function (e) {
	        return e ? -1 < S.inArray(e, s) : 0 < s.length;
	      },
	      empty: function () {
	        return s && (s = []), this;
	      },
	      disable: function () {
	        return a = u = [], s = t = "", this;
	      },
	      disabled: function () {
	        return !s;
	      },
	      lock: function () {
	        return a = u = [], t || i || (s = t = ""), this;
	      },
	      locked: function () {
	        return !!a;
	      },
	      fireWith: function (e, t) {
	        return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this;
	      },
	      fire: function () {
	        return f.fireWith(this, arguments), this;
	      },
	      fired: function () {
	        return !!o;
	      }
	    };

	    return f;
	  }, S.extend({
	    Deferred: function (e) {
	      var o = [["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2], ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]],
	          i = "pending",
	          a = {
	        state: function () {
	          return i;
	        },
	        always: function () {
	          return s.done(arguments).fail(arguments), this;
	        },
	        "catch": function (e) {
	          return a.then(null, e);
	        },
	        pipe: function () {
	          var i = arguments;
	          return S.Deferred(function (r) {
	            S.each(o, function (e, t) {
	              var n = m(i[t[4]]) && i[t[4]];
	              s[t[1]](function () {
	                var e = n && n.apply(this, arguments);
	                e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments);
	              });
	            }), i = null;
	          }).promise();
	        },
	        then: function (t, n, r) {
	          var u = 0;

	          function l(i, o, a, s) {
	            return function () {
	              var n = this,
	                  r = arguments,
	                  e = function () {
	                var e, t;

	                if (!(i < u)) {
	                  if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution");
	                  t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [e]), (s || o.resolveWith)(n, r));
	                }
	              },
	                  t = s ? e : function () {
	                try {
	                  e();
	                } catch (e) {
	                  S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== M && (n = void 0, r = [e]), o.rejectWith(n, r));
	                }
	              };

	              i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t));
	            };
	          }

	          return S.Deferred(function (e) {
	            o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : R)), o[2][3].add(l(0, e, m(n) ? n : M));
	          }).promise();
	        },
	        promise: function (e) {
	          return null != e ? S.extend(e, a) : a;
	        }
	      },
	          s = {};
	      return S.each(o, function (e, t) {
	        var n = t[2],
	            r = t[5];
	        a[t[1]] = n.add, r && n.add(function () {
	          i = r;
	        }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function () {
	          return s[t[0] + "With"](this === s ? void 0 : this, arguments), this;
	        }, s[t[0] + "With"] = n.fireWith;
	      }), a.promise(s), e && e.call(s, s), s;
	    },
	    when: function (e) {
	      var n = arguments.length,
	          t = n,
	          r = Array(t),
	          i = s.call(arguments),
	          o = S.Deferred(),
	          a = function (t) {
	        return function (e) {
	          r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i);
	        };
	      };

	      if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then();

	      while (t--) I(i[t], a(t), o.reject);

	      return o.promise();
	    }
	  });
	  var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	  S.Deferred.exceptionHook = function (e, t) {
	    C.console && C.console.warn && e && W.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t);
	  }, S.readyException = function (e) {
	    C.setTimeout(function () {
	      throw e;
	    });
	  };
	  var F = S.Deferred();

	  function B() {
	    E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), S.ready();
	  }

	  S.fn.ready = function (e) {
	    return F.then(e)["catch"](function (e) {
	      S.readyException(e);
	    }), this;
	  }, S.extend({
	    isReady: !1,
	    readyWait: 1,
	    ready: function (e) {
	      (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [S]);
	    }
	  }), S.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B));

	  var $ = function (e, t, n, r, i, o, a) {
	    var s = 0,
	        u = e.length,
	        l = null == n;
	    if ("object" === w(n)) for (s in i = !0, n) $(e, t, s, n[s], !0, o, a);else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) {
	      return l.call(S(e), n);
	    })), t)) for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
	    return i ? e : l ? t.call(e) : u ? t(e[0], n) : o;
	  },
	      _ = /^-ms-/,
	      z = /-([a-z])/g;

	  function U(e, t) {
	    return t.toUpperCase();
	  }

	  function X(e) {
	    return e.replace(_, "ms-").replace(z, U);
	  }

	  var V = function (e) {
	    return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
	  };

	  function G() {
	    this.expando = S.expando + G.uid++;
	  }

	  G.uid = 1, G.prototype = {
	    cache: function (e) {
	      var t = e[this.expando];
	      return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
	        value: t,
	        configurable: !0
	      }))), t;
	    },
	    set: function (e, t, n) {
	      var r,
	          i = this.cache(e);
	      if ("string" == typeof t) i[X(t)] = n;else for (r in t) i[X(r)] = t[r];
	      return i;
	    },
	    get: function (e, t) {
	      return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)];
	    },
	    access: function (e, t, n) {
	      return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t);
	    },
	    remove: function (e, t) {
	      var n,
	          r = e[this.expando];

	      if (void 0 !== r) {
	        if (void 0 !== t) {
	          n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [t] : t.match(P) || []).length;

	          while (n--) delete r[t[n]];
	        }

	        (void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]);
	      }
	    },
	    hasData: function (e) {
	      var t = e[this.expando];
	      return void 0 !== t && !S.isEmptyObject(t);
	    }
	  };
	  var Y = new G(),
	      Q = new G(),
	      J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	      K = /[A-Z]/g;

	  function Z(e, t, n) {
	    var r, i;
	    if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) {
	      try {
	        n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i);
	      } catch (e) {}

	      Q.set(e, t, n);
	    } else n = void 0;
	    return n;
	  }

	  S.extend({
	    hasData: function (e) {
	      return Q.hasData(e) || Y.hasData(e);
	    },
	    data: function (e, t, n) {
	      return Q.access(e, t, n);
	    },
	    removeData: function (e, t) {
	      Q.remove(e, t);
	    },
	    _data: function (e, t, n) {
	      return Y.access(e, t, n);
	    },
	    _removeData: function (e, t) {
	      Y.remove(e, t);
	    }
	  }), S.fn.extend({
	    data: function (n, e) {
	      var t,
	          r,
	          i,
	          o = this[0],
	          a = o && o.attributes;

	      if (void 0 === n) {
	        if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) {
	          t = a.length;

	          while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = X(r.slice(5)), Z(o, r, i[r]));

	          Y.set(o, "hasDataAttrs", !0);
	        }

	        return i;
	      }

	      return "object" == typeof n ? this.each(function () {
	        Q.set(this, n);
	      }) : $(this, function (e) {
	        var t;
	        if (o && void 0 === e) return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ? t : void 0;
	        this.each(function () {
	          Q.set(this, n, e);
	        });
	      }, null, e, 1 < arguments.length, null, !0);
	    },
	    removeData: function (e) {
	      return this.each(function () {
	        Q.remove(this, e);
	      });
	    }
	  }), S.extend({
	    queue: function (e, t, n) {
	      var r;
	      if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || [];
	    },
	    dequeue: function (e, t) {
	      t = t || "fx";

	      var n = S.queue(e, t),
	          r = n.length,
	          i = n.shift(),
	          o = S._queueHooks(e, t);

	      "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function () {
	        S.dequeue(e, t);
	      }, o)), !r && o && o.empty.fire();
	    },
	    _queueHooks: function (e, t) {
	      var n = t + "queueHooks";
	      return Y.get(e, n) || Y.access(e, n, {
	        empty: S.Callbacks("once memory").add(function () {
	          Y.remove(e, [t + "queue", n]);
	        })
	      });
	    }
	  }), S.fn.extend({
	    queue: function (t, n) {
	      var e = 2;
	      return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function () {
	        var e = S.queue(this, t, n);
	        S._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && S.dequeue(this, t);
	      });
	    },
	    dequeue: function (e) {
	      return this.each(function () {
	        S.dequeue(this, e);
	      });
	    },
	    clearQueue: function (e) {
	      return this.queue(e || "fx", []);
	    },
	    promise: function (e, t) {
	      var n,
	          r = 1,
	          i = S.Deferred(),
	          o = this,
	          a = this.length,
	          s = function () {
	        --r || i.resolveWith(o, [o]);
	      };

	      "string" != typeof e && (t = e, e = void 0), e = e || "fx";

	      while (a--) (n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));

	      return s(), i.promise(t);
	    }
	  });

	  var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
	      te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"),
	      ne = ["Top", "Right", "Bottom", "Left"],
	      re = E.documentElement,
	      ie = function (e) {
	    return S.contains(e.ownerDocument, e);
	  },
	      oe = {
	    composed: !0
	  };

	  re.getRootNode && (ie = function (e) {
	    return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument;
	  });

	  var ae = function (e, t) {
	    return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === S.css(e, "display");
	  };

	  function se(e, t, n, r) {
	    var i,
	        o,
	        a = 20,
	        s = r ? function () {
	      return r.cur();
	    } : function () {
	      return S.css(e, t, "");
	    },
	        u = s(),
	        l = n && n[3] || (S.cssNumber[t] ? "" : "px"),
	        c = e.nodeType && (S.cssNumber[t] || "px" !== l && +u) && te.exec(S.css(e, t));

	    if (c && c[3] !== l) {
	      u /= 2, l = l || c[3], c = +u || 1;

	      while (a--) S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;

	      c *= 2, S.style(e, t, c + l), n = n || [];
	    }

	    return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i;
	  }

	  var ue = {};

	  function le(e, t) {
	    for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++) (r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Y.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ue[s] = u)))) : "none" !== n && (l[c] = "none", Y.set(r, "display", n)));

	    for (c = 0; c < f; c++) null != l[c] && (e[c].style.display = l[c]);

	    return e;
	  }

	  S.fn.extend({
	    show: function () {
	      return le(this, !0);
	    },
	    hide: function () {
	      return le(this);
	    },
	    toggle: function (e) {
	      return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
	        ae(this) ? S(this).show() : S(this).hide();
	      });
	    }
	  });
	  var ce,
	      fe,
	      pe = /^(?:checkbox|radio)$/i,
	      de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
	      he = /^$|^module$|\/(?:java|ecma)script/i;
	  ce = E.createDocumentFragment().appendChild(E.createElement("div")), (fe = E.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = "<option></option>", y.option = !!ce.lastChild;
	  var ge = {
	    thead: [1, "<table>", "</table>"],
	    col: [2, "<table><colgroup>", "</colgroup></table>"],
	    tr: [2, "<table><tbody>", "</tbody></table>"],
	    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	    _default: [0, "", ""]
	  };

	  function ve(e, t) {
	    var n;
	    return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? S.merge([e], n) : n;
	  }

	  function ye(e, t) {
	    for (var n = 0, r = e.length; n < r; n++) Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval"));
	  }

	  ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]);
	  var me = /<|&#?\w+;/;

	  function xe(e, t, n, r, i) {
	    for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++) if ((o = e[d]) || 0 === o) if ("object" === w(o)) S.merge(p, o.nodeType ? [o] : o);else if (me.test(o)) {
	      a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2], c = u[0];

	      while (c--) a = a.lastChild;

	      S.merge(p, a.childNodes), (a = f.firstChild).textContent = "";
	    } else p.push(t.createTextNode(o));

	    f.textContent = "", d = 0;

	    while (o = p[d++]) if (r && -1 < S.inArray(o, r)) i && i.push(o);else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) {
	      c = 0;

	      while (o = a[c++]) he.test(o.type || "") && n.push(o);
	    }

	    return f;
	  }

	  var be = /^([^.]*)(?:\.(.+)|)/;

	  function we() {
	    return !0;
	  }

	  function Te() {
	    return !1;
	  }

	  function Ce(e, t) {
	    return e === function () {
	      try {
	        return E.activeElement;
	      } catch (e) {}
	    }() == ("focus" === t);
	  }

	  function Ee(e, t, n, r, i, o) {
	    var a, s;

	    if ("object" == typeof t) {
	      for (s in "string" != typeof n && (r = r || n, n = void 0), t) Ee(e, s, n, r, t[s], o);

	      return e;
	    }

	    if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Te;else if (!i) return e;
	    return 1 === o && (a = i, (i = function (e) {
	      return S().off(e), a.apply(this, arguments);
	    }).guid = a.guid || (a.guid = S.guid++)), e.each(function () {
	      S.event.add(this, t, i, r, n);
	    });
	  }

	  function Se(e, i, o) {
	    o ? (Y.set(e, i, !1), S.event.add(e, i, {
	      namespace: !1,
	      handler: function (e) {
	        var t,
	            n,
	            r = Y.get(this, i);

	        if (1 & e.isTrigger && this[i]) {
	          if (r.length) (S.event.special[i] || {}).delegateType && e.stopPropagation();else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n && n.value;
	        } else r.length && (Y.set(this, i, {
	          value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this)
	        }), e.stopImmediatePropagation());
	      }
	    })) : void 0 === Y.get(e, i) && S.event.add(e, i, we);
	  }

	  S.event = {
	    global: {},
	    add: function (t, e, n, r, i) {
	      var o,
	          a,
	          s,
	          u,
	          l,
	          c,
	          f,
	          p,
	          d,
	          h,
	          g,
	          v = Y.get(t);

	      if (V(t)) {
	        n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(re, i), n.guid || (n.guid = S.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function (e) {
	          return "undefined" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0;
	        }), l = (e = (e || "").match(P) || [""]).length;

	        while (l--) d = g = (s = be.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({
	          type: d,
	          origType: g,
	          data: r,
	          handler: n,
	          guid: n.guid,
	          selector: i,
	          needsContext: i && S.expr.match.needsContext.test(i),
	          namespace: h.join(".")
	        }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0);
	      }
	    },
	    remove: function (e, t, n, r, i) {
	      var o,
	          a,
	          s,
	          u,
	          l,
	          c,
	          f,
	          p,
	          d,
	          h,
	          g,
	          v = Y.hasData(e) && Y.get(e);

	      if (v && (u = v.events)) {
	        l = (t = (t || "").match(P) || [""]).length;

	        while (l--) if (d = g = (s = be.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) {
	          f = S.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length;

	          while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));

	          a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d]);
	        } else for (d in u) S.event.remove(e, d + t[l], n, r, !0);

	        S.isEmptyObject(u) && Y.remove(e, "handle events");
	      }
	    },
	    dispatch: function (e) {
	      var t,
	          n,
	          r,
	          i,
	          o,
	          a,
	          s = new Array(arguments.length),
	          u = S.event.fix(e),
	          l = (Y.get(this, "events") || Object.create(null))[u.type] || [],
	          c = S.event.special[u.type] || {};

	      for (s[0] = u, t = 1; t < arguments.length; t++) s[t] = arguments[t];

	      if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) {
	        a = S.event.handlers.call(this, u, l), t = 0;

	        while ((i = a[t++]) && !u.isPropagationStopped()) {
	          u.currentTarget = i.elem, n = 0;

	          while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped()) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation()));
	        }

	        return c.postDispatch && c.postDispatch.call(this, u), u.result;
	      }
	    },
	    handlers: function (e, t) {
	      var n,
	          r,
	          i,
	          o,
	          a,
	          s = [],
	          u = t.delegateCount,
	          l = e.target;
	      if (u && l.nodeType && !("click" === e.type && 1 <= e.button)) for (; l !== this; l = l.parentNode || this) if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
	        for (o = [], a = {}, n = 0; n < u; n++) void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r);

	        o.length && s.push({
	          elem: l,
	          handlers: o
	        });
	      }
	      return l = this, u < t.length && s.push({
	        elem: l,
	        handlers: t.slice(u)
	      }), s;
	    },
	    addProp: function (t, e) {
	      Object.defineProperty(S.Event.prototype, t, {
	        enumerable: !0,
	        configurable: !0,
	        get: m(e) ? function () {
	          if (this.originalEvent) return e(this.originalEvent);
	        } : function () {
	          if (this.originalEvent) return this.originalEvent[t];
	        },
	        set: function (e) {
	          Object.defineProperty(this, t, {
	            enumerable: !0,
	            configurable: !0,
	            writable: !0,
	            value: e
	          });
	        }
	      });
	    },
	    fix: function (e) {
	      return e[S.expando] ? e : new S.Event(e);
	    },
	    special: {
	      load: {
	        noBubble: !0
	      },
	      click: {
	        setup: function (e) {
	          var t = this || e;
	          return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click", we), !1;
	        },
	        trigger: function (e) {
	          var t = this || e;
	          return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click"), !0;
	        },
	        _default: function (e) {
	          var t = e.target;
	          return pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click") || A(t, "a");
	        }
	      },
	      beforeunload: {
	        postDispatch: function (e) {
	          void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result);
	        }
	      }
	    }
	  }, S.removeEvent = function (e, t, n) {
	    e.removeEventListener && e.removeEventListener(t, n);
	  }, S.Event = function (e, t) {
	    if (!(this instanceof S.Event)) return new S.Event(e, t);
	    e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Te, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0;
	  }, S.Event.prototype = {
	    constructor: S.Event,
	    isDefaultPrevented: Te,
	    isPropagationStopped: Te,
	    isImmediatePropagationStopped: Te,
	    isSimulated: !1,
	    preventDefault: function () {
	      var e = this.originalEvent;
	      this.isDefaultPrevented = we, e && !this.isSimulated && e.preventDefault();
	    },
	    stopPropagation: function () {
	      var e = this.originalEvent;
	      this.isPropagationStopped = we, e && !this.isSimulated && e.stopPropagation();
	    },
	    stopImmediatePropagation: function () {
	      var e = this.originalEvent;
	      this.isImmediatePropagationStopped = we, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation();
	    }
	  }, S.each({
	    altKey: !0,
	    bubbles: !0,
	    cancelable: !0,
	    changedTouches: !0,
	    ctrlKey: !0,
	    detail: !0,
	    eventPhase: !0,
	    metaKey: !0,
	    pageX: !0,
	    pageY: !0,
	    shiftKey: !0,
	    view: !0,
	    "char": !0,
	    code: !0,
	    charCode: !0,
	    key: !0,
	    keyCode: !0,
	    button: !0,
	    buttons: !0,
	    clientX: !0,
	    clientY: !0,
	    offsetX: !0,
	    offsetY: !0,
	    pointerId: !0,
	    pointerType: !0,
	    screenX: !0,
	    screenY: !0,
	    targetTouches: !0,
	    toElement: !0,
	    touches: !0,
	    which: !0
	  }, S.event.addProp), S.each({
	    focus: "focusin",
	    blur: "focusout"
	  }, function (e, t) {
	    S.event.special[e] = {
	      setup: function () {
	        return Se(this, e, Ce), !1;
	      },
	      trigger: function () {
	        return Se(this, e), !0;
	      },
	      _default: function () {
	        return !0;
	      },
	      delegateType: t
	    };
	  }), S.each({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout",
	    pointerenter: "pointerover",
	    pointerleave: "pointerout"
	  }, function (e, i) {
	    S.event.special[e] = {
	      delegateType: i,
	      bindType: i,
	      handle: function (e) {
	        var t,
	            n = e.relatedTarget,
	            r = e.handleObj;
	        return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t;
	      }
	    };
	  }), S.fn.extend({
	    on: function (e, t, n, r) {
	      return Ee(this, e, t, n, r);
	    },
	    one: function (e, t, n, r) {
	      return Ee(this, e, t, n, r, 1);
	    },
	    off: function (e, t, n) {
	      var r, i;
	      if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;

	      if ("object" == typeof e) {
	        for (i in e) this.off(i, t, e[i]);

	        return this;
	      }

	      return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Te), this.each(function () {
	        S.event.remove(this, e, n, t);
	      });
	    }
	  });
	  var ke = /<script|<style|<link/i,
	      Ae = /checked\s*(?:[^=]|=\s*.checked.)/i,
	      Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	  function je(e, t) {
	    return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e;
	  }

	  function De(e) {
	    return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e;
	  }

	  function qe(e) {
	    return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e;
	  }

	  function Le(e, t) {
	    var n, r, i, o, a, s;

	    if (1 === t.nodeType) {
	      if (Y.hasData(e) && (s = Y.get(e).events)) for (i in Y.remove(t, "handle events"), s) for (n = 0, r = s[i].length; n < r; n++) S.event.add(t, i, s[i][n]);
	      Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a));
	    }
	  }

	  function He(n, r, i, o) {
	    r = g(r);
	    var e,
	        t,
	        a,
	        s,
	        u,
	        l,
	        c = 0,
	        f = n.length,
	        p = f - 1,
	        d = r[0],
	        h = m(d);
	    if (h || 1 < f && "string" == typeof d && !y.checkClone && Ae.test(d)) return n.each(function (e) {
	      var t = n.eq(e);
	      h && (r[0] = d.call(this, e, t.html())), He(t, r, i, o);
	    });

	    if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
	      for (s = (a = S.map(ve(e, "script"), De)).length; c < f; c++) u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, "script"))), i.call(n[c], u, c);

	      if (s) for (l = a[a.length - 1].ownerDocument, S.map(a, qe), c = 0; c < s; c++) u = a[c], he.test(u.type || "") && !Y.access(u, "globalEval") && S.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? S._evalUrl && !u.noModule && S._evalUrl(u.src, {
	        nonce: u.nonce || u.getAttribute("nonce")
	      }, l) : b(u.textContent.replace(Ne, ""), u, l));
	    }

	    return n;
	  }

	  function Oe(e, t, n) {
	    for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r));

	    return e;
	  }

	  S.extend({
	    htmlPrefilter: function (e) {
	      return e;
	    },
	    clone: function (e, t, n) {
	      var r,
	          i,
	          o,
	          a,
	          s,
	          u,
	          l,
	          c = e.cloneNode(!0),
	          f = ie(e);
	      if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e))) for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++) s = o[r], u = a[r], "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue);
	      if (t) if (n) for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++) Le(o[r], a[r]);else Le(e, c);
	      return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c;
	    },
	    cleanData: function (e) {
	      for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++) if (V(n)) {
	        if (t = n[Y.expando]) {
	          if (t.events) for (r in t.events) i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle);
	          n[Y.expando] = void 0;
	        }

	        n[Q.expando] && (n[Q.expando] = void 0);
	      }
	    }
	  }), S.fn.extend({
	    detach: function (e) {
	      return Oe(this, e, !0);
	    },
	    remove: function (e) {
	      return Oe(this, e);
	    },
	    text: function (e) {
	      return $(this, function (e) {
	        return void 0 === e ? S.text(this) : this.empty().each(function () {
	          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e);
	        });
	      }, null, e, arguments.length);
	    },
	    append: function () {
	      return He(this, arguments, function (e) {
	        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e).appendChild(e);
	      });
	    },
	    prepend: function () {
	      return He(this, arguments, function (e) {
	        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
	          var t = je(this, e);
	          t.insertBefore(e, t.firstChild);
	        }
	      });
	    },
	    before: function () {
	      return He(this, arguments, function (e) {
	        this.parentNode && this.parentNode.insertBefore(e, this);
	      });
	    },
	    after: function () {
	      return He(this, arguments, function (e) {
	        this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
	      });
	    },
	    empty: function () {
	      for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = "");

	      return this;
	    },
	    clone: function (e, t) {
	      return e = null != e && e, t = null == t ? e : t, this.map(function () {
	        return S.clone(this, e, t);
	      });
	    },
	    html: function (e) {
	      return $(this, function (e) {
	        var t = this[0] || {},
	            n = 0,
	            r = this.length;
	        if (void 0 === e && 1 === t.nodeType) return t.innerHTML;

	        if ("string" == typeof e && !ke.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) {
	          e = S.htmlPrefilter(e);

	          try {
	            for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e);

	            t = 0;
	          } catch (e) {}
	        }

	        t && this.empty().append(e);
	      }, null, e, arguments.length);
	    },
	    replaceWith: function () {
	      var n = [];
	      return He(this, arguments, function (e) {
	        var t = this.parentNode;
	        S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this));
	      }, n);
	    }
	  }), S.each({
	    appendTo: "append",
	    prependTo: "prepend",
	    insertBefore: "before",
	    insertAfter: "after",
	    replaceAll: "replaceWith"
	  }, function (e, a) {
	    S.fn[e] = function (e) {
	      for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++) t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get());

	      return this.pushStack(n);
	    };
	  });

	  var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"),
	      Re = function (e) {
	    var t = e.ownerDocument.defaultView;
	    return t && t.opener || (t = C), t.getComputedStyle(e);
	  },
	      Me = function (e, t, n) {
	    var r,
	        i,
	        o = {};

	    for (i in t) o[i] = e.style[i], e.style[i] = t[i];

	    for (i in r = n.call(e), t) e.style[i] = o[i];

	    return r;
	  },
	      Ie = new RegExp(ne.join("|"), "i");

	  function We(e, t, n) {
	    var r,
	        i,
	        o,
	        a,
	        s = e.style;
	    return (n = n || Re(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Pe.test(a) && Ie.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a;
	  }

	  function Fe(e, t) {
	    return {
	      get: function () {
	        if (!e()) return (this.get = t).apply(this, arguments);
	        delete this.get;
	      }
	    };
	  }

	  !function () {
	    function e() {
	      if (l) {
	        u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(u).appendChild(l);
	        var e = C.getComputedStyle(l);
	        n = "1%" !== e.top, s = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", i = 12 === t(l.offsetWidth / 3), re.removeChild(u), l = null;
	      }
	    }

	    function t(e) {
	      return Math.round(parseFloat(e));
	    }

	    var n,
	        r,
	        i,
	        o,
	        a,
	        s,
	        u = E.createElement("div"),
	        l = E.createElement("div");
	    l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend(y, {
	      boxSizingReliable: function () {
	        return e(), r;
	      },
	      pixelBoxStyles: function () {
	        return e(), o;
	      },
	      pixelPosition: function () {
	        return e(), n;
	      },
	      reliableMarginLeft: function () {
	        return e(), s;
	      },
	      scrollboxSize: function () {
	        return e(), i;
	      },
	      reliableTrDimensions: function () {
	        var e, t, n, r;
	        return null == a && (e = E.createElement("table"), t = E.createElement("tr"), n = E.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, re.removeChild(e)), a;
	      }
	    }));
	  }();
	  var Be = ["Webkit", "Moz", "ms"],
	      $e = E.createElement("div").style,
	      _e = {};

	  function ze(e) {
	    var t = S.cssProps[e] || _e[e];
	    return t || (e in $e ? e : _e[e] = function (e) {
	      var t = e[0].toUpperCase() + e.slice(1),
	          n = Be.length;

	      while (n--) if ((e = Be[n] + t) in $e) return e;
	    }(e) || e);
	  }

	  var Ue = /^(none|table(?!-c[ea]).+)/,
	      Xe = /^--/,
	      Ve = {
	    position: "absolute",
	    visibility: "hidden",
	    display: "block"
	  },
	      Ge = {
	    letterSpacing: "0",
	    fontWeight: "400"
	  };

	  function Ye(e, t, n) {
	    var r = te.exec(t);
	    return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t;
	  }

	  function Qe(e, t, n, r, i, o) {
	    var a = "width" === t ? 1 : 0,
	        s = 0,
	        u = 0;
	    if (n === (r ? "border" : "content")) return 0;

	    for (; a < 4; a += 2) "margin" === n && (u += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (u += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i));

	    return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u;
	  }

	  function Je(e, t, n) {
	    var r = Re(e),
	        i = (!y.boxSizingReliable() || n) && "border-box" === S.css(e, "boxSizing", !1, r),
	        o = i,
	        a = We(e, t, r),
	        s = "offset" + t[0].toUpperCase() + t.slice(1);

	    if (Pe.test(a)) {
	      if (!n) return a;
	      a = "auto";
	    }

	    return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === S.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Qe(e, t, n || (i ? "border" : "content"), o, r, a) + "px";
	  }

	  function Ke(e, t, n, r, i) {
	    return new Ke.prototype.init(e, t, n, r, i);
	  }

	  S.extend({
	    cssHooks: {
	      opacity: {
	        get: function (e, t) {
	          if (t) {
	            var n = We(e, "opacity");
	            return "" === n ? "1" : n;
	          }
	        }
	      }
	    },
	    cssNumber: {
	      animationIterationCount: !0,
	      columnCount: !0,
	      fillOpacity: !0,
	      flexGrow: !0,
	      flexShrink: !0,
	      fontWeight: !0,
	      gridArea: !0,
	      gridColumn: !0,
	      gridColumnEnd: !0,
	      gridColumnStart: !0,
	      gridRow: !0,
	      gridRowEnd: !0,
	      gridRowStart: !0,
	      lineHeight: !0,
	      opacity: !0,
	      order: !0,
	      orphans: !0,
	      widows: !0,
	      zIndex: !0,
	      zoom: !0
	    },
	    cssProps: {},
	    style: function (e, t, n, r) {
	      if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
	        var i,
	            o,
	            a,
	            s = X(t),
	            u = Xe.test(t),
	            l = e.style;
	        if (u || (t = ze(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
	        "string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n));
	      }
	    },
	    css: function (e, t, n, r) {
	      var i,
	          o,
	          a,
	          s = X(t);
	      return Xe.test(t) || (t = ze(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = We(e, t, r)), "normal" === i && t in Ge && (i = Ge[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i;
	    }
	  }), S.each(["height", "width"], function (e, u) {
	    S.cssHooks[u] = {
	      get: function (e, t, n) {
	        if (t) return !Ue.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Je(e, u, n) : Me(e, Ve, function () {
	          return Je(e, u, n);
	        });
	      },
	      set: function (e, t, n) {
	        var r,
	            i = Re(e),
	            o = !y.scrollboxSize() && "absolute" === i.position,
	            a = (o || n) && "border-box" === S.css(e, "boxSizing", !1, i),
	            s = n ? Qe(e, u, n, a, i) : 0;
	        return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Qe(e, u, "border", !1, i) - .5)), s && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = S.css(e, u)), Ye(0, t, s);
	      }
	    };
	  }), S.cssHooks.marginLeft = Fe(y.reliableMarginLeft, function (e, t) {
	    if (t) return (parseFloat(We(e, "marginLeft")) || e.getBoundingClientRect().left - Me(e, {
	      marginLeft: 0
	    }, function () {
	      return e.getBoundingClientRect().left;
	    })) + "px";
	  }), S.each({
	    margin: "",
	    padding: "",
	    border: "Width"
	  }, function (i, o) {
	    S.cssHooks[i + o] = {
	      expand: function (e) {
	        for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++) n[i + ne[t] + o] = r[t] || r[t - 2] || r[0];

	        return n;
	      }
	    }, "margin" !== i && (S.cssHooks[i + o].set = Ye);
	  }), S.fn.extend({
	    css: function (e, t) {
	      return $(this, function (e, t, n) {
	        var r,
	            i,
	            o = {},
	            a = 0;

	        if (Array.isArray(t)) {
	          for (r = Re(e), i = t.length; a < i; a++) o[t[a]] = S.css(e, t[a], !1, r);

	          return o;
	        }

	        return void 0 !== n ? S.style(e, t, n) : S.css(e, t);
	      }, e, t, 1 < arguments.length);
	    }
	  }), ((S.Tween = Ke).prototype = {
	    constructor: Ke,
	    init: function (e, t, n, r, i, o) {
	      this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? "" : "px");
	    },
	    cur: function () {
	      var e = Ke.propHooks[this.prop];
	      return e && e.get ? e.get(this) : Ke.propHooks._default.get(this);
	    },
	    run: function (e) {
	      var t,
	          n = Ke.propHooks[this.prop];
	      return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Ke.propHooks._default.set(this), this;
	    }
	  }).init.prototype = Ke.prototype, (Ke.propHooks = {
	    _default: {
	      get: function (e) {
	        var t;
	        return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0;
	      },
	      set: function (e) {
	        S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[ze(e.prop)] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit);
	      }
	    }
	  }).scrollTop = Ke.propHooks.scrollLeft = {
	    set: function (e) {
	      e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
	    }
	  }, S.easing = {
	    linear: function (e) {
	      return e;
	    },
	    swing: function (e) {
	      return .5 - Math.cos(e * Math.PI) / 2;
	    },
	    _default: "swing"
	  }, S.fx = Ke.prototype.init, S.fx.step = {};
	  var Ze,
	      et,
	      tt,
	      nt,
	      rt = /^(?:toggle|show|hide)$/,
	      it = /queueHooks$/;

	  function ot() {
	    et && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(ot) : C.setTimeout(ot, S.fx.interval), S.fx.tick());
	  }

	  function at() {
	    return C.setTimeout(function () {
	      Ze = void 0;
	    }), Ze = Date.now();
	  }

	  function st(e, t) {
	    var n,
	        r = 0,
	        i = {
	      height: e
	    };

	    for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = ne[r])] = i["padding" + n] = e;

	    return t && (i.opacity = i.width = e), i;
	  }

	  function ut(e, t, n) {
	    for (var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), o = 0, a = i.length; o < a; o++) if (r = i[o].call(n, t, e)) return r;
	  }

	  function lt(o, e, t) {
	    var n,
	        a,
	        r = 0,
	        i = lt.prefilters.length,
	        s = S.Deferred().always(function () {
	      delete u.elem;
	    }),
	        u = function () {
	      if (a) return !1;

	      for (var e = Ze || at(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++) l.tweens[r].run(n);

	      return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1);
	    },
	        l = s.promise({
	      elem: o,
	      props: S.extend({}, e),
	      opts: S.extend(!0, {
	        specialEasing: {},
	        easing: S.easing._default
	      }, t),
	      originalProperties: e,
	      originalOptions: t,
	      startTime: Ze || at(),
	      duration: t.duration,
	      tweens: [],
	      createTween: function (e, t) {
	        var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing);
	        return l.tweens.push(n), n;
	      },
	      stop: function (e) {
	        var t = 0,
	            n = e ? l.tweens.length : 0;
	        if (a) return this;

	        for (a = !0; t < n; t++) l.tweens[t].run(1);

	        return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this;
	      }
	    }),
	        c = l.props;

	    for (!function (e, t) {
	      var n, r, i, o, a;

	      for (n in e) if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && ("expand" in a)) for (n in o = a.expand(o), delete e[r], o) (n in e) || (e[n] = o[n], t[n] = i);else t[r] = i;
	    }(c, l.opts.specialEasing); r < i; r++) if (n = lt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n;

	    return S.map(c, ut, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(u, {
	      elem: o,
	      anim: l,
	      queue: l.opts.queue
	    })), l;
	  }

	  S.Animation = S.extend(lt, {
	    tweeners: {
	      "*": [function (e, t) {
	        var n = this.createTween(e, t);
	        return se(n.elem, e, te.exec(t), n), n;
	      }]
	    },
	    tweener: function (e, t) {
	      m(e) ? (t = e, e = ["*"]) : e = e.match(P);

	      for (var n, r = 0, i = e.length; r < i; r++) n = e[r], lt.tweeners[n] = lt.tweeners[n] || [], lt.tweeners[n].unshift(t);
	    },
	    prefilters: [function (e, t, n) {
	      var r,
	          i,
	          o,
	          a,
	          s,
	          u,
	          l,
	          c,
	          f = "width" in t || "height" in t,
	          p = this,
	          d = {},
	          h = e.style,
	          g = e.nodeType && ae(e),
	          v = Y.get(e, "fxshow");

	      for (r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
	        a.unqueued || s();
	      }), a.unqueued++, p.always(function () {
	        p.always(function () {
	          a.unqueued--, S.queue(e, "fx").length || a.empty.fire();
	        });
	      })), t) if (i = t[r], rt.test(i)) {
	        if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
	          if ("show" !== i || !v || void 0 === v[r]) continue;
	          g = !0;
	        }

	        d[r] = v && v[r] || S.style(e, r);
	      }

	      if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y.get(e, "display")), "none" === (c = S.css(e, "display")) && (l ? c = l : (le([e], !0), l = e.style.display || l, c = S.css(e, "display"), le([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === S.css(e, "float") && (u || (p.done(function () {
	        h.display = l;
	      }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () {
	        h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2];
	      })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = Y.access(e, "fxshow", {
	        display: l
	      }), o && (v.hidden = !g), g && le([e], !0), p.done(function () {
	        for (r in g || le([e]), Y.remove(e, "fxshow"), d) S.style(e, r, d[r]);
	      })), u = ut(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0));
	    }],
	    prefilter: function (e, t) {
	      t ? lt.prefilters.unshift(e) : lt.prefilters.push(e);
	    }
	  }), S.speed = function (e, t, n) {
	    var r = e && "object" == typeof e ? S.extend({}, e) : {
	      complete: n || !n && t || m(e) && e,
	      duration: e,
	      easing: n && t || t && !m(t) && t
	    };
	    return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () {
	      m(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue);
	    }, r;
	  }, S.fn.extend({
	    fadeTo: function (e, t, n, r) {
	      return this.filter(ae).css("opacity", 0).show().end().animate({
	        opacity: t
	      }, e, n, r);
	    },
	    animate: function (t, e, n, r) {
	      var i = S.isEmptyObject(t),
	          o = S.speed(e, n, r),
	          a = function () {
	        var e = lt(this, S.extend({}, t), o);
	        (i || Y.get(this, "finish")) && e.stop(!0);
	      };

	      return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a);
	    },
	    stop: function (i, e, o) {
	      var a = function (e) {
	        var t = e.stop;
	        delete e.stop, t(o);
	      };

	      return "string" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || "fx", []), this.each(function () {
	        var e = !0,
	            t = null != i && i + "queueHooks",
	            n = S.timers,
	            r = Y.get(this);
	        if (t) r[t] && r[t].stop && a(r[t]);else for (t in r) r[t] && r[t].stop && it.test(t) && a(r[t]);

	        for (t = n.length; t--;) n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1));

	        !e && o || S.dequeue(this, i);
	      });
	    },
	    finish: function (a) {
	      return !1 !== a && (a = a || "fx"), this.each(function () {
	        var e,
	            t = Y.get(this),
	            n = t[a + "queue"],
	            r = t[a + "queueHooks"],
	            i = S.timers,
	            o = n ? n.length : 0;

	        for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;) i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1));

	        for (e = 0; e < o; e++) n[e] && n[e].finish && n[e].finish.call(this);

	        delete t.finish;
	      });
	    }
	  }), S.each(["toggle", "show", "hide"], function (e, r) {
	    var i = S.fn[r];

	    S.fn[r] = function (e, t, n) {
	      return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(st(r, !0), e, t, n);
	    };
	  }), S.each({
	    slideDown: st("show"),
	    slideUp: st("hide"),
	    slideToggle: st("toggle"),
	    fadeIn: {
	      opacity: "show"
	    },
	    fadeOut: {
	      opacity: "hide"
	    },
	    fadeToggle: {
	      opacity: "toggle"
	    }
	  }, function (e, r) {
	    S.fn[e] = function (e, t, n) {
	      return this.animate(r, e, t, n);
	    };
	  }), S.timers = [], S.fx.tick = function () {
	    var e,
	        t = 0,
	        n = S.timers;

	    for (Ze = Date.now(); t < n.length; t++) (e = n[t])() || n[t] !== e || n.splice(t--, 1);

	    n.length || S.fx.stop(), Ze = void 0;
	  }, S.fx.timer = function (e) {
	    S.timers.push(e), S.fx.start();
	  }, S.fx.interval = 13, S.fx.start = function () {
	    et || (et = !0, ot());
	  }, S.fx.stop = function () {
	    et = null;
	  }, S.fx.speeds = {
	    slow: 600,
	    fast: 200,
	    _default: 400
	  }, S.fn.delay = function (r, e) {
	    return r = S.fx && S.fx.speeds[r] || r, e = e || "fx", this.queue(e, function (e, t) {
	      var n = C.setTimeout(e, r);

	      t.stop = function () {
	        C.clearTimeout(n);
	      };
	    });
	  }, tt = E.createElement("input"), nt = E.createElement("select").appendChild(E.createElement("option")), tt.type = "checkbox", y.checkOn = "" !== tt.value, y.optSelected = nt.selected, (tt = E.createElement("input")).value = "t", tt.type = "radio", y.radioValue = "t" === tt.value;
	  var ct,
	      ft = S.expr.attrHandle;
	  S.fn.extend({
	    attr: function (e, t) {
	      return $(this, S.attr, e, t, 1 < arguments.length);
	    },
	    removeAttr: function (e) {
	      return this.each(function () {
	        S.removeAttr(this, e);
	      });
	    }
	  }), S.extend({
	    attr: function (e, t, n) {
	      var r,
	          i,
	          o = e.nodeType;
	      if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? ct : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r);
	    },
	    attrHooks: {
	      type: {
	        set: function (e, t) {
	          if (!y.radioValue && "radio" === t && A(e, "input")) {
	            var n = e.value;
	            return e.setAttribute("type", t), n && (e.value = n), t;
	          }
	        }
	      }
	    },
	    removeAttr: function (e, t) {
	      var n,
	          r = 0,
	          i = t && t.match(P);
	      if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n);
	    }
	  }), ct = {
	    set: function (e, t, n) {
	      return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n;
	    }
	  }, S.each(S.expr.match.bool.source.match(/\w+/g), function (e, t) {
	    var a = ft[t] || S.find.attr;

	    ft[t] = function (e, t, n) {
	      var r,
	          i,
	          o = t.toLowerCase();
	      return n || (i = ft[o], ft[o] = r, r = null != a(e, t, n) ? o : null, ft[o] = i), r;
	    };
	  });
	  var pt = /^(?:input|select|textarea|button)$/i,
	      dt = /^(?:a|area)$/i;

	  function ht(e) {
	    return (e.match(P) || []).join(" ");
	  }

	  function gt(e) {
	    return e.getAttribute && e.getAttribute("class") || "";
	  }

	  function vt(e) {
	    return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || [];
	  }

	  S.fn.extend({
	    prop: function (e, t) {
	      return $(this, S.prop, e, t, 1 < arguments.length);
	    },
	    removeProp: function (e) {
	      return this.each(function () {
	        delete this[S.propFix[e] || e];
	      });
	    }
	  }), S.extend({
	    prop: function (e, t, n) {
	      var r,
	          i,
	          o = e.nodeType;
	      if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t];
	    },
	    propHooks: {
	      tabIndex: {
	        get: function (e) {
	          var t = S.find.attr(e, "tabindex");
	          return t ? parseInt(t, 10) : pt.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1;
	        }
	      }
	    },
	    propFix: {
	      "for": "htmlFor",
	      "class": "className"
	    }
	  }), y.optSelected || (S.propHooks.selected = {
	    get: function (e) {
	      var t = e.parentNode;
	      return t && t.parentNode && t.parentNode.selectedIndex, null;
	    },
	    set: function (e) {
	      var t = e.parentNode;
	      t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);
	    }
	  }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
	    S.propFix[this.toLowerCase()] = this;
	  }), S.fn.extend({
	    addClass: function (t) {
	      var e,
	          n,
	          r,
	          i,
	          o,
	          a,
	          s,
	          u = 0;
	      if (m(t)) return this.each(function (e) {
	        S(this).addClass(t.call(this, e, gt(this)));
	      });
	      if ((e = vt(t)).length) while (n = this[u++]) if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
	        a = 0;

	        while (o = e[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " ");

	        i !== (s = ht(r)) && n.setAttribute("class", s);
	      }
	      return this;
	    },
	    removeClass: function (t) {
	      var e,
	          n,
	          r,
	          i,
	          o,
	          a,
	          s,
	          u = 0;
	      if (m(t)) return this.each(function (e) {
	        S(this).removeClass(t.call(this, e, gt(this)));
	      });
	      if (!arguments.length) return this.attr("class", "");
	      if ((e = vt(t)).length) while (n = this[u++]) if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
	        a = 0;

	        while (o = e[a++]) while (-1 < r.indexOf(" " + o + " ")) r = r.replace(" " + o + " ", " ");

	        i !== (s = ht(r)) && n.setAttribute("class", s);
	      }
	      return this;
	    },
	    toggleClass: function (i, t) {
	      var o = typeof i,
	          a = "string" === o || Array.isArray(i);
	      return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function (e) {
	        S(this).toggleClass(i.call(this, e, gt(this), t), t);
	      }) : this.each(function () {
	        var e, t, n, r;

	        if (a) {
	          t = 0, n = S(this), r = vt(i);

	          while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e);
	        } else void 0 !== i && "boolean" !== o || ((e = gt(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Y.get(this, "__className__") || ""));
	      });
	    },
	    hasClass: function (e) {
	      var t,
	          n,
	          r = 0;
	      t = " " + e + " ";

	      while (n = this[r++]) if (1 === n.nodeType && -1 < (" " + ht(gt(n)) + " ").indexOf(t)) return !0;

	      return !1;
	    }
	  });
	  var yt = /\r/g;
	  S.fn.extend({
	    val: function (n) {
	      var r,
	          e,
	          i,
	          t = this[0];
	      return arguments.length ? (i = m(n), this.each(function (e) {
	        var t;
	        1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function (e) {
	          return null == e ? "" : e + "";
	        })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t));
	      })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(yt, "") : null == e ? "" : e : void 0;
	    }
	  }), S.extend({
	    valHooks: {
	      option: {
	        get: function (e) {
	          var t = S.find.attr(e, "value");
	          return null != t ? t : ht(S.text(e));
	        }
	      },
	      select: {
	        get: function (e) {
	          var t,
	              n,
	              r,
	              i = e.options,
	              o = e.selectedIndex,
	              a = "select-one" === e.type,
	              s = a ? null : [],
	              u = a ? o + 1 : i.length;

	          for (r = o < 0 ? u : a ? o : 0; r < u; r++) if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) {
	            if (t = S(n).val(), a) return t;
	            s.push(t);
	          }

	          return s;
	        },
	        set: function (e, t) {
	          var n,
	              r,
	              i = e.options,
	              o = S.makeArray(t),
	              a = i.length;

	          while (a--) ((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0);

	          return n || (e.selectedIndex = -1), o;
	        }
	      }
	    }
	  }), S.each(["radio", "checkbox"], function () {
	    S.valHooks[this] = {
	      set: function (e, t) {
	        if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t);
	      }
	    }, y.checkOn || (S.valHooks[this].get = function (e) {
	      return null === e.getAttribute("value") ? "on" : e.value;
	    });
	  }), y.focusin = "onfocusin" in C;

	  var mt = /^(?:focusinfocus|focusoutblur)$/,
	      xt = function (e) {
	    e.stopPropagation();
	  };

	  S.extend(S.event, {
	    trigger: function (e, t, n, r) {
	      var i,
	          o,
	          a,
	          s,
	          u,
	          l,
	          c,
	          f,
	          p = [n || E],
	          d = v.call(e, "type") ? e.type : e,
	          h = v.call(e, "namespace") ? e.namespace.split(".") : [];

	      if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !mt.test(d + S.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[S.expando] ? e : new S.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : S.makeArray(t, [e]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) {
	        if (!r && !c.noBubble && !x(n)) {
	          for (s = c.delegateType || d, mt.test(s + d) || (o = o.parentNode); o; o = o.parentNode) p.push(o), a = o;

	          a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C);
	        }

	        i = 0;

	        while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Y.get(o, "events") || Object.create(null))[e.type] && Y.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());

	        return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, xt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, xt), S.event.triggered = void 0, a && (n[u] = a)), e.result;
	      }
	    },
	    simulate: function (e, t, n) {
	      var r = S.extend(new S.Event(), n, {
	        type: e,
	        isSimulated: !0
	      });
	      S.event.trigger(r, null, t);
	    }
	  }), S.fn.extend({
	    trigger: function (e, t) {
	      return this.each(function () {
	        S.event.trigger(e, t, this);
	      });
	    },
	    triggerHandler: function (e, t) {
	      var n = this[0];
	      if (n) return S.event.trigger(e, t, n, !0);
	    }
	  }), y.focusin || S.each({
	    focus: "focusin",
	    blur: "focusout"
	  }, function (n, r) {
	    var i = function (e) {
	      S.event.simulate(r, e.target, S.event.fix(e));
	    };

	    S.event.special[r] = {
	      setup: function () {
	        var e = this.ownerDocument || this.document || this,
	            t = Y.access(e, r);
	        t || e.addEventListener(n, i, !0), Y.access(e, r, (t || 0) + 1);
	      },
	      teardown: function () {
	        var e = this.ownerDocument || this.document || this,
	            t = Y.access(e, r) - 1;
	        t ? Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r));
	      }
	    };
	  });
	  var bt = C.location,
	      wt = {
	    guid: Date.now()
	  },
	      Tt = /\?/;

	  S.parseXML = function (e) {
	    var t, n;
	    if (!e || "string" != typeof e) return null;

	    try {
	      t = new C.DOMParser().parseFromString(e, "text/xml");
	    } catch (e) {}

	    return n = t && t.getElementsByTagName("parsererror")[0], t && !n || S.error("Invalid XML: " + (n ? S.map(n.childNodes, function (e) {
	      return e.textContent;
	    }).join("\n") : e)), t;
	  };

	  var Ct = /\[\]$/,
	      Et = /\r?\n/g,
	      St = /^(?:submit|button|image|reset|file)$/i,
	      kt = /^(?:input|select|textarea|keygen)/i;

	  function At(n, e, r, i) {
	    var t;
	    if (Array.isArray(e)) S.each(e, function (e, t) {
	      r || Ct.test(n) ? i(n, t) : At(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i);
	    });else if (r || "object" !== w(e)) i(n, e);else for (t in e) At(n + "[" + t + "]", e[t], r, i);
	  }

	  S.param = function (e, t) {
	    var n,
	        r = [],
	        i = function (e, t) {
	      var n = m(t) ? t() : t;
	      r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);
	    };

	    if (null == e) return "";
	    if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function () {
	      i(this.name, this.value);
	    });else for (n in e) At(n, e[n], t, i);
	    return r.join("&");
	  }, S.fn.extend({
	    serialize: function () {
	      return S.param(this.serializeArray());
	    },
	    serializeArray: function () {
	      return this.map(function () {
	        var e = S.prop(this, "elements");
	        return e ? S.makeArray(e) : this;
	      }).filter(function () {
	        var e = this.type;
	        return this.name && !S(this).is(":disabled") && kt.test(this.nodeName) && !St.test(e) && (this.checked || !pe.test(e));
	      }).map(function (e, t) {
	        var n = S(this).val();
	        return null == n ? null : Array.isArray(n) ? S.map(n, function (e) {
	          return {
	            name: t.name,
	            value: e.replace(Et, "\r\n")
	          };
	        }) : {
	          name: t.name,
	          value: n.replace(Et, "\r\n")
	        };
	      }).get();
	    }
	  });
	  var Nt = /%20/g,
	      jt = /#.*$/,
	      Dt = /([?&])_=[^&]*/,
	      qt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
	      Lt = /^(?:GET|HEAD)$/,
	      Ht = /^\/\//,
	      Ot = {},
	      Pt = {},
	      Rt = "*/".concat("*"),
	      Mt = E.createElement("a");

	  function It(o) {
	    return function (e, t) {
	      "string" != typeof e && (t = e, e = "*");
	      var n,
	          r = 0,
	          i = e.toLowerCase().match(P) || [];
	      if (m(t)) while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t);
	    };
	  }

	  function Wt(t, i, o, a) {
	    var s = {},
	        u = t === Pt;

	    function l(e) {
	      var r;
	      return s[e] = !0, S.each(t[e] || [], function (e, t) {
	        var n = t(i, o, a);
	        return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1);
	      }), r;
	    }

	    return l(i.dataTypes[0]) || !s["*"] && l("*");
	  }

	  function Ft(e, t) {
	    var n,
	        r,
	        i = S.ajaxSettings.flatOptions || {};

	    for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);

	    return r && S.extend(!0, e, r), e;
	  }

	  Mt.href = bt.href, S.extend({
	    active: 0,
	    lastModified: {},
	    etag: {},
	    ajaxSettings: {
	      url: bt.href,
	      type: "GET",
	      isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),
	      global: !0,
	      processData: !0,
	      async: !0,
	      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	      accepts: {
	        "*": Rt,
	        text: "text/plain",
	        html: "text/html",
	        xml: "application/xml, text/xml",
	        json: "application/json, text/javascript"
	      },
	      contents: {
	        xml: /\bxml\b/,
	        html: /\bhtml/,
	        json: /\bjson\b/
	      },
	      responseFields: {
	        xml: "responseXML",
	        text: "responseText",
	        json: "responseJSON"
	      },
	      converters: {
	        "* text": String,
	        "text html": !0,
	        "text json": JSON.parse,
	        "text xml": S.parseXML
	      },
	      flatOptions: {
	        url: !0,
	        context: !0
	      }
	    },
	    ajaxSetup: function (e, t) {
	      return t ? Ft(Ft(e, S.ajaxSettings), t) : Ft(S.ajaxSettings, e);
	    },
	    ajaxPrefilter: It(Ot),
	    ajaxTransport: It(Pt),
	    ajax: function (e, t) {
	      "object" == typeof e && (t = e, e = void 0), t = t || {};
	      var c,
	          f,
	          p,
	          n,
	          d,
	          r,
	          h,
	          g,
	          i,
	          o,
	          v = S.ajaxSetup({}, t),
	          y = v.context || v,
	          m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event,
	          x = S.Deferred(),
	          b = S.Callbacks("once memory"),
	          w = v.statusCode || {},
	          a = {},
	          s = {},
	          u = "canceled",
	          T = {
	        readyState: 0,
	        getResponseHeader: function (e) {
	          var t;

	          if (h) {
	            if (!n) {
	              n = {};

	              while (t = qt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]);
	            }

	            t = n[e.toLowerCase() + " "];
	          }

	          return null == t ? null : t.join(", ");
	        },
	        getAllResponseHeaders: function () {
	          return h ? p : null;
	        },
	        setRequestHeader: function (e, t) {
	          return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this;
	        },
	        overrideMimeType: function (e) {
	          return null == h && (v.mimeType = e), this;
	        },
	        statusCode: function (e) {
	          var t;
	          if (e) if (h) T.always(e[T.status]);else for (t in e) w[t] = [w[t], e[t]];
	          return this;
	        },
	        abort: function (e) {
	          var t = e || u;
	          return c && c.abort(t), l(0, t), this;
	        }
	      };

	      if (x.promise(T), v.url = ((e || v.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [""], null == v.crossDomain) {
	        r = E.createElement("a");

	        try {
	          r.href = v.url, r.href = r.href, v.crossDomain = Mt.protocol + "//" + Mt.host != r.protocol + "//" + r.host;
	        } catch (e) {
	          v.crossDomain = !0;
	        }
	      }

	      if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Wt(Ot, v, t, T), h) return T;

	      for (i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Lt.test(v.type), f = v.url.replace(jt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Nt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Tt.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Dt, "$1"), o = (Tt.test(f) ? "&" : "?") + "_=" + wt.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]);

	      if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort();

	      if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Wt(Pt, v, t, T)) {
	        if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T;
	        v.async && 0 < v.timeout && (d = C.setTimeout(function () {
	          T.abort("timeout");
	        }, v.timeout));

	        try {
	          h = !1, c.send(a, l);
	        } catch (e) {
	          if (h) throw e;
	          l(-1, e);
	        }
	      } else l(-1, "No Transport");

	      function l(e, t, n, r) {
	        var i,
	            o,
	            a,
	            s,
	            u,
	            l = t;
	        h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) {
	          var r,
	              i,
	              o,
	              a,
	              s = e.contents,
	              u = e.dataTypes;

	          while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));

	          if (r) for (i in s) if (s[i] && s[i].test(r)) {
	            u.unshift(i);
	            break;
	          }
	          if (u[0] in n) o = u[0];else {
	            for (i in n) {
	              if (!u[0] || e.converters[i + " " + u[0]]) {
	                o = i;
	                break;
	              }

	              a || (a = i);
	            }

	            o = o || a;
	          }
	          if (o) return o !== u[0] && u.unshift(o), n[o];
	        }(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && S.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function () {}), s = function (e, t, n, r) {
	          var i,
	              o,
	              a,
	              s,
	              u,
	              l = {},
	              c = e.dataTypes.slice();
	          if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
	          o = c.shift();

	          while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u;else if ("*" !== u && u !== o) {
	            if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {
	              !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1]));
	              break;
	            }
	            if (!0 !== a) if (a && e["throws"]) t = a(t);else try {
	              t = a(t);
	            } catch (e) {
	              return {
	                state: "parsererror",
	                error: a ? e : "No conversion from " + u + " to " + o
	              };
	            }
	          }

	          return {
	            state: "success",
	            data: t
	          };
	        }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --S.active || S.event.trigger("ajaxStop")));
	      }

	      return T;
	    },
	    getJSON: function (e, t, n) {
	      return S.get(e, t, n, "json");
	    },
	    getScript: function (e, t) {
	      return S.get(e, void 0, t, "script");
	    }
	  }), S.each(["get", "post"], function (e, i) {
	    S[i] = function (e, t, n, r) {
	      return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({
	        url: e,
	        type: i,
	        dataType: r,
	        data: t,
	        success: n
	      }, S.isPlainObject(e) && e));
	    };
	  }), S.ajaxPrefilter(function (e) {
	    var t;

	    for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "");
	  }), S._evalUrl = function (e, t, n) {
	    return S.ajax({
	      url: e,
	      type: "GET",
	      dataType: "script",
	      cache: !0,
	      async: !1,
	      global: !1,
	      converters: {
	        "text script": function () {}
	      },
	      dataFilter: function (e) {
	        S.globalEval(e, t, n);
	      }
	    });
	  }, S.fn.extend({
	    wrapAll: function (e) {
	      var t;
	      return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
	        var e = this;

	        while (e.firstElementChild) e = e.firstElementChild;

	        return e;
	      }).append(this)), this;
	    },
	    wrapInner: function (n) {
	      return m(n) ? this.each(function (e) {
	        S(this).wrapInner(n.call(this, e));
	      }) : this.each(function () {
	        var e = S(this),
	            t = e.contents();
	        t.length ? t.wrapAll(n) : e.append(n);
	      });
	    },
	    wrap: function (t) {
	      var n = m(t);
	      return this.each(function (e) {
	        S(this).wrapAll(n ? t.call(this, e) : t);
	      });
	    },
	    unwrap: function (e) {
	      return this.parent(e).not("body").each(function () {
	        S(this).replaceWith(this.childNodes);
	      }), this;
	    }
	  }), S.expr.pseudos.hidden = function (e) {
	    return !S.expr.pseudos.visible(e);
	  }, S.expr.pseudos.visible = function (e) {
	    return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
	  }, S.ajaxSettings.xhr = function () {
	    try {
	      return new C.XMLHttpRequest();
	    } catch (e) {}
	  };
	  var Bt = {
	    0: 200,
	    1223: 204
	  },
	      $t = S.ajaxSettings.xhr();
	  y.cors = !!$t && "withCredentials" in $t, y.ajax = $t = !!$t, S.ajaxTransport(function (i) {
	    var o, a;
	    if (y.cors || $t && !i.crossDomain) return {
	      send: function (e, t) {
	        var n,
	            r = i.xhr();
	        if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for (n in i.xhrFields) r[n] = i.xhrFields[n];

	        for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]);

	        o = function (e) {
	          return function () {
	            o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? {
	              binary: r.response
	            } : {
	              text: r.responseText
	            }, r.getAllResponseHeaders()));
	          };
	        }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () {
	          4 === r.readyState && C.setTimeout(function () {
	            o && a();
	          });
	        }, o = o("abort");

	        try {
	          r.send(i.hasContent && i.data || null);
	        } catch (e) {
	          if (o) throw e;
	        }
	      },
	      abort: function () {
	        o && o();
	      }
	    };
	  }), S.ajaxPrefilter(function (e) {
	    e.crossDomain && (e.contents.script = !1);
	  }), S.ajaxSetup({
	    accepts: {
	      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	    },
	    contents: {
	      script: /\b(?:java|ecma)script\b/
	    },
	    converters: {
	      "text script": function (e) {
	        return S.globalEval(e), e;
	      }
	    }
	  }), S.ajaxPrefilter("script", function (e) {
	    void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET");
	  }), S.ajaxTransport("script", function (n) {
	    var r, i;
	    if (n.crossDomain || n.scriptAttrs) return {
	      send: function (e, t) {
	        r = S("<script>").attr(n.scriptAttrs || {}).prop({
	          charset: n.scriptCharset,
	          src: n.url
	        }).on("load error", i = function (e) {
	          r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type);
	        }), E.head.appendChild(r[0]);
	      },
	      abort: function () {
	        i && i();
	      }
	    };
	  });

	  var _t,
	      zt = [],
	      Ut = /(=)\?(?=&|$)|\?\?/;

	  S.ajaxSetup({
	    jsonp: "callback",
	    jsonpCallback: function () {
	      var e = zt.pop() || S.expando + "_" + wt.guid++;
	      return this[e] = !0, e;
	    }
	  }), S.ajaxPrefilter("json jsonp", function (e, t, n) {
	    var r,
	        i,
	        o,
	        a = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data");
	    if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ut, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {
	      return o || S.error(r + " was not called"), o[0];
	    }, e.dataTypes[0] = "json", i = C[r], C[r] = function () {
	      o = arguments;
	    }, n.always(function () {
	      void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, zt.push(r)), o && m(i) && i(o[0]), o = i = void 0;
	    }), "script";
	  }), y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length), S.parseHTML = function (e, t, n) {
	    return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes)));
	    var r, i, o;
	  }, S.fn.load = function (e, t, n) {
	    var r,
	        i,
	        o,
	        a = this,
	        s = e.indexOf(" ");
	    return -1 < s && (r = ht(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && S.ajax({
	      url: e,
	      type: i || "GET",
	      dataType: "html",
	      data: t
	    }).done(function (e) {
	      o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e);
	    }).always(n && function (e, t) {
	      a.each(function () {
	        n.apply(this, o || [e.responseText, t, e]);
	      });
	    }), this;
	  }, S.expr.pseudos.animated = function (t) {
	    return S.grep(S.timers, function (e) {
	      return t === e.elem;
	    }).length;
	  }, S.offset = {
	    setOffset: function (e, t, n) {
	      var r,
	          i,
	          o,
	          a,
	          s,
	          u,
	          l = S.css(e, "position"),
	          c = S(e),
	          f = {};
	      "static" === l && (e.style.position = "relative"), s = c.offset(), o = S.css(e, "top"), u = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f);
	    }
	  }, S.fn.extend({
	    offset: function (t) {
	      if (arguments.length) return void 0 === t ? this : this.each(function (e) {
	        S.offset.setOffset(this, t, e);
	      });
	      var e,
	          n,
	          r = this[0];
	      return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
	        top: e.top + n.pageYOffset,
	        left: e.left + n.pageXOffset
	      }) : {
	        top: 0,
	        left: 0
	      } : void 0;
	    },
	    position: function () {
	      if (this[0]) {
	        var e,
	            t,
	            n,
	            r = this[0],
	            i = {
	          top: 0,
	          left: 0
	        };
	        if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect();else {
	          t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement;

	          while (e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position")) e = e.parentNode;

	          e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0));
	        }
	        return {
	          top: t.top - i.top - S.css(r, "marginTop", !0),
	          left: t.left - i.left - S.css(r, "marginLeft", !0)
	        };
	      }
	    },
	    offsetParent: function () {
	      return this.map(function () {
	        var e = this.offsetParent;

	        while (e && "static" === S.css(e, "position")) e = e.offsetParent;

	        return e || re;
	      });
	    }
	  }), S.each({
	    scrollLeft: "pageXOffset",
	    scrollTop: "pageYOffset"
	  }, function (t, i) {
	    var o = "pageYOffset" === i;

	    S.fn[t] = function (e) {
	      return $(this, function (e, t, n) {
	        var r;
	        if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t];
	        r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n;
	      }, t, e, arguments.length);
	    };
	  }), S.each(["top", "left"], function (e, n) {
	    S.cssHooks[n] = Fe(y.pixelPosition, function (e, t) {
	      if (t) return t = We(e, n), Pe.test(t) ? S(e).position()[n] + "px" : t;
	    });
	  }), S.each({
	    Height: "height",
	    Width: "width"
	  }, function (a, s) {
	    S.each({
	      padding: "inner" + a,
	      content: s,
	      "": "outer" + a
	    }, function (r, o) {
	      S.fn[o] = function (e, t) {
	        var n = arguments.length && (r || "boolean" != typeof e),
	            i = r || (!0 === e || !0 === t ? "margin" : "border");
	        return $(this, function (e, t, n) {
	          var r;
	          return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i);
	        }, s, n ? e : void 0, n);
	      };
	    });
	  }), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
	    S.fn[t] = function (e) {
	      return this.on(t, e);
	    };
	  }), S.fn.extend({
	    bind: function (e, t, n) {
	      return this.on(e, null, t, n);
	    },
	    unbind: function (e, t) {
	      return this.off(e, null, t);
	    },
	    delegate: function (e, t, n, r) {
	      return this.on(t, e, n, r);
	    },
	    undelegate: function (e, t, n) {
	      return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
	    },
	    hover: function (e, t) {
	      return this.mouseenter(e).mouseleave(t || e);
	    }
	  }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, n) {
	    S.fn[n] = function (e, t) {
	      return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n);
	    };
	  });
	  var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
	  S.proxy = function (e, t) {
	    var n, r, i;
	    if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function () {
	      return e.apply(t || this, r.concat(s.call(arguments)));
	    }).guid = e.guid = e.guid || S.guid++, i;
	  }, S.holdReady = function (e) {
	    e ? S.readyWait++ : S.ready(!0);
	  }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) {
	    var t = S.type(e);
	    return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));
	  }, S.trim = function (e) {
	    return null == e ? "" : (e + "").replace(Xt, "");
	  };
	  var Vt = C.jQuery,
	      Gt = C.$;
	  return S.noConflict = function (e) {
	    return C.$ === S && (C.$ = Gt), e && C.jQuery === S && (C.jQuery = Vt), S;
	  }, "undefined" == typeof e && (C.jQuery = C.$ = S), S;
	});
	});

	return jquery3_6_0_min;

}));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJqcXVlcnktMy42LjAubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdqcXVlcnkzNjBNaW4nLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5qcXVlcnkzNjBNaW4gPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0XHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG5cdH1cblxuXHR2YXIganF1ZXJ5M182XzBfbWluID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQvKiEgalF1ZXJ5IHYzLjYuMCB8IChjKSBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXG5cdCFmdW5jdGlvbiAoZSwgdCkge1xuXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBlLmRvY3VtZW50ID8gdChlLCAhMCkgOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgaWYgKCFlLmRvY3VtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO1xuXHQgICAgcmV0dXJuIHQoZSk7XG5cdCAgfSA7XG5cdH0oXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDogY29tbW9uanNHbG9iYWwsIGZ1bmN0aW9uIChDLCBlKSB7XG5cblx0ICB2YXIgdCA9IFtdLFxuXHQgICAgICByID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuXHQgICAgICBzID0gdC5zbGljZSxcblx0ICAgICAgZyA9IHQuZmxhdCA/IGZ1bmN0aW9uIChlKSB7XG5cdCAgICByZXR1cm4gdC5mbGF0LmNhbGwoZSk7XG5cdCAgfSA6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICByZXR1cm4gdC5jb25jYXQuYXBwbHkoW10sIGUpO1xuXHQgIH0sXG5cdCAgICAgIHUgPSB0LnB1c2gsXG5cdCAgICAgIGkgPSB0LmluZGV4T2YsXG5cdCAgICAgIG4gPSB7fSxcblx0ICAgICAgbyA9IG4udG9TdHJpbmcsXG5cdCAgICAgIHYgPSBuLmhhc093blByb3BlcnR5LFxuXHQgICAgICBhID0gdi50b1N0cmluZyxcblx0ICAgICAgbCA9IGEuY2FsbChPYmplY3QpLFxuXHQgICAgICB5ID0ge30sXG5cdCAgICAgIG0gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiBcIm51bWJlclwiICE9IHR5cGVvZiBlLm5vZGVUeXBlICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZS5pdGVtO1xuXHQgIH0sXG5cdCAgICAgIHggPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgcmV0dXJuIG51bGwgIT0gZSAmJiBlID09PSBlLndpbmRvdztcblx0ICB9LFxuXHQgICAgICBFID0gQy5kb2N1bWVudCxcblx0ICAgICAgYyA9IHtcblx0ICAgIHR5cGU6ICEwLFxuXHQgICAgc3JjOiAhMCxcblx0ICAgIG5vbmNlOiAhMCxcblx0ICAgIG5vTW9kdWxlOiAhMFxuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBiKGUsIHQsIG4pIHtcblx0ICAgIHZhciByLFxuXHQgICAgICAgIGksXG5cdCAgICAgICAgbyA9IChuID0gbiB8fCBFKS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXHQgICAgaWYgKG8udGV4dCA9IGUsIHQpIGZvciAociBpbiBjKSAoaSA9IHRbcl0gfHwgdC5nZXRBdHRyaWJ1dGUgJiYgdC5nZXRBdHRyaWJ1dGUocikpICYmIG8uc2V0QXR0cmlidXRlKHIsIGkpO1xuXHQgICAgbi5oZWFkLmFwcGVuZENoaWxkKG8pLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobyk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdyhlKSB7XG5cdCAgICByZXR1cm4gbnVsbCA9PSBlID8gZSArIFwiXCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IG5bby5jYWxsKGUpXSB8fCBcIm9iamVjdFwiIDogdHlwZW9mIGU7XG5cdCAgfVxuXG5cdCAgdmFyIGYgPSBcIjMuNi4wXCIsXG5cdCAgICAgIFMgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgcmV0dXJuIG5ldyBTLmZuLmluaXQoZSwgdCk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHAoZSkge1xuXHQgICAgdmFyIHQgPSAhIWUgJiYgXCJsZW5ndGhcIiBpbiBlICYmIGUubGVuZ3RoLFxuXHQgICAgICAgIG4gPSB3KGUpO1xuXHQgICAgcmV0dXJuICFtKGUpICYmICF4KGUpICYmIChcImFycmF5XCIgPT09IG4gfHwgMCA9PT0gdCB8fCBcIm51bWJlclwiID09IHR5cGVvZiB0ICYmIDAgPCB0ICYmIHQgLSAxIGluIGUpO1xuXHQgIH1cblxuXHQgIFMuZm4gPSBTLnByb3RvdHlwZSA9IHtcblx0ICAgIGpxdWVyeTogZixcblx0ICAgIGNvbnN0cnVjdG9yOiBTLFxuXHQgICAgbGVuZ3RoOiAwLFxuXHQgICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gcy5jYWxsKHRoaXMpO1xuXHQgICAgfSxcblx0ICAgIGdldDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIG51bGwgPT0gZSA/IHMuY2FsbCh0aGlzKSA6IGUgPCAwID8gdGhpc1tlICsgdGhpcy5sZW5ndGhdIDogdGhpc1tlXTtcblx0ICAgIH0sXG5cdCAgICBwdXNoU3RhY2s6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0ID0gUy5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGUpO1xuXHQgICAgICByZXR1cm4gdC5wcmV2T2JqZWN0ID0gdGhpcywgdDtcblx0ICAgIH0sXG5cdCAgICBlYWNoOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gUy5lYWNoKHRoaXMsIGUpO1xuXHQgICAgfSxcblx0ICAgIG1hcDogZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFMubWFwKHRoaXMsIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgcmV0dXJuIG4uY2FsbChlLCB0LCBlKTtcblx0ICAgICAgfSkpO1xuXHQgICAgfSxcblx0ICAgIHNsaWNlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgICAgfSxcblx0ICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmVxKDApO1xuXHQgICAgfSxcblx0ICAgIGxhc3Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZXEoLTEpO1xuXHQgICAgfSxcblx0ICAgIGV2ZW46IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFMuZ3JlcCh0aGlzLCBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIHJldHVybiAodCArIDEpICUgMjtcblx0ICAgICAgfSkpO1xuXHQgICAgfSxcblx0ICAgIG9kZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soUy5ncmVwKHRoaXMsIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgcmV0dXJuIHQgJSAyO1xuXHQgICAgICB9KSk7XG5cdCAgICB9LFxuXHQgICAgZXE6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0ID0gdGhpcy5sZW5ndGgsXG5cdCAgICAgICAgICBuID0gK2UgKyAoZSA8IDAgPyB0IDogMCk7XG5cdCAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjaygwIDw9IG4gJiYgbiA8IHQgPyBbdGhpc1tuXV0gOiBbXSk7XG5cdCAgICB9LFxuXHQgICAgZW5kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHQgICAgfSxcblx0ICAgIHB1c2g6IHUsXG5cdCAgICBzb3J0OiB0LnNvcnQsXG5cdCAgICBzcGxpY2U6IHQuc3BsaWNlXG5cdCAgfSwgUy5leHRlbmQgPSBTLmZuLmV4dGVuZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBlLFxuXHQgICAgICAgIHQsXG5cdCAgICAgICAgbixcblx0ICAgICAgICByLFxuXHQgICAgICAgIGksXG5cdCAgICAgICAgbyxcblx0ICAgICAgICBhID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuXHQgICAgICAgIHMgPSAxLFxuXHQgICAgICAgIHUgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHQgICAgICAgIGwgPSAhMTtcblxuXHQgICAgZm9yIChcImJvb2xlYW5cIiA9PSB0eXBlb2YgYSAmJiAobCA9IGEsIGEgPSBhcmd1bWVudHNbc10gfHwge30sIHMrKyksIFwib2JqZWN0XCIgPT0gdHlwZW9mIGEgfHwgbShhKSB8fCAoYSA9IHt9KSwgcyA9PT0gdSAmJiAoYSA9IHRoaXMsIHMtLSk7IHMgPCB1OyBzKyspIGlmIChudWxsICE9IChlID0gYXJndW1lbnRzW3NdKSkgZm9yICh0IGluIGUpIHIgPSBlW3RdLCBcIl9fcHJvdG9fX1wiICE9PSB0ICYmIGEgIT09IHIgJiYgKGwgJiYgciAmJiAoUy5pc1BsYWluT2JqZWN0KHIpIHx8IChpID0gQXJyYXkuaXNBcnJheShyKSkpID8gKG4gPSBhW3RdLCBvID0gaSAmJiAhQXJyYXkuaXNBcnJheShuKSA/IFtdIDogaSB8fCBTLmlzUGxhaW5PYmplY3QobikgPyBuIDoge30sIGkgPSAhMSwgYVt0XSA9IFMuZXh0ZW5kKGwsIG8sIHIpKSA6IHZvaWQgMCAhPT0gciAmJiAoYVt0XSA9IHIpKTtcblxuXHQgICAgcmV0dXJuIGE7XG5cdCAgfSwgUy5leHRlbmQoe1xuXHQgICAgZXhwYW5kbzogXCJqUXVlcnlcIiArIChmICsgTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csIFwiXCIpLFxuXHQgICAgaXNSZWFkeTogITAsXG5cdCAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuXHQgICAgfSxcblx0ICAgIG5vb3A6IGZ1bmN0aW9uICgpIHt9LFxuXHQgICAgaXNQbGFpbk9iamVjdDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQsIG47XG5cdCAgICAgIHJldHVybiAhKCFlIHx8IFwiW29iamVjdCBPYmplY3RdXCIgIT09IG8uY2FsbChlKSkgJiYgKCEodCA9IHIoZSkpIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgKG4gPSB2LmNhbGwodCwgXCJjb25zdHJ1Y3RvclwiKSAmJiB0LmNvbnN0cnVjdG9yKSAmJiBhLmNhbGwobikgPT09IGwpO1xuXHQgICAgfSxcblx0ICAgIGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0O1xuXG5cdCAgICAgIGZvciAodCBpbiBlKSByZXR1cm4gITE7XG5cblx0ICAgICAgcmV0dXJuICEwO1xuXHQgICAgfSxcblx0ICAgIGdsb2JhbEV2YWw6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIGIoZSwge1xuXHQgICAgICAgIG5vbmNlOiB0ICYmIHQubm9uY2Vcblx0ICAgICAgfSwgbik7XG5cdCAgICB9LFxuXHQgICAgZWFjaDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgdmFyIG4sXG5cdCAgICAgICAgICByID0gMDtcblxuXHQgICAgICBpZiAocChlKSkge1xuXHQgICAgICAgIGZvciAobiA9IGUubGVuZ3RoOyByIDwgbjsgcisrKSBpZiAoITEgPT09IHQuY2FsbChlW3JdLCByLCBlW3JdKSkgYnJlYWs7XG5cdCAgICAgIH0gZWxzZSBmb3IgKHIgaW4gZSkgaWYgKCExID09PSB0LmNhbGwoZVtyXSwgciwgZVtyXSkpIGJyZWFrO1xuXG5cdCAgICAgIHJldHVybiBlO1xuXHQgICAgfSxcblx0ICAgIG1ha2VBcnJheTogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgdmFyIG4gPSB0IHx8IFtdO1xuXHQgICAgICByZXR1cm4gbnVsbCAhPSBlICYmIChwKE9iamVjdChlKSkgPyBTLm1lcmdlKG4sIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBbZV0gOiBlKSA6IHUuY2FsbChuLCBlKSksIG47XG5cdCAgICB9LFxuXHQgICAgaW5BcnJheTogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgcmV0dXJuIG51bGwgPT0gdCA/IC0xIDogaS5jYWxsKHQsIGUsIG4pO1xuXHQgICAgfSxcblx0ICAgIG1lcmdlOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICBmb3IgKHZhciBuID0gK3QubGVuZ3RoLCByID0gMCwgaSA9IGUubGVuZ3RoOyByIDwgbjsgcisrKSBlW2krK10gPSB0W3JdO1xuXG5cdCAgICAgIHJldHVybiBlLmxlbmd0aCA9IGksIGU7XG5cdCAgICB9LFxuXHQgICAgZ3JlcDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgZm9yICh2YXIgciA9IFtdLCBpID0gMCwgbyA9IGUubGVuZ3RoLCBhID0gIW47IGkgPCBvOyBpKyspICF0KGVbaV0sIGkpICE9PSBhICYmIHIucHVzaChlW2ldKTtcblxuXHQgICAgICByZXR1cm4gcjtcblx0ICAgIH0sXG5cdCAgICBtYXA6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHZhciByLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8gPSAwLFxuXHQgICAgICAgICAgYSA9IFtdO1xuXHQgICAgICBpZiAocChlKSkgZm9yIChyID0gZS5sZW5ndGg7IG8gPCByOyBvKyspIG51bGwgIT0gKGkgPSB0KGVbb10sIG8sIG4pKSAmJiBhLnB1c2goaSk7ZWxzZSBmb3IgKG8gaW4gZSkgbnVsbCAhPSAoaSA9IHQoZVtvXSwgbywgbikpICYmIGEucHVzaChpKTtcblx0ICAgICAgcmV0dXJuIGcoYSk7XG5cdCAgICB9LFxuXHQgICAgZ3VpZDogMSxcblx0ICAgIHN1cHBvcnQ6IHlcblx0ICB9KSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgKFMuZm5bU3ltYm9sLml0ZXJhdG9yXSA9IHRbU3ltYm9sLml0ZXJhdG9yXSksIFMuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgbltcIltvYmplY3QgXCIgKyB0ICsgXCJdXCJdID0gdC50b0xvd2VyQ2FzZSgpO1xuXHQgIH0pO1xuXG5cdCAgdmFyIGQgPSBmdW5jdGlvbiAobikge1xuXHQgICAgdmFyIGUsXG5cdCAgICAgICAgZCxcblx0ICAgICAgICBiLFxuXHQgICAgICAgIG8sXG5cdCAgICAgICAgaSxcblx0ICAgICAgICBoLFxuXHQgICAgICAgIGYsXG5cdCAgICAgICAgZyxcblx0ICAgICAgICB3LFxuXHQgICAgICAgIHUsXG5cdCAgICAgICAgbCxcblx0ICAgICAgICBULFxuXHQgICAgICAgIEMsXG5cdCAgICAgICAgYSxcblx0ICAgICAgICBFLFxuXHQgICAgICAgIHYsXG5cdCAgICAgICAgcyxcblx0ICAgICAgICBjLFxuXHQgICAgICAgIHksXG5cdCAgICAgICAgUyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0ICAgICAgICBwID0gbi5kb2N1bWVudCxcblx0ICAgICAgICBrID0gMCxcblx0ICAgICAgICByID0gMCxcblx0ICAgICAgICBtID0gdWUoKSxcblx0ICAgICAgICB4ID0gdWUoKSxcblx0ICAgICAgICBBID0gdWUoKSxcblx0ICAgICAgICBOID0gdWUoKSxcblx0ICAgICAgICBqID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgcmV0dXJuIGUgPT09IHQgJiYgKGwgPSAhMCksIDA7XG5cdCAgICB9LFxuXHQgICAgICAgIEQgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcblx0ICAgICAgICB0ID0gW10sXG5cdCAgICAgICAgcSA9IHQucG9wLFxuXHQgICAgICAgIEwgPSB0LnB1c2gsXG5cdCAgICAgICAgSCA9IHQucHVzaCxcblx0ICAgICAgICBPID0gdC5zbGljZSxcblx0ICAgICAgICBQID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgZm9yICh2YXIgbiA9IDAsIHIgPSBlLmxlbmd0aDsgbiA8IHI7IG4rKykgaWYgKGVbbl0gPT09IHQpIHJldHVybiBuO1xuXG5cdCAgICAgIHJldHVybiAtMTtcblx0ICAgIH0sXG5cdCAgICAgICAgUiA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblx0ICAgICAgICBNID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXHQgICAgICAgIEkgPSBcIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyBNICsgXCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixcblx0ICAgICAgICBXID0gXCJcXFxcW1wiICsgTSArIFwiKihcIiArIEkgKyBcIikoPzpcIiArIE0gKyBcIiooWypeJHwhfl0/PSlcIiArIE0gKyBcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgSSArIFwiKSl8KVwiICsgTSArIFwiKlxcXFxdXCIsXG5cdCAgICAgICAgRiA9IFwiOihcIiArIEkgKyBcIikoPzpcXFxcKCgoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXwoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBXICsgXCIpKil8LiopXFxcXCl8KVwiLFxuXHQgICAgICAgIEIgPSBuZXcgUmVnRXhwKE0gKyBcIitcIiwgXCJnXCIpLFxuXHQgICAgICAgICQgPSBuZXcgUmVnRXhwKFwiXlwiICsgTSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIE0gKyBcIiskXCIsIFwiZ1wiKSxcblx0ICAgICAgICBfID0gbmV3IFJlZ0V4cChcIl5cIiArIE0gKyBcIiosXCIgKyBNICsgXCIqXCIpLFxuXHQgICAgICAgIHogPSBuZXcgUmVnRXhwKFwiXlwiICsgTSArIFwiKihbPit+XXxcIiArIE0gKyBcIilcIiArIE0gKyBcIipcIiksXG5cdCAgICAgICAgVSA9IG5ldyBSZWdFeHAoTSArIFwifD5cIiksXG5cdCAgICAgICAgWCA9IG5ldyBSZWdFeHAoRiksXG5cdCAgICAgICAgViA9IG5ldyBSZWdFeHAoXCJeXCIgKyBJICsgXCIkXCIpLFxuXHQgICAgICAgIEcgPSB7XG5cdCAgICAgIElEOiBuZXcgUmVnRXhwKFwiXiMoXCIgKyBJICsgXCIpXCIpLFxuXHQgICAgICBDTEFTUzogbmV3IFJlZ0V4cChcIl5cXFxcLihcIiArIEkgKyBcIilcIiksXG5cdCAgICAgIFRBRzogbmV3IFJlZ0V4cChcIl4oXCIgKyBJICsgXCJ8WypdKVwiKSxcblx0ICAgICAgQVRUUjogbmV3IFJlZ0V4cChcIl5cIiArIFcpLFxuXHQgICAgICBQU0VVRE86IG5ldyBSZWdFeHAoXCJeXCIgKyBGKSxcblx0ICAgICAgQ0hJTEQ6IG5ldyBSZWdFeHAoXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgTSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyBNICsgXCIqKD86KFsrLV18KVwiICsgTSArIFwiKihcXFxcZCspfCkpXCIgKyBNICsgXCIqXFxcXCl8KVwiLCBcImlcIiksXG5cdCAgICAgIGJvb2w6IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBSICsgXCIpJFwiLCBcImlcIiksXG5cdCAgICAgIG5lZWRzQ29udGV4dDogbmV3IFJlZ0V4cChcIl5cIiArIE0gKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgKyBNICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgTSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiKVxuXHQgICAgfSxcblx0ICAgICAgICBZID0gL0hUTUwkL2ksXG5cdCAgICAgICAgUSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdCAgICAgICAgSiA9IC9eaFxcZCQvaSxcblx0ICAgICAgICBLID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3Lyxcblx0ICAgICAgICBaID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cdCAgICAgICAgZWUgPSAvWyt+XS8sXG5cdCAgICAgICAgdGUgPSBuZXcgUmVnRXhwKFwiXFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIE0gKyBcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLCBcImdcIiksXG5cdCAgICAgICAgbmUgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbiA9IFwiMHhcIiArIGUuc2xpY2UoMSkgLSA2NTUzNjtcblx0ICAgICAgcmV0dXJuIHQgfHwgKG4gPCAwID8gU3RyaW5nLmZyb21DaGFyQ29kZShuICsgNjU1MzYpIDogU3RyaW5nLmZyb21DaGFyQ29kZShuID4+IDEwIHwgNTUyOTYsIDEwMjMgJiBuIHwgNTYzMjApKTtcblx0ICAgIH0sXG5cdCAgICAgICAgcmUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ICAgICAgICBpZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiB0ID8gXCJcXDBcIiA9PT0gZSA/IFwiXFx1ZmZmZFwiIDogZS5zbGljZSgwLCAtMSkgKyBcIlxcXFxcIiArIGUuY2hhckNvZGVBdChlLmxlbmd0aCAtIDEpLnRvU3RyaW5nKDE2KSArIFwiIFwiIDogXCJcXFxcXCIgKyBlO1xuXHQgICAgfSxcblx0ICAgICAgICBvZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgVCgpO1xuXHQgICAgfSxcblx0ICAgICAgICBhZSA9IGJlKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiAhMCA9PT0gZS5kaXNhYmxlZCAmJiBcImZpZWxkc2V0XCIgPT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgIH0sIHtcblx0ICAgICAgZGlyOiBcInBhcmVudE5vZGVcIixcblx0ICAgICAgbmV4dDogXCJsZWdlbmRcIlxuXHQgICAgfSk7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIEguYXBwbHkodCA9IE8uY2FsbChwLmNoaWxkTm9kZXMpLCBwLmNoaWxkTm9kZXMpLCB0W3AuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICBIID0ge1xuXHQgICAgICAgIGFwcGx5OiB0Lmxlbmd0aCA/IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgICBMLmFwcGx5KGUsIE8uY2FsbCh0KSk7XG5cdCAgICAgICAgfSA6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgICB2YXIgbiA9IGUubGVuZ3RoLFxuXHQgICAgICAgICAgICAgIHIgPSAwO1xuXG5cdCAgICAgICAgICB3aGlsZSAoZVtuKytdID0gdFtyKytdKTtcblxuXHQgICAgICAgICAgZS5sZW5ndGggPSBuIC0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHNlKHQsIGUsIG4sIHIpIHtcblx0ICAgICAgdmFyIGksXG5cdCAgICAgICAgICBvLFxuXHQgICAgICAgICAgYSxcblx0ICAgICAgICAgIHMsXG5cdCAgICAgICAgICB1LFxuXHQgICAgICAgICAgbCxcblx0ICAgICAgICAgIGMsXG5cdCAgICAgICAgICBmID0gZSAmJiBlLm93bmVyRG9jdW1lbnQsXG5cdCAgICAgICAgICBwID0gZSA/IGUubm9kZVR5cGUgOiA5O1xuXHQgICAgICBpZiAobiA9IG4gfHwgW10sIFwic3RyaW5nXCIgIT0gdHlwZW9mIHQgfHwgIXQgfHwgMSAhPT0gcCAmJiA5ICE9PSBwICYmIDExICE9PSBwKSByZXR1cm4gbjtcblxuXHQgICAgICBpZiAoIXIgJiYgKFQoZSksIGUgPSBlIHx8IEMsIEUpKSB7XG5cdCAgICAgICAgaWYgKDExICE9PSBwICYmICh1ID0gWi5leGVjKHQpKSkgaWYgKGkgPSB1WzFdKSB7XG5cdCAgICAgICAgICBpZiAoOSA9PT0gcCkge1xuXHQgICAgICAgICAgICBpZiAoIShhID0gZS5nZXRFbGVtZW50QnlJZChpKSkpIHJldHVybiBuO1xuXHQgICAgICAgICAgICBpZiAoYS5pZCA9PT0gaSkgcmV0dXJuIG4ucHVzaChhKSwgbjtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoZiAmJiAoYSA9IGYuZ2V0RWxlbWVudEJ5SWQoaSkpICYmIHkoZSwgYSkgJiYgYS5pZCA9PT0gaSkgcmV0dXJuIG4ucHVzaChhKSwgbjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaWYgKHVbMl0pIHJldHVybiBILmFwcGx5KG4sIGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodCkpLCBuO1xuXHQgICAgICAgICAgaWYgKChpID0gdVszXSkgJiYgZC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkgcmV0dXJuIEguYXBwbHkobiwgZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGkpKSwgbjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZC5xc2EgJiYgIU5bdCArIFwiIFwiXSAmJiAoIXYgfHwgIXYudGVzdCh0KSkgJiYgKDEgIT09IHAgfHwgXCJvYmplY3RcIiAhPT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuXHQgICAgICAgICAgaWYgKGMgPSB0LCBmID0gZSwgMSA9PT0gcCAmJiAoVS50ZXN0KHQpIHx8IHoudGVzdCh0KSkpIHtcblx0ICAgICAgICAgICAgKGYgPSBlZS50ZXN0KHQpICYmIHllKGUucGFyZW50Tm9kZSkgfHwgZSkgPT09IGUgJiYgZC5zY29wZSB8fCAoKHMgPSBlLmdldEF0dHJpYnV0ZShcImlkXCIpKSA/IHMgPSBzLnJlcGxhY2UocmUsIGllKSA6IGUuc2V0QXR0cmlidXRlKFwiaWRcIiwgcyA9IFMpKSwgbyA9IChsID0gaCh0KSkubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIHdoaWxlIChvLS0pIGxbb10gPSAocyA/IFwiI1wiICsgcyA6IFwiOnNjb3BlXCIpICsgXCIgXCIgKyB4ZShsW29dKTtcblxuXHQgICAgICAgICAgICBjID0gbC5qb2luKFwiLFwiKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmV0dXJuIEguYXBwbHkobiwgZi5xdWVyeVNlbGVjdG9yQWxsKGMpKSwgbjtcblx0ICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgTih0LCAhMCk7XG5cdCAgICAgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgICAgICBzID09PSBTICYmIGUucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGcodC5yZXBsYWNlKCQsIFwiJDFcIiksIGUsIG4sIHIpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB1ZSgpIHtcblx0ICAgICAgdmFyIHIgPSBbXTtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIGUodCwgbikge1xuXHQgICAgICAgIHJldHVybiByLnB1c2godCArIFwiIFwiKSA+IGIuY2FjaGVMZW5ndGggJiYgZGVsZXRlIGVbci5zaGlmdCgpXSwgZVt0ICsgXCIgXCJdID0gbjtcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gbGUoZSkge1xuXHQgICAgICByZXR1cm4gZVtTXSA9ICEwLCBlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjZShlKSB7XG5cdCAgICAgIHZhciB0ID0gQy5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gISFlKHQpO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCksIHQgPSBudWxsO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGZlKGUsIHQpIHtcblx0ICAgICAgdmFyIG4gPSBlLnNwbGl0KFwifFwiKSxcblx0ICAgICAgICAgIHIgPSBuLmxlbmd0aDtcblxuXHQgICAgICB3aGlsZSAoci0tKSBiLmF0dHJIYW5kbGVbbltyXV0gPSB0O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwZShlLCB0KSB7XG5cdCAgICAgIHZhciBuID0gdCAmJiBlLFxuXHQgICAgICAgICAgciA9IG4gJiYgMSA9PT0gZS5ub2RlVHlwZSAmJiAxID09PSB0Lm5vZGVUeXBlICYmIGUuc291cmNlSW5kZXggLSB0LnNvdXJjZUluZGV4O1xuXHQgICAgICBpZiAocikgcmV0dXJuIHI7XG5cdCAgICAgIGlmIChuKSB3aGlsZSAobiA9IG4ubmV4dFNpYmxpbmcpIGlmIChuID09PSB0KSByZXR1cm4gLTE7XG5cdCAgICAgIHJldHVybiBlID8gMSA6IC0xO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBkZSh0KSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHJldHVybiBcImlucHV0XCIgPT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAmJiBlLnR5cGUgPT09IHQ7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGhlKG4pIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIHQgPSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgcmV0dXJuIChcImlucHV0XCIgPT09IHQgfHwgXCJidXR0b25cIiA9PT0gdCkgJiYgZS50eXBlID09PSBuO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBnZSh0KSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHJldHVybiBcImZvcm1cIiBpbiBlID8gZS5wYXJlbnROb2RlICYmICExID09PSBlLmRpc2FibGVkID8gXCJsYWJlbFwiIGluIGUgPyBcImxhYmVsXCIgaW4gZS5wYXJlbnROb2RlID8gZS5wYXJlbnROb2RlLmRpc2FibGVkID09PSB0IDogZS5kaXNhYmxlZCA9PT0gdCA6IGUuaXNEaXNhYmxlZCA9PT0gdCB8fCBlLmlzRGlzYWJsZWQgIT09ICF0ICYmIGFlKGUpID09PSB0IDogZS5kaXNhYmxlZCA9PT0gdCA6IFwibGFiZWxcIiBpbiBlICYmIGUuZGlzYWJsZWQgPT09IHQ7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHZlKGEpIHtcblx0ICAgICAgcmV0dXJuIGxlKGZ1bmN0aW9uIChvKSB7XG5cdCAgICAgICAgcmV0dXJuIG8gPSArbywgbGUoZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICAgIHZhciBuLFxuXHQgICAgICAgICAgICAgIHIgPSBhKFtdLCBlLmxlbmd0aCwgbyksXG5cdCAgICAgICAgICAgICAgaSA9IHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICB3aGlsZSAoaS0tKSBlW24gPSByW2ldXSAmJiAoZVtuXSA9ICEodFtuXSA9IGVbbl0pKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHllKGUpIHtcblx0ICAgICAgcmV0dXJuIGUgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSAmJiBlO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKGUgaW4gZCA9IHNlLnN1cHBvcnQgPSB7fSwgaSA9IHNlLmlzWE1MID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQgPSBlICYmIGUubmFtZXNwYWNlVVJJLFxuXHQgICAgICAgICAgbiA9IGUgJiYgKGUub3duZXJEb2N1bWVudCB8fCBlKS5kb2N1bWVudEVsZW1lbnQ7XG5cdCAgICAgIHJldHVybiAhWS50ZXN0KHQgfHwgbiAmJiBuLm5vZGVOYW1lIHx8IFwiSFRNTFwiKTtcblx0ICAgIH0sIFQgPSBzZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0LFxuXHQgICAgICAgICAgbixcblx0ICAgICAgICAgIHIgPSBlID8gZS5vd25lckRvY3VtZW50IHx8IGUgOiBwO1xuXHQgICAgICByZXR1cm4gciAhPSBDICYmIDkgPT09IHIubm9kZVR5cGUgJiYgci5kb2N1bWVudEVsZW1lbnQgJiYgKGEgPSAoQyA9IHIpLmRvY3VtZW50RWxlbWVudCwgRSA9ICFpKEMpLCBwICE9IEMgJiYgKG4gPSBDLmRlZmF1bHRWaWV3KSAmJiBuLnRvcCAhPT0gbiAmJiAobi5hZGRFdmVudExpc3RlbmVyID8gbi5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIG9lLCAhMSkgOiBuLmF0dGFjaEV2ZW50ICYmIG4uYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLCBvZSkpLCBkLnNjb3BlID0gY2UoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICByZXR1cm4gYS5hcHBlbmRDaGlsZChlKS5hcHBlbmRDaGlsZChDLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBlLnF1ZXJ5U2VsZWN0b3JBbGwgJiYgIWUucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSBmaWVsZHNldCBkaXZcIikubGVuZ3RoO1xuXHQgICAgICB9KSwgZC5hdHRyaWJ1dGVzID0gY2UoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICByZXR1cm4gZS5jbGFzc05hbWUgPSBcImlcIiwgIWUuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHQgICAgICB9KSwgZC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGNlKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIGUuYXBwZW5kQ2hpbGQoQy5jcmVhdGVDb21tZW50KFwiXCIpKSwgIWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0ICAgICAgfSksIGQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IEsudGVzdChDLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLCBkLmdldEJ5SWQgPSBjZShmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHJldHVybiBhLmFwcGVuZENoaWxkKGUpLmlkID0gUywgIUMuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIUMuZ2V0RWxlbWVudHNCeU5hbWUoUykubGVuZ3RoO1xuXHQgICAgICB9KSwgZC5nZXRCeUlkID8gKGIuZmlsdGVyLklEID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdCA9IGUucmVwbGFjZSh0ZSwgbmUpO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IHQ7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfSwgYi5maW5kLklEID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgdC5nZXRFbGVtZW50QnlJZCAmJiBFKSB7XG5cdCAgICAgICAgICB2YXIgbiA9IHQuZ2V0RWxlbWVudEJ5SWQoZSk7XG5cdCAgICAgICAgICByZXR1cm4gbiA/IFtuXSA6IFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSkgOiAoYi5maWx0ZXIuSUQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciBuID0gZS5yZXBsYWNlKHRlLCBuZSk7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGUuZ2V0QXR0cmlidXRlTm9kZSAmJiBlLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0ICAgICAgICAgIHJldHVybiB0ICYmIHQudmFsdWUgPT09IG47XG5cdCAgICAgICAgfTtcblx0ICAgICAgfSwgYi5maW5kLklEID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgdC5nZXRFbGVtZW50QnlJZCAmJiBFKSB7XG5cdCAgICAgICAgICB2YXIgbixcblx0ICAgICAgICAgICAgICByLFxuXHQgICAgICAgICAgICAgIGksXG5cdCAgICAgICAgICAgICAgbyA9IHQuZ2V0RWxlbWVudEJ5SWQoZSk7XG5cblx0ICAgICAgICAgIGlmIChvKSB7XG5cdCAgICAgICAgICAgIGlmICgobiA9IG8uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpKSAmJiBuLnZhbHVlID09PSBlKSByZXR1cm4gW29dO1xuXHQgICAgICAgICAgICBpID0gdC5nZXRFbGVtZW50c0J5TmFtZShlKSwgciA9IDA7XG5cblx0ICAgICAgICAgICAgd2hpbGUgKG8gPSBpW3IrK10pIGlmICgobiA9IG8uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpKSAmJiBuLnZhbHVlID09PSBlKSByZXR1cm4gW29dO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgfVxuXHQgICAgICB9KSwgYi5maW5kLlRBRyA9IGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gdC5nZXRFbGVtZW50c0J5VGFnTmFtZShlKSA6IGQucXNhID8gdC5xdWVyeVNlbGVjdG9yQWxsKGUpIDogdm9pZCAwO1xuXHQgICAgICB9IDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICB2YXIgbixcblx0ICAgICAgICAgICAgciA9IFtdLFxuXHQgICAgICAgICAgICBpID0gMCxcblx0ICAgICAgICAgICAgbyA9IHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk7XG5cblx0ICAgICAgICBpZiAoXCIqXCIgPT09IGUpIHtcblx0ICAgICAgICAgIHdoaWxlIChuID0gb1tpKytdKSAxID09PSBuLm5vZGVUeXBlICYmIHIucHVzaChuKTtcblxuXHQgICAgICAgICAgcmV0dXJuIHI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG87XG5cdCAgICAgIH0sIGIuZmluZC5DTEFTUyA9IGQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgRSkgcmV0dXJuIHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShlKTtcblx0ICAgICAgfSwgcyA9IFtdLCB2ID0gW10sIChkLnFzYSA9IEsudGVzdChDLnF1ZXJ5U2VsZWN0b3JBbGwpKSAmJiAoY2UoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdDtcblx0ICAgICAgICBhLmFwcGVuZENoaWxkKGUpLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgUyArIFwiJz48L2E+PHNlbGVjdCBpZD0nXCIgKyBTICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIiwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICYmIHYucHVzaChcIlsqXiRdPVwiICsgTSArIFwiKig/OicnfFxcXCJcXFwiKVwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggfHwgdi5wdXNoKFwiXFxcXFtcIiArIE0gKyBcIiooPzp2YWx1ZXxcIiArIFIgKyBcIilcIiksIGUucXVlcnlTZWxlY3RvckFsbChcIltpZH49XCIgKyBTICsgXCItXVwiKS5sZW5ndGggfHwgdi5wdXNoKFwifj1cIiksICh0ID0gQy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJcIiksIGUuYXBwZW5kQ2hpbGQodCksIGUucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPScnXVwiKS5sZW5ndGggfHwgdi5wdXNoKFwiXFxcXFtcIiArIE0gKyBcIipuYW1lXCIgKyBNICsgXCIqPVwiICsgTSArIFwiKig/OicnfFxcXCJcXFwiKVwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoIHx8IHYucHVzaChcIjpjaGVja2VkXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhI1wiICsgUyArIFwiKypcIikubGVuZ3RoIHx8IHYucHVzaChcIi4jLitbK35dXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJcXFxcXFxmXCIpLCB2LnB1c2goXCJbXFxcXHJcXFxcblxcXFxmXVwiKTtcblx0ICAgICAgfSksIGNlKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgZS5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+PHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXHQgICAgICAgIHZhciB0ID0gQy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdCAgICAgICAgdC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpLCBlLmFwcGVuZENoaWxkKHQpLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJEXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggJiYgdi5wdXNoKFwibmFtZVwiICsgTSArIFwiKlsqXiR8IX5dPz1cIiksIDIgIT09IGUucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAmJiB2LnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKSwgYS5hcHBlbmRDaGlsZChlKS5kaXNhYmxlZCA9ICEwLCAyICE9PSBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICYmIHYucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpLCB2LnB1c2goXCIsLio6XCIpO1xuXHQgICAgICB9KSksIChkLm1hdGNoZXNTZWxlY3RvciA9IEsudGVzdChjID0gYS5tYXRjaGVzIHx8IGEud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGEubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGEub01hdGNoZXNTZWxlY3RvciB8fCBhLm1zTWF0Y2hlc1NlbGVjdG9yKSkgJiYgY2UoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBkLmRpc2Nvbm5lY3RlZE1hdGNoID0gYy5jYWxsKGUsIFwiKlwiKSwgYy5jYWxsKGUsIFwiW3MhPScnXTp4XCIpLCBzLnB1c2goXCIhPVwiLCBGKTtcblx0ICAgICAgfSksIHYgPSB2Lmxlbmd0aCAmJiBuZXcgUmVnRXhwKHYuam9pbihcInxcIikpLCBzID0gcy5sZW5ndGggJiYgbmV3IFJlZ0V4cChzLmpvaW4oXCJ8XCIpKSwgdCA9IEsudGVzdChhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSwgeSA9IHQgfHwgSy50ZXN0KGEuY29udGFpbnMpID8gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IDkgPT09IGUubm9kZVR5cGUgPyBlLmRvY3VtZW50RWxlbWVudCA6IGUsXG5cdCAgICAgICAgICAgIHIgPSB0ICYmIHQucGFyZW50Tm9kZTtcblx0ICAgICAgICByZXR1cm4gZSA9PT0gciB8fCAhKCFyIHx8IDEgIT09IHIubm9kZVR5cGUgfHwgIShuLmNvbnRhaW5zID8gbi5jb250YWlucyhyKSA6IGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgMTYgJiBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHIpKSk7XG5cdCAgICAgIH0gOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIGlmICh0KSB3aGlsZSAodCA9IHQucGFyZW50Tm9kZSkgaWYgKHQgPT09IGUpIHJldHVybiAhMDtcblx0ICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgIH0sIGogPSB0ID8gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICBpZiAoZSA9PT0gdCkgcmV0dXJuIGwgPSAhMCwgMDtcblx0ICAgICAgICB2YXIgbiA9ICFlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIXQuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdCAgICAgICAgcmV0dXJuIG4gfHwgKDEgJiAobiA9IChlLm93bmVyRG9jdW1lbnQgfHwgZSkgPT0gKHQub3duZXJEb2N1bWVudCB8fCB0KSA/IGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24odCkgOiAxKSB8fCAhZC5zb3J0RGV0YWNoZWQgJiYgdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlKSA9PT0gbiA/IGUgPT0gQyB8fCBlLm93bmVyRG9jdW1lbnQgPT0gcCAmJiB5KHAsIGUpID8gLTEgOiB0ID09IEMgfHwgdC5vd25lckRvY3VtZW50ID09IHAgJiYgeShwLCB0KSA/IDEgOiB1ID8gUCh1LCBlKSAtIFAodSwgdCkgOiAwIDogNCAmIG4gPyAtMSA6IDEpO1xuXHQgICAgICB9IDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICBpZiAoZSA9PT0gdCkgcmV0dXJuIGwgPSAhMCwgMDtcblx0ICAgICAgICB2YXIgbixcblx0ICAgICAgICAgICAgciA9IDAsXG5cdCAgICAgICAgICAgIGkgPSBlLnBhcmVudE5vZGUsXG5cdCAgICAgICAgICAgIG8gPSB0LnBhcmVudE5vZGUsXG5cdCAgICAgICAgICAgIGEgPSBbZV0sXG5cdCAgICAgICAgICAgIHMgPSBbdF07XG5cdCAgICAgICAgaWYgKCFpIHx8ICFvKSByZXR1cm4gZSA9PSBDID8gLTEgOiB0ID09IEMgPyAxIDogaSA/IC0xIDogbyA/IDEgOiB1ID8gUCh1LCBlKSAtIFAodSwgdCkgOiAwO1xuXHQgICAgICAgIGlmIChpID09PSBvKSByZXR1cm4gcGUoZSwgdCk7XG5cdCAgICAgICAgbiA9IGU7XG5cblx0ICAgICAgICB3aGlsZSAobiA9IG4ucGFyZW50Tm9kZSkgYS51bnNoaWZ0KG4pO1xuXG5cdCAgICAgICAgbiA9IHQ7XG5cblx0ICAgICAgICB3aGlsZSAobiA9IG4ucGFyZW50Tm9kZSkgcy51bnNoaWZ0KG4pO1xuXG5cdCAgICAgICAgd2hpbGUgKGFbcl0gPT09IHNbcl0pIHIrKztcblxuXHQgICAgICAgIHJldHVybiByID8gcGUoYVtyXSwgc1tyXSkgOiBhW3JdID09IHAgPyAtMSA6IHNbcl0gPT0gcCA/IDEgOiAwO1xuXHQgICAgICB9KSwgQztcblx0ICAgIH0sIHNlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gc2UoZSwgbnVsbCwgbnVsbCwgdCk7XG5cdCAgICB9LCBzZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICBpZiAoVChlKSwgZC5tYXRjaGVzU2VsZWN0b3IgJiYgRSAmJiAhTlt0ICsgXCIgXCJdICYmICghcyB8fCAhcy50ZXN0KHQpKSAmJiAoIXYgfHwgIXYudGVzdCh0KSkpIHRyeSB7XG5cdCAgICAgICAgdmFyIG4gPSBjLmNhbGwoZSwgdCk7XG5cdCAgICAgICAgaWYgKG4gfHwgZC5kaXNjb25uZWN0ZWRNYXRjaCB8fCBlLmRvY3VtZW50ICYmIDExICE9PSBlLmRvY3VtZW50Lm5vZGVUeXBlKSByZXR1cm4gbjtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIE4odCwgITApO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAwIDwgc2UodCwgQywgbnVsbCwgW2VdKS5sZW5ndGg7XG5cdCAgICB9LCBzZS5jb250YWlucyA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiAoZS5vd25lckRvY3VtZW50IHx8IGUpICE9IEMgJiYgVChlKSwgeShlLCB0KTtcblx0ICAgIH0sIHNlLmF0dHIgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAoZS5vd25lckRvY3VtZW50IHx8IGUpICE9IEMgJiYgVChlKTtcblx0ICAgICAgdmFyIG4gPSBiLmF0dHJIYW5kbGVbdC50b0xvd2VyQ2FzZSgpXSxcblx0ICAgICAgICAgIHIgPSBuICYmIEQuY2FsbChiLmF0dHJIYW5kbGUsIHQudG9Mb3dlckNhc2UoKSkgPyBuKGUsIHQsICFFKSA6IHZvaWQgMDtcblx0ICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gciA/IHIgOiBkLmF0dHJpYnV0ZXMgfHwgIUUgPyBlLmdldEF0dHJpYnV0ZSh0KSA6IChyID0gZS5nZXRBdHRyaWJ1dGVOb2RlKHQpKSAmJiByLnNwZWNpZmllZCA/IHIudmFsdWUgOiBudWxsO1xuXHQgICAgfSwgc2UuZXNjYXBlID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIChlICsgXCJcIikucmVwbGFjZShyZSwgaWUpO1xuXHQgICAgfSwgc2UuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIGUpO1xuXHQgICAgfSwgc2UudW5pcXVlU29ydCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0LFxuXHQgICAgICAgICAgbiA9IFtdLFxuXHQgICAgICAgICAgciA9IDAsXG5cdCAgICAgICAgICBpID0gMDtcblxuXHQgICAgICBpZiAobCA9ICFkLmRldGVjdER1cGxpY2F0ZXMsIHUgPSAhZC5zb3J0U3RhYmxlICYmIGUuc2xpY2UoMCksIGUuc29ydChqKSwgbCkge1xuXHQgICAgICAgIHdoaWxlICh0ID0gZVtpKytdKSB0ID09PSBlW2ldICYmIChyID0gbi5wdXNoKGkpKTtcblxuXHQgICAgICAgIHdoaWxlIChyLS0pIGUuc3BsaWNlKG5bcl0sIDEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHUgPSBudWxsLCBlO1xuXHQgICAgfSwgbyA9IHNlLmdldFRleHQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdCxcblx0ICAgICAgICAgIG4gPSBcIlwiLFxuXHQgICAgICAgICAgciA9IDAsXG5cdCAgICAgICAgICBpID0gZS5ub2RlVHlwZTtcblxuXHQgICAgICBpZiAoaSkge1xuXHQgICAgICAgIGlmICgxID09PSBpIHx8IDkgPT09IGkgfHwgMTEgPT09IGkpIHtcblx0ICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlLnRleHRDb250ZW50KSByZXR1cm4gZS50ZXh0Q29udGVudDtcblxuXHQgICAgICAgICAgZm9yIChlID0gZS5maXJzdENoaWxkOyBlOyBlID0gZS5uZXh0U2libGluZykgbiArPSBvKGUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoMyA9PT0gaSB8fCA0ID09PSBpKSByZXR1cm4gZS5ub2RlVmFsdWU7XG5cdCAgICAgIH0gZWxzZSB3aGlsZSAodCA9IGVbcisrXSkgbiArPSBvKHQpO1xuXG5cdCAgICAgIHJldHVybiBuO1xuXHQgICAgfSwgKGIgPSBzZS5zZWxlY3RvcnMgPSB7XG5cdCAgICAgIGNhY2hlTGVuZ3RoOiA1MCxcblx0ICAgICAgY3JlYXRlUHNldWRvOiBsZSxcblx0ICAgICAgbWF0Y2g6IEcsXG5cdCAgICAgIGF0dHJIYW5kbGU6IHt9LFxuXHQgICAgICBmaW5kOiB7fSxcblx0ICAgICAgcmVsYXRpdmU6IHtcblx0ICAgICAgICBcIj5cIjoge1xuXHQgICAgICAgICAgZGlyOiBcInBhcmVudE5vZGVcIixcblx0ICAgICAgICAgIGZpcnN0OiAhMFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgXCIgXCI6IHtcblx0ICAgICAgICAgIGRpcjogXCJwYXJlbnROb2RlXCJcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFwiK1wiOiB7XG5cdCAgICAgICAgICBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdCAgICAgICAgICBmaXJzdDogITBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFwiflwiOiB7XG5cdCAgICAgICAgICBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCJcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIHByZUZpbHRlcjoge1xuXHQgICAgICAgIEFUVFI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gZVsxXSA9IGVbMV0ucmVwbGFjZSh0ZSwgbmUpLCBlWzNdID0gKGVbM10gfHwgZVs0XSB8fCBlWzVdIHx8IFwiXCIpLnJlcGxhY2UodGUsIG5lKSwgXCJ+PVwiID09PSBlWzJdICYmIChlWzNdID0gXCIgXCIgKyBlWzNdICsgXCIgXCIpLCBlLnNsaWNlKDAsIDQpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgQ0hJTEQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gZVsxXSA9IGVbMV0udG9Mb3dlckNhc2UoKSwgXCJudGhcIiA9PT0gZVsxXS5zbGljZSgwLCAzKSA/IChlWzNdIHx8IHNlLmVycm9yKGVbMF0pLCBlWzRdID0gKyhlWzRdID8gZVs1XSArIChlWzZdIHx8IDEpIDogMiAqIChcImV2ZW5cIiA9PT0gZVszXSB8fCBcIm9kZFwiID09PSBlWzNdKSksIGVbNV0gPSArKGVbN10gKyBlWzhdIHx8IFwib2RkXCIgPT09IGVbM10pKSA6IGVbM10gJiYgc2UuZXJyb3IoZVswXSksIGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBQU0VVRE86IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdCxcblx0ICAgICAgICAgICAgICBuID0gIWVbNl0gJiYgZVsyXTtcblx0ICAgICAgICAgIHJldHVybiBHLkNISUxELnRlc3QoZVswXSkgPyBudWxsIDogKGVbM10gPyBlWzJdID0gZVs0XSB8fCBlWzVdIHx8IFwiXCIgOiBuICYmIFgudGVzdChuKSAmJiAodCA9IGgobiwgITApKSAmJiAodCA9IG4uaW5kZXhPZihcIilcIiwgbi5sZW5ndGggLSB0KSAtIG4ubGVuZ3RoKSAmJiAoZVswXSA9IGVbMF0uc2xpY2UoMCwgdCksIGVbMl0gPSBuLnNsaWNlKDAsIHQpKSwgZS5zbGljZSgwLCAzKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBmaWx0ZXI6IHtcblx0ICAgICAgICBUQUc6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdCA9IGUucmVwbGFjZSh0ZSwgbmUpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICByZXR1cm4gXCIqXCIgPT09IGUgPyBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAhMDtcblx0ICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZS5ub2RlTmFtZSAmJiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHQ7XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgQ0xBU1M6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdCA9IG1bZSArIFwiIFwiXTtcblx0ICAgICAgICAgIHJldHVybiB0IHx8ICh0ID0gbmV3IFJlZ0V4cChcIihefFwiICsgTSArIFwiKVwiICsgZSArIFwiKFwiICsgTSArIFwifCQpXCIpKSAmJiBtKGUsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0LnRlc3QoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZS5jbGFzc05hbWUgJiYgZS5jbGFzc05hbWUgfHwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRBdHRyaWJ1dGUgJiYgZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgQVRUUjogZnVuY3Rpb24gKG4sIHIsIGkpIHtcblx0ICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICB2YXIgdCA9IHNlLmF0dHIoZSwgbik7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsID09IHQgPyBcIiE9XCIgPT09IHIgOiAhciB8fCAodCArPSBcIlwiLCBcIj1cIiA9PT0gciA/IHQgPT09IGkgOiBcIiE9XCIgPT09IHIgPyB0ICE9PSBpIDogXCJePVwiID09PSByID8gaSAmJiAwID09PSB0LmluZGV4T2YoaSkgOiBcIio9XCIgPT09IHIgPyBpICYmIC0xIDwgdC5pbmRleE9mKGkpIDogXCIkPVwiID09PSByID8gaSAmJiB0LnNsaWNlKC1pLmxlbmd0aCkgPT09IGkgOiBcIn49XCIgPT09IHIgPyAtMSA8IChcIiBcIiArIHQucmVwbGFjZShCLCBcIiBcIikgKyBcIiBcIikuaW5kZXhPZihpKSA6IFwifD1cIiA9PT0gciAmJiAodCA9PT0gaSB8fCB0LnNsaWNlKDAsIGkubGVuZ3RoICsgMSkgPT09IGkgKyBcIi1cIikpO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIENISUxEOiBmdW5jdGlvbiAoaCwgZSwgdCwgZywgdikge1xuXHQgICAgICAgICAgdmFyIHkgPSBcIm50aFwiICE9PSBoLnNsaWNlKDAsIDMpLFxuXHQgICAgICAgICAgICAgIG0gPSBcImxhc3RcIiAhPT0gaC5zbGljZSgtNCksXG5cdCAgICAgICAgICAgICAgeCA9IFwib2YtdHlwZVwiID09PSBlO1xuXHQgICAgICAgICAgcmV0dXJuIDEgPT09IGcgJiYgMCA9PT0gdiA/IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAhIWUucGFyZW50Tm9kZTtcblx0ICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICAgICAgICB2YXIgcixcblx0ICAgICAgICAgICAgICAgIGksXG5cdCAgICAgICAgICAgICAgICBvLFxuXHQgICAgICAgICAgICAgICAgYSxcblx0ICAgICAgICAgICAgICAgIHMsXG5cdCAgICAgICAgICAgICAgICB1LFxuXHQgICAgICAgICAgICAgICAgbCA9IHkgIT09IG0gPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHQgICAgICAgICAgICAgICAgYyA9IGUucGFyZW50Tm9kZSxcblx0ICAgICAgICAgICAgICAgIGYgPSB4ICYmIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0ICAgICAgICAgICAgICAgIHAgPSAhbiAmJiAheCxcblx0ICAgICAgICAgICAgICAgIGQgPSAhMTtcblxuXHQgICAgICAgICAgICBpZiAoYykge1xuXHQgICAgICAgICAgICAgIGlmICh5KSB7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAobCkge1xuXHQgICAgICAgICAgICAgICAgICBhID0gZTtcblxuXHQgICAgICAgICAgICAgICAgICB3aGlsZSAoYSA9IGFbbF0pIGlmICh4ID8gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBmIDogMSA9PT0gYS5ub2RlVHlwZSkgcmV0dXJuICExO1xuXG5cdCAgICAgICAgICAgICAgICAgIHUgPSBsID0gXCJvbmx5XCIgPT09IGggJiYgIXUgJiYgXCJuZXh0U2libGluZ1wiO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgaWYgKHUgPSBbbSA/IGMuZmlyc3RDaGlsZCA6IGMubGFzdENoaWxkXSwgbSAmJiBwKSB7XG5cdCAgICAgICAgICAgICAgICBkID0gKHMgPSAociA9IChpID0gKG8gPSAoYSA9IGMpW1NdIHx8IChhW1NdID0ge30pKVthLnVuaXF1ZUlEXSB8fCAob1thLnVuaXF1ZUlEXSA9IHt9KSlbaF0gfHwgW10pWzBdID09PSBrICYmIHJbMV0pICYmIHJbMl0sIGEgPSBzICYmIGMuY2hpbGROb2Rlc1tzXTtcblxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGEgPSArK3MgJiYgYSAmJiBhW2xdIHx8IChkID0gcyA9IDApIHx8IHUucG9wKCkpIGlmICgxID09PSBhLm5vZGVUeXBlICYmICsrZCAmJiBhID09PSBlKSB7XG5cdCAgICAgICAgICAgICAgICAgIGlbaF0gPSBbaywgcywgZF07XG5cdCAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH0gZWxzZSBpZiAocCAmJiAoZCA9IHMgPSAociA9IChpID0gKG8gPSAoYSA9IGUpW1NdIHx8IChhW1NdID0ge30pKVthLnVuaXF1ZUlEXSB8fCAob1thLnVuaXF1ZUlEXSA9IHt9KSlbaF0gfHwgW10pWzBdID09PSBrICYmIHJbMV0pLCAhMSA9PT0gZCkgd2hpbGUgKGEgPSArK3MgJiYgYSAmJiBhW2xdIHx8IChkID0gcyA9IDApIHx8IHUucG9wKCkpIGlmICgoeCA/IGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZiA6IDEgPT09IGEubm9kZVR5cGUpICYmICsrZCAmJiAocCAmJiAoKGkgPSAobyA9IGFbU10gfHwgKGFbU10gPSB7fSkpW2EudW5pcXVlSURdIHx8IChvW2EudW5pcXVlSURdID0ge30pKVtoXSA9IFtrLCBkXSksIGEgPT09IGUpKSBicmVhaztcblxuXHQgICAgICAgICAgICAgIHJldHVybiAoZCAtPSB2KSA9PT0gZyB8fCBkICUgZyA9PSAwICYmIDAgPD0gZCAvIGc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBQU0VVRE86IGZ1bmN0aW9uIChlLCBvKSB7XG5cdCAgICAgICAgICB2YXIgdCxcblx0ICAgICAgICAgICAgICBhID0gYi5wc2V1ZG9zW2VdIHx8IGIuc2V0RmlsdGVyc1tlLnRvTG93ZXJDYXNlKCldIHx8IHNlLmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIGUpO1xuXHQgICAgICAgICAgcmV0dXJuIGFbU10gPyBhKG8pIDogMSA8IGEubGVuZ3RoID8gKHQgPSBbZSwgZSwgXCJcIiwgb10sIGIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShlLnRvTG93ZXJDYXNlKCkpID8gbGUoZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICAgICAgdmFyIG4sXG5cdCAgICAgICAgICAgICAgICByID0gYShlLCBvKSxcblx0ICAgICAgICAgICAgICAgIGkgPSByLmxlbmd0aDtcblxuXHQgICAgICAgICAgICB3aGlsZSAoaS0tKSBlW24gPSBQKGUsIHJbaV0pXSA9ICEodFtuXSA9IHJbaV0pO1xuXHQgICAgICAgICAgfSkgOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gYShlLCAwLCB0KTtcblx0ICAgICAgICAgIH0pIDogYTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIHBzZXVkb3M6IHtcblx0ICAgICAgICBub3Q6IGxlKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgciA9IFtdLFxuXHQgICAgICAgICAgICAgIGkgPSBbXSxcblx0ICAgICAgICAgICAgICBzID0gZihlLnJlcGxhY2UoJCwgXCIkMVwiKSk7XG5cdCAgICAgICAgICByZXR1cm4gc1tTXSA/IGxlKGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG5cdCAgICAgICAgICAgIHZhciBpLFxuXHQgICAgICAgICAgICAgICAgbyA9IHMoZSwgbnVsbCwgciwgW10pLFxuXHQgICAgICAgICAgICAgICAgYSA9IGUubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIHdoaWxlIChhLS0pIChpID0gb1thXSkgJiYgKGVbYV0gPSAhKHRbYV0gPSBpKSk7XG5cdCAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiByWzBdID0gZSwgcyhyLCBudWxsLCBuLCBpKSwgclswXSA9IG51bGwsICFpLnBvcCgpO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBoYXM6IGxlKGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDAgPCBzZSh0LCBlKS5sZW5ndGg7XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIGNvbnRhaW5zOiBsZShmdW5jdGlvbiAodCkge1xuXHQgICAgICAgICAgcmV0dXJuIHQgPSB0LnJlcGxhY2UodGUsIG5lKSwgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIC0xIDwgKGUudGV4dENvbnRlbnQgfHwgbyhlKSkuaW5kZXhPZih0KTtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgbGFuZzogbGUoZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgIHJldHVybiBWLnRlc3QobiB8fCBcIlwiKSB8fCBzZS5lcnJvcihcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbiksIG4gPSBuLnJlcGxhY2UodGUsIG5lKS50b0xvd2VyQ2FzZSgpLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICB2YXIgdDtcblxuXHQgICAgICAgICAgICBkbyB7XG5cdCAgICAgICAgICAgICAgaWYgKHQgPSBFID8gZS5sYW5nIDogZS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlLmdldEF0dHJpYnV0ZShcImxhbmdcIikpIHJldHVybiAodCA9IHQudG9Mb3dlckNhc2UoKSkgPT09IG4gfHwgMCA9PT0gdC5pbmRleE9mKG4gKyBcIi1cIik7XG5cdCAgICAgICAgICAgIH0gd2hpbGUgKChlID0gZS5wYXJlbnROb2RlKSAmJiAxID09PSBlLm5vZGVUeXBlKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIHRhcmdldDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciB0ID0gbi5sb2NhdGlvbiAmJiBuLmxvY2F0aW9uLmhhc2g7XG5cdCAgICAgICAgICByZXR1cm4gdCAmJiB0LnNsaWNlKDEpID09PSBlLmlkO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcm9vdDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiBlID09PSBhO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gZSA9PT0gQy5hY3RpdmVFbGVtZW50ICYmICghQy5oYXNGb2N1cyB8fCBDLmhhc0ZvY3VzKCkpICYmICEhKGUudHlwZSB8fCBlLmhyZWYgfHwgfmUudGFiSW5kZXgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW5hYmxlZDogZ2UoITEpLFxuXHQgICAgICAgIGRpc2FibGVkOiBnZSghMCksXG5cdCAgICAgICAgY2hlY2tlZDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciB0ID0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgcmV0dXJuIFwiaW5wdXRcIiA9PT0gdCAmJiAhIWUuY2hlY2tlZCB8fCBcIm9wdGlvblwiID09PSB0ICYmICEhZS5zZWxlY3RlZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGUucGFyZW50Tm9kZSAmJiBlLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgITAgPT09IGUuc2VsZWN0ZWQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbXB0eTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIGZvciAoZSA9IGUuZmlyc3RDaGlsZDsgZTsgZSA9IGUubmV4dFNpYmxpbmcpIGlmIChlLm5vZGVUeXBlIDwgNikgcmV0dXJuICExO1xuXG5cdCAgICAgICAgICByZXR1cm4gITA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gIWIucHNldWRvcy5lbXB0eShlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGhlYWRlcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiBKLnRlc3QoZS5ub2RlTmFtZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBpbnB1dDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiBRLnRlc3QoZS5ub2RlTmFtZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBidXR0b246IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdCA9IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICAgIHJldHVybiBcImlucHV0XCIgPT09IHQgJiYgXCJidXR0b25cIiA9PT0gZS50eXBlIHx8IFwiYnV0dG9uXCIgPT09IHQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB0ZXh0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQ7XG5cdCAgICAgICAgICByZXR1cm4gXCJpbnB1dFwiID09PSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgJiYgXCJ0ZXh0XCIgPT09IGUudHlwZSAmJiAobnVsbCA9PSAodCA9IGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgfHwgXCJ0ZXh0XCIgPT09IHQudG9Mb3dlckNhc2UoKSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmaXJzdDogdmUoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgcmV0dXJuIFswXTtcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBsYXN0OiB2ZShmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgICAgcmV0dXJuIFt0IC0gMV07XG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgZXE6IHZlKGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgICByZXR1cm4gW24gPCAwID8gbiArIHQgOiBuXTtcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBldmVuOiB2ZShmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0OyBuICs9IDIpIGUucHVzaChuKTtcblxuXHQgICAgICAgICAgcmV0dXJuIGU7XG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgb2RkOiB2ZShmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgICAgZm9yICh2YXIgbiA9IDE7IG4gPCB0OyBuICs9IDIpIGUucHVzaChuKTtcblxuXHQgICAgICAgICAgcmV0dXJuIGU7XG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgbHQ6IHZlKGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgICBmb3IgKHZhciByID0gbiA8IDAgPyBuICsgdCA6IHQgPCBuID8gdCA6IG47IDAgPD0gLS1yOykgZS5wdXNoKHIpO1xuXG5cdCAgICAgICAgICByZXR1cm4gZTtcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBndDogdmUoZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgICAgIGZvciAodmFyIHIgPSBuIDwgMCA/IG4gKyB0IDogbjsgKytyIDwgdDspIGUucHVzaChyKTtcblxuXHQgICAgICAgICAgcmV0dXJuIGU7XG5cdCAgICAgICAgfSlcblx0ICAgICAgfVxuXHQgICAgfSkucHNldWRvcy5udGggPSBiLnBzZXVkb3MuZXEsIHtcblx0ICAgICAgcmFkaW86ICEwLFxuXHQgICAgICBjaGVja2JveDogITAsXG5cdCAgICAgIGZpbGU6ICEwLFxuXHQgICAgICBwYXNzd29yZDogITAsXG5cdCAgICAgIGltYWdlOiAhMFxuXHQgICAgfSkgYi5wc2V1ZG9zW2VdID0gZGUoZSk7XG5cblx0ICAgIGZvciAoZSBpbiB7XG5cdCAgICAgIHN1Ym1pdDogITAsXG5cdCAgICAgIHJlc2V0OiAhMFxuXHQgICAgfSkgYi5wc2V1ZG9zW2VdID0gaGUoZSk7XG5cblx0ICAgIGZ1bmN0aW9uIG1lKCkge31cblxuXHQgICAgZnVuY3Rpb24geGUoZSkge1xuXHQgICAgICBmb3IgKHZhciB0ID0gMCwgbiA9IGUubGVuZ3RoLCByID0gXCJcIjsgdCA8IG47IHQrKykgciArPSBlW3RdLnZhbHVlO1xuXG5cdCAgICAgIHJldHVybiByO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBiZShzLCBlLCB0KSB7XG5cdCAgICAgIHZhciB1ID0gZS5kaXIsXG5cdCAgICAgICAgICBsID0gZS5uZXh0LFxuXHQgICAgICAgICAgYyA9IGwgfHwgdSxcblx0ICAgICAgICAgIGYgPSB0ICYmIFwicGFyZW50Tm9kZVwiID09PSBjLFxuXHQgICAgICAgICAgcCA9IHIrKztcblx0ICAgICAgcmV0dXJuIGUuZmlyc3QgPyBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICAgIHdoaWxlIChlID0gZVt1XSkgaWYgKDEgPT09IGUubm9kZVR5cGUgfHwgZikgcmV0dXJuIHMoZSwgdCwgbik7XG5cblx0ICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgIH0gOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICAgIHZhciByLFxuXHQgICAgICAgICAgICBpLFxuXHQgICAgICAgICAgICBvLFxuXHQgICAgICAgICAgICBhID0gW2ssIHBdO1xuXG5cdCAgICAgICAgaWYgKG4pIHtcblx0ICAgICAgICAgIHdoaWxlIChlID0gZVt1XSkgaWYgKCgxID09PSBlLm5vZGVUeXBlIHx8IGYpICYmIHMoZSwgdCwgbikpIHJldHVybiAhMDtcblx0ICAgICAgICB9IGVsc2Ugd2hpbGUgKGUgPSBlW3VdKSBpZiAoMSA9PT0gZS5ub2RlVHlwZSB8fCBmKSBpZiAoaSA9IChvID0gZVtTXSB8fCAoZVtTXSA9IHt9KSlbZS51bmlxdWVJRF0gfHwgKG9bZS51bmlxdWVJRF0gPSB7fSksIGwgJiYgbCA9PT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSBlID0gZVt1XSB8fCBlO2Vsc2Uge1xuXHQgICAgICAgICAgaWYgKChyID0gaVtjXSkgJiYgclswXSA9PT0gayAmJiByWzFdID09PSBwKSByZXR1cm4gYVsyXSA9IHJbMl07XG5cdCAgICAgICAgICBpZiAoKGlbY10gPSBhKVsyXSA9IHMoZSwgdCwgbikpIHJldHVybiAhMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHdlKGkpIHtcblx0ICAgICAgcmV0dXJuIDEgPCBpLmxlbmd0aCA/IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgdmFyIHIgPSBpLmxlbmd0aDtcblxuXHQgICAgICAgIHdoaWxlIChyLS0pIGlmICghaVtyXShlLCB0LCBuKSkgcmV0dXJuICExO1xuXG5cdCAgICAgICAgcmV0dXJuICEwO1xuXHQgICAgICB9IDogaVswXTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gVGUoZSwgdCwgbiwgciwgaSkge1xuXHQgICAgICBmb3IgKHZhciBvLCBhID0gW10sIHMgPSAwLCB1ID0gZS5sZW5ndGgsIGwgPSBudWxsICE9IHQ7IHMgPCB1OyBzKyspIChvID0gZVtzXSkgJiYgKG4gJiYgIW4obywgciwgaSkgfHwgKGEucHVzaChvKSwgbCAmJiB0LnB1c2gocykpKTtcblxuXHQgICAgICByZXR1cm4gYTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gQ2UoZCwgaCwgZywgdiwgeSwgZSkge1xuXHQgICAgICByZXR1cm4gdiAmJiAhdltTXSAmJiAodiA9IENlKHYpKSwgeSAmJiAheVtTXSAmJiAoeSA9IENlKHksIGUpKSwgbGUoZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcblx0ICAgICAgICB2YXIgaSxcblx0ICAgICAgICAgICAgbyxcblx0ICAgICAgICAgICAgYSxcblx0ICAgICAgICAgICAgcyA9IFtdLFxuXHQgICAgICAgICAgICB1ID0gW10sXG5cdCAgICAgICAgICAgIGwgPSB0Lmxlbmd0aCxcblx0ICAgICAgICAgICAgYyA9IGUgfHwgZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBpID0gdC5sZW5ndGg7IHIgPCBpOyByKyspIHNlKGUsIHRbcl0sIG4pO1xuXG5cdCAgICAgICAgICByZXR1cm4gbjtcblx0ICAgICAgICB9KGggfHwgXCIqXCIsIG4ubm9kZVR5cGUgPyBbbl0gOiBuLCBbXSksXG5cdCAgICAgICAgICAgIGYgPSAhZCB8fCAhZSAmJiBoID8gYyA6IFRlKGMsIHMsIGQsIG4sIHIpLFxuXHQgICAgICAgICAgICBwID0gZyA/IHkgfHwgKGUgPyBkIDogbCB8fCB2KSA/IFtdIDogdCA6IGY7XG5cblx0ICAgICAgICBpZiAoZyAmJiBnKGYsIHAsIG4sIHIpLCB2KSB7XG5cdCAgICAgICAgICBpID0gVGUocCwgdSksIHYoaSwgW10sIG4sIHIpLCBvID0gaS5sZW5ndGg7XG5cblx0ICAgICAgICAgIHdoaWxlIChvLS0pIChhID0gaVtvXSkgJiYgKHBbdVtvXV0gPSAhKGZbdVtvXV0gPSBhKSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGUpIHtcblx0ICAgICAgICAgIGlmICh5IHx8IGQpIHtcblx0ICAgICAgICAgICAgaWYgKHkpIHtcblx0ICAgICAgICAgICAgICBpID0gW10sIG8gPSBwLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAgIHdoaWxlIChvLS0pIChhID0gcFtvXSkgJiYgaS5wdXNoKGZbb10gPSBhKTtcblxuXHQgICAgICAgICAgICAgIHkobnVsbCwgcCA9IFtdLCBpLCByKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG8gPSBwLmxlbmd0aDtcblxuXHQgICAgICAgICAgICB3aGlsZSAoby0tKSAoYSA9IHBbb10pICYmIC0xIDwgKGkgPSB5ID8gUChlLCBhKSA6IHNbb10pICYmIChlW2ldID0gISh0W2ldID0gYSkpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBwID0gVGUocCA9PT0gdCA/IHAuc3BsaWNlKGwsIHAubGVuZ3RoKSA6IHApLCB5ID8geShudWxsLCB0LCBwLCByKSA6IEguYXBwbHkodCwgcCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBFZShlKSB7XG5cdCAgICAgIGZvciAodmFyIGksIHQsIG4sIHIgPSBlLmxlbmd0aCwgbyA9IGIucmVsYXRpdmVbZVswXS50eXBlXSwgYSA9IG8gfHwgYi5yZWxhdGl2ZVtcIiBcIl0sIHMgPSBvID8gMSA6IDAsIHUgPSBiZShmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHJldHVybiBlID09PSBpO1xuXHQgICAgICB9LCBhLCAhMCksIGwgPSBiZShmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHJldHVybiAtMSA8IFAoaSwgZSk7XG5cdCAgICAgIH0sIGEsICEwKSwgYyA9IFtmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICAgIHZhciByID0gIW8gJiYgKG4gfHwgdCAhPT0gdykgfHwgKChpID0gdCkubm9kZVR5cGUgPyB1KGUsIHQsIG4pIDogbChlLCB0LCBuKSk7XG5cdCAgICAgICAgcmV0dXJuIGkgPSBudWxsLCByO1xuXHQgICAgICB9XTsgcyA8IHI7IHMrKykgaWYgKHQgPSBiLnJlbGF0aXZlW2Vbc10udHlwZV0pIGMgPSBbYmUod2UoYyksIHQpXTtlbHNlIHtcblx0ICAgICAgICBpZiAoKHQgPSBiLmZpbHRlcltlW3NdLnR5cGVdLmFwcGx5KG51bGwsIGVbc10ubWF0Y2hlcykpW1NdKSB7XG5cdCAgICAgICAgICBmb3IgKG4gPSArK3M7IG4gPCByOyBuKyspIGlmIChiLnJlbGF0aXZlW2Vbbl0udHlwZV0pIGJyZWFrO1xuXG5cdCAgICAgICAgICByZXR1cm4gQ2UoMSA8IHMgJiYgd2UoYyksIDEgPCBzICYmIHhlKGUuc2xpY2UoMCwgcyAtIDEpLmNvbmNhdCh7XG5cdCAgICAgICAgICAgIHZhbHVlOiBcIiBcIiA9PT0gZVtzIC0gMl0udHlwZSA/IFwiKlwiIDogXCJcIlxuXHQgICAgICAgICAgfSkpLnJlcGxhY2UoJCwgXCIkMVwiKSwgdCwgcyA8IG4gJiYgRWUoZS5zbGljZShzLCBuKSksIG4gPCByICYmIEVlKGUgPSBlLnNsaWNlKG4pKSwgbiA8IHIgJiYgeGUoZSkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGMucHVzaCh0KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB3ZShjKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG1lLnByb3RvdHlwZSA9IGIuZmlsdGVycyA9IGIucHNldWRvcywgYi5zZXRGaWx0ZXJzID0gbmV3IG1lKCksIGggPSBzZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHZhciBuLFxuXHQgICAgICAgICAgcixcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICBvLFxuXHQgICAgICAgICAgYSxcblx0ICAgICAgICAgIHMsXG5cdCAgICAgICAgICB1LFxuXHQgICAgICAgICAgbCA9IHhbZSArIFwiIFwiXTtcblx0ICAgICAgaWYgKGwpIHJldHVybiB0ID8gMCA6IGwuc2xpY2UoMCk7XG5cdCAgICAgIGEgPSBlLCBzID0gW10sIHUgPSBiLnByZUZpbHRlcjtcblxuXHQgICAgICB3aGlsZSAoYSkge1xuXHQgICAgICAgIGZvciAobyBpbiBuICYmICEociA9IF8uZXhlYyhhKSkgfHwgKHIgJiYgKGEgPSBhLnNsaWNlKHJbMF0ubGVuZ3RoKSB8fCBhKSwgcy5wdXNoKGkgPSBbXSkpLCBuID0gITEsIChyID0gei5leGVjKGEpKSAmJiAobiA9IHIuc2hpZnQoKSwgaS5wdXNoKHtcblx0ICAgICAgICAgIHZhbHVlOiBuLFxuXHQgICAgICAgICAgdHlwZTogclswXS5yZXBsYWNlKCQsIFwiIFwiKVxuXHQgICAgICAgIH0pLCBhID0gYS5zbGljZShuLmxlbmd0aCkpLCBiLmZpbHRlcikgIShyID0gR1tvXS5leGVjKGEpKSB8fCB1W29dICYmICEociA9IHVbb10ocikpIHx8IChuID0gci5zaGlmdCgpLCBpLnB1c2goe1xuXHQgICAgICAgICAgdmFsdWU6IG4sXG5cdCAgICAgICAgICB0eXBlOiBvLFxuXHQgICAgICAgICAgbWF0Y2hlczogclxuXHQgICAgICAgIH0pLCBhID0gYS5zbGljZShuLmxlbmd0aCkpO1xuXG5cdCAgICAgICAgaWYgKCFuKSBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB0ID8gYS5sZW5ndGggOiBhID8gc2UuZXJyb3IoZSkgOiB4KGUsIHMpLnNsaWNlKDApO1xuXHQgICAgfSwgZiA9IHNlLmNvbXBpbGUgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbixcblx0ICAgICAgICAgIHYsXG5cdCAgICAgICAgICB5LFxuXHQgICAgICAgICAgbSxcblx0ICAgICAgICAgIHgsXG5cdCAgICAgICAgICByLFxuXHQgICAgICAgICAgaSA9IFtdLFxuXHQgICAgICAgICAgbyA9IFtdLFxuXHQgICAgICAgICAgYSA9IEFbZSArIFwiIFwiXTtcblxuXHQgICAgICBpZiAoIWEpIHtcblx0ICAgICAgICB0IHx8ICh0ID0gaChlKSksIG4gPSB0Lmxlbmd0aDtcblxuXHQgICAgICAgIHdoaWxlIChuLS0pIChhID0gRWUodFtuXSkpW1NdID8gaS5wdXNoKGEpIDogby5wdXNoKGEpO1xuXG5cdCAgICAgICAgKGEgPSBBKGUsICh2ID0gbywgbSA9IDAgPCAoeSA9IGkpLmxlbmd0aCwgeCA9IDAgPCB2Lmxlbmd0aCwgciA9IGZ1bmN0aW9uIChlLCB0LCBuLCByLCBpKSB7XG5cdCAgICAgICAgICB2YXIgbyxcblx0ICAgICAgICAgICAgICBhLFxuXHQgICAgICAgICAgICAgIHMsXG5cdCAgICAgICAgICAgICAgdSA9IDAsXG5cdCAgICAgICAgICAgICAgbCA9IFwiMFwiLFxuXHQgICAgICAgICAgICAgIGMgPSBlICYmIFtdLFxuXHQgICAgICAgICAgICAgIGYgPSBbXSxcblx0ICAgICAgICAgICAgICBwID0gdyxcblx0ICAgICAgICAgICAgICBkID0gZSB8fCB4ICYmIGIuZmluZC5UQUcoXCIqXCIsIGkpLFxuXHQgICAgICAgICAgICAgIGggPSBrICs9IG51bGwgPT0gcCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IC4xLFxuXHQgICAgICAgICAgICAgIGcgPSBkLmxlbmd0aDtcblxuXHQgICAgICAgICAgZm9yIChpICYmICh3ID0gdCA9PSBDIHx8IHQgfHwgaSk7IGwgIT09IGcgJiYgbnVsbCAhPSAobyA9IGRbbF0pOyBsKyspIHtcblx0ICAgICAgICAgICAgaWYgKHggJiYgbykge1xuXHQgICAgICAgICAgICAgIGEgPSAwLCB0IHx8IG8ub3duZXJEb2N1bWVudCA9PSBDIHx8IChUKG8pLCBuID0gIUUpO1xuXG5cdCAgICAgICAgICAgICAgd2hpbGUgKHMgPSB2W2ErK10pIGlmIChzKG8sIHQgfHwgQywgbikpIHtcblx0ICAgICAgICAgICAgICAgIHIucHVzaChvKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgIGkgJiYgKGsgPSBoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG0gJiYgKChvID0gIXMgJiYgbykgJiYgdS0tLCBlICYmIGMucHVzaChvKSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmICh1ICs9IGwsIG0gJiYgbCAhPT0gdSkge1xuXHQgICAgICAgICAgICBhID0gMDtcblxuXHQgICAgICAgICAgICB3aGlsZSAocyA9IHlbYSsrXSkgcyhjLCBmLCB0LCBuKTtcblxuXHQgICAgICAgICAgICBpZiAoZSkge1xuXHQgICAgICAgICAgICAgIGlmICgwIDwgdSkgd2hpbGUgKGwtLSkgY1tsXSB8fCBmW2xdIHx8IChmW2xdID0gcS5jYWxsKHIpKTtcblx0ICAgICAgICAgICAgICBmID0gVGUoZik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBILmFwcGx5KHIsIGYpLCBpICYmICFlICYmIDAgPCBmLmxlbmd0aCAmJiAxIDwgdSArIHkubGVuZ3RoICYmIHNlLnVuaXF1ZVNvcnQocik7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJldHVybiBpICYmIChrID0gaCwgdyA9IHApLCBjO1xuXHQgICAgICAgIH0sIG0gPyBsZShyKSA6IHIpKSkuc2VsZWN0b3IgPSBlO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGE7XG5cdCAgICB9LCBnID0gc2Uuc2VsZWN0ID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcblx0ICAgICAgdmFyIGksXG5cdCAgICAgICAgICBvLFxuXHQgICAgICAgICAgYSxcblx0ICAgICAgICAgIHMsXG5cdCAgICAgICAgICB1LFxuXHQgICAgICAgICAgbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiBlLFxuXHQgICAgICAgICAgYyA9ICFyICYmIGgoZSA9IGwuc2VsZWN0b3IgfHwgZSk7XG5cblx0ICAgICAgaWYgKG4gPSBuIHx8IFtdLCAxID09PSBjLmxlbmd0aCkge1xuXHQgICAgICAgIGlmICgyIDwgKG8gPSBjWzBdID0gY1swXS5zbGljZSgwKSkubGVuZ3RoICYmIFwiSURcIiA9PT0gKGEgPSBvWzBdKS50eXBlICYmIDkgPT09IHQubm9kZVR5cGUgJiYgRSAmJiBiLnJlbGF0aXZlW29bMV0udHlwZV0pIHtcblx0ICAgICAgICAgIGlmICghKHQgPSAoYi5maW5kLklEKGEubWF0Y2hlc1swXS5yZXBsYWNlKHRlLCBuZSksIHQpIHx8IFtdKVswXSkpIHJldHVybiBuO1xuXHQgICAgICAgICAgbCAmJiAodCA9IHQucGFyZW50Tm9kZSksIGUgPSBlLnNsaWNlKG8uc2hpZnQoKS52YWx1ZS5sZW5ndGgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGkgPSBHLm5lZWRzQ29udGV4dC50ZXN0KGUpID8gMCA6IG8ubGVuZ3RoO1xuXG5cdCAgICAgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICAgICAgaWYgKGEgPSBvW2ldLCBiLnJlbGF0aXZlW3MgPSBhLnR5cGVdKSBicmVhaztcblxuXHQgICAgICAgICAgaWYgKCh1ID0gYi5maW5kW3NdKSAmJiAociA9IHUoYS5tYXRjaGVzWzBdLnJlcGxhY2UodGUsIG5lKSwgZWUudGVzdChvWzBdLnR5cGUpICYmIHllKHQucGFyZW50Tm9kZSkgfHwgdCkpKSB7XG5cdCAgICAgICAgICAgIGlmIChvLnNwbGljZShpLCAxKSwgIShlID0gci5sZW5ndGggJiYgeGUobykpKSByZXR1cm4gSC5hcHBseShuLCByKSwgbjtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIChsIHx8IGYoZSwgYykpKHIsIHQsICFFLCBuLCAhdCB8fCBlZS50ZXN0KGUpICYmIHllKHQucGFyZW50Tm9kZSkgfHwgdCksIG47XG5cdCAgICB9LCBkLnNvcnRTdGFibGUgPSBTLnNwbGl0KFwiXCIpLnNvcnQoaikuam9pbihcIlwiKSA9PT0gUywgZC5kZXRlY3REdXBsaWNhdGVzID0gISFsLCBUKCksIGQuc29ydERldGFjaGVkID0gY2UoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIDEgJiBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKEMuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpKTtcblx0ICAgIH0pLCBjZShmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gZS5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIiwgXCIjXCIgPT09IGUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuXHQgICAgfSkgfHwgZmUoXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIGlmICghbikgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKHQsIFwidHlwZVwiID09PSB0LnRvTG93ZXJDYXNlKCkgPyAxIDogMik7XG5cdCAgICB9KSwgZC5hdHRyaWJ1dGVzICYmIGNlKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBlLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIiwgZS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIFwiXCIpLCBcIlwiID09PSBlLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cdCAgICB9KSB8fCBmZShcInZhbHVlXCIsIGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIGlmICghbiAmJiBcImlucHV0XCIgPT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgcmV0dXJuIGUuZGVmYXVsdFZhbHVlO1xuXHQgICAgfSksIGNlKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBudWxsID09IGUuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG5cdCAgICB9KSB8fCBmZShSLCBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICB2YXIgcjtcblx0ICAgICAgaWYgKCFuKSByZXR1cm4gITAgPT09IGVbdF0gPyB0LnRvTG93ZXJDYXNlKCkgOiAociA9IGUuZ2V0QXR0cmlidXRlTm9kZSh0KSkgJiYgci5zcGVjaWZpZWQgPyByLnZhbHVlIDogbnVsbDtcblx0ICAgIH0pLCBzZTtcblx0ICB9KEMpO1xuXG5cdCAgUy5maW5kID0gZCwgUy5leHByID0gZC5zZWxlY3RvcnMsIFMuZXhwcltcIjpcIl0gPSBTLmV4cHIucHNldWRvcywgUy51bmlxdWVTb3J0ID0gUy51bmlxdWUgPSBkLnVuaXF1ZVNvcnQsIFMudGV4dCA9IGQuZ2V0VGV4dCwgUy5pc1hNTERvYyA9IGQuaXNYTUwsIFMuY29udGFpbnMgPSBkLmNvbnRhaW5zLCBTLmVzY2FwZVNlbGVjdG9yID0gZC5lc2NhcGU7XG5cblx0ICB2YXIgaCA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICB2YXIgciA9IFtdLFxuXHQgICAgICAgIGkgPSB2b2lkIDAgIT09IG47XG5cblx0ICAgIHdoaWxlICgoZSA9IGVbdF0pICYmIDkgIT09IGUubm9kZVR5cGUpIGlmICgxID09PSBlLm5vZGVUeXBlKSB7XG5cdCAgICAgIGlmIChpICYmIFMoZSkuaXMobikpIGJyZWFrO1xuXHQgICAgICByLnB1c2goZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByO1xuXHQgIH0sXG5cdCAgICAgIFQgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgZm9yICh2YXIgbiA9IFtdOyBlOyBlID0gZS5uZXh0U2libGluZykgMSA9PT0gZS5ub2RlVHlwZSAmJiBlICE9PSB0ICYmIG4ucHVzaChlKTtcblxuXHQgICAgcmV0dXJuIG47XG5cdCAgfSxcblx0ICAgICAgayA9IFMuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblx0ICBmdW5jdGlvbiBBKGUsIHQpIHtcblx0ICAgIHJldHVybiBlLm5vZGVOYW1lICYmIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdC50b0xvd2VyQ2FzZSgpO1xuXHQgIH1cblxuXHQgIHZhciBOID0gL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2k7XG5cblx0ICBmdW5jdGlvbiBqKGUsIG4sIHIpIHtcblx0ICAgIHJldHVybiBtKG4pID8gUy5ncmVwKGUsIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiAhIW4uY2FsbChlLCB0LCBlKSAhPT0gcjtcblx0ICAgIH0pIDogbi5ub2RlVHlwZSA/IFMuZ3JlcChlLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gZSA9PT0gbiAhPT0gcjtcblx0ICAgIH0pIDogXCJzdHJpbmdcIiAhPSB0eXBlb2YgbiA/IFMuZ3JlcChlLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gLTEgPCBpLmNhbGwobiwgZSkgIT09IHI7XG5cdCAgICB9KSA6IFMuZmlsdGVyKG4sIGUsIHIpO1xuXHQgIH1cblxuXHQgIFMuZmlsdGVyID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgIHZhciByID0gdFswXTtcblx0ICAgIHJldHVybiBuICYmIChlID0gXCI6bm90KFwiICsgZSArIFwiKVwiKSwgMSA9PT0gdC5sZW5ndGggJiYgMSA9PT0gci5ub2RlVHlwZSA/IFMuZmluZC5tYXRjaGVzU2VsZWN0b3IociwgZSkgPyBbcl0gOiBbXSA6IFMuZmluZC5tYXRjaGVzKGUsIFMuZ3JlcCh0LCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gMSA9PT0gZS5ub2RlVHlwZTtcblx0ICAgIH0pKTtcblx0ICB9LCBTLmZuLmV4dGVuZCh7XG5cdCAgICBmaW5kOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdCxcblx0ICAgICAgICAgIG4sXG5cdCAgICAgICAgICByID0gdGhpcy5sZW5ndGgsXG5cdCAgICAgICAgICBpID0gdGhpcztcblx0ICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHJldHVybiB0aGlzLnB1c2hTdGFjayhTKGUpLmZpbHRlcihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh0ID0gMDsgdCA8IHI7IHQrKykgaWYgKFMuY29udGFpbnMoaVt0XSwgdGhpcykpIHJldHVybiAhMDtcblx0ICAgICAgfSkpO1xuXG5cdCAgICAgIGZvciAobiA9IHRoaXMucHVzaFN0YWNrKFtdKSwgdCA9IDA7IHQgPCByOyB0KyspIFMuZmluZChlLCBpW3RdLCBuKTtcblxuXHQgICAgICByZXR1cm4gMSA8IHIgPyBTLnVuaXF1ZVNvcnQobikgOiBuO1xuXHQgICAgfSxcblx0ICAgIGZpbHRlcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGoodGhpcywgZSB8fCBbXSwgITEpKTtcblx0ICAgIH0sXG5cdCAgICBub3Q6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqKHRoaXMsIGUgfHwgW10sICEwKSk7XG5cdCAgICB9LFxuXHQgICAgaXM6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiAhIWoodGhpcywgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiBrLnRlc3QoZSkgPyBTKGUpIDogZSB8fCBbXSwgITEpLmxlbmd0aDtcblx0ICAgIH1cblx0ICB9KTtcblx0ICB2YXIgRCxcblx0ICAgICAgcSA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvO1xuXHQgIChTLmZuLmluaXQgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgdmFyIHIsIGk7XG5cdCAgICBpZiAoIWUpIHJldHVybiB0aGlzO1xuXG5cdCAgICBpZiAobiA9IG4gfHwgRCwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuXHQgICAgICBpZiAoIShyID0gXCI8XCIgPT09IGVbMF0gJiYgXCI+XCIgPT09IGVbZS5sZW5ndGggLSAxXSAmJiAzIDw9IGUubGVuZ3RoID8gW251bGwsIGUsIG51bGxdIDogcS5leGVjKGUpKSB8fCAhclsxXSAmJiB0KSByZXR1cm4gIXQgfHwgdC5qcXVlcnkgPyAodCB8fCBuKS5maW5kKGUpIDogdGhpcy5jb25zdHJ1Y3Rvcih0KS5maW5kKGUpO1xuXG5cdCAgICAgIGlmIChyWzFdKSB7XG5cdCAgICAgICAgaWYgKHQgPSB0IGluc3RhbmNlb2YgUyA/IHRbMF0gOiB0LCBTLm1lcmdlKHRoaXMsIFMucGFyc2VIVE1MKHJbMV0sIHQgJiYgdC5ub2RlVHlwZSA/IHQub3duZXJEb2N1bWVudCB8fCB0IDogRSwgITApKSwgTi50ZXN0KHJbMV0pICYmIFMuaXNQbGFpbk9iamVjdCh0KSkgZm9yIChyIGluIHQpIG0odGhpc1tyXSkgPyB0aGlzW3JdKHRbcl0pIDogdGhpcy5hdHRyKHIsIHRbcl0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIChpID0gRS5nZXRFbGVtZW50QnlJZChyWzJdKSkgJiYgKHRoaXNbMF0gPSBpLCB0aGlzLmxlbmd0aCA9IDEpLCB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZS5ub2RlVHlwZSA/ICh0aGlzWzBdID0gZSwgdGhpcy5sZW5ndGggPSAxLCB0aGlzKSA6IG0oZSkgPyB2b2lkIDAgIT09IG4ucmVhZHkgPyBuLnJlYWR5KGUpIDogZShTKSA6IFMubWFrZUFycmF5KGUsIHRoaXMpO1xuXHQgIH0pLnByb3RvdHlwZSA9IFMuZm4sIEQgPSBTKEUpO1xuXHQgIHZhciBMID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cdCAgICAgIEggPSB7XG5cdCAgICBjaGlsZHJlbjogITAsXG5cdCAgICBjb250ZW50czogITAsXG5cdCAgICBuZXh0OiAhMCxcblx0ICAgIHByZXY6ICEwXG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIE8oZSwgdCkge1xuXHQgICAgd2hpbGUgKChlID0gZVt0XSkgJiYgMSAhPT0gZS5ub2RlVHlwZSk7XG5cblx0ICAgIHJldHVybiBlO1xuXHQgIH1cblxuXHQgIFMuZm4uZXh0ZW5kKHtcblx0ICAgIGhhczogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQgPSBTKGUsIHRoaXMpLFxuXHQgICAgICAgICAgbiA9IHQubGVuZ3RoO1xuXHQgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgbjsgZSsrKSBpZiAoUy5jb250YWlucyh0aGlzLCB0W2VdKSkgcmV0dXJuICEwO1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICBjbG9zZXN0OiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbixcblx0ICAgICAgICAgIHIgPSAwLFxuXHQgICAgICAgICAgaSA9IHRoaXMubGVuZ3RoLFxuXHQgICAgICAgICAgbyA9IFtdLFxuXHQgICAgICAgICAgYSA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgUyhlKTtcblx0ICAgICAgaWYgKCFrLnRlc3QoZSkpIGZvciAoOyByIDwgaTsgcisrKSBmb3IgKG4gPSB0aGlzW3JdOyBuICYmIG4gIT09IHQ7IG4gPSBuLnBhcmVudE5vZGUpIGlmIChuLm5vZGVUeXBlIDwgMTEgJiYgKGEgPyAtMSA8IGEuaW5kZXgobikgOiAxID09PSBuLm5vZGVUeXBlICYmIFMuZmluZC5tYXRjaGVzU2VsZWN0b3IobiwgZSkpKSB7XG5cdCAgICAgICAgby5wdXNoKG4pO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjaygxIDwgby5sZW5ndGggPyBTLnVuaXF1ZVNvcnQobykgOiBvKTtcblx0ICAgIH0sXG5cdCAgICBpbmRleDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIGUgPyBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gaS5jYWxsKFMoZSksIHRoaXNbMF0pIDogaS5jYWxsKHRoaXMsIGUuanF1ZXJ5ID8gZVswXSA6IGUpIDogdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHQgICAgfSxcblx0ICAgIGFkZDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFMudW5pcXVlU29ydChTLm1lcmdlKHRoaXMuZ2V0KCksIFMoZSwgdCkpKSk7XG5cdCAgICB9LFxuXHQgICAgYWRkQmFjazogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYWRkKG51bGwgPT0gZSA/IHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoZSkpO1xuXHQgICAgfVxuXHQgIH0pLCBTLmVhY2goe1xuXHQgICAgcGFyZW50OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdCA9IGUucGFyZW50Tm9kZTtcblx0ICAgICAgcmV0dXJuIHQgJiYgMTEgIT09IHQubm9kZVR5cGUgPyB0IDogbnVsbDtcblx0ICAgIH0sXG5cdCAgICBwYXJlbnRzOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gaChlLCBcInBhcmVudE5vZGVcIik7XG5cdCAgICB9LFxuXHQgICAgcGFyZW50c1VudGlsOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gaChlLCBcInBhcmVudE5vZGVcIiwgbik7XG5cdCAgICB9LFxuXHQgICAgbmV4dDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIE8oZSwgXCJuZXh0U2libGluZ1wiKTtcblx0ICAgIH0sXG5cdCAgICBwcmV2OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gTyhlLCBcInByZXZpb3VzU2libGluZ1wiKTtcblx0ICAgIH0sXG5cdCAgICBuZXh0QWxsOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gaChlLCBcIm5leHRTaWJsaW5nXCIpO1xuXHQgICAgfSxcblx0ICAgIHByZXZBbGw6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBoKGUsIFwicHJldmlvdXNTaWJsaW5nXCIpO1xuXHQgICAgfSxcblx0ICAgIG5leHRVbnRpbDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgcmV0dXJuIGgoZSwgXCJuZXh0U2libGluZ1wiLCBuKTtcblx0ICAgIH0sXG5cdCAgICBwcmV2VW50aWw6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHJldHVybiBoKGUsIFwicHJldmlvdXNTaWJsaW5nXCIsIG4pO1xuXHQgICAgfSxcblx0ICAgIHNpYmxpbmdzOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gVCgoZS5wYXJlbnROb2RlIHx8IHt9KS5maXJzdENoaWxkLCBlKTtcblx0ICAgIH0sXG5cdCAgICBjaGlsZHJlbjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIFQoZS5maXJzdENoaWxkKTtcblx0ICAgIH0sXG5cdCAgICBjb250ZW50czogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIG51bGwgIT0gZS5jb250ZW50RG9jdW1lbnQgJiYgcihlLmNvbnRlbnREb2N1bWVudCkgPyBlLmNvbnRlbnREb2N1bWVudCA6IChBKGUsIFwidGVtcGxhdGVcIikgJiYgKGUgPSBlLmNvbnRlbnQgfHwgZSksIFMubWVyZ2UoW10sIGUuY2hpbGROb2RlcykpO1xuXHQgICAgfVxuXHQgIH0sIGZ1bmN0aW9uIChyLCBpKSB7XG5cdCAgICBTLmZuW3JdID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgdmFyIG4gPSBTLm1hcCh0aGlzLCBpLCBlKTtcblx0ICAgICAgcmV0dXJuIFwiVW50aWxcIiAhPT0gci5zbGljZSgtNSkgJiYgKHQgPSBlKSwgdCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIChuID0gUy5maWx0ZXIodCwgbikpLCAxIDwgdGhpcy5sZW5ndGggJiYgKEhbcl0gfHwgUy51bmlxdWVTb3J0KG4pLCBMLnRlc3QocikgJiYgbi5yZXZlcnNlKCkpLCB0aGlzLnB1c2hTdGFjayhuKTtcblx0ICAgIH07XG5cdCAgfSk7XG5cdCAgdmFyIFAgPSAvW15cXHgyMFxcdFxcclxcblxcZl0rL2c7XG5cblx0ICBmdW5jdGlvbiBSKGUpIHtcblx0ICAgIHJldHVybiBlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIE0oZSkge1xuXHQgICAgdGhyb3cgZTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBJKGUsIHQsIG4sIHIpIHtcblx0ICAgIHZhciBpO1xuXG5cdCAgICB0cnkge1xuXHQgICAgICBlICYmIG0oaSA9IGUucHJvbWlzZSkgPyBpLmNhbGwoZSkuZG9uZSh0KS5mYWlsKG4pIDogZSAmJiBtKGkgPSBlLnRoZW4pID8gaS5jYWxsKGUsIHQsIG4pIDogdC5hcHBseSh2b2lkIDAsIFtlXS5zbGljZShyKSk7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIG4uYXBwbHkodm9pZCAwLCBbZV0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIFMuQ2FsbGJhY2tzID0gZnVuY3Rpb24gKHIpIHtcblx0ICAgIHZhciBlLCBuO1xuXHQgICAgciA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIHIgPyAoZSA9IHIsIG4gPSB7fSwgUy5lYWNoKGUubWF0Y2goUCkgfHwgW10sIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIG5bdF0gPSAhMDtcblx0ICAgIH0pLCBuKSA6IFMuZXh0ZW5kKHt9LCByKTtcblxuXHQgICAgdmFyIGksXG5cdCAgICAgICAgdCxcblx0ICAgICAgICBvLFxuXHQgICAgICAgIGEsXG5cdCAgICAgICAgcyA9IFtdLFxuXHQgICAgICAgIHUgPSBbXSxcblx0ICAgICAgICBsID0gLTEsXG5cdCAgICAgICAgYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgZm9yIChhID0gYSB8fCByLm9uY2UsIG8gPSBpID0gITA7IHUubGVuZ3RoOyBsID0gLTEpIHtcblx0ICAgICAgICB0ID0gdS5zaGlmdCgpO1xuXG5cdCAgICAgICAgd2hpbGUgKCsrbCA8IHMubGVuZ3RoKSAhMSA9PT0gc1tsXS5hcHBseSh0WzBdLCB0WzFdKSAmJiByLnN0b3BPbkZhbHNlICYmIChsID0gcy5sZW5ndGgsIHQgPSAhMSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByLm1lbW9yeSB8fCAodCA9ICExKSwgaSA9ICExLCBhICYmIChzID0gdCA/IFtdIDogXCJcIik7XG5cdCAgICB9LFxuXHQgICAgICAgIGYgPSB7XG5cdCAgICAgIGFkZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBzICYmICh0ICYmICFpICYmIChsID0gcy5sZW5ndGggLSAxLCB1LnB1c2godCkpLCBmdW5jdGlvbiBuKGUpIHtcblx0ICAgICAgICAgIFMuZWFjaChlLCBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgICAgICBtKHQpID8gci51bmlxdWUgJiYgZi5oYXModCkgfHwgcy5wdXNoKHQpIDogdCAmJiB0Lmxlbmd0aCAmJiBcInN0cmluZ1wiICE9PSB3KHQpICYmIG4odCk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9KGFyZ3VtZW50cyksIHQgJiYgIWkgJiYgYygpKSwgdGhpcztcblx0ICAgICAgfSxcblx0ICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFMuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgICB2YXIgbjtcblxuXHQgICAgICAgICAgd2hpbGUgKC0xIDwgKG4gPSBTLmluQXJyYXkodCwgcywgbikpKSBzLnNwbGljZShuLCAxKSwgbiA8PSBsICYmIGwtLTtcblx0ICAgICAgICB9KSwgdGhpcztcblx0ICAgICAgfSxcblx0ICAgICAgaGFzOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHJldHVybiBlID8gLTEgPCBTLmluQXJyYXkoZSwgcykgOiAwIDwgcy5sZW5ndGg7XG5cdCAgICAgIH0sXG5cdCAgICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHMgJiYgKHMgPSBbXSksIHRoaXM7XG5cdCAgICAgIH0sXG5cdCAgICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gYSA9IHUgPSBbXSwgcyA9IHQgPSBcIlwiLCB0aGlzO1xuXHQgICAgICB9LFxuXHQgICAgICBkaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAhcztcblx0ICAgICAgfSxcblx0ICAgICAgbG9jazogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBhID0gdSA9IFtdLCB0IHx8IGkgfHwgKHMgPSB0ID0gXCJcIiksIHRoaXM7XG5cdCAgICAgIH0sXG5cdCAgICAgIGxvY2tlZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAhIWE7XG5cdCAgICAgIH0sXG5cdCAgICAgIGZpcmVXaXRoOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIHJldHVybiBhIHx8ICh0ID0gW2UsICh0ID0gdCB8fCBbXSkuc2xpY2UgPyB0LnNsaWNlKCkgOiB0XSwgdS5wdXNoKHQpLCBpIHx8IGMoKSksIHRoaXM7XG5cdCAgICAgIH0sXG5cdCAgICAgIGZpcmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gZi5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpLCB0aGlzO1xuXHQgICAgICB9LFxuXHQgICAgICBmaXJlZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAhIW87XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBmO1xuXHQgIH0sIFMuZXh0ZW5kKHtcblx0ICAgIERlZmVycmVkOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgbyA9IFtbXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBTLkNhbGxiYWNrcyhcIm1lbW9yeVwiKSwgUy5DYWxsYmFja3MoXCJtZW1vcnlcIiksIDJdLCBbXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBTLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBTLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCAwLCBcInJlc29sdmVkXCJdLCBbXCJyZWplY3RcIiwgXCJmYWlsXCIsIFMuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFMuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDEsIFwicmVqZWN0ZWRcIl1dLFxuXHQgICAgICAgICAgaSA9IFwicGVuZGluZ1wiLFxuXHQgICAgICAgICAgYSA9IHtcblx0ICAgICAgICBzdGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgcmV0dXJuIGk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBhbHdheXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHJldHVybiBzLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyksIHRoaXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gYS50aGVuKG51bGwsIGUpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcGlwZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHM7XG5cdCAgICAgICAgICByZXR1cm4gUy5EZWZlcnJlZChmdW5jdGlvbiAocikge1xuXHQgICAgICAgICAgICBTLmVhY2gobywgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICAgICAgICB2YXIgbiA9IG0oaVt0WzRdXSkgJiYgaVt0WzRdXTtcblx0ICAgICAgICAgICAgICBzW3RbMV1dKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBlID0gbiAmJiBuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICBlICYmIG0oZS5wcm9taXNlKSA/IGUucHJvbWlzZSgpLnByb2dyZXNzKHIubm90aWZ5KS5kb25lKHIucmVzb2x2ZSkuZmFpbChyLnJlamVjdCkgOiByW3RbMF0gKyBcIldpdGhcIl0odGhpcywgbiA/IFtlXSA6IGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pLCBpID0gbnVsbDtcblx0ICAgICAgICAgIH0pLnByb21pc2UoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHRoZW46IGZ1bmN0aW9uICh0LCBuLCByKSB7XG5cdCAgICAgICAgICB2YXIgdSA9IDA7XG5cblx0ICAgICAgICAgIGZ1bmN0aW9uIGwoaSwgbywgYSwgcykge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgIHZhciBuID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgICAgciA9IGFyZ3VtZW50cyxcblx0ICAgICAgICAgICAgICAgICAgZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBlLCB0O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoIShpIDwgdSkpIHtcblx0ICAgICAgICAgICAgICAgICAgaWYgKChlID0gYS5hcHBseShuLCByKSkgPT09IG8ucHJvbWlzZSgpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgICB0ID0gZSAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpICYmIGUudGhlbiwgbSh0KSA/IHMgPyB0LmNhbGwoZSwgbCh1LCBvLCBSLCBzKSwgbCh1LCBvLCBNLCBzKSkgOiAodSsrLCB0LmNhbGwoZSwgbCh1LCBvLCBSLCBzKSwgbCh1LCBvLCBNLCBzKSwgbCh1LCBvLCBSLCBvLm5vdGlmeVdpdGgpKSkgOiAoYSAhPT0gUiAmJiAobiA9IHZvaWQgMCwgciA9IFtlXSksIChzIHx8IG8ucmVzb2x2ZVdpdGgpKG4sIHIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICB0ID0gcyA/IGUgOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICBlKCk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICAgIFMuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayAmJiBTLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soZSwgdC5zdGFja1RyYWNlKSwgdSA8PSBpICsgMSAmJiAoYSAhPT0gTSAmJiAobiA9IHZvaWQgMCwgciA9IFtlXSksIG8ucmVqZWN0V2l0aChuLCByKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICAgIGkgPyB0KCkgOiAoUy5EZWZlcnJlZC5nZXRTdGFja0hvb2sgJiYgKHQuc3RhY2tUcmFjZSA9IFMuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCkpLCBDLnNldFRpbWVvdXQodCkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gUy5EZWZlcnJlZChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICBvWzBdWzNdLmFkZChsKDAsIGUsIG0ocikgPyByIDogUiwgZS5ub3RpZnlXaXRoKSksIG9bMV1bM10uYWRkKGwoMCwgZSwgbSh0KSA/IHQgOiBSKSksIG9bMl1bM10uYWRkKGwoMCwgZSwgbShuKSA/IG4gOiBNKSk7XG5cdCAgICAgICAgICB9KS5wcm9taXNlKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBwcm9taXNlOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgcmV0dXJuIG51bGwgIT0gZSA/IFMuZXh0ZW5kKGUsIGEpIDogYTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgICAgICBzID0ge307XG5cdCAgICAgIHJldHVybiBTLmVhY2gobywgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IHRbMl0sXG5cdCAgICAgICAgICAgIHIgPSB0WzVdO1xuXHQgICAgICAgIGFbdFsxXV0gPSBuLmFkZCwgciAmJiBuLmFkZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBpID0gcjtcblx0ICAgICAgICB9LCBvWzMgLSBlXVsyXS5kaXNhYmxlLCBvWzMgLSBlXVszXS5kaXNhYmxlLCBvWzBdWzJdLmxvY2ssIG9bMF1bM10ubG9jayksIG4uYWRkKHRbM10uZmlyZSksIHNbdFswXV0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICByZXR1cm4gc1t0WzBdICsgXCJXaXRoXCJdKHRoaXMgPT09IHMgPyB2b2lkIDAgOiB0aGlzLCBhcmd1bWVudHMpLCB0aGlzO1xuXHQgICAgICAgIH0sIHNbdFswXSArIFwiV2l0aFwiXSA9IG4uZmlyZVdpdGg7XG5cdCAgICAgIH0pLCBhLnByb21pc2UocyksIGUgJiYgZS5jYWxsKHMsIHMpLCBzO1xuXHQgICAgfSxcblx0ICAgIHdoZW46IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCxcblx0ICAgICAgICAgIHQgPSBuLFxuXHQgICAgICAgICAgciA9IEFycmF5KHQpLFxuXHQgICAgICAgICAgaSA9IHMuY2FsbChhcmd1bWVudHMpLFxuXHQgICAgICAgICAgbyA9IFMuRGVmZXJyZWQoKSxcblx0ICAgICAgICAgIGEgPSBmdW5jdGlvbiAodCkge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgclt0XSA9IHRoaXMsIGlbdF0gPSAxIDwgYXJndW1lbnRzLmxlbmd0aCA/IHMuY2FsbChhcmd1bWVudHMpIDogZSwgLS1uIHx8IG8ucmVzb2x2ZVdpdGgociwgaSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfTtcblxuXHQgICAgICBpZiAobiA8PSAxICYmIChJKGUsIG8uZG9uZShhKHQpKS5yZXNvbHZlLCBvLnJlamVjdCwgIW4pLCBcInBlbmRpbmdcIiA9PT0gby5zdGF0ZSgpIHx8IG0oaVt0XSAmJiBpW3RdLnRoZW4pKSkgcmV0dXJuIG8udGhlbigpO1xuXG5cdCAgICAgIHdoaWxlICh0LS0pIEkoaVt0XSwgYSh0KSwgby5yZWplY3QpO1xuXG5cdCAgICAgIHJldHVybiBvLnByb21pc2UoKTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICB2YXIgVyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXHQgIFMuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICBDLmNvbnNvbGUgJiYgQy5jb25zb2xlLndhcm4gJiYgZSAmJiBXLnRlc3QoZS5uYW1lKSAmJiBDLmNvbnNvbGUud2FybihcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZS5tZXNzYWdlLCBlLnN0YWNrLCB0KTtcblx0ICB9LCBTLnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIEMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRocm93IGU7XG5cdCAgICB9KTtcblx0ICB9O1xuXHQgIHZhciBGID0gUy5EZWZlcnJlZCgpO1xuXG5cdCAgZnVuY3Rpb24gQigpIHtcblx0ICAgIEUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgQiksIEMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgQiksIFMucmVhZHkoKTtcblx0ICB9XG5cblx0ICBTLmZuLnJlYWR5ID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiBGLnRoZW4oZSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuXHQgICAgICBTLnJlYWR5RXhjZXB0aW9uKGUpO1xuXHQgICAgfSksIHRoaXM7XG5cdCAgfSwgUy5leHRlbmQoe1xuXHQgICAgaXNSZWFkeTogITEsXG5cdCAgICByZWFkeVdhaXQ6IDEsXG5cdCAgICByZWFkeTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgKCEwID09PSBlID8gLS1TLnJlYWR5V2FpdCA6IFMuaXNSZWFkeSkgfHwgKFMuaXNSZWFkeSA9ICEwKSAhPT0gZSAmJiAwIDwgLS1TLnJlYWR5V2FpdCB8fCBGLnJlc29sdmVXaXRoKEUsIFtTXSk7XG5cdCAgICB9XG5cdCAgfSksIFMucmVhZHkudGhlbiA9IEYudGhlbiwgXCJjb21wbGV0ZVwiID09PSBFLnJlYWR5U3RhdGUgfHwgXCJsb2FkaW5nXCIgIT09IEUucmVhZHlTdGF0ZSAmJiAhRS5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgPyBDLnNldFRpbWVvdXQoUy5yZWFkeSkgOiAoRS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBCKSwgQy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBCKSk7XG5cblx0ICB2YXIgJCA9IGZ1bmN0aW9uIChlLCB0LCBuLCByLCBpLCBvLCBhKSB7XG5cdCAgICB2YXIgcyA9IDAsXG5cdCAgICAgICAgdSA9IGUubGVuZ3RoLFxuXHQgICAgICAgIGwgPSBudWxsID09IG47XG5cdCAgICBpZiAoXCJvYmplY3RcIiA9PT0gdyhuKSkgZm9yIChzIGluIGkgPSAhMCwgbikgJChlLCB0LCBzLCBuW3NdLCAhMCwgbywgYSk7ZWxzZSBpZiAodm9pZCAwICE9PSByICYmIChpID0gITAsIG0ocikgfHwgKGEgPSAhMCksIGwgJiYgKGEgPyAodC5jYWxsKGUsIHIpLCB0ID0gbnVsbCkgOiAobCA9IHQsIHQgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gbC5jYWxsKFMoZSksIG4pO1xuXHQgICAgfSkpLCB0KSkgZm9yICg7IHMgPCB1OyBzKyspIHQoZVtzXSwgbiwgYSA/IHIgOiByLmNhbGwoZVtzXSwgcywgdChlW3NdLCBuKSkpO1xuXHQgICAgcmV0dXJuIGkgPyBlIDogbCA/IHQuY2FsbChlKSA6IHUgPyB0KGVbMF0sIG4pIDogbztcblx0ICB9LFxuXHQgICAgICBfID0gL14tbXMtLyxcblx0ICAgICAgeiA9IC8tKFthLXpdKS9nO1xuXG5cdCAgZnVuY3Rpb24gVShlLCB0KSB7XG5cdCAgICByZXR1cm4gdC50b1VwcGVyQ2FzZSgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIFgoZSkge1xuXHQgICAgcmV0dXJuIGUucmVwbGFjZShfLCBcIm1zLVwiKS5yZXBsYWNlKHosIFUpO1xuXHQgIH1cblxuXHQgIHZhciBWID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiAxID09PSBlLm5vZGVUeXBlIHx8IDkgPT09IGUubm9kZVR5cGUgfHwgIStlLm5vZGVUeXBlO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBHKCkge1xuXHQgICAgdGhpcy5leHBhbmRvID0gUy5leHBhbmRvICsgRy51aWQrKztcblx0ICB9XG5cblx0ICBHLnVpZCA9IDEsIEcucHJvdG90eXBlID0ge1xuXHQgICAgY2FjaGU6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0ID0gZVt0aGlzLmV4cGFuZG9dO1xuXHQgICAgICByZXR1cm4gdCB8fCAodCA9IHt9LCBWKGUpICYmIChlLm5vZGVUeXBlID8gZVt0aGlzLmV4cGFuZG9dID0gdCA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0aGlzLmV4cGFuZG8sIHtcblx0ICAgICAgICB2YWx1ZTogdCxcblx0ICAgICAgICBjb25maWd1cmFibGU6ICEwXG5cdCAgICAgIH0pKSksIHQ7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICB2YXIgcixcblx0ICAgICAgICAgIGkgPSB0aGlzLmNhY2hlKGUpO1xuXHQgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkgaVtYKHQpXSA9IG47ZWxzZSBmb3IgKHIgaW4gdCkgaVtYKHIpXSA9IHRbcl07XG5cdCAgICAgIHJldHVybiBpO1xuXHQgICAgfSxcblx0ICAgIGdldDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdCA/IHRoaXMuY2FjaGUoZSkgOiBlW3RoaXMuZXhwYW5kb10gJiYgZVt0aGlzLmV4cGFuZG9dW1godCldO1xuXHQgICAgfSxcblx0ICAgIGFjY2VzczogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdCB8fCB0ICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgdm9pZCAwID09PSBuID8gdGhpcy5nZXQoZSwgdCkgOiAodGhpcy5zZXQoZSwgdCwgbiksIHZvaWQgMCAhPT0gbiA/IG4gOiB0KTtcblx0ICAgIH0sXG5cdCAgICByZW1vdmU6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHZhciBuLFxuXHQgICAgICAgICAgciA9IGVbdGhpcy5leHBhbmRvXTtcblxuXHQgICAgICBpZiAodm9pZCAwICE9PSByKSB7XG5cdCAgICAgICAgaWYgKHZvaWQgMCAhPT0gdCkge1xuXHQgICAgICAgICAgbiA9ICh0ID0gQXJyYXkuaXNBcnJheSh0KSA/IHQubWFwKFgpIDogKHQgPSBYKHQpKSBpbiByID8gW3RdIDogdC5tYXRjaChQKSB8fCBbXSkubGVuZ3RoO1xuXG5cdCAgICAgICAgICB3aGlsZSAobi0tKSBkZWxldGUgclt0W25dXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAodm9pZCAwID09PSB0IHx8IFMuaXNFbXB0eU9iamVjdChyKSkgJiYgKGUubm9kZVR5cGUgPyBlW3RoaXMuZXhwYW5kb10gPSB2b2lkIDAgOiBkZWxldGUgZVt0aGlzLmV4cGFuZG9dKTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIGhhc0RhdGE6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0ID0gZVt0aGlzLmV4cGFuZG9dO1xuXHQgICAgICByZXR1cm4gdm9pZCAwICE9PSB0ICYmICFTLmlzRW1wdHlPYmplY3QodCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICB2YXIgWSA9IG5ldyBHKCksXG5cdCAgICAgIFEgPSBuZXcgRygpLFxuXHQgICAgICBKID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHQgICAgICBLID0gL1tBLVpdL2c7XG5cblx0ICBmdW5jdGlvbiBaKGUsIHQsIG4pIHtcblx0ICAgIHZhciByLCBpO1xuXHQgICAgaWYgKHZvaWQgMCA9PT0gbiAmJiAxID09PSBlLm5vZGVUeXBlKSBpZiAociA9IFwiZGF0YS1cIiArIHQucmVwbGFjZShLLCBcIi0kJlwiKS50b0xvd2VyQ2FzZSgpLCBcInN0cmluZ1wiID09IHR5cGVvZiAobiA9IGUuZ2V0QXR0cmlidXRlKHIpKSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIG4gPSBcInRydWVcIiA9PT0gKGkgPSBuKSB8fCBcImZhbHNlXCIgIT09IGkgJiYgKFwibnVsbFwiID09PSBpID8gbnVsbCA6IGkgPT09ICtpICsgXCJcIiA/ICtpIDogSi50ZXN0KGkpID8gSlNPTi5wYXJzZShpKSA6IGkpO1xuXHQgICAgICB9IGNhdGNoIChlKSB7fVxuXG5cdCAgICAgIFEuc2V0KGUsIHQsIG4pO1xuXHQgICAgfSBlbHNlIG4gPSB2b2lkIDA7XG5cdCAgICByZXR1cm4gbjtcblx0ICB9XG5cblx0ICBTLmV4dGVuZCh7XG5cdCAgICBoYXNEYXRhOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gUS5oYXNEYXRhKGUpIHx8IFkuaGFzRGF0YShlKTtcblx0ICAgIH0sXG5cdCAgICBkYXRhOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gUS5hY2Nlc3MoZSwgdCwgbik7XG5cdCAgICB9LFxuXHQgICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgUS5yZW1vdmUoZSwgdCk7XG5cdCAgICB9LFxuXHQgICAgX2RhdGE6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHJldHVybiBZLmFjY2VzcyhlLCB0LCBuKTtcblx0ICAgIH0sXG5cdCAgICBfcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgWS5yZW1vdmUoZSwgdCk7XG5cdCAgICB9XG5cdCAgfSksIFMuZm4uZXh0ZW5kKHtcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIChuLCBlKSB7XG5cdCAgICAgIHZhciB0LFxuXHQgICAgICAgICAgcixcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICBvID0gdGhpc1swXSxcblx0ICAgICAgICAgIGEgPSBvICYmIG8uYXR0cmlidXRlcztcblxuXHQgICAgICBpZiAodm9pZCAwID09PSBuKSB7XG5cdCAgICAgICAgaWYgKHRoaXMubGVuZ3RoICYmIChpID0gUS5nZXQobyksIDEgPT09IG8ubm9kZVR5cGUgJiYgIVkuZ2V0KG8sIFwiaGFzRGF0YUF0dHJzXCIpKSkge1xuXHQgICAgICAgICAgdCA9IGEubGVuZ3RoO1xuXG5cdCAgICAgICAgICB3aGlsZSAodC0tKSBhW3RdICYmIDAgPT09IChyID0gYVt0XS5uYW1lKS5pbmRleE9mKFwiZGF0YS1cIikgJiYgKHIgPSBYKHIuc2xpY2UoNSkpLCBaKG8sIHIsIGlbcl0pKTtcblxuXHQgICAgICAgICAgWS5zZXQobywgXCJoYXNEYXRhQXR0cnNcIiwgITApO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT0gdHlwZW9mIG4gPyB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFEuc2V0KHRoaXMsIG4pO1xuXHQgICAgICB9KSA6ICQodGhpcywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdDtcblx0ICAgICAgICBpZiAobyAmJiB2b2lkIDAgPT09IGUpIHJldHVybiB2b2lkIDAgIT09ICh0ID0gUS5nZXQobywgbikpID8gdCA6IHZvaWQgMCAhPT0gKHQgPSBaKG8sIG4pKSA/IHQgOiB2b2lkIDA7XG5cdCAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIFEuc2V0KHRoaXMsIG4sIGUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9LCBudWxsLCBlLCAxIDwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCwgITApO1xuXHQgICAgfSxcblx0ICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFEucmVtb3ZlKHRoaXMsIGUpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9KSwgUy5leHRlbmQoe1xuXHQgICAgcXVldWU6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHZhciByO1xuXHQgICAgICBpZiAoZSkgcmV0dXJuIHQgPSAodCB8fCBcImZ4XCIpICsgXCJxdWV1ZVwiLCByID0gWS5nZXQoZSwgdCksIG4gJiYgKCFyIHx8IEFycmF5LmlzQXJyYXkobikgPyByID0gWS5hY2Nlc3MoZSwgdCwgUy5tYWtlQXJyYXkobikpIDogci5wdXNoKG4pKSwgciB8fCBbXTtcblx0ICAgIH0sXG5cdCAgICBkZXF1ZXVlOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB0ID0gdCB8fCBcImZ4XCI7XG5cblx0ICAgICAgdmFyIG4gPSBTLnF1ZXVlKGUsIHQpLFxuXHQgICAgICAgICAgciA9IG4ubGVuZ3RoLFxuXHQgICAgICAgICAgaSA9IG4uc2hpZnQoKSxcblx0ICAgICAgICAgIG8gPSBTLl9xdWV1ZUhvb2tzKGUsIHQpO1xuXG5cdCAgICAgIFwiaW5wcm9ncmVzc1wiID09PSBpICYmIChpID0gbi5zaGlmdCgpLCByLS0pLCBpICYmIChcImZ4XCIgPT09IHQgJiYgbi51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKSwgZGVsZXRlIG8uc3RvcCwgaS5jYWxsKGUsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBTLmRlcXVldWUoZSwgdCk7XG5cdCAgICAgIH0sIG8pKSwgIXIgJiYgbyAmJiBvLmVtcHR5LmZpcmUoKTtcblx0ICAgIH0sXG5cdCAgICBfcXVldWVIb29rczogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgdmFyIG4gPSB0ICsgXCJxdWV1ZUhvb2tzXCI7XG5cdCAgICAgIHJldHVybiBZLmdldChlLCBuKSB8fCBZLmFjY2VzcyhlLCBuLCB7XG5cdCAgICAgICAgZW1wdHk6IFMuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIFkucmVtb3ZlKGUsIFt0ICsgXCJxdWV1ZVwiLCBuXSk7XG5cdCAgICAgICAgfSlcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSksIFMuZm4uZXh0ZW5kKHtcblx0ICAgIHF1ZXVlOiBmdW5jdGlvbiAodCwgbikge1xuXHQgICAgICB2YXIgZSA9IDI7XG5cdCAgICAgIHJldHVybiBcInN0cmluZ1wiICE9IHR5cGVvZiB0ICYmIChuID0gdCwgdCA9IFwiZnhcIiwgZS0tKSwgYXJndW1lbnRzLmxlbmd0aCA8IGUgPyBTLnF1ZXVlKHRoaXNbMF0sIHQpIDogdm9pZCAwID09PSBuID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGUgPSBTLnF1ZXVlKHRoaXMsIHQsIG4pO1xuXHQgICAgICAgIFMuX3F1ZXVlSG9va3ModGhpcywgdCksIFwiZnhcIiA9PT0gdCAmJiBcImlucHJvZ3Jlc3NcIiAhPT0gZVswXSAmJiBTLmRlcXVldWUodGhpcywgdCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIGRlcXVldWU6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFMuZGVxdWV1ZSh0aGlzLCBlKTtcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucXVldWUoZSB8fCBcImZ4XCIsIFtdKTtcblx0ICAgIH0sXG5cdCAgICBwcm9taXNlOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbixcblx0ICAgICAgICAgIHIgPSAxLFxuXHQgICAgICAgICAgaSA9IFMuRGVmZXJyZWQoKSxcblx0ICAgICAgICAgIG8gPSB0aGlzLFxuXHQgICAgICAgICAgYSA9IHRoaXMubGVuZ3RoLFxuXHQgICAgICAgICAgcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAtLXIgfHwgaS5yZXNvbHZlV2l0aChvLCBbb10pO1xuXHQgICAgICB9O1xuXG5cdCAgICAgIFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgKHQgPSBlLCBlID0gdm9pZCAwKSwgZSA9IGUgfHwgXCJmeFwiO1xuXG5cdCAgICAgIHdoaWxlIChhLS0pIChuID0gWS5nZXQob1thXSwgZSArIFwicXVldWVIb29rc1wiKSkgJiYgbi5lbXB0eSAmJiAocisrLCBuLmVtcHR5LmFkZChzKSk7XG5cblx0ICAgICAgcmV0dXJuIHMoKSwgaS5wcm9taXNlKHQpO1xuXHQgICAgfVxuXHQgIH0pO1xuXG5cdCAgdmFyIGVlID0gL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlLFxuXHQgICAgICB0ZSA9IG5ldyBSZWdFeHAoXCJeKD86KFsrLV0pPXwpKFwiICsgZWUgKyBcIikoW2EteiVdKikkXCIsIFwiaVwiKSxcblx0ICAgICAgbmUgPSBbXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIl0sXG5cdCAgICAgIHJlID0gRS5kb2N1bWVudEVsZW1lbnQsXG5cdCAgICAgIGllID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiBTLmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCwgZSk7XG5cdCAgfSxcblx0ICAgICAgb2UgPSB7XG5cdCAgICBjb21wb3NlZDogITBcblx0ICB9O1xuXG5cdCAgcmUuZ2V0Um9vdE5vZGUgJiYgKGllID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiBTLmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCwgZSkgfHwgZS5nZXRSb290Tm9kZShvZSkgPT09IGUub3duZXJEb2N1bWVudDtcblx0ICB9KTtcblxuXHQgIHZhciBhZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICByZXR1cm4gXCJub25lXCIgPT09IChlID0gdCB8fCBlKS5zdHlsZS5kaXNwbGF5IHx8IFwiXCIgPT09IGUuc3R5bGUuZGlzcGxheSAmJiBpZShlKSAmJiBcIm5vbmVcIiA9PT0gUy5jc3MoZSwgXCJkaXNwbGF5XCIpO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBzZShlLCB0LCBuLCByKSB7XG5cdCAgICB2YXIgaSxcblx0ICAgICAgICBvLFxuXHQgICAgICAgIGEgPSAyMCxcblx0ICAgICAgICBzID0gciA/IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHIuY3VyKCk7XG5cdCAgICB9IDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gUy5jc3MoZSwgdCwgXCJcIik7XG5cdCAgICB9LFxuXHQgICAgICAgIHUgPSBzKCksXG5cdCAgICAgICAgbCA9IG4gJiYgblszXSB8fCAoUy5jc3NOdW1iZXJbdF0gPyBcIlwiIDogXCJweFwiKSxcblx0ICAgICAgICBjID0gZS5ub2RlVHlwZSAmJiAoUy5jc3NOdW1iZXJbdF0gfHwgXCJweFwiICE9PSBsICYmICt1KSAmJiB0ZS5leGVjKFMuY3NzKGUsIHQpKTtcblxuXHQgICAgaWYgKGMgJiYgY1szXSAhPT0gbCkge1xuXHQgICAgICB1IC89IDIsIGwgPSBsIHx8IGNbM10sIGMgPSArdSB8fCAxO1xuXG5cdCAgICAgIHdoaWxlIChhLS0pIFMuc3R5bGUoZSwgdCwgYyArIGwpLCAoMSAtIG8pICogKDEgLSAobyA9IHMoKSAvIHUgfHwgLjUpKSA8PSAwICYmIChhID0gMCksIGMgLz0gbztcblxuXHQgICAgICBjICo9IDIsIFMuc3R5bGUoZSwgdCwgYyArIGwpLCBuID0gbiB8fCBbXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG4gJiYgKGMgPSArYyB8fCArdSB8fCAwLCBpID0gblsxXSA/IGMgKyAoblsxXSArIDEpICogblsyXSA6ICtuWzJdLCByICYmIChyLnVuaXQgPSBsLCByLnN0YXJ0ID0gYywgci5lbmQgPSBpKSksIGk7XG5cdCAgfVxuXG5cdCAgdmFyIHVlID0ge307XG5cblx0ICBmdW5jdGlvbiBsZShlLCB0KSB7XG5cdCAgICBmb3IgKHZhciBuLCByLCBpLCBvLCBhLCBzLCB1LCBsID0gW10sIGMgPSAwLCBmID0gZS5sZW5ndGg7IGMgPCBmOyBjKyspIChyID0gZVtjXSkuc3R5bGUgJiYgKG4gPSByLnN0eWxlLmRpc3BsYXksIHQgPyAoXCJub25lXCIgPT09IG4gJiYgKGxbY10gPSBZLmdldChyLCBcImRpc3BsYXlcIikgfHwgbnVsbCwgbFtjXSB8fCAoci5zdHlsZS5kaXNwbGF5ID0gXCJcIikpLCBcIlwiID09PSByLnN0eWxlLmRpc3BsYXkgJiYgYWUocikgJiYgKGxbY10gPSAodSA9IGEgPSBvID0gdm9pZCAwLCBhID0gKGkgPSByKS5vd25lckRvY3VtZW50LCBzID0gaS5ub2RlTmFtZSwgKHUgPSB1ZVtzXSkgfHwgKG8gPSBhLmJvZHkuYXBwZW5kQ2hpbGQoYS5jcmVhdGVFbGVtZW50KHMpKSwgdSA9IFMuY3NzKG8sIFwiZGlzcGxheVwiKSwgby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG8pLCBcIm5vbmVcIiA9PT0gdSAmJiAodSA9IFwiYmxvY2tcIiksIHVlW3NdID0gdSkpKSkgOiBcIm5vbmVcIiAhPT0gbiAmJiAobFtjXSA9IFwibm9uZVwiLCBZLnNldChyLCBcImRpc3BsYXlcIiwgbikpKTtcblxuXHQgICAgZm9yIChjID0gMDsgYyA8IGY7IGMrKykgbnVsbCAhPSBsW2NdICYmIChlW2NdLnN0eWxlLmRpc3BsYXkgPSBsW2NdKTtcblxuXHQgICAgcmV0dXJuIGU7XG5cdCAgfVxuXG5cdCAgUy5mbi5leHRlbmQoe1xuXHQgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gbGUodGhpcywgITApO1xuXHQgICAgfSxcblx0ICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGxlKHRoaXMpO1xuXHQgICAgfSxcblx0ICAgIHRvZ2dsZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIFwiYm9vbGVhblwiID09IHR5cGVvZiBlID8gZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGFlKHRoaXMpID8gUyh0aGlzKS5zaG93KCkgOiBTKHRoaXMpLmhpZGUoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgdmFyIGNlLFxuXHQgICAgICBmZSxcblx0ICAgICAgcGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSxcblx0ICAgICAgZGUgPSAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2ksXG5cdCAgICAgIGhlID0gL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaTtcblx0ICBjZSA9IEUuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLmFwcGVuZENoaWxkKEUuY3JlYXRlRWxlbWVudChcImRpdlwiKSksIChmZSA9IEUuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwicmFkaW9cIiksIGZlLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIpLCBmZS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwidFwiKSwgY2UuYXBwZW5kQ2hpbGQoZmUpLCB5LmNoZWNrQ2xvbmUgPSBjZS5jbG9uZU5vZGUoITApLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmNoZWNrZWQsIGNlLmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiLCB5Lm5vQ2xvbmVDaGVja2VkID0gISFjZS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWUsIGNlLmlubmVySFRNTCA9IFwiPG9wdGlvbj48L29wdGlvbj5cIiwgeS5vcHRpb24gPSAhIWNlLmxhc3RDaGlsZDtcblx0ICB2YXIgZ2UgPSB7XG5cdCAgICB0aGVhZDogWzEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCJdLFxuXHQgICAgY29sOiBbMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sXG5cdCAgICB0cjogWzIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCJdLFxuXHQgICAgdGQ6IFszLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSxcblx0ICAgIF9kZWZhdWx0OiBbMCwgXCJcIiwgXCJcIl1cblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gdmUoZSwgdCkge1xuXHQgICAgdmFyIG47XG5cdCAgICByZXR1cm4gbiA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHQgfHwgXCIqXCIpIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5xdWVyeVNlbGVjdG9yQWxsID8gZS5xdWVyeVNlbGVjdG9yQWxsKHQgfHwgXCIqXCIpIDogW10sIHZvaWQgMCA9PT0gdCB8fCB0ICYmIEEoZSwgdCkgPyBTLm1lcmdlKFtlXSwgbikgOiBuO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHllKGUsIHQpIHtcblx0ICAgIGZvciAodmFyIG4gPSAwLCByID0gZS5sZW5ndGg7IG4gPCByOyBuKyspIFkuc2V0KGVbbl0sIFwiZ2xvYmFsRXZhbFwiLCAhdCB8fCBZLmdldCh0W25dLCBcImdsb2JhbEV2YWxcIikpO1xuXHQgIH1cblxuXHQgIGdlLnRib2R5ID0gZ2UudGZvb3QgPSBnZS5jb2xncm91cCA9IGdlLmNhcHRpb24gPSBnZS50aGVhZCwgZ2UudGggPSBnZS50ZCwgeS5vcHRpb24gfHwgKGdlLm9wdGdyb3VwID0gZ2Uub3B0aW9uID0gWzEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiXSk7XG5cdCAgdmFyIG1lID0gLzx8JiM/XFx3KzsvO1xuXG5cdCAgZnVuY3Rpb24geGUoZSwgdCwgbiwgciwgaSkge1xuXHQgICAgZm9yICh2YXIgbywgYSwgcywgdSwgbCwgYywgZiA9IHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBwID0gW10sIGQgPSAwLCBoID0gZS5sZW5ndGg7IGQgPCBoOyBkKyspIGlmICgobyA9IGVbZF0pIHx8IDAgPT09IG8pIGlmIChcIm9iamVjdFwiID09PSB3KG8pKSBTLm1lcmdlKHAsIG8ubm9kZVR5cGUgPyBbb10gOiBvKTtlbHNlIGlmIChtZS50ZXN0KG8pKSB7XG5cdCAgICAgIGEgPSBhIHx8IGYuYXBwZW5kQ2hpbGQodC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwgcyA9IChkZS5leGVjKG8pIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSwgdSA9IGdlW3NdIHx8IGdlLl9kZWZhdWx0LCBhLmlubmVySFRNTCA9IHVbMV0gKyBTLmh0bWxQcmVmaWx0ZXIobykgKyB1WzJdLCBjID0gdVswXTtcblxuXHQgICAgICB3aGlsZSAoYy0tKSBhID0gYS5sYXN0Q2hpbGQ7XG5cblx0ICAgICAgUy5tZXJnZShwLCBhLmNoaWxkTm9kZXMpLCAoYSA9IGYuZmlyc3RDaGlsZCkudGV4dENvbnRlbnQgPSBcIlwiO1xuXHQgICAgfSBlbHNlIHAucHVzaCh0LmNyZWF0ZVRleHROb2RlKG8pKTtcblxuXHQgICAgZi50ZXh0Q29udGVudCA9IFwiXCIsIGQgPSAwO1xuXG5cdCAgICB3aGlsZSAobyA9IHBbZCsrXSkgaWYgKHIgJiYgLTEgPCBTLmluQXJyYXkobywgcikpIGkgJiYgaS5wdXNoKG8pO2Vsc2UgaWYgKGwgPSBpZShvKSwgYSA9IHZlKGYuYXBwZW5kQ2hpbGQobyksIFwic2NyaXB0XCIpLCBsICYmIHllKGEpLCBuKSB7XG5cdCAgICAgIGMgPSAwO1xuXG5cdCAgICAgIHdoaWxlIChvID0gYVtjKytdKSBoZS50ZXN0KG8udHlwZSB8fCBcIlwiKSAmJiBuLnB1c2gobyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmO1xuXHQgIH1cblxuXHQgIHZhciBiZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cblx0ICBmdW5jdGlvbiB3ZSgpIHtcblx0ICAgIHJldHVybiAhMDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBUZSgpIHtcblx0ICAgIHJldHVybiAhMTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBDZShlLCB0KSB7XG5cdCAgICByZXR1cm4gZSA9PT0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiBFLmFjdGl2ZUVsZW1lbnQ7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgICB9KCkgPT0gKFwiZm9jdXNcIiA9PT0gdCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gRWUoZSwgdCwgbiwgciwgaSwgbykge1xuXHQgICAgdmFyIGEsIHM7XG5cblx0ICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiB0KSB7XG5cdCAgICAgIGZvciAocyBpbiBcInN0cmluZ1wiICE9IHR5cGVvZiBuICYmIChyID0gciB8fCBuLCBuID0gdm9pZCAwKSwgdCkgRWUoZSwgcywgbiwgciwgdFtzXSwgbyk7XG5cblx0ICAgICAgcmV0dXJuIGU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChudWxsID09IHIgJiYgbnVsbCA9PSBpID8gKGkgPSBuLCByID0gbiA9IHZvaWQgMCkgOiBudWxsID09IGkgJiYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIG4gPyAoaSA9IHIsIHIgPSB2b2lkIDApIDogKGkgPSByLCByID0gbiwgbiA9IHZvaWQgMCkpLCAhMSA9PT0gaSkgaSA9IFRlO2Vsc2UgaWYgKCFpKSByZXR1cm4gZTtcblx0ICAgIHJldHVybiAxID09PSBvICYmIChhID0gaSwgKGkgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gUygpLm9mZihlKSwgYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfSkuZ3VpZCA9IGEuZ3VpZCB8fCAoYS5ndWlkID0gUy5ndWlkKyspKSwgZS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgUy5ldmVudC5hZGQodGhpcywgdCwgaSwgciwgbik7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBTZShlLCBpLCBvKSB7XG5cdCAgICBvID8gKFkuc2V0KGUsIGksICExKSwgUy5ldmVudC5hZGQoZSwgaSwge1xuXHQgICAgICBuYW1lc3BhY2U6ICExLFxuXHQgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciB0LFxuXHQgICAgICAgICAgICBuLFxuXHQgICAgICAgICAgICByID0gWS5nZXQodGhpcywgaSk7XG5cblx0ICAgICAgICBpZiAoMSAmIGUuaXNUcmlnZ2VyICYmIHRoaXNbaV0pIHtcblx0ICAgICAgICAgIGlmIChyLmxlbmd0aCkgKFMuZXZlbnQuc3BlY2lhbFtpXSB8fCB7fSkuZGVsZWdhdGVUeXBlICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7ZWxzZSBpZiAociA9IHMuY2FsbChhcmd1bWVudHMpLCBZLnNldCh0aGlzLCBpLCByKSwgdCA9IG8odGhpcywgaSksIHRoaXNbaV0oKSwgciAhPT0gKG4gPSBZLmdldCh0aGlzLCBpKSkgfHwgdCA/IFkuc2V0KHRoaXMsIGksICExKSA6IG4gPSB7fSwgciAhPT0gbikgcmV0dXJuIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIGUucHJldmVudERlZmF1bHQoKSwgbiAmJiBuLnZhbHVlO1xuXHQgICAgICAgIH0gZWxzZSByLmxlbmd0aCAmJiAoWS5zZXQodGhpcywgaSwge1xuXHQgICAgICAgICAgdmFsdWU6IFMuZXZlbnQudHJpZ2dlcihTLmV4dGVuZChyWzBdLCBTLkV2ZW50LnByb3RvdHlwZSksIHIuc2xpY2UoMSksIHRoaXMpXG5cdCAgICAgICAgfSksIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkpO1xuXHQgICAgICB9XG5cdCAgICB9KSkgOiB2b2lkIDAgPT09IFkuZ2V0KGUsIGkpICYmIFMuZXZlbnQuYWRkKGUsIGksIHdlKTtcblx0ICB9XG5cblx0ICBTLmV2ZW50ID0ge1xuXHQgICAgZ2xvYmFsOiB7fSxcblx0ICAgIGFkZDogZnVuY3Rpb24gKHQsIGUsIG4sIHIsIGkpIHtcblx0ICAgICAgdmFyIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyxcblx0ICAgICAgICAgIHUsXG5cdCAgICAgICAgICBsLFxuXHQgICAgICAgICAgYyxcblx0ICAgICAgICAgIGYsXG5cdCAgICAgICAgICBwLFxuXHQgICAgICAgICAgZCxcblx0ICAgICAgICAgIGgsXG5cdCAgICAgICAgICBnLFxuXHQgICAgICAgICAgdiA9IFkuZ2V0KHQpO1xuXG5cdCAgICAgIGlmIChWKHQpKSB7XG5cdCAgICAgICAgbi5oYW5kbGVyICYmIChuID0gKG8gPSBuKS5oYW5kbGVyLCBpID0gby5zZWxlY3RvciksIGkgJiYgUy5maW5kLm1hdGNoZXNTZWxlY3RvcihyZSwgaSksIG4uZ3VpZCB8fCAobi5ndWlkID0gUy5ndWlkKyspLCAodSA9IHYuZXZlbnRzKSB8fCAodSA9IHYuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKSksIChhID0gdi5oYW5kbGUpIHx8IChhID0gdi5oYW5kbGUgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFMgJiYgUy5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/IFMuZXZlbnQuZGlzcGF0Y2guYXBwbHkodCwgYXJndW1lbnRzKSA6IHZvaWQgMDtcblx0ICAgICAgICB9KSwgbCA9IChlID0gKGUgfHwgXCJcIikubWF0Y2goUCkgfHwgW1wiXCJdKS5sZW5ndGg7XG5cblx0ICAgICAgICB3aGlsZSAobC0tKSBkID0gZyA9IChzID0gYmUuZXhlYyhlW2xdKSB8fCBbXSlbMV0sIGggPSAoc1syXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLCBkICYmIChmID0gUy5ldmVudC5zcGVjaWFsW2RdIHx8IHt9LCBkID0gKGkgPyBmLmRlbGVnYXRlVHlwZSA6IGYuYmluZFR5cGUpIHx8IGQsIGYgPSBTLmV2ZW50LnNwZWNpYWxbZF0gfHwge30sIGMgPSBTLmV4dGVuZCh7XG5cdCAgICAgICAgICB0eXBlOiBkLFxuXHQgICAgICAgICAgb3JpZ1R5cGU6IGcsXG5cdCAgICAgICAgICBkYXRhOiByLFxuXHQgICAgICAgICAgaGFuZGxlcjogbixcblx0ICAgICAgICAgIGd1aWQ6IG4uZ3VpZCxcblx0ICAgICAgICAgIHNlbGVjdG9yOiBpLFxuXHQgICAgICAgICAgbmVlZHNDb250ZXh0OiBpICYmIFMuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChpKSxcblx0ICAgICAgICAgIG5hbWVzcGFjZTogaC5qb2luKFwiLlwiKVxuXHQgICAgICAgIH0sIG8pLCAocCA9IHVbZF0pIHx8ICgocCA9IHVbZF0gPSBbXSkuZGVsZWdhdGVDb3VudCA9IDAsIGYuc2V0dXAgJiYgITEgIT09IGYuc2V0dXAuY2FsbCh0LCByLCBoLCBhKSB8fCB0LmFkZEV2ZW50TGlzdGVuZXIgJiYgdC5hZGRFdmVudExpc3RlbmVyKGQsIGEpKSwgZi5hZGQgJiYgKGYuYWRkLmNhbGwodCwgYyksIGMuaGFuZGxlci5ndWlkIHx8IChjLmhhbmRsZXIuZ3VpZCA9IG4uZ3VpZCkpLCBpID8gcC5zcGxpY2UocC5kZWxlZ2F0ZUNvdW50KyssIDAsIGMpIDogcC5wdXNoKGMpLCBTLmV2ZW50Lmdsb2JhbFtkXSA9ICEwKTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHJlbW92ZTogZnVuY3Rpb24gKGUsIHQsIG4sIHIsIGkpIHtcblx0ICAgICAgdmFyIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyxcblx0ICAgICAgICAgIHUsXG5cdCAgICAgICAgICBsLFxuXHQgICAgICAgICAgYyxcblx0ICAgICAgICAgIGYsXG5cdCAgICAgICAgICBwLFxuXHQgICAgICAgICAgZCxcblx0ICAgICAgICAgIGgsXG5cdCAgICAgICAgICBnLFxuXHQgICAgICAgICAgdiA9IFkuaGFzRGF0YShlKSAmJiBZLmdldChlKTtcblxuXHQgICAgICBpZiAodiAmJiAodSA9IHYuZXZlbnRzKSkge1xuXHQgICAgICAgIGwgPSAodCA9ICh0IHx8IFwiXCIpLm1hdGNoKFApIHx8IFtcIlwiXSkubGVuZ3RoO1xuXG5cdCAgICAgICAgd2hpbGUgKGwtLSkgaWYgKGQgPSBnID0gKHMgPSBiZS5leGVjKHRbbF0pIHx8IFtdKVsxXSwgaCA9IChzWzJdIHx8IFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksIGQpIHtcblx0ICAgICAgICAgIGYgPSBTLmV2ZW50LnNwZWNpYWxbZF0gfHwge30sIHAgPSB1W2QgPSAociA/IGYuZGVsZWdhdGVUeXBlIDogZi5iaW5kVHlwZSkgfHwgZF0gfHwgW10sIHMgPSBzWzJdICYmIG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIGguam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiksIGEgPSBvID0gcC5sZW5ndGg7XG5cblx0ICAgICAgICAgIHdoaWxlIChvLS0pIGMgPSBwW29dLCAhaSAmJiBnICE9PSBjLm9yaWdUeXBlIHx8IG4gJiYgbi5ndWlkICE9PSBjLmd1aWQgfHwgcyAmJiAhcy50ZXN0KGMubmFtZXNwYWNlKSB8fCByICYmIHIgIT09IGMuc2VsZWN0b3IgJiYgKFwiKipcIiAhPT0gciB8fCAhYy5zZWxlY3RvcikgfHwgKHAuc3BsaWNlKG8sIDEpLCBjLnNlbGVjdG9yICYmIHAuZGVsZWdhdGVDb3VudC0tLCBmLnJlbW92ZSAmJiBmLnJlbW92ZS5jYWxsKGUsIGMpKTtcblxuXHQgICAgICAgICAgYSAmJiAhcC5sZW5ndGggJiYgKGYudGVhcmRvd24gJiYgITEgIT09IGYudGVhcmRvd24uY2FsbChlLCBoLCB2LmhhbmRsZSkgfHwgUy5yZW1vdmVFdmVudChlLCBkLCB2LmhhbmRsZSksIGRlbGV0ZSB1W2RdKTtcblx0ICAgICAgICB9IGVsc2UgZm9yIChkIGluIHUpIFMuZXZlbnQucmVtb3ZlKGUsIGQgKyB0W2xdLCBuLCByLCAhMCk7XG5cblx0ICAgICAgICBTLmlzRW1wdHlPYmplY3QodSkgJiYgWS5yZW1vdmUoZSwgXCJoYW5kbGUgZXZlbnRzXCIpO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0LFxuXHQgICAgICAgICAgbixcblx0ICAgICAgICAgIHIsXG5cdCAgICAgICAgICBpLFxuXHQgICAgICAgICAgbyxcblx0ICAgICAgICAgIGEsXG5cdCAgICAgICAgICBzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLFxuXHQgICAgICAgICAgdSA9IFMuZXZlbnQuZml4KGUpLFxuXHQgICAgICAgICAgbCA9IChZLmdldCh0aGlzLCBcImV2ZW50c1wiKSB8fCBPYmplY3QuY3JlYXRlKG51bGwpKVt1LnR5cGVdIHx8IFtdLFxuXHQgICAgICAgICAgYyA9IFMuZXZlbnQuc3BlY2lhbFt1LnR5cGVdIHx8IHt9O1xuXG5cdCAgICAgIGZvciAoc1swXSA9IHUsIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSBzW3RdID0gYXJndW1lbnRzW3RdO1xuXG5cdCAgICAgIGlmICh1LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcywgIWMucHJlRGlzcGF0Y2ggfHwgITEgIT09IGMucHJlRGlzcGF0Y2guY2FsbCh0aGlzLCB1KSkge1xuXHQgICAgICAgIGEgPSBTLmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcywgdSwgbCksIHQgPSAwO1xuXG5cdCAgICAgICAgd2hpbGUgKChpID0gYVt0KytdKSAmJiAhdS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG5cdCAgICAgICAgICB1LmN1cnJlbnRUYXJnZXQgPSBpLmVsZW0sIG4gPSAwO1xuXG5cdCAgICAgICAgICB3aGlsZSAoKG8gPSBpLmhhbmRsZXJzW24rK10pICYmICF1LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHUucm5hbWVzcGFjZSAmJiAhMSAhPT0gby5uYW1lc3BhY2UgJiYgIXUucm5hbWVzcGFjZS50ZXN0KG8ubmFtZXNwYWNlKSB8fCAodS5oYW5kbGVPYmogPSBvLCB1LmRhdGEgPSBvLmRhdGEsIHZvaWQgMCAhPT0gKHIgPSAoKFMuZXZlbnQuc3BlY2lhbFtvLm9yaWdUeXBlXSB8fCB7fSkuaGFuZGxlIHx8IG8uaGFuZGxlcikuYXBwbHkoaS5lbGVtLCBzKSkgJiYgITEgPT09ICh1LnJlc3VsdCA9IHIpICYmICh1LnByZXZlbnREZWZhdWx0KCksIHUuc3RvcFByb3BhZ2F0aW9uKCkpKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gYy5wb3N0RGlzcGF0Y2ggJiYgYy5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCB1KSwgdS5yZXN1bHQ7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBoYW5kbGVyczogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgdmFyIG4sXG5cdCAgICAgICAgICByLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyA9IFtdLFxuXHQgICAgICAgICAgdSA9IHQuZGVsZWdhdGVDb3VudCxcblx0ICAgICAgICAgIGwgPSBlLnRhcmdldDtcblx0ICAgICAgaWYgKHUgJiYgbC5ub2RlVHlwZSAmJiAhKFwiY2xpY2tcIiA9PT0gZS50eXBlICYmIDEgPD0gZS5idXR0b24pKSBmb3IgKDsgbCAhPT0gdGhpczsgbCA9IGwucGFyZW50Tm9kZSB8fCB0aGlzKSBpZiAoMSA9PT0gbC5ub2RlVHlwZSAmJiAoXCJjbGlja1wiICE9PSBlLnR5cGUgfHwgITAgIT09IGwuZGlzYWJsZWQpKSB7XG5cdCAgICAgICAgZm9yIChvID0gW10sIGEgPSB7fSwgbiA9IDA7IG4gPCB1OyBuKyspIHZvaWQgMCA9PT0gYVtpID0gKHIgPSB0W25dKS5zZWxlY3RvciArIFwiIFwiXSAmJiAoYVtpXSA9IHIubmVlZHNDb250ZXh0ID8gLTEgPCBTKGksIHRoaXMpLmluZGV4KGwpIDogUy5maW5kKGksIHRoaXMsIG51bGwsIFtsXSkubGVuZ3RoKSwgYVtpXSAmJiBvLnB1c2gocik7XG5cblx0ICAgICAgICBvLmxlbmd0aCAmJiBzLnB1c2goe1xuXHQgICAgICAgICAgZWxlbTogbCxcblx0ICAgICAgICAgIGhhbmRsZXJzOiBvXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGwgPSB0aGlzLCB1IDwgdC5sZW5ndGggJiYgcy5wdXNoKHtcblx0ICAgICAgICBlbGVtOiBsLFxuXHQgICAgICAgIGhhbmRsZXJzOiB0LnNsaWNlKHUpXG5cdCAgICAgIH0pLCBzO1xuXHQgICAgfSxcblx0ICAgIGFkZFByb3A6IGZ1bmN0aW9uICh0LCBlKSB7XG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTLkV2ZW50LnByb3RvdHlwZSwgdCwge1xuXHQgICAgICAgIGVudW1lcmFibGU6ICEwLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG5cdCAgICAgICAgZ2V0OiBtKGUpID8gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxFdmVudCkgcmV0dXJuIGUodGhpcy5vcmlnaW5hbEV2ZW50KTtcblx0ICAgICAgICB9IDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxFdmVudCkgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFt0XTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCB0LCB7XG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuXHQgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuXHQgICAgICAgICAgICB3cml0YWJsZTogITAsXG5cdCAgICAgICAgICAgIHZhbHVlOiBlXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIGZpeDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIGVbUy5leHBhbmRvXSA/IGUgOiBuZXcgUy5FdmVudChlKTtcblx0ICAgIH0sXG5cdCAgICBzcGVjaWFsOiB7XG5cdCAgICAgIGxvYWQ6IHtcblx0ICAgICAgICBub0J1YmJsZTogITBcblx0ICAgICAgfSxcblx0ICAgICAgY2xpY2s6IHtcblx0ICAgICAgICBzZXR1cDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciB0ID0gdGhpcyB8fCBlO1xuXHQgICAgICAgICAgcmV0dXJuIHBlLnRlc3QodC50eXBlKSAmJiB0LmNsaWNrICYmIEEodCwgXCJpbnB1dFwiKSAmJiBTZSh0LCBcImNsaWNrXCIsIHdlKSwgITE7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQgPSB0aGlzIHx8IGU7XG5cdCAgICAgICAgICByZXR1cm4gcGUudGVzdCh0LnR5cGUpICYmIHQuY2xpY2sgJiYgQSh0LCBcImlucHV0XCIpICYmIFNlKHQsIFwiY2xpY2tcIiksICEwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgX2RlZmF1bHQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdCA9IGUudGFyZ2V0O1xuXHQgICAgICAgICAgcmV0dXJuIHBlLnRlc3QodC50eXBlKSAmJiB0LmNsaWNrICYmIEEodCwgXCJpbnB1dFwiKSAmJiBZLmdldCh0LCBcImNsaWNrXCIpIHx8IEEodCwgXCJhXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgYmVmb3JldW5sb2FkOiB7XG5cdCAgICAgICAgcG9zdERpc3BhdGNoOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdm9pZCAwICE9PSBlLnJlc3VsdCAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgKGUub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGUucmVzdWx0KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCBTLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgbik7XG5cdCAgfSwgUy5FdmVudCA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUy5FdmVudCkpIHJldHVybiBuZXcgUy5FdmVudChlLCB0KTtcblx0ICAgIGUgJiYgZS50eXBlID8gKHRoaXMub3JpZ2luYWxFdmVudCA9IGUsIHRoaXMudHlwZSA9IGUudHlwZSwgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgdm9pZCAwID09PSBlLmRlZmF1bHRQcmV2ZW50ZWQgJiYgITEgPT09IGUucmV0dXJuVmFsdWUgPyB3ZSA6IFRlLCB0aGlzLnRhcmdldCA9IGUudGFyZ2V0ICYmIDMgPT09IGUudGFyZ2V0Lm5vZGVUeXBlID8gZS50YXJnZXQucGFyZW50Tm9kZSA6IGUudGFyZ2V0LCB0aGlzLmN1cnJlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQsIHRoaXMucmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldCkgOiB0aGlzLnR5cGUgPSBlLCB0ICYmIFMuZXh0ZW5kKHRoaXMsIHQpLCB0aGlzLnRpbWVTdGFtcCA9IGUgJiYgZS50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKSwgdGhpc1tTLmV4cGFuZG9dID0gITA7XG5cdCAgfSwgUy5FdmVudC5wcm90b3R5cGUgPSB7XG5cdCAgICBjb25zdHJ1Y3RvcjogUy5FdmVudCxcblx0ICAgIGlzRGVmYXVsdFByZXZlbnRlZDogVGUsXG5cdCAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogVGUsXG5cdCAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogVGUsXG5cdCAgICBpc1NpbXVsYXRlZDogITEsXG5cdCAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblx0ICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSB3ZSwgZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICB9LFxuXHQgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXHQgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gd2UsIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgIH0sXG5cdCAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cdCAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB3ZSwgZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgfVxuXHQgIH0sIFMuZWFjaCh7XG5cdCAgICBhbHRLZXk6ICEwLFxuXHQgICAgYnViYmxlczogITAsXG5cdCAgICBjYW5jZWxhYmxlOiAhMCxcblx0ICAgIGNoYW5nZWRUb3VjaGVzOiAhMCxcblx0ICAgIGN0cmxLZXk6ICEwLFxuXHQgICAgZGV0YWlsOiAhMCxcblx0ICAgIGV2ZW50UGhhc2U6ICEwLFxuXHQgICAgbWV0YUtleTogITAsXG5cdCAgICBwYWdlWDogITAsXG5cdCAgICBwYWdlWTogITAsXG5cdCAgICBzaGlmdEtleTogITAsXG5cdCAgICB2aWV3OiAhMCxcblx0ICAgIFwiY2hhclwiOiAhMCxcblx0ICAgIGNvZGU6ICEwLFxuXHQgICAgY2hhckNvZGU6ICEwLFxuXHQgICAga2V5OiAhMCxcblx0ICAgIGtleUNvZGU6ICEwLFxuXHQgICAgYnV0dG9uOiAhMCxcblx0ICAgIGJ1dHRvbnM6ICEwLFxuXHQgICAgY2xpZW50WDogITAsXG5cdCAgICBjbGllbnRZOiAhMCxcblx0ICAgIG9mZnNldFg6ICEwLFxuXHQgICAgb2Zmc2V0WTogITAsXG5cdCAgICBwb2ludGVySWQ6ICEwLFxuXHQgICAgcG9pbnRlclR5cGU6ICEwLFxuXHQgICAgc2NyZWVuWDogITAsXG5cdCAgICBzY3JlZW5ZOiAhMCxcblx0ICAgIHRhcmdldFRvdWNoZXM6ICEwLFxuXHQgICAgdG9FbGVtZW50OiAhMCxcblx0ICAgIHRvdWNoZXM6ICEwLFxuXHQgICAgd2hpY2g6ICEwXG5cdCAgfSwgUy5ldmVudC5hZGRQcm9wKSwgUy5lYWNoKHtcblx0ICAgIGZvY3VzOiBcImZvY3VzaW5cIixcblx0ICAgIGJsdXI6IFwiZm9jdXNvdXRcIlxuXHQgIH0sIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICBTLmV2ZW50LnNwZWNpYWxbZV0gPSB7XG5cdCAgICAgIHNldHVwOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFNlKHRoaXMsIGUsIENlKSwgITE7XG5cdCAgICAgIH0sXG5cdCAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gU2UodGhpcywgZSksICEwO1xuXHQgICAgICB9LFxuXHQgICAgICBfZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAhMDtcblx0ICAgICAgfSxcblx0ICAgICAgZGVsZWdhdGVUeXBlOiB0XG5cdCAgICB9O1xuXHQgIH0pLCBTLmVhY2goe1xuXHQgICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0ICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0ICAgIHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHQgICAgcG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxuXHQgIH0sIGZ1bmN0aW9uIChlLCBpKSB7XG5cdCAgICBTLmV2ZW50LnNwZWNpYWxbZV0gPSB7XG5cdCAgICAgIGRlbGVnYXRlVHlwZTogaSxcblx0ICAgICAgYmluZFR5cGU6IGksXG5cdCAgICAgIGhhbmRsZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdCxcblx0ICAgICAgICAgICAgbiA9IGUucmVsYXRlZFRhcmdldCxcblx0ICAgICAgICAgICAgciA9IGUuaGFuZGxlT2JqO1xuXHQgICAgICAgIHJldHVybiBuICYmIChuID09PSB0aGlzIHx8IFMuY29udGFpbnModGhpcywgbikpIHx8IChlLnR5cGUgPSByLm9yaWdUeXBlLCB0ID0gci5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGUudHlwZSA9IGkpLCB0O1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0pLCBTLmZuLmV4dGVuZCh7XG5cdCAgICBvbjogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcblx0ICAgICAgcmV0dXJuIEVlKHRoaXMsIGUsIHQsIG4sIHIpO1xuXHQgICAgfSxcblx0ICAgIG9uZTogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcblx0ICAgICAgcmV0dXJuIEVlKHRoaXMsIGUsIHQsIG4sIHIsIDEpO1xuXHQgICAgfSxcblx0ICAgIG9mZjogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgdmFyIHIsIGk7XG5cdCAgICAgIGlmIChlICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5oYW5kbGVPYmopIHJldHVybiByID0gZS5oYW5kbGVPYmosIFMoZS5kZWxlZ2F0ZVRhcmdldCkub2ZmKHIubmFtZXNwYWNlID8gci5vcmlnVHlwZSArIFwiLlwiICsgci5uYW1lc3BhY2UgOiByLm9yaWdUeXBlLCByLnNlbGVjdG9yLCByLmhhbmRsZXIpLCB0aGlzO1xuXG5cdCAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlKSB7XG5cdCAgICAgICAgZm9yIChpIGluIGUpIHRoaXMub2ZmKGksIHQsIGVbaV0pO1xuXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gITEgIT09IHQgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0IHx8IChuID0gdCwgdCA9IHZvaWQgMCksICExID09PSBuICYmIChuID0gVGUpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFMuZXZlbnQucmVtb3ZlKHRoaXMsIGUsIG4sIHQpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICB2YXIga2UgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblx0ICAgICAgQWUgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHQgICAgICBOZSA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuXHQgIGZ1bmN0aW9uIGplKGUsIHQpIHtcblx0ICAgIHJldHVybiBBKGUsIFwidGFibGVcIikgJiYgQSgxMSAhPT0gdC5ub2RlVHlwZSA/IHQgOiB0LmZpcnN0Q2hpbGQsIFwidHJcIikgJiYgUyhlKS5jaGlsZHJlbihcInRib2R5XCIpWzBdIHx8IGU7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gRGUoZSkge1xuXHQgICAgcmV0dXJuIGUudHlwZSA9IChudWxsICE9PSBlLmdldEF0dHJpYnV0ZShcInR5cGVcIikpICsgXCIvXCIgKyBlLnR5cGUsIGU7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcWUoZSkge1xuXHQgICAgcmV0dXJuIFwidHJ1ZS9cIiA9PT0gKGUudHlwZSB8fCBcIlwiKS5zbGljZSgwLCA1KSA/IGUudHlwZSA9IGUudHlwZS5zbGljZSg1KSA6IGUucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKSwgZTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBMZShlLCB0KSB7XG5cdCAgICB2YXIgbiwgciwgaSwgbywgYSwgcztcblxuXHQgICAgaWYgKDEgPT09IHQubm9kZVR5cGUpIHtcblx0ICAgICAgaWYgKFkuaGFzRGF0YShlKSAmJiAocyA9IFkuZ2V0KGUpLmV2ZW50cykpIGZvciAoaSBpbiBZLnJlbW92ZSh0LCBcImhhbmRsZSBldmVudHNcIiksIHMpIGZvciAobiA9IDAsIHIgPSBzW2ldLmxlbmd0aDsgbiA8IHI7IG4rKykgUy5ldmVudC5hZGQodCwgaSwgc1tpXVtuXSk7XG5cdCAgICAgIFEuaGFzRGF0YShlKSAmJiAobyA9IFEuYWNjZXNzKGUpLCBhID0gUy5leHRlbmQoe30sIG8pLCBRLnNldCh0LCBhKSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gSGUobiwgciwgaSwgbykge1xuXHQgICAgciA9IGcocik7XG5cdCAgICB2YXIgZSxcblx0ICAgICAgICB0LFxuXHQgICAgICAgIGEsXG5cdCAgICAgICAgcyxcblx0ICAgICAgICB1LFxuXHQgICAgICAgIGwsXG5cdCAgICAgICAgYyA9IDAsXG5cdCAgICAgICAgZiA9IG4ubGVuZ3RoLFxuXHQgICAgICAgIHAgPSBmIC0gMSxcblx0ICAgICAgICBkID0gclswXSxcblx0ICAgICAgICBoID0gbShkKTtcblx0ICAgIGlmIChoIHx8IDEgPCBmICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGQgJiYgIXkuY2hlY2tDbG9uZSAmJiBBZS50ZXN0KGQpKSByZXR1cm4gbi5lYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0ID0gbi5lcShlKTtcblx0ICAgICAgaCAmJiAoclswXSA9IGQuY2FsbCh0aGlzLCBlLCB0Lmh0bWwoKSkpLCBIZSh0LCByLCBpLCBvKTtcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAoZiAmJiAodCA9IChlID0geGUociwgblswXS5vd25lckRvY3VtZW50LCAhMSwgbiwgbykpLmZpcnN0Q2hpbGQsIDEgPT09IGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgKGUgPSB0KSwgdCB8fCBvKSkge1xuXHQgICAgICBmb3IgKHMgPSAoYSA9IFMubWFwKHZlKGUsIFwic2NyaXB0XCIpLCBEZSkpLmxlbmd0aDsgYyA8IGY7IGMrKykgdSA9IGUsIGMgIT09IHAgJiYgKHUgPSBTLmNsb25lKHUsICEwLCAhMCksIHMgJiYgUy5tZXJnZShhLCB2ZSh1LCBcInNjcmlwdFwiKSkpLCBpLmNhbGwobltjXSwgdSwgYyk7XG5cblx0ICAgICAgaWYgKHMpIGZvciAobCA9IGFbYS5sZW5ndGggLSAxXS5vd25lckRvY3VtZW50LCBTLm1hcChhLCBxZSksIGMgPSAwOyBjIDwgczsgYysrKSB1ID0gYVtjXSwgaGUudGVzdCh1LnR5cGUgfHwgXCJcIikgJiYgIVkuYWNjZXNzKHUsIFwiZ2xvYmFsRXZhbFwiKSAmJiBTLmNvbnRhaW5zKGwsIHUpICYmICh1LnNyYyAmJiBcIm1vZHVsZVwiICE9PSAodS50eXBlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPyBTLl9ldmFsVXJsICYmICF1Lm5vTW9kdWxlICYmIFMuX2V2YWxVcmwodS5zcmMsIHtcblx0ICAgICAgICBub25jZTogdS5ub25jZSB8fCB1LmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpXG5cdCAgICAgIH0sIGwpIDogYih1LnRleHRDb250ZW50LnJlcGxhY2UoTmUsIFwiXCIpLCB1LCBsKSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIE9lKGUsIHQsIG4pIHtcblx0ICAgIGZvciAodmFyIHIsIGkgPSB0ID8gUy5maWx0ZXIodCwgZSkgOiBlLCBvID0gMDsgbnVsbCAhPSAociA9IGlbb10pOyBvKyspIG4gfHwgMSAhPT0gci5ub2RlVHlwZSB8fCBTLmNsZWFuRGF0YSh2ZShyKSksIHIucGFyZW50Tm9kZSAmJiAobiAmJiBpZShyKSAmJiB5ZSh2ZShyLCBcInNjcmlwdFwiKSksIHIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyKSk7XG5cblx0ICAgIHJldHVybiBlO1xuXHQgIH1cblxuXHQgIFMuZXh0ZW5kKHtcblx0ICAgIGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBlO1xuXHQgICAgfSxcblx0ICAgIGNsb25lOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICB2YXIgcixcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICBvLFxuXHQgICAgICAgICAgYSxcblx0ICAgICAgICAgIHMsXG5cdCAgICAgICAgICB1LFxuXHQgICAgICAgICAgbCxcblx0ICAgICAgICAgIGMgPSBlLmNsb25lTm9kZSghMCksXG5cdCAgICAgICAgICBmID0gaWUoZSk7XG5cdCAgICAgIGlmICghKHkubm9DbG9uZUNoZWNrZWQgfHwgMSAhPT0gZS5ub2RlVHlwZSAmJiAxMSAhPT0gZS5ub2RlVHlwZSB8fCBTLmlzWE1MRG9jKGUpKSkgZm9yIChhID0gdmUoYyksIHIgPSAwLCBpID0gKG8gPSB2ZShlKSkubGVuZ3RoOyByIDwgaTsgcisrKSBzID0gb1tyXSwgdSA9IGFbcl0sIFwiaW5wdXRcIiA9PT0gKGwgPSB1Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpICYmIHBlLnRlc3Qocy50eXBlKSA/IHUuY2hlY2tlZCA9IHMuY2hlY2tlZCA6IFwiaW5wdXRcIiAhPT0gbCAmJiBcInRleHRhcmVhXCIgIT09IGwgfHwgKHUuZGVmYXVsdFZhbHVlID0gcy5kZWZhdWx0VmFsdWUpO1xuXHQgICAgICBpZiAodCkgaWYgKG4pIGZvciAobyA9IG8gfHwgdmUoZSksIGEgPSBhIHx8IHZlKGMpLCByID0gMCwgaSA9IG8ubGVuZ3RoOyByIDwgaTsgcisrKSBMZShvW3JdLCBhW3JdKTtlbHNlIExlKGUsIGMpO1xuXHQgICAgICByZXR1cm4gMCA8IChhID0gdmUoYywgXCJzY3JpcHRcIikpLmxlbmd0aCAmJiB5ZShhLCAhZiAmJiB2ZShlLCBcInNjcmlwdFwiKSksIGM7XG5cdCAgICB9LFxuXHQgICAgY2xlYW5EYXRhOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBmb3IgKHZhciB0LCBuLCByLCBpID0gUy5ldmVudC5zcGVjaWFsLCBvID0gMDsgdm9pZCAwICE9PSAobiA9IGVbb10pOyBvKyspIGlmIChWKG4pKSB7XG5cdCAgICAgICAgaWYgKHQgPSBuW1kuZXhwYW5kb10pIHtcblx0ICAgICAgICAgIGlmICh0LmV2ZW50cykgZm9yIChyIGluIHQuZXZlbnRzKSBpW3JdID8gUy5ldmVudC5yZW1vdmUobiwgcikgOiBTLnJlbW92ZUV2ZW50KG4sIHIsIHQuaGFuZGxlKTtcblx0ICAgICAgICAgIG5bWS5leHBhbmRvXSA9IHZvaWQgMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBuW1EuZXhwYW5kb10gJiYgKG5bUS5leHBhbmRvXSA9IHZvaWQgMCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9KSwgUy5mbi5leHRlbmQoe1xuXHQgICAgZGV0YWNoOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gT2UodGhpcywgZSwgITApO1xuXHQgICAgfSxcblx0ICAgIHJlbW92ZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIE9lKHRoaXMsIGUpO1xuXHQgICAgfSxcblx0ICAgIHRleHQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiAkKHRoaXMsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZSA/IFMudGV4dCh0aGlzKSA6IHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIDEgIT09IHRoaXMubm9kZVR5cGUgJiYgMTEgIT09IHRoaXMubm9kZVR5cGUgJiYgOSAhPT0gdGhpcy5ub2RlVHlwZSB8fCAodGhpcy50ZXh0Q29udGVudCA9IGUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9LCBudWxsLCBlLCBhcmd1bWVudHMubGVuZ3RoKTtcblx0ICAgIH0sXG5cdCAgICBhcHBlbmQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIEhlKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAxICE9PSB0aGlzLm5vZGVUeXBlICYmIDExICE9PSB0aGlzLm5vZGVUeXBlICYmIDkgIT09IHRoaXMubm9kZVR5cGUgfHwgamUodGhpcywgZSkuYXBwZW5kQ2hpbGQoZSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIHByZXBlbmQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIEhlKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBpZiAoMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCAxMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCA5ID09PSB0aGlzLm5vZGVUeXBlKSB7XG5cdCAgICAgICAgICB2YXIgdCA9IGplKHRoaXMsIGUpO1xuXHQgICAgICAgICAgdC5pbnNlcnRCZWZvcmUoZSwgdC5maXJzdENoaWxkKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIGJlZm9yZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gSGUodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMpO1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICBhZnRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gSGUodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMubmV4dFNpYmxpbmcpO1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xuXHQgICAgICBmb3IgKHZhciBlLCB0ID0gMDsgbnVsbCAhPSAoZSA9IHRoaXNbdF0pOyB0KyspIDEgPT09IGUubm9kZVR5cGUgJiYgKFMuY2xlYW5EYXRhKHZlKGUsICExKSksIGUudGV4dENvbnRlbnQgPSBcIlwiKTtcblxuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH0sXG5cdCAgICBjbG9uZTogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgcmV0dXJuIGUgPSBudWxsICE9IGUgJiYgZSwgdCA9IG51bGwgPT0gdCA/IGUgOiB0LCB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFMuY2xvbmUodGhpcywgZSwgdCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIGh0bWw6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiAkKHRoaXMsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIHQgPSB0aGlzWzBdIHx8IHt9LFxuXHQgICAgICAgICAgICBuID0gMCxcblx0ICAgICAgICAgICAgciA9IHRoaXMubGVuZ3RoO1xuXHQgICAgICAgIGlmICh2b2lkIDAgPT09IGUgJiYgMSA9PT0gdC5ub2RlVHlwZSkgcmV0dXJuIHQuaW5uZXJIVE1MO1xuXG5cdCAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgIWtlLnRlc3QoZSkgJiYgIWdlWyhkZS5leGVjKGUpIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pIHtcblx0ICAgICAgICAgIGUgPSBTLmh0bWxQcmVmaWx0ZXIoZSk7XG5cblx0ICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGZvciAoOyBuIDwgcjsgbisrKSAxID09PSAodCA9IHRoaXNbbl0gfHwge30pLm5vZGVUeXBlICYmIChTLmNsZWFuRGF0YSh2ZSh0LCAhMSkpLCB0LmlubmVySFRNTCA9IGUpO1xuXG5cdCAgICAgICAgICAgIHQgPSAwO1xuXHQgICAgICAgICAgfSBjYXRjaCAoZSkge31cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0ICYmIHRoaXMuZW1wdHkoKS5hcHBlbmQoZSk7XG5cdCAgICAgIH0sIG51bGwsIGUsIGFyZ3VtZW50cy5sZW5ndGgpO1xuXHQgICAgfSxcblx0ICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBuID0gW107XG5cdCAgICAgIHJldHVybiBIZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIHQgPSB0aGlzLnBhcmVudE5vZGU7XG5cdCAgICAgICAgUy5pbkFycmF5KHRoaXMsIG4pIDwgMCAmJiAoUy5jbGVhbkRhdGEodmUodGhpcykpLCB0ICYmIHQucmVwbGFjZUNoaWxkKGUsIHRoaXMpKTtcblx0ICAgICAgfSwgbik7XG5cdCAgICB9XG5cdCAgfSksIFMuZWFjaCh7XG5cdCAgICBhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0ICAgIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdCAgICBpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdCAgICBpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHQgICAgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG5cdCAgfSwgZnVuY3Rpb24gKGUsIGEpIHtcblx0ICAgIFMuZm5bZV0gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBmb3IgKHZhciB0LCBuID0gW10sIHIgPSBTKGUpLCBpID0gci5sZW5ndGggLSAxLCBvID0gMDsgbyA8PSBpOyBvKyspIHQgPSBvID09PSBpID8gdGhpcyA6IHRoaXMuY2xvbmUoITApLCBTKHJbb10pW2FdKHQpLCB1LmFwcGx5KG4sIHQuZ2V0KCkpO1xuXG5cdCAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhuKTtcblx0ICAgIH07XG5cdCAgfSk7XG5cblx0ICB2YXIgUGUgPSBuZXcgUmVnRXhwKFwiXihcIiArIGVlICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpLFxuXHQgICAgICBSZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgdCA9IGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0ICAgIHJldHVybiB0ICYmIHQub3BlbmVyIHx8ICh0ID0gQyksIHQuZ2V0Q29tcHV0ZWRTdHlsZShlKTtcblx0ICB9LFxuXHQgICAgICBNZSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICB2YXIgcixcblx0ICAgICAgICBpLFxuXHQgICAgICAgIG8gPSB7fTtcblxuXHQgICAgZm9yIChpIGluIHQpIG9baV0gPSBlLnN0eWxlW2ldLCBlLnN0eWxlW2ldID0gdFtpXTtcblxuXHQgICAgZm9yIChpIGluIHIgPSBuLmNhbGwoZSksIHQpIGUuc3R5bGVbaV0gPSBvW2ldO1xuXG5cdCAgICByZXR1cm4gcjtcblx0ICB9LFxuXHQgICAgICBJZSA9IG5ldyBSZWdFeHAobmUuam9pbihcInxcIiksIFwiaVwiKTtcblxuXHQgIGZ1bmN0aW9uIFdlKGUsIHQsIG4pIHtcblx0ICAgIHZhciByLFxuXHQgICAgICAgIGksXG5cdCAgICAgICAgbyxcblx0ICAgICAgICBhLFxuXHQgICAgICAgIHMgPSBlLnN0eWxlO1xuXHQgICAgcmV0dXJuIChuID0gbiB8fCBSZShlKSkgJiYgKFwiXCIgIT09IChhID0gbi5nZXRQcm9wZXJ0eVZhbHVlKHQpIHx8IG5bdF0pIHx8IGllKGUpIHx8IChhID0gUy5zdHlsZShlLCB0KSksICF5LnBpeGVsQm94U3R5bGVzKCkgJiYgUGUudGVzdChhKSAmJiBJZS50ZXN0KHQpICYmIChyID0gcy53aWR0aCwgaSA9IHMubWluV2lkdGgsIG8gPSBzLm1heFdpZHRoLCBzLm1pbldpZHRoID0gcy5tYXhXaWR0aCA9IHMud2lkdGggPSBhLCBhID0gbi53aWR0aCwgcy53aWR0aCA9IHIsIHMubWluV2lkdGggPSBpLCBzLm1heFdpZHRoID0gbykpLCB2b2lkIDAgIT09IGEgPyBhICsgXCJcIiA6IGE7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gRmUoZSwgdCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCFlKCkpIHJldHVybiAodGhpcy5nZXQgPSB0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIGRlbGV0ZSB0aGlzLmdldDtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICB9XG5cblx0ICAhZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gZSgpIHtcblx0ICAgICAgaWYgKGwpIHtcblx0ICAgICAgICB1LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDttYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIiwgbC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7bWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo2MCU7dG9wOjElXCIsIHJlLmFwcGVuZENoaWxkKHUpLmFwcGVuZENoaWxkKGwpO1xuXHQgICAgICAgIHZhciBlID0gQy5nZXRDb21wdXRlZFN0eWxlKGwpO1xuXHQgICAgICAgIG4gPSBcIjElXCIgIT09IGUudG9wLCBzID0gMTIgPT09IHQoZS5tYXJnaW5MZWZ0KSwgbC5zdHlsZS5yaWdodCA9IFwiNjAlXCIsIG8gPSAzNiA9PT0gdChlLnJpZ2h0KSwgciA9IDM2ID09PSB0KGUud2lkdGgpLCBsLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCBpID0gMTIgPT09IHQobC5vZmZzZXRXaWR0aCAvIDMpLCByZS5yZW1vdmVDaGlsZCh1KSwgbCA9IG51bGw7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gdChlKSB7XG5cdCAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZSkpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbixcblx0ICAgICAgICByLFxuXHQgICAgICAgIGksXG5cdCAgICAgICAgbyxcblx0ICAgICAgICBhLFxuXHQgICAgICAgIHMsXG5cdCAgICAgICAgdSA9IEUuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblx0ICAgICAgICBsID0gRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHQgICAgbC5zdHlsZSAmJiAobC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIiwgbC5jbG9uZU5vZGUoITApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIiwgeS5jbGVhckNsb25lU3R5bGUgPSBcImNvbnRlbnQtYm94XCIgPT09IGwuc3R5bGUuYmFja2dyb3VuZENsaXAsIFMuZXh0ZW5kKHksIHtcblx0ICAgICAgYm94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gZSgpLCByO1xuXHQgICAgICB9LFxuXHQgICAgICBwaXhlbEJveFN0eWxlczogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBlKCksIG87XG5cdCAgICAgIH0sXG5cdCAgICAgIHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gZSgpLCBuO1xuXHQgICAgICB9LFxuXHQgICAgICByZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gZSgpLCBzO1xuXHQgICAgICB9LFxuXHQgICAgICBzY3JvbGxib3hTaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGUoKSwgaTtcblx0ICAgICAgfSxcblx0ICAgICAgcmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZSwgdCwgbiwgcjtcblx0ICAgICAgICByZXR1cm4gbnVsbCA9PSBhICYmIChlID0gRS5jcmVhdGVFbGVtZW50KFwidGFibGVcIiksIHQgPSBFLmNyZWF0ZUVsZW1lbnQoXCJ0clwiKSwgbiA9IEUuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiLCB0LnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjoxcHggc29saWRcIiwgdC5zdHlsZS5oZWlnaHQgPSBcIjFweFwiLCBuLnN0eWxlLmhlaWdodCA9IFwiOXB4XCIsIG4uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIiwgcmUuYXBwZW5kQ2hpbGQoZSkuYXBwZW5kQ2hpbGQodCkuYXBwZW5kQ2hpbGQobiksIHIgPSBDLmdldENvbXB1dGVkU3R5bGUodCksIGEgPSBwYXJzZUludChyLmhlaWdodCwgMTApICsgcGFyc2VJbnQoci5ib3JkZXJUb3BXaWR0aCwgMTApICsgcGFyc2VJbnQoci5ib3JkZXJCb3R0b21XaWR0aCwgMTApID09PSB0Lm9mZnNldEhlaWdodCwgcmUucmVtb3ZlQ2hpbGQoZSkpLCBhO1xuXHQgICAgICB9XG5cdCAgICB9KSk7XG5cdCAgfSgpO1xuXHQgIHZhciBCZSA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCJdLFxuXHQgICAgICAkZSA9IEUuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSxcblx0ICAgICAgX2UgPSB7fTtcblxuXHQgIGZ1bmN0aW9uIHplKGUpIHtcblx0ICAgIHZhciB0ID0gUy5jc3NQcm9wc1tlXSB8fCBfZVtlXTtcblx0ICAgIHJldHVybiB0IHx8IChlIGluICRlID8gZSA6IF9lW2VdID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQgPSBlWzBdLnRvVXBwZXJDYXNlKCkgKyBlLnNsaWNlKDEpLFxuXHQgICAgICAgICAgbiA9IEJlLmxlbmd0aDtcblxuXHQgICAgICB3aGlsZSAobi0tKSBpZiAoKGUgPSBCZVtuXSArIHQpIGluICRlKSByZXR1cm4gZTtcblx0ICAgIH0oZSkgfHwgZSk7XG5cdCAgfVxuXG5cdCAgdmFyIFVlID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHQgICAgICBYZSA9IC9eLS0vLFxuXHQgICAgICBWZSA9IHtcblx0ICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG5cdCAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiLFxuXHQgICAgZGlzcGxheTogXCJibG9ja1wiXG5cdCAgfSxcblx0ICAgICAgR2UgPSB7XG5cdCAgICBsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0ICAgIGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gWWUoZSwgdCwgbikge1xuXHQgICAgdmFyIHIgPSB0ZS5leGVjKHQpO1xuXHQgICAgcmV0dXJuIHIgPyBNYXRoLm1heCgwLCByWzJdIC0gKG4gfHwgMCkpICsgKHJbM10gfHwgXCJweFwiKSA6IHQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gUWUoZSwgdCwgbiwgciwgaSwgbykge1xuXHQgICAgdmFyIGEgPSBcIndpZHRoXCIgPT09IHQgPyAxIDogMCxcblx0ICAgICAgICBzID0gMCxcblx0ICAgICAgICB1ID0gMDtcblx0ICAgIGlmIChuID09PSAociA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIikpIHJldHVybiAwO1xuXG5cdCAgICBmb3IgKDsgYSA8IDQ7IGEgKz0gMikgXCJtYXJnaW5cIiA9PT0gbiAmJiAodSArPSBTLmNzcyhlLCBuICsgbmVbYV0sICEwLCBpKSksIHIgPyAoXCJjb250ZW50XCIgPT09IG4gJiYgKHUgLT0gUy5jc3MoZSwgXCJwYWRkaW5nXCIgKyBuZVthXSwgITAsIGkpKSwgXCJtYXJnaW5cIiAhPT0gbiAmJiAodSAtPSBTLmNzcyhlLCBcImJvcmRlclwiICsgbmVbYV0gKyBcIldpZHRoXCIsICEwLCBpKSkpIDogKHUgKz0gUy5jc3MoZSwgXCJwYWRkaW5nXCIgKyBuZVthXSwgITAsIGkpLCBcInBhZGRpbmdcIiAhPT0gbiA/IHUgKz0gUy5jc3MoZSwgXCJib3JkZXJcIiArIG5lW2FdICsgXCJXaWR0aFwiLCAhMCwgaSkgOiBzICs9IFMuY3NzKGUsIFwiYm9yZGVyXCIgKyBuZVthXSArIFwiV2lkdGhcIiwgITAsIGkpKTtcblxuXHQgICAgcmV0dXJuICFyICYmIDAgPD0gbyAmJiAodSArPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoZVtcIm9mZnNldFwiICsgdFswXS50b1VwcGVyQ2FzZSgpICsgdC5zbGljZSgxKV0gLSBvIC0gdSAtIHMgLSAuNSkpIHx8IDApLCB1O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIEplKGUsIHQsIG4pIHtcblx0ICAgIHZhciByID0gUmUoZSksXG5cdCAgICAgICAgaSA9ICgheS5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IG4pICYmIFwiYm9yZGVyLWJveFwiID09PSBTLmNzcyhlLCBcImJveFNpemluZ1wiLCAhMSwgciksXG5cdCAgICAgICAgbyA9IGksXG5cdCAgICAgICAgYSA9IFdlKGUsIHQsIHIpLFxuXHQgICAgICAgIHMgPSBcIm9mZnNldFwiICsgdFswXS50b1VwcGVyQ2FzZSgpICsgdC5zbGljZSgxKTtcblxuXHQgICAgaWYgKFBlLnRlc3QoYSkpIHtcblx0ICAgICAgaWYgKCFuKSByZXR1cm4gYTtcblx0ICAgICAgYSA9IFwiYXV0b1wiO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gKCF5LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaSB8fCAheS5yZWxpYWJsZVRyRGltZW5zaW9ucygpICYmIEEoZSwgXCJ0clwiKSB8fCBcImF1dG9cIiA9PT0gYSB8fCAhcGFyc2VGbG9hdChhKSAmJiBcImlubGluZVwiID09PSBTLmNzcyhlLCBcImRpc3BsYXlcIiwgITEsIHIpKSAmJiBlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICYmIChpID0gXCJib3JkZXItYm94XCIgPT09IFMuY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCByKSwgKG8gPSBzIGluIGUpICYmIChhID0gZVtzXSkpLCAoYSA9IHBhcnNlRmxvYXQoYSkgfHwgMCkgKyBRZShlLCB0LCBuIHx8IChpID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSwgbywgciwgYSkgKyBcInB4XCI7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gS2UoZSwgdCwgbiwgciwgaSkge1xuXHQgICAgcmV0dXJuIG5ldyBLZS5wcm90b3R5cGUuaW5pdChlLCB0LCBuLCByLCBpKTtcblx0ICB9XG5cblx0ICBTLmV4dGVuZCh7XG5cdCAgICBjc3NIb29rczoge1xuXHQgICAgICBvcGFjaXR5OiB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgICAgaWYgKHQpIHtcblx0ICAgICAgICAgICAgdmFyIG4gPSBXZShlLCBcIm9wYWNpdHlcIik7XG5cdCAgICAgICAgICAgIHJldHVybiBcIlwiID09PSBuID8gXCIxXCIgOiBuO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIGNzc051bWJlcjoge1xuXHQgICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogITAsXG5cdCAgICAgIGNvbHVtbkNvdW50OiAhMCxcblx0ICAgICAgZmlsbE9wYWNpdHk6ICEwLFxuXHQgICAgICBmbGV4R3JvdzogITAsXG5cdCAgICAgIGZsZXhTaHJpbms6ICEwLFxuXHQgICAgICBmb250V2VpZ2h0OiAhMCxcblx0ICAgICAgZ3JpZEFyZWE6ICEwLFxuXHQgICAgICBncmlkQ29sdW1uOiAhMCxcblx0ICAgICAgZ3JpZENvbHVtbkVuZDogITAsXG5cdCAgICAgIGdyaWRDb2x1bW5TdGFydDogITAsXG5cdCAgICAgIGdyaWRSb3c6ICEwLFxuXHQgICAgICBncmlkUm93RW5kOiAhMCxcblx0ICAgICAgZ3JpZFJvd1N0YXJ0OiAhMCxcblx0ICAgICAgbGluZUhlaWdodDogITAsXG5cdCAgICAgIG9wYWNpdHk6ICEwLFxuXHQgICAgICBvcmRlcjogITAsXG5cdCAgICAgIG9ycGhhbnM6ICEwLFxuXHQgICAgICB3aWRvd3M6ICEwLFxuXHQgICAgICB6SW5kZXg6ICEwLFxuXHQgICAgICB6b29tOiAhMFxuXHQgICAgfSxcblx0ICAgIGNzc1Byb3BzOiB7fSxcblx0ICAgIHN0eWxlOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICBpZiAoZSAmJiAzICE9PSBlLm5vZGVUeXBlICYmIDggIT09IGUubm9kZVR5cGUgJiYgZS5zdHlsZSkge1xuXHQgICAgICAgIHZhciBpLFxuXHQgICAgICAgICAgICBvLFxuXHQgICAgICAgICAgICBhLFxuXHQgICAgICAgICAgICBzID0gWCh0KSxcblx0ICAgICAgICAgICAgdSA9IFhlLnRlc3QodCksXG5cdCAgICAgICAgICAgIGwgPSBlLnN0eWxlO1xuXHQgICAgICAgIGlmICh1IHx8ICh0ID0gemUocykpLCBhID0gUy5jc3NIb29rc1t0XSB8fCBTLmNzc0hvb2tzW3NdLCB2b2lkIDAgPT09IG4pIHJldHVybiBhICYmIFwiZ2V0XCIgaW4gYSAmJiB2b2lkIDAgIT09IChpID0gYS5nZXQoZSwgITEsIHIpKSA/IGkgOiBsW3RdO1xuXHQgICAgICAgIFwic3RyaW5nXCIgPT09IChvID0gdHlwZW9mIG4pICYmIChpID0gdGUuZXhlYyhuKSkgJiYgaVsxXSAmJiAobiA9IHNlKGUsIHQsIGkpLCBvID0gXCJudW1iZXJcIiksIG51bGwgIT0gbiAmJiBuID09IG4gJiYgKFwibnVtYmVyXCIgIT09IG8gfHwgdSB8fCAobiArPSBpICYmIGlbM10gfHwgKFMuY3NzTnVtYmVyW3NdID8gXCJcIiA6IFwicHhcIikpLCB5LmNsZWFyQ2xvbmVTdHlsZSB8fCBcIlwiICE9PSBuIHx8IDAgIT09IHQuaW5kZXhPZihcImJhY2tncm91bmRcIikgfHwgKGxbdF0gPSBcImluaGVyaXRcIiksIGEgJiYgXCJzZXRcIiBpbiBhICYmIHZvaWQgMCA9PT0gKG4gPSBhLnNldChlLCBuLCByKSkgfHwgKHUgPyBsLnNldFByb3BlcnR5KHQsIG4pIDogbFt0XSA9IG4pKTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIGNzczogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcblx0ICAgICAgdmFyIGksXG5cdCAgICAgICAgICBvLFxuXHQgICAgICAgICAgYSxcblx0ICAgICAgICAgIHMgPSBYKHQpO1xuXHQgICAgICByZXR1cm4gWGUudGVzdCh0KSB8fCAodCA9IHplKHMpKSwgKGEgPSBTLmNzc0hvb2tzW3RdIHx8IFMuY3NzSG9va3Nbc10pICYmIFwiZ2V0XCIgaW4gYSAmJiAoaSA9IGEuZ2V0KGUsICEwLCBuKSksIHZvaWQgMCA9PT0gaSAmJiAoaSA9IFdlKGUsIHQsIHIpKSwgXCJub3JtYWxcIiA9PT0gaSAmJiB0IGluIEdlICYmIChpID0gR2VbdF0pLCBcIlwiID09PSBuIHx8IG4gPyAobyA9IHBhcnNlRmxvYXQoaSksICEwID09PSBuIHx8IGlzRmluaXRlKG8pID8gbyB8fCAwIDogaSkgOiBpO1xuXHQgICAgfVxuXHQgIH0pLCBTLmVhY2goW1wiaGVpZ2h0XCIsIFwid2lkdGhcIl0sIGZ1bmN0aW9uIChlLCB1KSB7XG5cdCAgICBTLmNzc0hvb2tzW3VdID0ge1xuXHQgICAgICBnZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgaWYgKHQpIHJldHVybiAhVWUudGVzdChTLmNzcyhlLCBcImRpc3BsYXlcIikpIHx8IGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggJiYgZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA/IEplKGUsIHUsIG4pIDogTWUoZSwgVmUsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHJldHVybiBKZShlLCB1LCBuKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSxcblx0ICAgICAgc2V0OiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICAgIHZhciByLFxuXHQgICAgICAgICAgICBpID0gUmUoZSksXG5cdCAgICAgICAgICAgIG8gPSAheS5zY3JvbGxib3hTaXplKCkgJiYgXCJhYnNvbHV0ZVwiID09PSBpLnBvc2l0aW9uLFxuXHQgICAgICAgICAgICBhID0gKG8gfHwgbikgJiYgXCJib3JkZXItYm94XCIgPT09IFMuY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCBpKSxcblx0ICAgICAgICAgICAgcyA9IG4gPyBRZShlLCB1LCBuLCBhLCBpKSA6IDA7XG5cdCAgICAgICAgcmV0dXJuIGEgJiYgbyAmJiAocyAtPSBNYXRoLmNlaWwoZVtcIm9mZnNldFwiICsgdVswXS50b1VwcGVyQ2FzZSgpICsgdS5zbGljZSgxKV0gLSBwYXJzZUZsb2F0KGlbdV0pIC0gUWUoZSwgdSwgXCJib3JkZXJcIiwgITEsIGkpIC0gLjUpKSwgcyAmJiAociA9IHRlLmV4ZWModCkpICYmIFwicHhcIiAhPT0gKHJbM10gfHwgXCJweFwiKSAmJiAoZS5zdHlsZVt1XSA9IHQsIHQgPSBTLmNzcyhlLCB1KSksIFllKDAsIHQsIHMpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0pLCBTLmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBGZSh5LnJlbGlhYmxlTWFyZ2luTGVmdCwgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgIGlmICh0KSByZXR1cm4gKHBhcnNlRmxvYXQoV2UoZSwgXCJtYXJnaW5MZWZ0XCIpKSB8fCBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBNZShlLCB7XG5cdCAgICAgIG1hcmdpbkxlZnQ6IDBcblx0ICAgIH0sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0ICAgIH0pKSArIFwicHhcIjtcblx0ICB9KSwgUy5lYWNoKHtcblx0ICAgIG1hcmdpbjogXCJcIixcblx0ICAgIHBhZGRpbmc6IFwiXCIsXG5cdCAgICBib3JkZXI6IFwiV2lkdGhcIlxuXHQgIH0sIGZ1bmN0aW9uIChpLCBvKSB7XG5cdCAgICBTLmNzc0hvb2tzW2kgKyBvXSA9IHtcblx0ICAgICAgZXhwYW5kOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIGZvciAodmFyIHQgPSAwLCBuID0ge30sIHIgPSBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gZS5zcGxpdChcIiBcIikgOiBbZV07IHQgPCA0OyB0KyspIG5baSArIG5lW3RdICsgb10gPSByW3RdIHx8IHJbdCAtIDJdIHx8IHJbMF07XG5cblx0ICAgICAgICByZXR1cm4gbjtcblx0ICAgICAgfVxuXHQgICAgfSwgXCJtYXJnaW5cIiAhPT0gaSAmJiAoUy5jc3NIb29rc1tpICsgb10uc2V0ID0gWWUpO1xuXHQgIH0pLCBTLmZuLmV4dGVuZCh7XG5cdCAgICBjc3M6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiAkKHRoaXMsIGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgdmFyIHIsXG5cdCAgICAgICAgICAgIGksXG5cdCAgICAgICAgICAgIG8gPSB7fSxcblx0ICAgICAgICAgICAgYSA9IDA7XG5cblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuXHQgICAgICAgICAgZm9yIChyID0gUmUoZSksIGkgPSB0Lmxlbmd0aDsgYSA8IGk7IGErKykgb1t0W2FdXSA9IFMuY3NzKGUsIHRbYV0sICExLCByKTtcblxuXHQgICAgICAgICAgcmV0dXJuIG87XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gbiA/IFMuc3R5bGUoZSwgdCwgbikgOiBTLmNzcyhlLCB0KTtcblx0ICAgICAgfSwgZSwgdCwgMSA8IGFyZ3VtZW50cy5sZW5ndGgpO1xuXHQgICAgfVxuXHQgIH0pLCAoKFMuVHdlZW4gPSBLZSkucHJvdG90eXBlID0ge1xuXHQgICAgY29uc3RydWN0b3I6IEtlLFxuXHQgICAgaW5pdDogZnVuY3Rpb24gKGUsIHQsIG4sIHIsIGksIG8pIHtcblx0ICAgICAgdGhpcy5lbGVtID0gZSwgdGhpcy5wcm9wID0gbiwgdGhpcy5lYXNpbmcgPSBpIHx8IFMuZWFzaW5nLl9kZWZhdWx0LCB0aGlzLm9wdGlvbnMgPSB0LCB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpLCB0aGlzLmVuZCA9IHIsIHRoaXMudW5pdCA9IG8gfHwgKFMuY3NzTnVtYmVyW25dID8gXCJcIiA6IFwicHhcIik7XG5cdCAgICB9LFxuXHQgICAgY3VyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBlID0gS2UucHJvcEhvb2tzW3RoaXMucHJvcF07XG5cdCAgICAgIHJldHVybiBlICYmIGUuZ2V0ID8gZS5nZXQodGhpcykgOiBLZS5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpO1xuXHQgICAgfSxcblx0ICAgIHJ1bjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQsXG5cdCAgICAgICAgICBuID0gS2UucHJvcEhvb2tzW3RoaXMucHJvcF07XG5cdCAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPyB0aGlzLnBvcyA9IHQgPSBTLmVhc2luZ1t0aGlzLmVhc2luZ10oZSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogZSwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uKSA6IHRoaXMucG9zID0gdCA9IGUsIHRoaXMubm93ID0gKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiB0ICsgdGhpcy5zdGFydCwgdGhpcy5vcHRpb25zLnN0ZXAgJiYgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKSwgbiAmJiBuLnNldCA/IG4uc2V0KHRoaXMpIDogS2UucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSwgdGhpcztcblx0ICAgIH1cblx0ICB9KS5pbml0LnByb3RvdHlwZSA9IEtlLnByb3RvdHlwZSwgKEtlLnByb3BIb29rcyA9IHtcblx0ICAgIF9kZWZhdWx0OiB7XG5cdCAgICAgIGdldDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdDtcblx0ICAgICAgICByZXR1cm4gMSAhPT0gZS5lbGVtLm5vZGVUeXBlIHx8IG51bGwgIT0gZS5lbGVtW2UucHJvcF0gJiYgbnVsbCA9PSBlLmVsZW0uc3R5bGVbZS5wcm9wXSA/IGUuZWxlbVtlLnByb3BdIDogKHQgPSBTLmNzcyhlLmVsZW0sIGUucHJvcCwgXCJcIikpICYmIFwiYXV0b1wiICE9PSB0ID8gdCA6IDA7XG5cdCAgICAgIH0sXG5cdCAgICAgIHNldDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBTLmZ4LnN0ZXBbZS5wcm9wXSA/IFMuZnguc3RlcFtlLnByb3BdKGUpIDogMSAhPT0gZS5lbGVtLm5vZGVUeXBlIHx8ICFTLmNzc0hvb2tzW2UucHJvcF0gJiYgbnVsbCA9PSBlLmVsZW0uc3R5bGVbemUoZS5wcm9wKV0gPyBlLmVsZW1bZS5wcm9wXSA9IGUubm93IDogUy5zdHlsZShlLmVsZW0sIGUucHJvcCwgZS5ub3cgKyBlLnVuaXQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSkuc2Nyb2xsVG9wID0gS2UucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdCAgICBzZXQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGUuZWxlbS5ub2RlVHlwZSAmJiBlLmVsZW0ucGFyZW50Tm9kZSAmJiAoZS5lbGVtW2UucHJvcF0gPSBlLm5vdyk7XG5cdCAgICB9XG5cdCAgfSwgUy5lYXNpbmcgPSB7XG5cdCAgICBsaW5lYXI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBlO1xuXHQgICAgfSxcblx0ICAgIHN3aW5nOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gLjUgLSBNYXRoLmNvcyhlICogTWF0aC5QSSkgLyAyO1xuXHQgICAgfSxcblx0ICAgIF9kZWZhdWx0OiBcInN3aW5nXCJcblx0ICB9LCBTLmZ4ID0gS2UucHJvdG90eXBlLmluaXQsIFMuZnguc3RlcCA9IHt9O1xuXHQgIHZhciBaZSxcblx0ICAgICAgZXQsXG5cdCAgICAgIHR0LFxuXHQgICAgICBudCxcblx0ICAgICAgcnQgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdCAgICAgIGl0ID0gL3F1ZXVlSG9va3MkLztcblxuXHQgIGZ1bmN0aW9uIG90KCkge1xuXHQgICAgZXQgJiYgKCExID09PSBFLmhpZGRlbiAmJiBDLnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IEMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG90KSA6IEMuc2V0VGltZW91dChvdCwgUy5meC5pbnRlcnZhbCksIFMuZngudGljaygpKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBhdCgpIHtcblx0ICAgIHJldHVybiBDLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICBaZSA9IHZvaWQgMDtcblx0ICAgIH0pLCBaZSA9IERhdGUubm93KCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gc3QoZSwgdCkge1xuXHQgICAgdmFyIG4sXG5cdCAgICAgICAgciA9IDAsXG5cdCAgICAgICAgaSA9IHtcblx0ICAgICAgaGVpZ2h0OiBlXG5cdCAgICB9O1xuXG5cdCAgICBmb3IgKHQgPSB0ID8gMSA6IDA7IHIgPCA0OyByICs9IDIgLSB0KSBpW1wibWFyZ2luXCIgKyAobiA9IG5lW3JdKV0gPSBpW1wicGFkZGluZ1wiICsgbl0gPSBlO1xuXG5cdCAgICByZXR1cm4gdCAmJiAoaS5vcGFjaXR5ID0gaS53aWR0aCA9IGUpLCBpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHV0KGUsIHQsIG4pIHtcblx0ICAgIGZvciAodmFyIHIsIGkgPSAobHQudHdlZW5lcnNbdF0gfHwgW10pLmNvbmNhdChsdC50d2VlbmVyc1tcIipcIl0pLCBvID0gMCwgYSA9IGkubGVuZ3RoOyBvIDwgYTsgbysrKSBpZiAociA9IGlbb10uY2FsbChuLCB0LCBlKSkgcmV0dXJuIHI7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbHQobywgZSwgdCkge1xuXHQgICAgdmFyIG4sXG5cdCAgICAgICAgYSxcblx0ICAgICAgICByID0gMCxcblx0ICAgICAgICBpID0gbHQucHJlZmlsdGVycy5sZW5ndGgsXG5cdCAgICAgICAgcyA9IFMuRGVmZXJyZWQoKS5hbHdheXMoZnVuY3Rpb24gKCkge1xuXHQgICAgICBkZWxldGUgdS5lbGVtO1xuXHQgICAgfSksXG5cdCAgICAgICAgdSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKGEpIHJldHVybiAhMTtcblxuXHQgICAgICBmb3IgKHZhciBlID0gWmUgfHwgYXQoKSwgdCA9IE1hdGgubWF4KDAsIGwuc3RhcnRUaW1lICsgbC5kdXJhdGlvbiAtIGUpLCBuID0gMSAtICh0IC8gbC5kdXJhdGlvbiB8fCAwKSwgciA9IDAsIGkgPSBsLnR3ZWVucy5sZW5ndGg7IHIgPCBpOyByKyspIGwudHdlZW5zW3JdLnJ1bihuKTtcblxuXHQgICAgICByZXR1cm4gcy5ub3RpZnlXaXRoKG8sIFtsLCBuLCB0XSksIG4gPCAxICYmIGkgPyB0IDogKGkgfHwgcy5ub3RpZnlXaXRoKG8sIFtsLCAxLCAwXSksIHMucmVzb2x2ZVdpdGgobywgW2xdKSwgITEpO1xuXHQgICAgfSxcblx0ICAgICAgICBsID0gcy5wcm9taXNlKHtcblx0ICAgICAgZWxlbTogbyxcblx0ICAgICAgcHJvcHM6IFMuZXh0ZW5kKHt9LCBlKSxcblx0ICAgICAgb3B0czogUy5leHRlbmQoITAsIHtcblx0ICAgICAgICBzcGVjaWFsRWFzaW5nOiB7fSxcblx0ICAgICAgICBlYXNpbmc6IFMuZWFzaW5nLl9kZWZhdWx0XG5cdCAgICAgIH0sIHQpLFxuXHQgICAgICBvcmlnaW5hbFByb3BlcnRpZXM6IGUsXG5cdCAgICAgIG9yaWdpbmFsT3B0aW9uczogdCxcblx0ICAgICAgc3RhcnRUaW1lOiBaZSB8fCBhdCgpLFxuXHQgICAgICBkdXJhdGlvbjogdC5kdXJhdGlvbixcblx0ICAgICAgdHdlZW5zOiBbXSxcblx0ICAgICAgY3JlYXRlVHdlZW46IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBTLlR3ZWVuKG8sIGwub3B0cywgZSwgdCwgbC5vcHRzLnNwZWNpYWxFYXNpbmdbZV0gfHwgbC5vcHRzLmVhc2luZyk7XG5cdCAgICAgICAgcmV0dXJuIGwudHdlZW5zLnB1c2gobiksIG47XG5cdCAgICAgIH0sXG5cdCAgICAgIHN0b3A6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIHQgPSAwLFxuXHQgICAgICAgICAgICBuID0gZSA/IGwudHdlZW5zLmxlbmd0aCA6IDA7XG5cdCAgICAgICAgaWYgKGEpIHJldHVybiB0aGlzO1xuXG5cdCAgICAgICAgZm9yIChhID0gITA7IHQgPCBuOyB0KyspIGwudHdlZW5zW3RdLnJ1bigxKTtcblxuXHQgICAgICAgIHJldHVybiBlID8gKHMubm90aWZ5V2l0aChvLCBbbCwgMSwgMF0pLCBzLnJlc29sdmVXaXRoKG8sIFtsLCBlXSkpIDogcy5yZWplY3RXaXRoKG8sIFtsLCBlXSksIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgIH0pLFxuXHQgICAgICAgIGMgPSBsLnByb3BzO1xuXG5cdCAgICBmb3IgKCFmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbiwgciwgaSwgbywgYTtcblxuXHQgICAgICBmb3IgKG4gaW4gZSkgaWYgKGkgPSB0W3IgPSBYKG4pXSwgbyA9IGVbbl0sIEFycmF5LmlzQXJyYXkobykgJiYgKGkgPSBvWzFdLCBvID0gZVtuXSA9IG9bMF0pLCBuICE9PSByICYmIChlW3JdID0gbywgZGVsZXRlIGVbbl0pLCAoYSA9IFMuY3NzSG9va3Nbcl0pICYmIChcImV4cGFuZFwiIGluIGEpKSBmb3IgKG4gaW4gbyA9IGEuZXhwYW5kKG8pLCBkZWxldGUgZVtyXSwgbykgKG4gaW4gZSkgfHwgKGVbbl0gPSBvW25dLCB0W25dID0gaSk7ZWxzZSB0W3JdID0gaTtcblx0ICAgIH0oYywgbC5vcHRzLnNwZWNpYWxFYXNpbmcpOyByIDwgaTsgcisrKSBpZiAobiA9IGx0LnByZWZpbHRlcnNbcl0uY2FsbChsLCBvLCBjLCBsLm9wdHMpKSByZXR1cm4gbShuLnN0b3ApICYmIChTLl9xdWV1ZUhvb2tzKGwuZWxlbSwgbC5vcHRzLnF1ZXVlKS5zdG9wID0gbi5zdG9wLmJpbmQobikpLCBuO1xuXG5cdCAgICByZXR1cm4gUy5tYXAoYywgdXQsIGwpLCBtKGwub3B0cy5zdGFydCkgJiYgbC5vcHRzLnN0YXJ0LmNhbGwobywgbCksIGwucHJvZ3Jlc3MobC5vcHRzLnByb2dyZXNzKS5kb25lKGwub3B0cy5kb25lLCBsLm9wdHMuY29tcGxldGUpLmZhaWwobC5vcHRzLmZhaWwpLmFsd2F5cyhsLm9wdHMuYWx3YXlzKSwgUy5meC50aW1lcihTLmV4dGVuZCh1LCB7XG5cdCAgICAgIGVsZW06IG8sXG5cdCAgICAgIGFuaW06IGwsXG5cdCAgICAgIHF1ZXVlOiBsLm9wdHMucXVldWVcblx0ICAgIH0pKSwgbDtcblx0ICB9XG5cblx0ICBTLkFuaW1hdGlvbiA9IFMuZXh0ZW5kKGx0LCB7XG5cdCAgICB0d2VlbmVyczoge1xuXHQgICAgICBcIipcIjogW2Z1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSB0aGlzLmNyZWF0ZVR3ZWVuKGUsIHQpO1xuXHQgICAgICAgIHJldHVybiBzZShuLmVsZW0sIGUsIHRlLmV4ZWModCksIG4pLCBuO1xuXHQgICAgICB9XVxuXHQgICAgfSxcblx0ICAgIHR3ZWVuZXI6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIG0oZSkgPyAodCA9IGUsIGUgPSBbXCIqXCJdKSA6IGUgPSBlLm1hdGNoKFApO1xuXG5cdCAgICAgIGZvciAodmFyIG4sIHIgPSAwLCBpID0gZS5sZW5ndGg7IHIgPCBpOyByKyspIG4gPSBlW3JdLCBsdC50d2VlbmVyc1tuXSA9IGx0LnR3ZWVuZXJzW25dIHx8IFtdLCBsdC50d2VlbmVyc1tuXS51bnNoaWZ0KHQpO1xuXHQgICAgfSxcblx0ICAgIHByZWZpbHRlcnM6IFtmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICB2YXIgcixcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICBvLFxuXHQgICAgICAgICAgYSxcblx0ICAgICAgICAgIHMsXG5cdCAgICAgICAgICB1LFxuXHQgICAgICAgICAgbCxcblx0ICAgICAgICAgIGMsXG5cdCAgICAgICAgICBmID0gXCJ3aWR0aFwiIGluIHQgfHwgXCJoZWlnaHRcIiBpbiB0LFxuXHQgICAgICAgICAgcCA9IHRoaXMsXG5cdCAgICAgICAgICBkID0ge30sXG5cdCAgICAgICAgICBoID0gZS5zdHlsZSxcblx0ICAgICAgICAgIGcgPSBlLm5vZGVUeXBlICYmIGFlKGUpLFxuXHQgICAgICAgICAgdiA9IFkuZ2V0KGUsIFwiZnhzaG93XCIpO1xuXG5cdCAgICAgIGZvciAociBpbiBuLnF1ZXVlIHx8IChudWxsID09IChhID0gUy5fcXVldWVIb29rcyhlLCBcImZ4XCIpKS51bnF1ZXVlZCAmJiAoYS51bnF1ZXVlZCA9IDAsIHMgPSBhLmVtcHR5LmZpcmUsIGEuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBhLnVucXVldWVkIHx8IHMoKTtcblx0ICAgICAgfSksIGEudW5xdWV1ZWQrKywgcC5hbHdheXMoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHAuYWx3YXlzKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGEudW5xdWV1ZWQtLSwgUy5xdWV1ZShlLCBcImZ4XCIpLmxlbmd0aCB8fCBhLmVtcHR5LmZpcmUoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSkpLCB0KSBpZiAoaSA9IHRbcl0sIHJ0LnRlc3QoaSkpIHtcblx0ICAgICAgICBpZiAoZGVsZXRlIHRbcl0sIG8gPSBvIHx8IFwidG9nZ2xlXCIgPT09IGksIGkgPT09IChnID8gXCJoaWRlXCIgOiBcInNob3dcIikpIHtcblx0ICAgICAgICAgIGlmIChcInNob3dcIiAhPT0gaSB8fCAhdiB8fCB2b2lkIDAgPT09IHZbcl0pIGNvbnRpbnVlO1xuXHQgICAgICAgICAgZyA9ICEwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGRbcl0gPSB2ICYmIHZbcl0gfHwgUy5zdHlsZShlLCByKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICgodSA9ICFTLmlzRW1wdHlPYmplY3QodCkpIHx8ICFTLmlzRW1wdHlPYmplY3QoZCkpIGZvciAociBpbiBmICYmIDEgPT09IGUubm9kZVR5cGUgJiYgKG4ub3ZlcmZsb3cgPSBbaC5vdmVyZmxvdywgaC5vdmVyZmxvd1gsIGgub3ZlcmZsb3dZXSwgbnVsbCA9PSAobCA9IHYgJiYgdi5kaXNwbGF5KSAmJiAobCA9IFkuZ2V0KGUsIFwiZGlzcGxheVwiKSksIFwibm9uZVwiID09PSAoYyA9IFMuY3NzKGUsIFwiZGlzcGxheVwiKSkgJiYgKGwgPyBjID0gbCA6IChsZShbZV0sICEwKSwgbCA9IGUuc3R5bGUuZGlzcGxheSB8fCBsLCBjID0gUy5jc3MoZSwgXCJkaXNwbGF5XCIpLCBsZShbZV0pKSksIChcImlubGluZVwiID09PSBjIHx8IFwiaW5saW5lLWJsb2NrXCIgPT09IGMgJiYgbnVsbCAhPSBsKSAmJiBcIm5vbmVcIiA9PT0gUy5jc3MoZSwgXCJmbG9hdFwiKSAmJiAodSB8fCAocC5kb25lKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBoLmRpc3BsYXkgPSBsO1xuXHQgICAgICB9KSwgbnVsbCA9PSBsICYmIChjID0gaC5kaXNwbGF5LCBsID0gXCJub25lXCIgPT09IGMgPyBcIlwiIDogYykpLCBoLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiKSksIG4ub3ZlcmZsb3cgJiYgKGgub3ZlcmZsb3cgPSBcImhpZGRlblwiLCBwLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaC5vdmVyZmxvdyA9IG4ub3ZlcmZsb3dbMF0sIGgub3ZlcmZsb3dYID0gbi5vdmVyZmxvd1sxXSwgaC5vdmVyZmxvd1kgPSBuLm92ZXJmbG93WzJdO1xuXHQgICAgICB9KSksIHUgPSAhMSwgZCkgdSB8fCAodiA/IFwiaGlkZGVuXCIgaW4gdiAmJiAoZyA9IHYuaGlkZGVuKSA6IHYgPSBZLmFjY2VzcyhlLCBcImZ4c2hvd1wiLCB7XG5cdCAgICAgICAgZGlzcGxheTogbFxuXHQgICAgICB9KSwgbyAmJiAodi5oaWRkZW4gPSAhZyksIGcgJiYgbGUoW2VdLCAhMCksIHAuZG9uZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yIChyIGluIGcgfHwgbGUoW2VdKSwgWS5yZW1vdmUoZSwgXCJmeHNob3dcIiksIGQpIFMuc3R5bGUoZSwgciwgZFtyXSk7XG5cdCAgICAgIH0pKSwgdSA9IHV0KGcgPyB2W3JdIDogMCwgciwgcCksIHIgaW4gdiB8fCAodltyXSA9IHUuc3RhcnQsIGcgJiYgKHUuZW5kID0gdS5zdGFydCwgdS5zdGFydCA9IDApKTtcblx0ICAgIH1dLFxuXHQgICAgcHJlZmlsdGVyOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB0ID8gbHQucHJlZmlsdGVycy51bnNoaWZ0KGUpIDogbHQucHJlZmlsdGVycy5wdXNoKGUpO1xuXHQgICAgfVxuXHQgIH0pLCBTLnNwZWVkID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgIHZhciByID0gZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBlID8gUy5leHRlbmQoe30sIGUpIDoge1xuXHQgICAgICBjb21wbGV0ZTogbiB8fCAhbiAmJiB0IHx8IG0oZSkgJiYgZSxcblx0ICAgICAgZHVyYXRpb246IGUsXG5cdCAgICAgIGVhc2luZzogbiAmJiB0IHx8IHQgJiYgIW0odCkgJiYgdFxuXHQgICAgfTtcblx0ICAgIHJldHVybiBTLmZ4Lm9mZiA/IHIuZHVyYXRpb24gPSAwIDogXCJudW1iZXJcIiAhPSB0eXBlb2Ygci5kdXJhdGlvbiAmJiAoci5kdXJhdGlvbiBpbiBTLmZ4LnNwZWVkcyA/IHIuZHVyYXRpb24gPSBTLmZ4LnNwZWVkc1tyLmR1cmF0aW9uXSA6IHIuZHVyYXRpb24gPSBTLmZ4LnNwZWVkcy5fZGVmYXVsdCksIG51bGwgIT0gci5xdWV1ZSAmJiAhMCAhPT0gci5xdWV1ZSB8fCAoci5xdWV1ZSA9IFwiZnhcIiksIHIub2xkID0gci5jb21wbGV0ZSwgci5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgbShyLm9sZCkgJiYgci5vbGQuY2FsbCh0aGlzKSwgci5xdWV1ZSAmJiBTLmRlcXVldWUodGhpcywgci5xdWV1ZSk7XG5cdCAgICB9LCByO1xuXHQgIH0sIFMuZm4uZXh0ZW5kKHtcblx0ICAgIGZhZGVUbzogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGFlKS5jc3MoXCJvcGFjaXR5XCIsIDApLnNob3coKS5lbmQoKS5hbmltYXRlKHtcblx0ICAgICAgICBvcGFjaXR5OiB0XG5cdCAgICAgIH0sIGUsIG4sIHIpO1xuXHQgICAgfSxcblx0ICAgIGFuaW1hdGU6IGZ1bmN0aW9uICh0LCBlLCBuLCByKSB7XG5cdCAgICAgIHZhciBpID0gUy5pc0VtcHR5T2JqZWN0KHQpLFxuXHQgICAgICAgICAgbyA9IFMuc3BlZWQoZSwgbiwgciksXG5cdCAgICAgICAgICBhID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBlID0gbHQodGhpcywgUy5leHRlbmQoe30sIHQpLCBvKTtcblx0ICAgICAgICAoaSB8fCBZLmdldCh0aGlzLCBcImZpbmlzaFwiKSkgJiYgZS5zdG9wKCEwKTtcblx0ICAgICAgfTtcblxuXHQgICAgICByZXR1cm4gYS5maW5pc2ggPSBhLCBpIHx8ICExID09PSBvLnF1ZXVlID8gdGhpcy5lYWNoKGEpIDogdGhpcy5xdWV1ZShvLnF1ZXVlLCBhKTtcblx0ICAgIH0sXG5cdCAgICBzdG9wOiBmdW5jdGlvbiAoaSwgZSwgbykge1xuXHQgICAgICB2YXIgYSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIHQgPSBlLnN0b3A7XG5cdCAgICAgICAgZGVsZXRlIGUuc3RvcCwgdChvKTtcblx0ICAgICAgfTtcblxuXHQgICAgICByZXR1cm4gXCJzdHJpbmdcIiAhPSB0eXBlb2YgaSAmJiAobyA9IGUsIGUgPSBpLCBpID0gdm9pZCAwKSwgZSAmJiB0aGlzLnF1ZXVlKGkgfHwgXCJmeFwiLCBbXSksIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGUgPSAhMCxcblx0ICAgICAgICAgICAgdCA9IG51bGwgIT0gaSAmJiBpICsgXCJxdWV1ZUhvb2tzXCIsXG5cdCAgICAgICAgICAgIG4gPSBTLnRpbWVycyxcblx0ICAgICAgICAgICAgciA9IFkuZ2V0KHRoaXMpO1xuXHQgICAgICAgIGlmICh0KSByW3RdICYmIHJbdF0uc3RvcCAmJiBhKHJbdF0pO2Vsc2UgZm9yICh0IGluIHIpIHJbdF0gJiYgclt0XS5zdG9wICYmIGl0LnRlc3QodCkgJiYgYShyW3RdKTtcblxuXHQgICAgICAgIGZvciAodCA9IG4ubGVuZ3RoOyB0LS07KSBuW3RdLmVsZW0gIT09IHRoaXMgfHwgbnVsbCAhPSBpICYmIG5bdF0ucXVldWUgIT09IGkgfHwgKG5bdF0uYW5pbS5zdG9wKG8pLCBlID0gITEsIG4uc3BsaWNlKHQsIDEpKTtcblxuXHQgICAgICAgICFlICYmIG8gfHwgUy5kZXF1ZXVlKHRoaXMsIGkpO1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICBmaW5pc2g6IGZ1bmN0aW9uIChhKSB7XG5cdCAgICAgIHJldHVybiAhMSAhPT0gYSAmJiAoYSA9IGEgfHwgXCJmeFwiKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZSxcblx0ICAgICAgICAgICAgdCA9IFkuZ2V0KHRoaXMpLFxuXHQgICAgICAgICAgICBuID0gdFthICsgXCJxdWV1ZVwiXSxcblx0ICAgICAgICAgICAgciA9IHRbYSArIFwicXVldWVIb29rc1wiXSxcblx0ICAgICAgICAgICAgaSA9IFMudGltZXJzLFxuXHQgICAgICAgICAgICBvID0gbiA/IG4ubGVuZ3RoIDogMDtcblxuXHQgICAgICAgIGZvciAodC5maW5pc2ggPSAhMCwgUy5xdWV1ZSh0aGlzLCBhLCBbXSksIHIgJiYgci5zdG9wICYmIHIuc3RvcC5jYWxsKHRoaXMsICEwKSwgZSA9IGkubGVuZ3RoOyBlLS07KSBpW2VdLmVsZW0gPT09IHRoaXMgJiYgaVtlXS5xdWV1ZSA9PT0gYSAmJiAoaVtlXS5hbmltLnN0b3AoITApLCBpLnNwbGljZShlLCAxKSk7XG5cblx0ICAgICAgICBmb3IgKGUgPSAwOyBlIDwgbzsgZSsrKSBuW2VdICYmIG5bZV0uZmluaXNoICYmIG5bZV0uZmluaXNoLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICBkZWxldGUgdC5maW5pc2g7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0pLCBTLmVhY2goW1widG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIl0sIGZ1bmN0aW9uIChlLCByKSB7XG5cdCAgICB2YXIgaSA9IFMuZm5bcl07XG5cblx0ICAgIFMuZm5bcl0gPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gbnVsbCA9PSBlIHx8IFwiYm9vbGVhblwiID09IHR5cGVvZiBlID8gaS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcy5hbmltYXRlKHN0KHIsICEwKSwgZSwgdCwgbik7XG5cdCAgICB9O1xuXHQgIH0pLCBTLmVhY2goe1xuXHQgICAgc2xpZGVEb3duOiBzdChcInNob3dcIiksXG5cdCAgICBzbGlkZVVwOiBzdChcImhpZGVcIiksXG5cdCAgICBzbGlkZVRvZ2dsZTogc3QoXCJ0b2dnbGVcIiksXG5cdCAgICBmYWRlSW46IHtcblx0ICAgICAgb3BhY2l0eTogXCJzaG93XCJcblx0ICAgIH0sXG5cdCAgICBmYWRlT3V0OiB7XG5cdCAgICAgIG9wYWNpdHk6IFwiaGlkZVwiXG5cdCAgICB9LFxuXHQgICAgZmFkZVRvZ2dsZToge1xuXHQgICAgICBvcGFjaXR5OiBcInRvZ2dsZVwiXG5cdCAgICB9XG5cdCAgfSwgZnVuY3Rpb24gKGUsIHIpIHtcblx0ICAgIFMuZm5bZV0gPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHIsIGUsIHQsIG4pO1xuXHQgICAgfTtcblx0ICB9KSwgUy50aW1lcnMgPSBbXSwgUy5meC50aWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGUsXG5cdCAgICAgICAgdCA9IDAsXG5cdCAgICAgICAgbiA9IFMudGltZXJzO1xuXG5cdCAgICBmb3IgKFplID0gRGF0ZS5ub3coKTsgdCA8IG4ubGVuZ3RoOyB0KyspIChlID0gblt0XSkoKSB8fCBuW3RdICE9PSBlIHx8IG4uc3BsaWNlKHQtLSwgMSk7XG5cblx0ICAgIG4ubGVuZ3RoIHx8IFMuZnguc3RvcCgpLCBaZSA9IHZvaWQgMDtcblx0ICB9LCBTLmZ4LnRpbWVyID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIFMudGltZXJzLnB1c2goZSksIFMuZnguc3RhcnQoKTtcblx0ICB9LCBTLmZ4LmludGVydmFsID0gMTMsIFMuZnguc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBldCB8fCAoZXQgPSAhMCwgb3QoKSk7XG5cdCAgfSwgUy5meC5zdG9wID0gZnVuY3Rpb24gKCkge1xuXHQgICAgZXQgPSBudWxsO1xuXHQgIH0sIFMuZnguc3BlZWRzID0ge1xuXHQgICAgc2xvdzogNjAwLFxuXHQgICAgZmFzdDogMjAwLFxuXHQgICAgX2RlZmF1bHQ6IDQwMFxuXHQgIH0sIFMuZm4uZGVsYXkgPSBmdW5jdGlvbiAociwgZSkge1xuXHQgICAgcmV0dXJuIHIgPSBTLmZ4ICYmIFMuZnguc3BlZWRzW3JdIHx8IHIsIGUgPSBlIHx8IFwiZnhcIiwgdGhpcy5xdWV1ZShlLCBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbiA9IEMuc2V0VGltZW91dChlLCByKTtcblxuXHQgICAgICB0LnN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgQy5jbGVhclRpbWVvdXQobik7XG5cdCAgICAgIH07XG5cdCAgICB9KTtcblx0ICB9LCB0dCA9IEUuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLCBudCA9IEUuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKS5hcHBlbmRDaGlsZChFLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpLCB0dC50eXBlID0gXCJjaGVja2JveFwiLCB5LmNoZWNrT24gPSBcIlwiICE9PSB0dC52YWx1ZSwgeS5vcHRTZWxlY3RlZCA9IG50LnNlbGVjdGVkLCAodHQgPSBFLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkudmFsdWUgPSBcInRcIiwgdHQudHlwZSA9IFwicmFkaW9cIiwgeS5yYWRpb1ZhbHVlID0gXCJ0XCIgPT09IHR0LnZhbHVlO1xuXHQgIHZhciBjdCxcblx0ICAgICAgZnQgPSBTLmV4cHIuYXR0ckhhbmRsZTtcblx0ICBTLmZuLmV4dGVuZCh7XG5cdCAgICBhdHRyOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gJCh0aGlzLCBTLmF0dHIsIGUsIHQsIDEgPCBhcmd1bWVudHMubGVuZ3RoKTtcblx0ICAgIH0sXG5cdCAgICByZW1vdmVBdHRyOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBTLnJlbW92ZUF0dHIodGhpcywgZSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0pLCBTLmV4dGVuZCh7XG5cdCAgICBhdHRyOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICB2YXIgcixcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICBvID0gZS5ub2RlVHlwZTtcblx0ICAgICAgaWYgKDMgIT09IG8gJiYgOCAhPT0gbyAmJiAyICE9PSBvKSByZXR1cm4gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgZS5nZXRBdHRyaWJ1dGUgPyBTLnByb3AoZSwgdCwgbikgOiAoMSA9PT0gbyAmJiBTLmlzWE1MRG9jKGUpIHx8IChpID0gUy5hdHRySG9va3NbdC50b0xvd2VyQ2FzZSgpXSB8fCAoUy5leHByLm1hdGNoLmJvb2wudGVzdCh0KSA/IGN0IDogdm9pZCAwKSksIHZvaWQgMCAhPT0gbiA/IG51bGwgPT09IG4gPyB2b2lkIFMucmVtb3ZlQXR0cihlLCB0KSA6IGkgJiYgXCJzZXRcIiBpbiBpICYmIHZvaWQgMCAhPT0gKHIgPSBpLnNldChlLCBuLCB0KSkgPyByIDogKGUuc2V0QXR0cmlidXRlKHQsIG4gKyBcIlwiKSwgbikgOiBpICYmIFwiZ2V0XCIgaW4gaSAmJiBudWxsICE9PSAociA9IGkuZ2V0KGUsIHQpKSA/IHIgOiBudWxsID09IChyID0gUy5maW5kLmF0dHIoZSwgdCkpID8gdm9pZCAwIDogcik7XG5cdCAgICB9LFxuXHQgICAgYXR0ckhvb2tzOiB7XG5cdCAgICAgIHR5cGU6IHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgICBpZiAoIXkucmFkaW9WYWx1ZSAmJiBcInJhZGlvXCIgPT09IHQgJiYgQShlLCBcImlucHV0XCIpKSB7XG5cdCAgICAgICAgICAgIHZhciBuID0gZS52YWx1ZTtcblx0ICAgICAgICAgICAgcmV0dXJuIGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLCB0KSwgbiAmJiAoZS52YWx1ZSA9IG4pLCB0O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHZhciBuLFxuXHQgICAgICAgICAgciA9IDAsXG5cdCAgICAgICAgICBpID0gdCAmJiB0Lm1hdGNoKFApO1xuXHQgICAgICBpZiAoaSAmJiAxID09PSBlLm5vZGVUeXBlKSB3aGlsZSAobiA9IGlbcisrXSkgZS5yZW1vdmVBdHRyaWJ1dGUobik7XG5cdCAgICB9XG5cdCAgfSksIGN0ID0ge1xuXHQgICAgc2V0OiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gITEgPT09IHQgPyBTLnJlbW92ZUF0dHIoZSwgbikgOiBlLnNldEF0dHJpYnV0ZShuLCBuKSwgbjtcblx0ICAgIH1cblx0ICB9LCBTLmVhY2goUy5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKC9cXHcrL2cpLCBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgdmFyIGEgPSBmdFt0XSB8fCBTLmZpbmQuYXR0cjtcblxuXHQgICAgZnRbdF0gPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICB2YXIgcixcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICBvID0gdC50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICByZXR1cm4gbiB8fCAoaSA9IGZ0W29dLCBmdFtvXSA9IHIsIHIgPSBudWxsICE9IGEoZSwgdCwgbikgPyBvIDogbnVsbCwgZnRbb10gPSBpKSwgcjtcblx0ICAgIH07XG5cdCAgfSk7XG5cdCAgdmFyIHB0ID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0ICAgICAgZHQgPSAvXig/OmF8YXJlYSkkL2k7XG5cblx0ICBmdW5jdGlvbiBodChlKSB7XG5cdCAgICByZXR1cm4gKGUubWF0Y2goUCkgfHwgW10pLmpvaW4oXCIgXCIpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGd0KGUpIHtcblx0ICAgIHJldHVybiBlLmdldEF0dHJpYnV0ZSAmJiBlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCI7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdnQoZSkge1xuXHQgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSkgPyBlIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiBlLm1hdGNoKFApIHx8IFtdO1xuXHQgIH1cblxuXHQgIFMuZm4uZXh0ZW5kKHtcblx0ICAgIHByb3A6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiAkKHRoaXMsIFMucHJvcCwgZSwgdCwgMSA8IGFyZ3VtZW50cy5sZW5ndGgpO1xuXHQgICAgfSxcblx0ICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGRlbGV0ZSB0aGlzW1MucHJvcEZpeFtlXSB8fCBlXTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSksIFMuZXh0ZW5kKHtcblx0ICAgIHByb3A6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHZhciByLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8gPSBlLm5vZGVUeXBlO1xuXHQgICAgICBpZiAoMyAhPT0gbyAmJiA4ICE9PSBvICYmIDIgIT09IG8pIHJldHVybiAxID09PSBvICYmIFMuaXNYTUxEb2MoZSkgfHwgKHQgPSBTLnByb3BGaXhbdF0gfHwgdCwgaSA9IFMucHJvcEhvb2tzW3RdKSwgdm9pZCAwICE9PSBuID8gaSAmJiBcInNldFwiIGluIGkgJiYgdm9pZCAwICE9PSAociA9IGkuc2V0KGUsIG4sIHQpKSA/IHIgOiBlW3RdID0gbiA6IGkgJiYgXCJnZXRcIiBpbiBpICYmIG51bGwgIT09IChyID0gaS5nZXQoZSwgdCkpID8gciA6IGVbdF07XG5cdCAgICB9LFxuXHQgICAgcHJvcEhvb2tzOiB7XG5cdCAgICAgIHRhYkluZGV4OiB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQgPSBTLmZpbmQuYXR0cihlLCBcInRhYmluZGV4XCIpO1xuXHQgICAgICAgICAgcmV0dXJuIHQgPyBwYXJzZUludCh0LCAxMCkgOiBwdC50ZXN0KGUubm9kZU5hbWUpIHx8IGR0LnRlc3QoZS5ub2RlTmFtZSkgJiYgZS5ocmVmID8gMCA6IC0xO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHByb3BGaXg6IHtcblx0ICAgICAgXCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdCAgICAgIFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHQgICAgfVxuXHQgIH0pLCB5Lm9wdFNlbGVjdGVkIHx8IChTLnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0ICAgIGdldDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQgPSBlLnBhcmVudE5vZGU7XG5cdCAgICAgIHJldHVybiB0ICYmIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgbnVsbDtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0ID0gZS5wYXJlbnROb2RlO1xuXHQgICAgICB0ICYmICh0LnNlbGVjdGVkSW5kZXgsIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCk7XG5cdCAgICB9XG5cdCAgfSksIFMuZWFjaChbXCJ0YWJJbmRleFwiLCBcInJlYWRPbmx5XCIsIFwibWF4TGVuZ3RoXCIsIFwiY2VsbFNwYWNpbmdcIiwgXCJjZWxsUGFkZGluZ1wiLCBcInJvd1NwYW5cIiwgXCJjb2xTcGFuXCIsIFwidXNlTWFwXCIsIFwiZnJhbWVCb3JkZXJcIiwgXCJjb250ZW50RWRpdGFibGVcIl0sIGZ1bmN0aW9uICgpIHtcblx0ICAgIFMucHJvcEZpeFt0aGlzLnRvTG93ZXJDYXNlKCldID0gdGhpcztcblx0ICB9KSwgUy5mbi5leHRlbmQoe1xuXHQgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgIHZhciBlLFxuXHQgICAgICAgICAgbixcblx0ICAgICAgICAgIHIsXG5cdCAgICAgICAgICBpLFxuXHQgICAgICAgICAgbyxcblx0ICAgICAgICAgIGEsXG5cdCAgICAgICAgICBzLFxuXHQgICAgICAgICAgdSA9IDA7XG5cdCAgICAgIGlmIChtKHQpKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgUyh0aGlzKS5hZGRDbGFzcyh0LmNhbGwodGhpcywgZSwgZ3QodGhpcykpKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIGlmICgoZSA9IHZ0KHQpKS5sZW5ndGgpIHdoaWxlIChuID0gdGhpc1t1KytdKSBpZiAoaSA9IGd0KG4pLCByID0gMSA9PT0gbi5ub2RlVHlwZSAmJiBcIiBcIiArIGh0KGkpICsgXCIgXCIpIHtcblx0ICAgICAgICBhID0gMDtcblxuXHQgICAgICAgIHdoaWxlIChvID0gZVthKytdKSByLmluZGV4T2YoXCIgXCIgKyBvICsgXCIgXCIpIDwgMCAmJiAociArPSBvICsgXCIgXCIpO1xuXG5cdCAgICAgICAgaSAhPT0gKHMgPSBodChyKSkgJiYgbi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH0sXG5cdCAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKHQpIHtcblx0ICAgICAgdmFyIGUsXG5cdCAgICAgICAgICBuLFxuXHQgICAgICAgICAgcixcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICBvLFxuXHQgICAgICAgICAgYSxcblx0ICAgICAgICAgIHMsXG5cdCAgICAgICAgICB1ID0gMDtcblx0ICAgICAgaWYgKG0odCkpIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBTKHRoaXMpLnJlbW92ZUNsYXNzKHQuY2FsbCh0aGlzLCBlLCBndCh0aGlzKSkpO1xuXHQgICAgICB9KTtcblx0ICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIiwgXCJcIik7XG5cdCAgICAgIGlmICgoZSA9IHZ0KHQpKS5sZW5ndGgpIHdoaWxlIChuID0gdGhpc1t1KytdKSBpZiAoaSA9IGd0KG4pLCByID0gMSA9PT0gbi5ub2RlVHlwZSAmJiBcIiBcIiArIGh0KGkpICsgXCIgXCIpIHtcblx0ICAgICAgICBhID0gMDtcblxuXHQgICAgICAgIHdoaWxlIChvID0gZVthKytdKSB3aGlsZSAoLTEgPCByLmluZGV4T2YoXCIgXCIgKyBvICsgXCIgXCIpKSByID0gci5yZXBsYWNlKFwiIFwiICsgbyArIFwiIFwiLCBcIiBcIik7XG5cblx0ICAgICAgICBpICE9PSAocyA9IGh0KHIpKSAmJiBuLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHMpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfSxcblx0ICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiAoaSwgdCkge1xuXHQgICAgICB2YXIgbyA9IHR5cGVvZiBpLFxuXHQgICAgICAgICAgYSA9IFwic3RyaW5nXCIgPT09IG8gfHwgQXJyYXkuaXNBcnJheShpKTtcblx0ICAgICAgcmV0dXJuIFwiYm9vbGVhblwiID09IHR5cGVvZiB0ICYmIGEgPyB0ID8gdGhpcy5hZGRDbGFzcyhpKSA6IHRoaXMucmVtb3ZlQ2xhc3MoaSkgOiBtKGkpID8gdGhpcy5lYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgUyh0aGlzKS50b2dnbGVDbGFzcyhpLmNhbGwodGhpcywgZSwgZ3QodGhpcyksIHQpLCB0KTtcblx0ICAgICAgfSkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBlLCB0LCBuLCByO1xuXG5cdCAgICAgICAgaWYgKGEpIHtcblx0ICAgICAgICAgIHQgPSAwLCBuID0gUyh0aGlzKSwgciA9IHZ0KGkpO1xuXG5cdCAgICAgICAgICB3aGlsZSAoZSA9IHJbdCsrXSkgbi5oYXNDbGFzcyhlKSA/IG4ucmVtb3ZlQ2xhc3MoZSkgOiBuLmFkZENsYXNzKGUpO1xuXHQgICAgICAgIH0gZWxzZSB2b2lkIDAgIT09IGkgJiYgXCJib29sZWFuXCIgIT09IG8gfHwgKChlID0gZ3QodGhpcykpICYmIFkuc2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBlKSwgdGhpcy5zZXRBdHRyaWJ1dGUgJiYgdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBlIHx8ICExID09PSBpID8gXCJcIiA6IFkuZ2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiKSB8fCBcIlwiKSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIGhhc0NsYXNzOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdCxcblx0ICAgICAgICAgIG4sXG5cdCAgICAgICAgICByID0gMDtcblx0ICAgICAgdCA9IFwiIFwiICsgZSArIFwiIFwiO1xuXG5cdCAgICAgIHdoaWxlIChuID0gdGhpc1tyKytdKSBpZiAoMSA9PT0gbi5ub2RlVHlwZSAmJiAtMSA8IChcIiBcIiArIGh0KGd0KG4pKSArIFwiIFwiKS5pbmRleE9mKHQpKSByZXR1cm4gITA7XG5cblx0ICAgICAgcmV0dXJuICExO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHZhciB5dCA9IC9cXHIvZztcblx0ICBTLmZuLmV4dGVuZCh7XG5cdCAgICB2YWw6IGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgIHZhciByLFxuXHQgICAgICAgICAgZSxcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICB0ID0gdGhpc1swXTtcblx0ICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaSA9IG0obiksIHRoaXMuZWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciB0O1xuXHQgICAgICAgIDEgPT09IHRoaXMubm9kZVR5cGUgJiYgKG51bGwgPT0gKHQgPSBpID8gbi5jYWxsKHRoaXMsIGUsIFModGhpcykudmFsKCkpIDogbikgPyB0ID0gXCJcIiA6IFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgPyB0ICs9IFwiXCIgOiBBcnJheS5pc0FycmF5KHQpICYmICh0ID0gUy5tYXAodCwgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiBudWxsID09IGUgPyBcIlwiIDogZSArIFwiXCI7XG5cdCAgICAgICAgfSkpLCAociA9IFMudmFsSG9va3NbdGhpcy50eXBlXSB8fCBTLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pICYmIFwic2V0XCIgaW4gciAmJiB2b2lkIDAgIT09IHIuc2V0KHRoaXMsIHQsIFwidmFsdWVcIikgfHwgKHRoaXMudmFsdWUgPSB0KSk7XG5cdCAgICAgIH0pKSA6IHQgPyAociA9IFMudmFsSG9va3NbdC50eXBlXSB8fCBTLnZhbEhvb2tzW3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pICYmIFwiZ2V0XCIgaW4gciAmJiB2b2lkIDAgIT09IChlID0gci5nZXQodCwgXCJ2YWx1ZVwiKSkgPyBlIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgKGUgPSB0LnZhbHVlKSA/IGUucmVwbGFjZSh5dCwgXCJcIikgOiBudWxsID09IGUgPyBcIlwiIDogZSA6IHZvaWQgMDtcblx0ICAgIH1cblx0ICB9KSwgUy5leHRlbmQoe1xuXHQgICAgdmFsSG9va3M6IHtcblx0ICAgICAgb3B0aW9uOiB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQgPSBTLmZpbmQuYXR0cihlLCBcInZhbHVlXCIpO1xuXHQgICAgICAgICAgcmV0dXJuIG51bGwgIT0gdCA/IHQgOiBodChTLnRleHQoZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgc2VsZWN0OiB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQsXG5cdCAgICAgICAgICAgICAgbixcblx0ICAgICAgICAgICAgICByLFxuXHQgICAgICAgICAgICAgIGkgPSBlLm9wdGlvbnMsXG5cdCAgICAgICAgICAgICAgbyA9IGUuc2VsZWN0ZWRJbmRleCxcblx0ICAgICAgICAgICAgICBhID0gXCJzZWxlY3Qtb25lXCIgPT09IGUudHlwZSxcblx0ICAgICAgICAgICAgICBzID0gYSA/IG51bGwgOiBbXSxcblx0ICAgICAgICAgICAgICB1ID0gYSA/IG8gKyAxIDogaS5sZW5ndGg7XG5cblx0ICAgICAgICAgIGZvciAociA9IG8gPCAwID8gdSA6IGEgPyBvIDogMDsgciA8IHU7IHIrKykgaWYgKCgobiA9IGlbcl0pLnNlbGVjdGVkIHx8IHIgPT09IG8pICYmICFuLmRpc2FibGVkICYmICghbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFBKG4ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiKSkpIHtcblx0ICAgICAgICAgICAgaWYgKHQgPSBTKG4pLnZhbCgpLCBhKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgcy5wdXNoKHQpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICAgIHZhciBuLFxuXHQgICAgICAgICAgICAgIHIsXG5cdCAgICAgICAgICAgICAgaSA9IGUub3B0aW9ucyxcblx0ICAgICAgICAgICAgICBvID0gUy5tYWtlQXJyYXkodCksXG5cdCAgICAgICAgICAgICAgYSA9IGkubGVuZ3RoO1xuXG5cdCAgICAgICAgICB3aGlsZSAoYS0tKSAoKHIgPSBpW2FdKS5zZWxlY3RlZCA9IC0xIDwgUy5pbkFycmF5KFMudmFsSG9va3Mub3B0aW9uLmdldChyKSwgbykpICYmIChuID0gITApO1xuXG5cdCAgICAgICAgICByZXR1cm4gbiB8fCAoZS5zZWxlY3RlZEluZGV4ID0gLTEpLCBvO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pLCBTLmVhY2goW1wicmFkaW9cIiwgXCJjaGVja2JveFwiXSwgZnVuY3Rpb24gKCkge1xuXHQgICAgUy52YWxIb29rc1t0aGlzXSA9IHtcblx0ICAgICAgc2V0OiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSByZXR1cm4gZS5jaGVja2VkID0gLTEgPCBTLmluQXJyYXkoUyhlKS52YWwoKSwgdCk7XG5cdCAgICAgIH1cblx0ICAgIH0sIHkuY2hlY2tPbiB8fCAoUy52YWxIb29rc1t0aGlzXS5nZXQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gbnVsbCA9PT0gZS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA/IFwib25cIiA6IGUudmFsdWU7XG5cdCAgICB9KTtcblx0ICB9KSwgeS5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiBDO1xuXG5cdCAgdmFyIG10ID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHQgICAgICB4dCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgIH07XG5cblx0ICBTLmV4dGVuZChTLmV2ZW50LCB7XG5cdCAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICB2YXIgaSxcblx0ICAgICAgICAgIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyxcblx0ICAgICAgICAgIHUsXG5cdCAgICAgICAgICBsLFxuXHQgICAgICAgICAgYyxcblx0ICAgICAgICAgIGYsXG5cdCAgICAgICAgICBwID0gW24gfHwgRV0sXG5cdCAgICAgICAgICBkID0gdi5jYWxsKGUsIFwidHlwZVwiKSA/IGUudHlwZSA6IGUsXG5cdCAgICAgICAgICBoID0gdi5jYWxsKGUsIFwibmFtZXNwYWNlXCIpID8gZS5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpIDogW107XG5cblx0ICAgICAgaWYgKG8gPSBmID0gYSA9IG4gPSBuIHx8IEUsIDMgIT09IG4ubm9kZVR5cGUgJiYgOCAhPT0gbi5ub2RlVHlwZSAmJiAhbXQudGVzdChkICsgUy5ldmVudC50cmlnZ2VyZWQpICYmICgtMSA8IGQuaW5kZXhPZihcIi5cIikgJiYgKGQgPSAoaCA9IGQuc3BsaXQoXCIuXCIpKS5zaGlmdCgpLCBoLnNvcnQoKSksIHUgPSBkLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyBkLCAoZSA9IGVbUy5leHBhbmRvXSA/IGUgOiBuZXcgUy5FdmVudChkLCBcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIGUpKS5pc1RyaWdnZXIgPSByID8gMiA6IDMsIGUubmFtZXNwYWNlID0gaC5qb2luKFwiLlwiKSwgZS5ybmFtZXNwYWNlID0gZS5uYW1lc3BhY2UgPyBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBoLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIpIDogbnVsbCwgZS5yZXN1bHQgPSB2b2lkIDAsIGUudGFyZ2V0IHx8IChlLnRhcmdldCA9IG4pLCB0ID0gbnVsbCA9PSB0ID8gW2VdIDogUy5tYWtlQXJyYXkodCwgW2VdKSwgYyA9IFMuZXZlbnQuc3BlY2lhbFtkXSB8fCB7fSwgciB8fCAhYy50cmlnZ2VyIHx8ICExICE9PSBjLnRyaWdnZXIuYXBwbHkobiwgdCkpKSB7XG5cdCAgICAgICAgaWYgKCFyICYmICFjLm5vQnViYmxlICYmICF4KG4pKSB7XG5cdCAgICAgICAgICBmb3IgKHMgPSBjLmRlbGVnYXRlVHlwZSB8fCBkLCBtdC50ZXN0KHMgKyBkKSB8fCAobyA9IG8ucGFyZW50Tm9kZSk7IG87IG8gPSBvLnBhcmVudE5vZGUpIHAucHVzaChvKSwgYSA9IG87XG5cblx0ICAgICAgICAgIGEgPT09IChuLm93bmVyRG9jdW1lbnQgfHwgRSkgJiYgcC5wdXNoKGEuZGVmYXVsdFZpZXcgfHwgYS5wYXJlbnRXaW5kb3cgfHwgQyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaSA9IDA7XG5cblx0ICAgICAgICB3aGlsZSAoKG8gPSBwW2krK10pICYmICFlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIGYgPSBvLCBlLnR5cGUgPSAxIDwgaSA/IHMgOiBjLmJpbmRUeXBlIHx8IGQsIChsID0gKFkuZ2V0KG8sIFwiZXZlbnRzXCIpIHx8IE9iamVjdC5jcmVhdGUobnVsbCkpW2UudHlwZV0gJiYgWS5nZXQobywgXCJoYW5kbGVcIikpICYmIGwuYXBwbHkobywgdCksIChsID0gdSAmJiBvW3VdKSAmJiBsLmFwcGx5ICYmIFYobykgJiYgKGUucmVzdWx0ID0gbC5hcHBseShvLCB0KSwgITEgPT09IGUucmVzdWx0ICYmIGUucHJldmVudERlZmF1bHQoKSk7XG5cblx0ICAgICAgICByZXR1cm4gZS50eXBlID0gZCwgciB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGMuX2RlZmF1bHQgJiYgITEgIT09IGMuX2RlZmF1bHQuYXBwbHkocC5wb3AoKSwgdCkgfHwgIVYobikgfHwgdSAmJiBtKG5bZF0pICYmICF4KG4pICYmICgoYSA9IG5bdV0pICYmIChuW3VdID0gbnVsbCksIFMuZXZlbnQudHJpZ2dlcmVkID0gZCwgZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICYmIGYuYWRkRXZlbnRMaXN0ZW5lcihkLCB4dCksIG5bZF0oKSwgZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICYmIGYucmVtb3ZlRXZlbnRMaXN0ZW5lcihkLCB4dCksIFMuZXZlbnQudHJpZ2dlcmVkID0gdm9pZCAwLCBhICYmIChuW3VdID0gYSkpLCBlLnJlc3VsdDtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHNpbXVsYXRlOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICB2YXIgciA9IFMuZXh0ZW5kKG5ldyBTLkV2ZW50KCksIG4sIHtcblx0ICAgICAgICB0eXBlOiBlLFxuXHQgICAgICAgIGlzU2ltdWxhdGVkOiAhMFxuXHQgICAgICB9KTtcblx0ICAgICAgUy5ldmVudC50cmlnZ2VyKHIsIG51bGwsIHQpO1xuXHQgICAgfVxuXHQgIH0pLCBTLmZuLmV4dGVuZCh7XG5cdCAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBTLmV2ZW50LnRyaWdnZXIoZSwgdCwgdGhpcyk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbiA9IHRoaXNbMF07XG5cdCAgICAgIGlmIChuKSByZXR1cm4gUy5ldmVudC50cmlnZ2VyKGUsIHQsIG4sICEwKTtcblx0ICAgIH1cblx0ICB9KSwgeS5mb2N1c2luIHx8IFMuZWFjaCh7XG5cdCAgICBmb2N1czogXCJmb2N1c2luXCIsXG5cdCAgICBibHVyOiBcImZvY3Vzb3V0XCJcblx0ICB9LCBmdW5jdGlvbiAobiwgcikge1xuXHQgICAgdmFyIGkgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBTLmV2ZW50LnNpbXVsYXRlKHIsIGUudGFyZ2V0LCBTLmV2ZW50LmZpeChlKSk7XG5cdCAgICB9O1xuXG5cdCAgICBTLmV2ZW50LnNwZWNpYWxbcl0gPSB7XG5cdCAgICAgIHNldHVwOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGUgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHQgICAgICAgICAgICB0ID0gWS5hY2Nlc3MoZSwgcik7XG5cdCAgICAgICAgdCB8fCBlLmFkZEV2ZW50TGlzdGVuZXIobiwgaSwgITApLCBZLmFjY2VzcyhlLCByLCAodCB8fCAwKSArIDEpO1xuXHQgICAgICB9LFxuXHQgICAgICB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBlID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0ICAgICAgICAgICAgdCA9IFkuYWNjZXNzKGUsIHIpIC0gMTtcblx0ICAgICAgICB0ID8gWS5hY2Nlc3MoZSwgciwgdCkgOiAoZS5yZW1vdmVFdmVudExpc3RlbmVyKG4sIGksICEwKSwgWS5yZW1vdmUoZSwgcikpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0pO1xuXHQgIHZhciBidCA9IEMubG9jYXRpb24sXG5cdCAgICAgIHd0ID0ge1xuXHQgICAgZ3VpZDogRGF0ZS5ub3coKVxuXHQgIH0sXG5cdCAgICAgIFR0ID0gL1xcPy87XG5cblx0ICBTLnBhcnNlWE1MID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciB0LCBuO1xuXHQgICAgaWYgKCFlIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHJldHVybiBudWxsO1xuXG5cdCAgICB0cnkge1xuXHQgICAgICB0ID0gbmV3IEMuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGUsIFwidGV4dC94bWxcIik7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXG5cdCAgICByZXR1cm4gbiA9IHQgJiYgdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpWzBdLCB0ICYmICFuIHx8IFMuZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIgKyAobiA/IFMubWFwKG4uY2hpbGROb2RlcywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIGUudGV4dENvbnRlbnQ7XG5cdCAgICB9KS5qb2luKFwiXFxuXCIpIDogZSkpLCB0O1xuXHQgIH07XG5cblx0ICB2YXIgQ3QgPSAvXFxbXFxdJC8sXG5cdCAgICAgIEV0ID0gL1xccj9cXG4vZyxcblx0ICAgICAgU3QgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdCAgICAgIGt0ID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5cdCAgZnVuY3Rpb24gQXQobiwgZSwgciwgaSkge1xuXHQgICAgdmFyIHQ7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkgUy5lYWNoKGUsIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHIgfHwgQ3QudGVzdChuKSA/IGkobiwgdCkgOiBBdChuICsgXCJbXCIgKyAoXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiBudWxsICE9IHQgPyBlIDogXCJcIikgKyBcIl1cIiwgdCwgciwgaSk7XG5cdCAgICB9KTtlbHNlIGlmIChyIHx8IFwib2JqZWN0XCIgIT09IHcoZSkpIGkobiwgZSk7ZWxzZSBmb3IgKHQgaW4gZSkgQXQobiArIFwiW1wiICsgdCArIFwiXVwiLCBlW3RdLCByLCBpKTtcblx0ICB9XG5cblx0ICBTLnBhcmFtID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgIHZhciBuLFxuXHQgICAgICAgIHIgPSBbXSxcblx0ICAgICAgICBpID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgdmFyIG4gPSBtKHQpID8gdCgpIDogdDtcblx0ICAgICAgcltyLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoZSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChudWxsID09IG4gPyBcIlwiIDogbik7XG5cdCAgICB9O1xuXG5cdCAgICBpZiAobnVsbCA9PSBlKSByZXR1cm4gXCJcIjtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KGUpIHx8IGUuanF1ZXJ5ICYmICFTLmlzUGxhaW5PYmplY3QoZSkpIFMuZWFjaChlLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGkodGhpcy5uYW1lLCB0aGlzLnZhbHVlKTtcblx0ICAgIH0pO2Vsc2UgZm9yIChuIGluIGUpIEF0KG4sIGVbbl0sIHQsIGkpO1xuXHQgICAgcmV0dXJuIHIuam9pbihcIiZcIik7XG5cdCAgfSwgUy5mbi5leHRlbmQoe1xuXHQgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBTLnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSk7XG5cdCAgICB9LFxuXHQgICAgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZSA9IFMucHJvcCh0aGlzLCBcImVsZW1lbnRzXCIpO1xuXHQgICAgICAgIHJldHVybiBlID8gUy5tYWtlQXJyYXkoZSkgOiB0aGlzO1xuXHQgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBlID0gdGhpcy50eXBlO1xuXHQgICAgICAgIHJldHVybiB0aGlzLm5hbWUgJiYgIVModGhpcykuaXMoXCI6ZGlzYWJsZWRcIikgJiYga3QudGVzdCh0aGlzLm5vZGVOYW1lKSAmJiAhU3QudGVzdChlKSAmJiAodGhpcy5jaGVja2VkIHx8ICFwZS50ZXN0KGUpKTtcblx0ICAgICAgfSkubWFwKGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBTKHRoaXMpLnZhbCgpO1xuXHQgICAgICAgIHJldHVybiBudWxsID09IG4gPyBudWxsIDogQXJyYXkuaXNBcnJheShuKSA/IFMubWFwKG4sIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBuYW1lOiB0Lm5hbWUsXG5cdCAgICAgICAgICAgIHZhbHVlOiBlLnJlcGxhY2UoRXQsIFwiXFxyXFxuXCIpXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0pIDoge1xuXHQgICAgICAgICAgbmFtZTogdC5uYW1lLFxuXHQgICAgICAgICAgdmFsdWU6IG4ucmVwbGFjZShFdCwgXCJcXHJcXG5cIilcblx0ICAgICAgICB9O1xuXHQgICAgICB9KS5nZXQoKTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICB2YXIgTnQgPSAvJTIwL2csXG5cdCAgICAgIGp0ID0gLyMuKiQvLFxuXHQgICAgICBEdCA9IC8oWz8mXSlfPVteJl0qLyxcblx0ICAgICAgcXQgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL2dtLFxuXHQgICAgICBMdCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdCAgICAgIEh0ID0gL15cXC9cXC8vLFxuXHQgICAgICBPdCA9IHt9LFxuXHQgICAgICBQdCA9IHt9LFxuXHQgICAgICBSdCA9IFwiKi9cIi5jb25jYXQoXCIqXCIpLFxuXHQgICAgICBNdCA9IEUuY3JlYXRlRWxlbWVudChcImFcIik7XG5cblx0ICBmdW5jdGlvbiBJdChvKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSAmJiAodCA9IGUsIGUgPSBcIipcIik7XG5cdCAgICAgIHZhciBuLFxuXHQgICAgICAgICAgciA9IDAsXG5cdCAgICAgICAgICBpID0gZS50b0xvd2VyQ2FzZSgpLm1hdGNoKFApIHx8IFtdO1xuXHQgICAgICBpZiAobSh0KSkgd2hpbGUgKG4gPSBpW3IrK10pIFwiK1wiID09PSBuWzBdID8gKG4gPSBuLnNsaWNlKDEpIHx8IFwiKlwiLCAob1tuXSA9IG9bbl0gfHwgW10pLnVuc2hpZnQodCkpIDogKG9bbl0gPSBvW25dIHx8IFtdKS5wdXNoKHQpO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBXdCh0LCBpLCBvLCBhKSB7XG5cdCAgICB2YXIgcyA9IHt9LFxuXHQgICAgICAgIHUgPSB0ID09PSBQdDtcblxuXHQgICAgZnVuY3Rpb24gbChlKSB7XG5cdCAgICAgIHZhciByO1xuXHQgICAgICByZXR1cm4gc1tlXSA9ICEwLCBTLmVhY2godFtlXSB8fCBbXSwgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IHQoaSwgbywgYSk7XG5cdCAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT0gdHlwZW9mIG4gfHwgdSB8fCBzW25dID8gdSA/ICEociA9IG4pIDogdm9pZCAwIDogKGkuZGF0YVR5cGVzLnVuc2hpZnQobiksIGwobiksICExKTtcblx0ICAgICAgfSksIHI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBsKGkuZGF0YVR5cGVzWzBdKSB8fCAhc1tcIipcIl0gJiYgbChcIipcIik7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gRnQoZSwgdCkge1xuXHQgICAgdmFyIG4sXG5cdCAgICAgICAgcixcblx0ICAgICAgICBpID0gUy5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0ICAgIGZvciAobiBpbiB0KSB2b2lkIDAgIT09IHRbbl0gJiYgKChpW25dID8gZSA6IHIgfHwgKHIgPSB7fSkpW25dID0gdFtuXSk7XG5cblx0ICAgIHJldHVybiByICYmIFMuZXh0ZW5kKCEwLCBlLCByKSwgZTtcblx0ICB9XG5cblx0ICBNdC5ocmVmID0gYnQuaHJlZiwgUy5leHRlbmQoe1xuXHQgICAgYWN0aXZlOiAwLFxuXHQgICAgbGFzdE1vZGlmaWVkOiB7fSxcblx0ICAgIGV0YWc6IHt9LFxuXHQgICAgYWpheFNldHRpbmdzOiB7XG5cdCAgICAgIHVybDogYnQuaHJlZixcblx0ICAgICAgdHlwZTogXCJHRVRcIixcblx0ICAgICAgaXNMb2NhbDogL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8udGVzdChidC5wcm90b2NvbCksXG5cdCAgICAgIGdsb2JhbDogITAsXG5cdCAgICAgIHByb2Nlc3NEYXRhOiAhMCxcblx0ICAgICAgYXN5bmM6ICEwLFxuXHQgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0ICAgICAgYWNjZXB0czoge1xuXHQgICAgICAgIFwiKlwiOiBSdCxcblx0ICAgICAgICB0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0ICAgICAgICBodG1sOiBcInRleHQvaHRtbFwiLFxuXHQgICAgICAgIHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdCAgICAgICAganNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHQgICAgICB9LFxuXHQgICAgICBjb250ZW50czoge1xuXHQgICAgICAgIHhtbDogL1xcYnhtbFxcYi8sXG5cdCAgICAgICAgaHRtbDogL1xcYmh0bWwvLFxuXHQgICAgICAgIGpzb246IC9cXGJqc29uXFxiL1xuXHQgICAgICB9LFxuXHQgICAgICByZXNwb25zZUZpZWxkczoge1xuXHQgICAgICAgIHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHQgICAgICAgIHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdCAgICAgICAganNvbjogXCJyZXNwb25zZUpTT05cIlxuXHQgICAgICB9LFxuXHQgICAgICBjb252ZXJ0ZXJzOiB7XG5cdCAgICAgICAgXCIqIHRleHRcIjogU3RyaW5nLFxuXHQgICAgICAgIFwidGV4dCBodG1sXCI6ICEwLFxuXHQgICAgICAgIFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cdCAgICAgICAgXCJ0ZXh0IHhtbFwiOiBTLnBhcnNlWE1MXG5cdCAgICAgIH0sXG5cdCAgICAgIGZsYXRPcHRpb25zOiB7XG5cdCAgICAgICAgdXJsOiAhMCxcblx0ICAgICAgICBjb250ZXh0OiAhMFxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgYWpheFNldHVwOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gdCA/IEZ0KEZ0KGUsIFMuYWpheFNldHRpbmdzKSwgdCkgOiBGdChTLmFqYXhTZXR0aW5ncywgZSk7XG5cdCAgICB9LFxuXHQgICAgYWpheFByZWZpbHRlcjogSXQoT3QpLFxuXHQgICAgYWpheFRyYW5zcG9ydDogSXQoUHQpLFxuXHQgICAgYWpheDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiAodCA9IGUsIGUgPSB2b2lkIDApLCB0ID0gdCB8fCB7fTtcblx0ICAgICAgdmFyIGMsXG5cdCAgICAgICAgICBmLFxuXHQgICAgICAgICAgcCxcblx0ICAgICAgICAgIG4sXG5cdCAgICAgICAgICBkLFxuXHQgICAgICAgICAgcixcblx0ICAgICAgICAgIGgsXG5cdCAgICAgICAgICBnLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8sXG5cdCAgICAgICAgICB2ID0gUy5hamF4U2V0dXAoe30sIHQpLFxuXHQgICAgICAgICAgeSA9IHYuY29udGV4dCB8fCB2LFxuXHQgICAgICAgICAgbSA9IHYuY29udGV4dCAmJiAoeS5ub2RlVHlwZSB8fCB5LmpxdWVyeSkgPyBTKHkpIDogUy5ldmVudCxcblx0ICAgICAgICAgIHggPSBTLkRlZmVycmVkKCksXG5cdCAgICAgICAgICBiID0gUy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcblx0ICAgICAgICAgIHcgPSB2LnN0YXR1c0NvZGUgfHwge30sXG5cdCAgICAgICAgICBhID0ge30sXG5cdCAgICAgICAgICBzID0ge30sXG5cdCAgICAgICAgICB1ID0gXCJjYW5jZWxlZFwiLFxuXHQgICAgICAgICAgVCA9IHtcblx0ICAgICAgICByZWFkeVN0YXRlOiAwLFxuXHQgICAgICAgIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQ7XG5cblx0ICAgICAgICAgIGlmIChoKSB7XG5cdCAgICAgICAgICAgIGlmICghbikge1xuXHQgICAgICAgICAgICAgIG4gPSB7fTtcblxuXHQgICAgICAgICAgICAgIHdoaWxlICh0ID0gcXQuZXhlYyhwKSkgblt0WzFdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIl0gPSAoblt0WzFdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIl0gfHwgW10pLmNvbmNhdCh0WzJdKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHQgPSBuW2UudG9Mb3dlckNhc2UoKSArIFwiIFwiXTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgcmV0dXJuIG51bGwgPT0gdCA/IG51bGwgOiB0LmpvaW4oXCIsIFwiKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgcmV0dXJuIGggPyBwIDogbnVsbDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgICByZXR1cm4gbnVsbCA9PSBoICYmIChlID0gc1tlLnRvTG93ZXJDYXNlKCldID0gc1tlLnRvTG93ZXJDYXNlKCldIHx8IGUsIGFbZV0gPSB0KSwgdGhpcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gbnVsbCA9PSBoICYmICh2Lm1pbWVUeXBlID0gZSksIHRoaXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzdGF0dXNDb2RlOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQ7XG5cdCAgICAgICAgICBpZiAoZSkgaWYgKGgpIFQuYWx3YXlzKGVbVC5zdGF0dXNdKTtlbHNlIGZvciAodCBpbiBlKSB3W3RdID0gW3dbdF0sIGVbdF1dO1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBhYm9ydDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciB0ID0gZSB8fCB1O1xuXHQgICAgICAgICAgcmV0dXJuIGMgJiYgYy5hYm9ydCh0KSwgbCgwLCB0KSwgdGhpcztcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cblx0ICAgICAgaWYgKHgucHJvbWlzZShUKSwgdi51cmwgPSAoKGUgfHwgdi51cmwgfHwgYnQuaHJlZikgKyBcIlwiKS5yZXBsYWNlKEh0LCBidC5wcm90b2NvbCArIFwiLy9cIiksIHYudHlwZSA9IHQubWV0aG9kIHx8IHQudHlwZSB8fCB2Lm1ldGhvZCB8fCB2LnR5cGUsIHYuZGF0YVR5cGVzID0gKHYuZGF0YVR5cGUgfHwgXCIqXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2goUCkgfHwgW1wiXCJdLCBudWxsID09IHYuY3Jvc3NEb21haW4pIHtcblx0ICAgICAgICByID0gRS5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICByLmhyZWYgPSB2LnVybCwgci5ocmVmID0gci5ocmVmLCB2LmNyb3NzRG9tYWluID0gTXQucHJvdG9jb2wgKyBcIi8vXCIgKyBNdC5ob3N0ICE9IHIucHJvdG9jb2wgKyBcIi8vXCIgKyByLmhvc3Q7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgdi5jcm9zc0RvbWFpbiA9ICEwO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh2LmRhdGEgJiYgdi5wcm9jZXNzRGF0YSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiB2LmRhdGEgJiYgKHYuZGF0YSA9IFMucGFyYW0odi5kYXRhLCB2LnRyYWRpdGlvbmFsKSksIFd0KE90LCB2LCB0LCBUKSwgaCkgcmV0dXJuIFQ7XG5cblx0ICAgICAgZm9yIChpIGluIChnID0gUy5ldmVudCAmJiB2Lmdsb2JhbCkgJiYgMCA9PSBTLmFjdGl2ZSsrICYmIFMuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKSwgdi50eXBlID0gdi50eXBlLnRvVXBwZXJDYXNlKCksIHYuaGFzQ29udGVudCA9ICFMdC50ZXN0KHYudHlwZSksIGYgPSB2LnVybC5yZXBsYWNlKGp0LCBcIlwiKSwgdi5oYXNDb250ZW50ID8gdi5kYXRhICYmIHYucHJvY2Vzc0RhdGEgJiYgMCA9PT0gKHYuY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAmJiAodi5kYXRhID0gdi5kYXRhLnJlcGxhY2UoTnQsIFwiK1wiKSkgOiAobyA9IHYudXJsLnNsaWNlKGYubGVuZ3RoKSwgdi5kYXRhICYmICh2LnByb2Nlc3NEYXRhIHx8IFwic3RyaW5nXCIgPT0gdHlwZW9mIHYuZGF0YSkgJiYgKGYgKz0gKFR0LnRlc3QoZikgPyBcIiZcIiA6IFwiP1wiKSArIHYuZGF0YSwgZGVsZXRlIHYuZGF0YSksICExID09PSB2LmNhY2hlICYmIChmID0gZi5yZXBsYWNlKER0LCBcIiQxXCIpLCBvID0gKFR0LnRlc3QoZikgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIHd0Lmd1aWQrKyArIG8pLCB2LnVybCA9IGYgKyBvKSwgdi5pZk1vZGlmaWVkICYmIChTLmxhc3RNb2RpZmllZFtmXSAmJiBULnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBTLmxhc3RNb2RpZmllZFtmXSksIFMuZXRhZ1tmXSAmJiBULnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Ob25lLU1hdGNoXCIsIFMuZXRhZ1tmXSkpLCAodi5kYXRhICYmIHYuaGFzQ29udGVudCAmJiAhMSAhPT0gdi5jb250ZW50VHlwZSB8fCB0LmNvbnRlbnRUeXBlKSAmJiBULnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgdi5jb250ZW50VHlwZSksIFQuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCB2LmRhdGFUeXBlc1swXSAmJiB2LmFjY2VwdHNbdi5kYXRhVHlwZXNbMF1dID8gdi5hY2NlcHRzW3YuZGF0YVR5cGVzWzBdXSArIChcIipcIiAhPT0gdi5kYXRhVHlwZXNbMF0gPyBcIiwgXCIgKyBSdCArIFwiOyBxPTAuMDFcIiA6IFwiXCIpIDogdi5hY2NlcHRzW1wiKlwiXSksIHYuaGVhZGVycykgVC5zZXRSZXF1ZXN0SGVhZGVyKGksIHYuaGVhZGVyc1tpXSk7XG5cblx0ICAgICAgaWYgKHYuYmVmb3JlU2VuZCAmJiAoITEgPT09IHYuYmVmb3JlU2VuZC5jYWxsKHksIFQsIHYpIHx8IGgpKSByZXR1cm4gVC5hYm9ydCgpO1xuXG5cdCAgICAgIGlmICh1ID0gXCJhYm9ydFwiLCBiLmFkZCh2LmNvbXBsZXRlKSwgVC5kb25lKHYuc3VjY2VzcyksIFQuZmFpbCh2LmVycm9yKSwgYyA9IFd0KFB0LCB2LCB0LCBUKSkge1xuXHQgICAgICAgIGlmIChULnJlYWR5U3RhdGUgPSAxLCBnICYmIG0udHJpZ2dlcihcImFqYXhTZW5kXCIsIFtULCB2XSksIGgpIHJldHVybiBUO1xuXHQgICAgICAgIHYuYXN5bmMgJiYgMCA8IHYudGltZW91dCAmJiAoZCA9IEMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBULmFib3J0KFwidGltZW91dFwiKTtcblx0ICAgICAgICB9LCB2LnRpbWVvdXQpKTtcblxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICBoID0gITEsIGMuc2VuZChhLCBsKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICBpZiAoaCkgdGhyb3cgZTtcblx0ICAgICAgICAgIGwoLTEsIGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGwoLTEsIFwiTm8gVHJhbnNwb3J0XCIpO1xuXG5cdCAgICAgIGZ1bmN0aW9uIGwoZSwgdCwgbiwgcikge1xuXHQgICAgICAgIHZhciBpLFxuXHQgICAgICAgICAgICBvLFxuXHQgICAgICAgICAgICBhLFxuXHQgICAgICAgICAgICBzLFxuXHQgICAgICAgICAgICB1LFxuXHQgICAgICAgICAgICBsID0gdDtcblx0ICAgICAgICBoIHx8IChoID0gITAsIGQgJiYgQy5jbGVhclRpbWVvdXQoZCksIGMgPSB2b2lkIDAsIHAgPSByIHx8IFwiXCIsIFQucmVhZHlTdGF0ZSA9IDAgPCBlID8gNCA6IDAsIGkgPSAyMDAgPD0gZSAmJiBlIDwgMzAwIHx8IDMwNCA9PT0gZSwgbiAmJiAocyA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgICB2YXIgcixcblx0ICAgICAgICAgICAgICBpLFxuXHQgICAgICAgICAgICAgIG8sXG5cdCAgICAgICAgICAgICAgYSxcblx0ICAgICAgICAgICAgICBzID0gZS5jb250ZW50cyxcblx0ICAgICAgICAgICAgICB1ID0gZS5kYXRhVHlwZXM7XG5cblx0ICAgICAgICAgIHdoaWxlIChcIipcIiA9PT0gdVswXSkgdS5zaGlmdCgpLCB2b2lkIDAgPT09IHIgJiYgKHIgPSBlLm1pbWVUeXBlIHx8IHQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpO1xuXG5cdCAgICAgICAgICBpZiAocikgZm9yIChpIGluIHMpIGlmIChzW2ldICYmIHNbaV0udGVzdChyKSkge1xuXHQgICAgICAgICAgICB1LnVuc2hpZnQoaSk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKHVbMF0gaW4gbikgbyA9IHVbMF07ZWxzZSB7XG5cdCAgICAgICAgICAgIGZvciAoaSBpbiBuKSB7XG5cdCAgICAgICAgICAgICAgaWYgKCF1WzBdIHx8IGUuY29udmVydGVyc1tpICsgXCIgXCIgKyB1WzBdXSkge1xuXHQgICAgICAgICAgICAgICAgbyA9IGk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICBhIHx8IChhID0gaSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBvID0gbyB8fCBhO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKG8pIHJldHVybiBvICE9PSB1WzBdICYmIHUudW5zaGlmdChvKSwgbltvXTtcblx0ICAgICAgICB9KHYsIFQsIG4pKSwgIWkgJiYgLTEgPCBTLmluQXJyYXkoXCJzY3JpcHRcIiwgdi5kYXRhVHlwZXMpICYmIFMuaW5BcnJheShcImpzb25cIiwgdi5kYXRhVHlwZXMpIDwgMCAmJiAodi5jb252ZXJ0ZXJzW1widGV4dCBzY3JpcHRcIl0gPSBmdW5jdGlvbiAoKSB7fSksIHMgPSBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICAgICAgdmFyIGksXG5cdCAgICAgICAgICAgICAgbyxcblx0ICAgICAgICAgICAgICBhLFxuXHQgICAgICAgICAgICAgIHMsXG5cdCAgICAgICAgICAgICAgdSxcblx0ICAgICAgICAgICAgICBsID0ge30sXG5cdCAgICAgICAgICAgICAgYyA9IGUuZGF0YVR5cGVzLnNsaWNlKCk7XG5cdCAgICAgICAgICBpZiAoY1sxXSkgZm9yIChhIGluIGUuY29udmVydGVycykgbFthLnRvTG93ZXJDYXNlKCldID0gZS5jb252ZXJ0ZXJzW2FdO1xuXHQgICAgICAgICAgbyA9IGMuc2hpZnQoKTtcblxuXHQgICAgICAgICAgd2hpbGUgKG8pIGlmIChlLnJlc3BvbnNlRmllbGRzW29dICYmIChuW2UucmVzcG9uc2VGaWVsZHNbb11dID0gdCksICF1ICYmIHIgJiYgZS5kYXRhRmlsdGVyICYmICh0ID0gZS5kYXRhRmlsdGVyKHQsIGUuZGF0YVR5cGUpKSwgdSA9IG8sIG8gPSBjLnNoaWZ0KCkpIGlmIChcIipcIiA9PT0gbykgbyA9IHU7ZWxzZSBpZiAoXCIqXCIgIT09IHUgJiYgdSAhPT0gbykge1xuXHQgICAgICAgICAgICBpZiAoIShhID0gbFt1ICsgXCIgXCIgKyBvXSB8fCBsW1wiKiBcIiArIG9dKSkgZm9yIChpIGluIGwpIGlmICgocyA9IGkuc3BsaXQoXCIgXCIpKVsxXSA9PT0gbyAmJiAoYSA9IGxbdSArIFwiIFwiICsgc1swXV0gfHwgbFtcIiogXCIgKyBzWzBdXSkpIHtcblx0ICAgICAgICAgICAgICAhMCA9PT0gYSA/IGEgPSBsW2ldIDogITAgIT09IGxbaV0gJiYgKG8gPSBzWzBdLCBjLnVuc2hpZnQoc1sxXSkpO1xuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghMCAhPT0gYSkgaWYgKGEgJiYgZVtcInRocm93c1wiXSkgdCA9IGEodCk7ZWxzZSB0cnkge1xuXHQgICAgICAgICAgICAgIHQgPSBhKHQpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdCAgICAgICAgICAgICAgICBlcnJvcjogYSA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHUgKyBcIiB0byBcIiArIG9cblx0ICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHN0YXRlOiBcInN1Y2Nlc3NcIixcblx0ICAgICAgICAgICAgZGF0YTogdFxuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9KHYsIHMsIFQsIGkpLCBpID8gKHYuaWZNb2RpZmllZCAmJiAoKHUgPSBULmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKSkgJiYgKFMubGFzdE1vZGlmaWVkW2ZdID0gdSksICh1ID0gVC5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIikpICYmIChTLmV0YWdbZl0gPSB1KSksIDIwNCA9PT0gZSB8fCBcIkhFQURcIiA9PT0gdi50eXBlID8gbCA9IFwibm9jb250ZW50XCIgOiAzMDQgPT09IGUgPyBsID0gXCJub3Rtb2RpZmllZFwiIDogKGwgPSBzLnN0YXRlLCBvID0gcy5kYXRhLCBpID0gIShhID0gcy5lcnJvcikpKSA6IChhID0gbCwgIWUgJiYgbCB8fCAobCA9IFwiZXJyb3JcIiwgZSA8IDAgJiYgKGUgPSAwKSkpLCBULnN0YXR1cyA9IGUsIFQuc3RhdHVzVGV4dCA9ICh0IHx8IGwpICsgXCJcIiwgaSA/IHgucmVzb2x2ZVdpdGgoeSwgW28sIGwsIFRdKSA6IHgucmVqZWN0V2l0aCh5LCBbVCwgbCwgYV0pLCBULnN0YXR1c0NvZGUodyksIHcgPSB2b2lkIDAsIGcgJiYgbS50cmlnZ2VyKGkgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLCBbVCwgdiwgaSA/IG8gOiBhXSksIGIuZmlyZVdpdGgoeSwgW1QsIGxdKSwgZyAmJiAobS50cmlnZ2VyKFwiYWpheENvbXBsZXRlXCIsIFtULCB2XSksIC0tUy5hY3RpdmUgfHwgUy5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIikpKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBUO1xuXHQgICAgfSxcblx0ICAgIGdldEpTT046IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHJldHVybiBTLmdldChlLCB0LCBuLCBcImpzb25cIik7XG5cdCAgICB9LFxuXHQgICAgZ2V0U2NyaXB0OiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gUy5nZXQoZSwgdm9pZCAwLCB0LCBcInNjcmlwdFwiKTtcblx0ICAgIH1cblx0ICB9KSwgUy5lYWNoKFtcImdldFwiLCBcInBvc3RcIl0sIGZ1bmN0aW9uIChlLCBpKSB7XG5cdCAgICBTW2ldID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcblx0ICAgICAgcmV0dXJuIG0odCkgJiYgKHIgPSByIHx8IG4sIG4gPSB0LCB0ID0gdm9pZCAwKSwgUy5hamF4KFMuZXh0ZW5kKHtcblx0ICAgICAgICB1cmw6IGUsXG5cdCAgICAgICAgdHlwZTogaSxcblx0ICAgICAgICBkYXRhVHlwZTogcixcblx0ICAgICAgICBkYXRhOiB0LFxuXHQgICAgICAgIHN1Y2Nlc3M6IG5cblx0ICAgICAgfSwgUy5pc1BsYWluT2JqZWN0KGUpICYmIGUpKTtcblx0ICAgIH07XG5cdCAgfSksIFMuYWpheFByZWZpbHRlcihmdW5jdGlvbiAoZSkge1xuXHQgICAgdmFyIHQ7XG5cblx0ICAgIGZvciAodCBpbiBlLmhlYWRlcnMpIFwiY29udGVudC10eXBlXCIgPT09IHQudG9Mb3dlckNhc2UoKSAmJiAoZS5jb250ZW50VHlwZSA9IGUuaGVhZGVyc1t0XSB8fCBcIlwiKTtcblx0ICB9KSwgUy5fZXZhbFVybCA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICByZXR1cm4gUy5hamF4KHtcblx0ICAgICAgdXJsOiBlLFxuXHQgICAgICB0eXBlOiBcIkdFVFwiLFxuXHQgICAgICBkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0ICAgICAgY2FjaGU6ICEwLFxuXHQgICAgICBhc3luYzogITEsXG5cdCAgICAgIGdsb2JhbDogITEsXG5cdCAgICAgIGNvbnZlcnRlcnM6IHtcblx0ICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uICgpIHt9XG5cdCAgICAgIH0sXG5cdCAgICAgIGRhdGFGaWx0ZXI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgUy5nbG9iYWxFdmFsKGUsIHQsIG4pO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9LCBTLmZuLmV4dGVuZCh7XG5cdCAgICB3cmFwQWxsOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdDtcblx0ICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgKG0oZSkgJiYgKGUgPSBlLmNhbGwodGhpc1swXSkpLCB0ID0gUyhlLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKSwgdGhpc1swXS5wYXJlbnROb2RlICYmIHQuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLCB0Lm1hcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGUgPSB0aGlzO1xuXG5cdCAgICAgICAgd2hpbGUgKGUuZmlyc3RFbGVtZW50Q2hpbGQpIGUgPSBlLmZpcnN0RWxlbWVudENoaWxkO1xuXG5cdCAgICAgICAgcmV0dXJuIGU7XG5cdCAgICAgIH0pLmFwcGVuZCh0aGlzKSksIHRoaXM7XG5cdCAgICB9LFxuXHQgICAgd3JhcElubmVyOiBmdW5jdGlvbiAobikge1xuXHQgICAgICByZXR1cm4gbShuKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIFModGhpcykud3JhcElubmVyKG4uY2FsbCh0aGlzLCBlKSk7XG5cdCAgICAgIH0pIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZSA9IFModGhpcyksXG5cdCAgICAgICAgICAgIHQgPSBlLmNvbnRlbnRzKCk7XG5cdCAgICAgICAgdC5sZW5ndGggPyB0LndyYXBBbGwobikgOiBlLmFwcGVuZChuKTtcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgd3JhcDogZnVuY3Rpb24gKHQpIHtcblx0ICAgICAgdmFyIG4gPSBtKHQpO1xuXHQgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgUyh0aGlzKS53cmFwQWxsKG4gPyB0LmNhbGwodGhpcywgZSkgOiB0KTtcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgdW53cmFwOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoZSkubm90KFwiYm9keVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBTKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyk7XG5cdCAgICAgIH0pLCB0aGlzO1xuXHQgICAgfVxuXHQgIH0pLCBTLmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgcmV0dXJuICFTLmV4cHIucHNldWRvcy52aXNpYmxlKGUpO1xuXHQgIH0sIFMuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgcmV0dXJuICEhKGUub2Zmc2V0V2lkdGggfHwgZS5vZmZzZXRIZWlnaHQgfHwgZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG5cdCAgfSwgUy5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIG5ldyBDLlhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgIH07XG5cdCAgdmFyIEJ0ID0ge1xuXHQgICAgMDogMjAwLFxuXHQgICAgMTIyMzogMjA0XG5cdCAgfSxcblx0ICAgICAgJHQgPSBTLmFqYXhTZXR0aW5ncy54aHIoKTtcblx0ICB5LmNvcnMgPSAhISR0ICYmIFwid2l0aENyZWRlbnRpYWxzXCIgaW4gJHQsIHkuYWpheCA9ICR0ID0gISEkdCwgUy5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uIChpKSB7XG5cdCAgICB2YXIgbywgYTtcblx0ICAgIGlmICh5LmNvcnMgfHwgJHQgJiYgIWkuY3Jvc3NEb21haW4pIHJldHVybiB7XG5cdCAgICAgIHNlbmQ6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgdmFyIG4sXG5cdCAgICAgICAgICAgIHIgPSBpLnhocigpO1xuXHQgICAgICAgIGlmIChyLm9wZW4oaS50eXBlLCBpLnVybCwgaS5hc3luYywgaS51c2VybmFtZSwgaS5wYXNzd29yZCksIGkueGhyRmllbGRzKSBmb3IgKG4gaW4gaS54aHJGaWVsZHMpIHJbbl0gPSBpLnhockZpZWxkc1tuXTtcblxuXHQgICAgICAgIGZvciAobiBpbiBpLm1pbWVUeXBlICYmIHIub3ZlcnJpZGVNaW1lVHlwZSAmJiByLm92ZXJyaWRlTWltZVR5cGUoaS5taW1lVHlwZSksIGkuY3Jvc3NEb21haW4gfHwgZVtcIlgtUmVxdWVzdGVkLVdpdGhcIl0gfHwgKGVbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiKSwgZSkgci5zZXRSZXF1ZXN0SGVhZGVyKG4sIGVbbl0pO1xuXG5cdCAgICAgICAgbyA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBvICYmIChvID0gYSA9IHIub25sb2FkID0gci5vbmVycm9yID0gci5vbmFib3J0ID0gci5vbnRpbWVvdXQgPSByLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGwsIFwiYWJvcnRcIiA9PT0gZSA/IHIuYWJvcnQoKSA6IFwiZXJyb3JcIiA9PT0gZSA/IFwibnVtYmVyXCIgIT0gdHlwZW9mIHIuc3RhdHVzID8gdCgwLCBcImVycm9yXCIpIDogdChyLnN0YXR1cywgci5zdGF0dXNUZXh0KSA6IHQoQnRbci5zdGF0dXNdIHx8IHIuc3RhdHVzLCByLnN0YXR1c1RleHQsIFwidGV4dFwiICE9PSAoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIpIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIHIucmVzcG9uc2VUZXh0ID8ge1xuXHQgICAgICAgICAgICAgIGJpbmFyeTogci5yZXNwb25zZVxuXHQgICAgICAgICAgICB9IDoge1xuXHQgICAgICAgICAgICAgIHRleHQ6IHIucmVzcG9uc2VUZXh0XG5cdCAgICAgICAgICAgIH0sIHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKTtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSwgci5vbmxvYWQgPSBvKCksIGEgPSByLm9uZXJyb3IgPSByLm9udGltZW91dCA9IG8oXCJlcnJvclwiKSwgdm9pZCAwICE9PSByLm9uYWJvcnQgPyByLm9uYWJvcnQgPSBhIDogci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICA0ID09PSByLnJlYWR5U3RhdGUgJiYgQy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgbyAmJiBhKCk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9LCBvID0gbyhcImFib3J0XCIpO1xuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIHIuc2VuZChpLmhhc0NvbnRlbnQgJiYgaS5kYXRhIHx8IG51bGwpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgIGlmIChvKSB0aHJvdyBlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBvICYmIG8oKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICB9KSwgUy5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG5cdCAgICBlLmNyb3NzRG9tYWluICYmIChlLmNvbnRlbnRzLnNjcmlwdCA9ICExKTtcblx0ICB9KSwgUy5hamF4U2V0dXAoe1xuXHQgICAgYWNjZXB0czoge1xuXHQgICAgICBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHQgICAgfSxcblx0ICAgIGNvbnRlbnRzOiB7XG5cdCAgICAgIHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdCAgICB9LFxuXHQgICAgY29udmVydGVyczoge1xuXHQgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIFMuZ2xvYmFsRXZhbChlKSwgZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pLCBTLmFqYXhQcmVmaWx0ZXIoXCJzY3JpcHRcIiwgZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZvaWQgMCA9PT0gZS5jYWNoZSAmJiAoZS5jYWNoZSA9ICExKSwgZS5jcm9zc0RvbWFpbiAmJiAoZS50eXBlID0gXCJHRVRcIik7XG5cdCAgfSksIFMuYWpheFRyYW5zcG9ydChcInNjcmlwdFwiLCBmdW5jdGlvbiAobikge1xuXHQgICAgdmFyIHIsIGk7XG5cdCAgICBpZiAobi5jcm9zc0RvbWFpbiB8fCBuLnNjcmlwdEF0dHJzKSByZXR1cm4ge1xuXHQgICAgICBzZW5kOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIHIgPSBTKFwiPHNjcmlwdD5cIikuYXR0cihuLnNjcmlwdEF0dHJzIHx8IHt9KS5wcm9wKHtcblx0ICAgICAgICAgIGNoYXJzZXQ6IG4uc2NyaXB0Q2hhcnNldCxcblx0ICAgICAgICAgIHNyYzogbi51cmxcblx0ICAgICAgICB9KS5vbihcImxvYWQgZXJyb3JcIiwgaSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByLnJlbW92ZSgpLCBpID0gbnVsbCwgZSAmJiB0KFwiZXJyb3JcIiA9PT0gZS50eXBlID8gNDA0IDogMjAwLCBlLnR5cGUpO1xuXHQgICAgICAgIH0pLCBFLmhlYWQuYXBwZW5kQ2hpbGQoclswXSk7XG5cdCAgICAgIH0sXG5cdCAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaSAmJiBpKCk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfSk7XG5cblx0ICB2YXIgX3QsXG5cdCAgICAgIHp0ID0gW10sXG5cdCAgICAgIFV0ID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuXHQgIFMuYWpheFNldHVwKHtcblx0ICAgIGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdCAgICBqc29ucENhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBlID0genQucG9wKCkgfHwgUy5leHBhbmRvICsgXCJfXCIgKyB3dC5ndWlkKys7XG5cdCAgICAgIHJldHVybiB0aGlzW2VdID0gITAsIGU7XG5cdCAgICB9XG5cdCAgfSksIFMuYWpheFByZWZpbHRlcihcImpzb24ganNvbnBcIiwgZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgIHZhciByLFxuXHQgICAgICAgIGksXG5cdCAgICAgICAgbyxcblx0ICAgICAgICBhID0gITEgIT09IGUuanNvbnAgJiYgKFV0LnRlc3QoZS51cmwpID8gXCJ1cmxcIiA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUuZGF0YSAmJiAwID09PSAoZS5jb250ZW50VHlwZSB8fCBcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIFV0LnRlc3QoZS5kYXRhKSAmJiBcImRhdGFcIik7XG5cdCAgICBpZiAoYSB8fCBcImpzb25wXCIgPT09IGUuZGF0YVR5cGVzWzBdKSByZXR1cm4gciA9IGUuanNvbnBDYWxsYmFjayA9IG0oZS5qc29ucENhbGxiYWNrKSA/IGUuanNvbnBDYWxsYmFjaygpIDogZS5qc29ucENhbGxiYWNrLCBhID8gZVthXSA9IGVbYV0ucmVwbGFjZShVdCwgXCIkMVwiICsgcikgOiAhMSAhPT0gZS5qc29ucCAmJiAoZS51cmwgKz0gKFR0LnRlc3QoZS51cmwpID8gXCImXCIgOiBcIj9cIikgKyBlLmpzb25wICsgXCI9XCIgKyByKSwgZS5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBvIHx8IFMuZXJyb3IociArIFwiIHdhcyBub3QgY2FsbGVkXCIpLCBvWzBdO1xuXHQgICAgfSwgZS5kYXRhVHlwZXNbMF0gPSBcImpzb25cIiwgaSA9IENbcl0sIENbcl0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIG8gPSBhcmd1bWVudHM7XG5cdCAgICB9LCBuLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZvaWQgMCA9PT0gaSA/IFMoQykucmVtb3ZlUHJvcChyKSA6IENbcl0gPSBpLCBlW3JdICYmIChlLmpzb25wQ2FsbGJhY2sgPSB0Lmpzb25wQ2FsbGJhY2ssIHp0LnB1c2gocikpLCBvICYmIG0oaSkgJiYgaShvWzBdKSwgbyA9IGkgPSB2b2lkIDA7XG5cdCAgICB9KSwgXCJzY3JpcHRcIjtcblx0ICB9KSwgeS5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoKF90ID0gRS5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikuYm9keSkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiLCAyID09PSBfdC5jaGlsZE5vZGVzLmxlbmd0aCksIFMucGFyc2VIVE1MID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgIHJldHVybiBcInN0cmluZ1wiICE9IHR5cGVvZiBlID8gW10gOiAoXCJib29sZWFuXCIgPT0gdHlwZW9mIHQgJiYgKG4gPSB0LCB0ID0gITEpLCB0IHx8ICh5LmNyZWF0ZUhUTUxEb2N1bWVudCA/ICgociA9ICh0ID0gRS5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikpLmNyZWF0ZUVsZW1lbnQoXCJiYXNlXCIpKS5ocmVmID0gRS5sb2NhdGlvbi5ocmVmLCB0LmhlYWQuYXBwZW5kQ2hpbGQocikpIDogdCA9IEUpLCBvID0gIW4gJiYgW10sIChpID0gTi5leGVjKGUpKSA/IFt0LmNyZWF0ZUVsZW1lbnQoaVsxXSldIDogKGkgPSB4ZShbZV0sIHQsIG8pLCBvICYmIG8ubGVuZ3RoICYmIFMobykucmVtb3ZlKCksIFMubWVyZ2UoW10sIGkuY2hpbGROb2RlcykpKTtcblx0ICAgIHZhciByLCBpLCBvO1xuXHQgIH0sIFMuZm4ubG9hZCA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICB2YXIgcixcblx0ICAgICAgICBpLFxuXHQgICAgICAgIG8sXG5cdCAgICAgICAgYSA9IHRoaXMsXG5cdCAgICAgICAgcyA9IGUuaW5kZXhPZihcIiBcIik7XG5cdCAgICByZXR1cm4gLTEgPCBzICYmIChyID0gaHQoZS5zbGljZShzKSksIGUgPSBlLnNsaWNlKDAsIHMpKSwgbSh0KSA/IChuID0gdCwgdCA9IHZvaWQgMCkgOiB0ICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgKGkgPSBcIlBPU1RcIiksIDAgPCBhLmxlbmd0aCAmJiBTLmFqYXgoe1xuXHQgICAgICB1cmw6IGUsXG5cdCAgICAgIHR5cGU6IGkgfHwgXCJHRVRcIixcblx0ICAgICAgZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHQgICAgICBkYXRhOiB0XG5cdCAgICB9KS5kb25lKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIG8gPSBhcmd1bWVudHMsIGEuaHRtbChyID8gUyhcIjxkaXY+XCIpLmFwcGVuZChTLnBhcnNlSFRNTChlKSkuZmluZChyKSA6IGUpO1xuXHQgICAgfSkuYWx3YXlzKG4gJiYgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgYS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBuLmFwcGx5KHRoaXMsIG8gfHwgW2UucmVzcG9uc2VUZXh0LCB0LCBlXSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSksIHRoaXM7XG5cdCAgfSwgUy5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiAodCkge1xuXHQgICAgcmV0dXJuIFMuZ3JlcChTLnRpbWVycywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIHQgPT09IGUuZWxlbTtcblx0ICAgIH0pLmxlbmd0aDtcblx0ICB9LCBTLm9mZnNldCA9IHtcblx0ICAgIHNldE9mZnNldDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgdmFyIHIsXG5cdCAgICAgICAgICBpLFxuXHQgICAgICAgICAgbyxcblx0ICAgICAgICAgIGEsXG5cdCAgICAgICAgICBzLFxuXHQgICAgICAgICAgdSxcblx0ICAgICAgICAgIGwgPSBTLmNzcyhlLCBcInBvc2l0aW9uXCIpLFxuXHQgICAgICAgICAgYyA9IFMoZSksXG5cdCAgICAgICAgICBmID0ge307XG5cdCAgICAgIFwic3RhdGljXCIgPT09IGwgJiYgKGUuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCIpLCBzID0gYy5vZmZzZXQoKSwgbyA9IFMuY3NzKGUsIFwidG9wXCIpLCB1ID0gUy5jc3MoZSwgXCJsZWZ0XCIpLCAoXCJhYnNvbHV0ZVwiID09PSBsIHx8IFwiZml4ZWRcIiA9PT0gbCkgJiYgLTEgPCAobyArIHUpLmluZGV4T2YoXCJhdXRvXCIpID8gKGEgPSAociA9IGMucG9zaXRpb24oKSkudG9wLCBpID0gci5sZWZ0KSA6IChhID0gcGFyc2VGbG9hdChvKSB8fCAwLCBpID0gcGFyc2VGbG9hdCh1KSB8fCAwKSwgbSh0KSAmJiAodCA9IHQuY2FsbChlLCBuLCBTLmV4dGVuZCh7fSwgcykpKSwgbnVsbCAhPSB0LnRvcCAmJiAoZi50b3AgPSB0LnRvcCAtIHMudG9wICsgYSksIG51bGwgIT0gdC5sZWZ0ICYmIChmLmxlZnQgPSB0LmxlZnQgLSBzLmxlZnQgKyBpKSwgXCJ1c2luZ1wiIGluIHQgPyB0LnVzaW5nLmNhbGwoZSwgZikgOiBjLmNzcyhmKTtcblx0ICAgIH1cblx0ICB9LCBTLmZuLmV4dGVuZCh7XG5cdCAgICBvZmZzZXQ6IGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdm9pZCAwID09PSB0ID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIFMub2Zmc2V0LnNldE9mZnNldCh0aGlzLCB0LCBlKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHZhciBlLFxuXHQgICAgICAgICAgbixcblx0ICAgICAgICAgIHIgPSB0aGlzWzBdO1xuXHQgICAgICByZXR1cm4gciA/IHIuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPyAoZSA9IHIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSByLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcsIHtcblx0ICAgICAgICB0b3A6IGUudG9wICsgbi5wYWdlWU9mZnNldCxcblx0ICAgICAgICBsZWZ0OiBlLmxlZnQgKyBuLnBhZ2VYT2Zmc2V0XG5cdCAgICAgIH0pIDoge1xuXHQgICAgICAgIHRvcDogMCxcblx0ICAgICAgICBsZWZ0OiAwXG5cdCAgICAgIH0gOiB2b2lkIDA7XG5cdCAgICB9LFxuXHQgICAgcG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHRoaXNbMF0pIHtcblx0ICAgICAgICB2YXIgZSxcblx0ICAgICAgICAgICAgdCxcblx0ICAgICAgICAgICAgbixcblx0ICAgICAgICAgICAgciA9IHRoaXNbMF0sXG5cdCAgICAgICAgICAgIGkgPSB7XG5cdCAgICAgICAgICB0b3A6IDAsXG5cdCAgICAgICAgICBsZWZ0OiAwXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAoXCJmaXhlZFwiID09PSBTLmNzcyhyLCBcInBvc2l0aW9uXCIpKSB0ID0gci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtlbHNlIHtcblx0ICAgICAgICAgIHQgPSB0aGlzLm9mZnNldCgpLCBuID0gci5vd25lckRvY3VtZW50LCBlID0gci5vZmZzZXRQYXJlbnQgfHwgbi5kb2N1bWVudEVsZW1lbnQ7XG5cblx0ICAgICAgICAgIHdoaWxlIChlICYmIChlID09PSBuLmJvZHkgfHwgZSA9PT0gbi5kb2N1bWVudEVsZW1lbnQpICYmIFwic3RhdGljXCIgPT09IFMuY3NzKGUsIFwicG9zaXRpb25cIikpIGUgPSBlLnBhcmVudE5vZGU7XG5cblx0ICAgICAgICAgIGUgJiYgZSAhPT0gciAmJiAxID09PSBlLm5vZGVUeXBlICYmICgoaSA9IFMoZSkub2Zmc2V0KCkpLnRvcCArPSBTLmNzcyhlLCBcImJvcmRlclRvcFdpZHRoXCIsICEwKSwgaS5sZWZ0ICs9IFMuY3NzKGUsIFwiYm9yZGVyTGVmdFdpZHRoXCIsICEwKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICB0b3A6IHQudG9wIC0gaS50b3AgLSBTLmNzcyhyLCBcIm1hcmdpblRvcFwiLCAhMCksXG5cdCAgICAgICAgICBsZWZ0OiB0LmxlZnQgLSBpLmxlZnQgLSBTLmNzcyhyLCBcIm1hcmdpbkxlZnRcIiwgITApXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBlID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0ICAgICAgICB3aGlsZSAoZSAmJiBcInN0YXRpY1wiID09PSBTLmNzcyhlLCBcInBvc2l0aW9uXCIpKSBlID0gZS5vZmZzZXRQYXJlbnQ7XG5cblx0ICAgICAgICByZXR1cm4gZSB8fCByZTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSksIFMuZWFjaCh7XG5cdCAgICBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsXG5cdCAgICBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIlxuXHQgIH0sIGZ1bmN0aW9uICh0LCBpKSB7XG5cdCAgICB2YXIgbyA9IFwicGFnZVlPZmZzZXRcIiA9PT0gaTtcblxuXHQgICAgUy5mblt0XSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiAkKHRoaXMsIGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgdmFyIHI7XG5cdCAgICAgICAgaWYgKHgoZSkgPyByID0gZSA6IDkgPT09IGUubm9kZVR5cGUgJiYgKHIgPSBlLmRlZmF1bHRWaWV3KSwgdm9pZCAwID09PSBuKSByZXR1cm4gciA/IHJbaV0gOiBlW3RdO1xuXHQgICAgICAgIHIgPyByLnNjcm9sbFRvKG8gPyByLnBhZ2VYT2Zmc2V0IDogbiwgbyA/IG4gOiByLnBhZ2VZT2Zmc2V0KSA6IGVbdF0gPSBuO1xuXHQgICAgICB9LCB0LCBlLCBhcmd1bWVudHMubGVuZ3RoKTtcblx0ICAgIH07XG5cdCAgfSksIFMuZWFjaChbXCJ0b3BcIiwgXCJsZWZ0XCJdLCBmdW5jdGlvbiAoZSwgbikge1xuXHQgICAgUy5jc3NIb29rc1tuXSA9IEZlKHkucGl4ZWxQb3NpdGlvbiwgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgaWYgKHQpIHJldHVybiB0ID0gV2UoZSwgbiksIFBlLnRlc3QodCkgPyBTKGUpLnBvc2l0aW9uKClbbl0gKyBcInB4XCIgOiB0O1xuXHQgICAgfSk7XG5cdCAgfSksIFMuZWFjaCh7XG5cdCAgICBIZWlnaHQ6IFwiaGVpZ2h0XCIsXG5cdCAgICBXaWR0aDogXCJ3aWR0aFwiXG5cdCAgfSwgZnVuY3Rpb24gKGEsIHMpIHtcblx0ICAgIFMuZWFjaCh7XG5cdCAgICAgIHBhZGRpbmc6IFwiaW5uZXJcIiArIGEsXG5cdCAgICAgIGNvbnRlbnQ6IHMsXG5cdCAgICAgIFwiXCI6IFwib3V0ZXJcIiArIGFcblx0ICAgIH0sIGZ1bmN0aW9uIChyLCBvKSB7XG5cdCAgICAgIFMuZm5bb10gPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCAmJiAociB8fCBcImJvb2xlYW5cIiAhPSB0eXBlb2YgZSksXG5cdCAgICAgICAgICAgIGkgPSByIHx8ICghMCA9PT0gZSB8fCAhMCA9PT0gdCA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiKTtcblx0ICAgICAgICByZXR1cm4gJCh0aGlzLCBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICAgICAgdmFyIHI7XG5cdCAgICAgICAgICByZXR1cm4geChlKSA/IDAgPT09IG8uaW5kZXhPZihcIm91dGVyXCIpID8gZVtcImlubmVyXCIgKyBhXSA6IGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIgKyBhXSA6IDkgPT09IGUubm9kZVR5cGUgPyAociA9IGUuZG9jdW1lbnRFbGVtZW50LCBNYXRoLm1heChlLmJvZHlbXCJzY3JvbGxcIiArIGFdLCByW1wic2Nyb2xsXCIgKyBhXSwgZS5ib2R5W1wib2Zmc2V0XCIgKyBhXSwgcltcIm9mZnNldFwiICsgYV0sIHJbXCJjbGllbnRcIiArIGFdKSkgOiB2b2lkIDAgPT09IG4gPyBTLmNzcyhlLCB0LCBpKSA6IFMuc3R5bGUoZSwgdCwgbiwgaSk7XG5cdCAgICAgICAgfSwgcywgbiA/IGUgOiB2b2lkIDAsIG4pO1xuXHQgICAgICB9O1xuXHQgICAgfSk7XG5cdCAgfSksIFMuZWFjaChbXCJhamF4U3RhcnRcIiwgXCJhamF4U3RvcFwiLCBcImFqYXhDb21wbGV0ZVwiLCBcImFqYXhFcnJvclwiLCBcImFqYXhTdWNjZXNzXCIsIFwiYWpheFNlbmRcIl0sIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICBTLmZuW3RdID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMub24odCwgZSk7XG5cdCAgICB9O1xuXHQgIH0pLCBTLmZuLmV4dGVuZCh7XG5cdCAgICBiaW5kOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gdGhpcy5vbihlLCBudWxsLCB0LCBuKTtcblx0ICAgIH0sXG5cdCAgICB1bmJpbmQ6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm9mZihlLCBudWxsLCB0KTtcblx0ICAgIH0sXG5cdCAgICBkZWxlZ2F0ZTogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMub24odCwgZSwgbiwgcik7XG5cdCAgICB9LFxuXHQgICAgdW5kZWxlZ2F0ZTogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgcmV0dXJuIDEgPT09IGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLm9mZihlLCBcIioqXCIpIDogdGhpcy5vZmYodCwgZSB8fCBcIioqXCIsIG4pO1xuXHQgICAgfSxcblx0ICAgIGhvdmVyOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGUpLm1vdXNlbGVhdmUodCB8fCBlKTtcblx0ICAgIH1cblx0ICB9KSwgUy5lYWNoKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24gKGUsIG4pIHtcblx0ICAgIFMuZm5bbl0gPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gMCA8IGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLm9uKG4sIG51bGwsIGUsIHQpIDogdGhpcy50cmlnZ2VyKG4pO1xuXHQgICAgfTtcblx0ICB9KTtcblx0ICB2YXIgWHQgPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cdCAgUy5wcm94eSA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICB2YXIgbiwgciwgaTtcblx0ICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIChuID0gZVt0XSwgdCA9IGUsIGUgPSBuKSwgbShlKSkgcmV0dXJuIHIgPSBzLmNhbGwoYXJndW1lbnRzLCAyKSwgKGkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBlLmFwcGx5KHQgfHwgdGhpcywgci5jb25jYXQocy5jYWxsKGFyZ3VtZW50cykpKTtcblx0ICAgIH0pLmd1aWQgPSBlLmd1aWQgPSBlLmd1aWQgfHwgUy5ndWlkKyssIGk7XG5cdCAgfSwgUy5ob2xkUmVhZHkgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgZSA/IFMucmVhZHlXYWl0KysgOiBTLnJlYWR5KCEwKTtcblx0ICB9LCBTLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5LCBTLnBhcnNlSlNPTiA9IEpTT04ucGFyc2UsIFMubm9kZU5hbWUgPSBBLCBTLmlzRnVuY3Rpb24gPSBtLCBTLmlzV2luZG93ID0geCwgUy5jYW1lbENhc2UgPSBYLCBTLnR5cGUgPSB3LCBTLm5vdyA9IERhdGUubm93LCBTLmlzTnVtZXJpYyA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgdCA9IFMudHlwZShlKTtcblx0ICAgIHJldHVybiAoXCJudW1iZXJcIiA9PT0gdCB8fCBcInN0cmluZ1wiID09PSB0KSAmJiAhaXNOYU4oZSAtIHBhcnNlRmxvYXQoZSkpO1xuXHQgIH0sIFMudHJpbSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICByZXR1cm4gbnVsbCA9PSBlID8gXCJcIiA6IChlICsgXCJcIikucmVwbGFjZShYdCwgXCJcIik7XG5cdCAgfTtcblx0ICB2YXIgVnQgPSBDLmpRdWVyeSxcblx0ICAgICAgR3QgPSBDLiQ7XG5cdCAgcmV0dXJuIFMubm9Db25mbGljdCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICByZXR1cm4gQy4kID09PSBTICYmIChDLiQgPSBHdCksIGUgJiYgQy5qUXVlcnkgPT09IFMgJiYgKEMualF1ZXJ5ID0gVnQpLCBTO1xuXHQgIH0sIFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGUgJiYgKEMualF1ZXJ5ID0gQy4kID0gUyksIFM7XG5cdH0pO1xuXHR9KTtcblxuXHRyZXR1cm4ganF1ZXJ5M182XzBfbWluO1xuXG59KSk7XG4iXSwiZmlsZSI6ImpxdWVyeS0zLjYuMC5taW4uanMifQ==
