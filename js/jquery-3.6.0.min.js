(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define('jquery360Min', factory) :
	(global = global || self, global.jquery360Min = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var jquery3_6_0_min = createCommonjsModule(function (module) {
	/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */
	!function (e, t) {

	   module.exports = e.document ? t(e, !0) : function (e) {
	    if (!e.document) throw new Error("jQuery requires a window with a document");
	    return t(e);
	  } ;
	}("undefined" != typeof window ? window : commonjsGlobal, function (C, e) {

	  var t = [],
	      r = Object.getPrototypeOf,
	      s = t.slice,
	      g = t.flat ? function (e) {
	    return t.flat.call(e);
	  } : function (e) {
	    return t.concat.apply([], e);
	  },
	      u = t.push,
	      i = t.indexOf,
	      n = {},
	      o = n.toString,
	      v = n.hasOwnProperty,
	      a = v.toString,
	      l = a.call(Object),
	      y = {},
	      m = function (e) {
	    return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item;
	  },
	      x = function (e) {
	    return null != e && e === e.window;
	  },
	      E = C.document,
	      c = {
	    type: !0,
	    src: !0,
	    nonce: !0,
	    noModule: !0
	  };

	  function b(e, t, n) {
	    var r,
	        i,
	        o = (n = n || E).createElement("script");
	    if (o.text = e, t) for (r in c) (i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i);
	    n.head.appendChild(o).parentNode.removeChild(o);
	  }

	  function w(e) {
	    return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e;
	  }

	  var f = "3.6.0",
	      S = function (e, t) {
	    return new S.fn.init(e, t);
	  };

	  function p(e) {
	    var t = !!e && "length" in e && e.length,
	        n = w(e);
	    return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e);
	  }

	  S.fn = S.prototype = {
	    jquery: f,
	    constructor: S,
	    length: 0,
	    toArray: function () {
	      return s.call(this);
	    },
	    get: function (e) {
	      return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e];
	    },
	    pushStack: function (e) {
	      var t = S.merge(this.constructor(), e);
	      return t.prevObject = this, t;
	    },
	    each: function (e) {
	      return S.each(this, e);
	    },
	    map: function (n) {
	      return this.pushStack(S.map(this, function (e, t) {
	        return n.call(e, t, e);
	      }));
	    },
	    slice: function () {
	      return this.pushStack(s.apply(this, arguments));
	    },
	    first: function () {
	      return this.eq(0);
	    },
	    last: function () {
	      return this.eq(-1);
	    },
	    even: function () {
	      return this.pushStack(S.grep(this, function (e, t) {
	        return (t + 1) % 2;
	      }));
	    },
	    odd: function () {
	      return this.pushStack(S.grep(this, function (e, t) {
	        return t % 2;
	      }));
	    },
	    eq: function (e) {
	      var t = this.length,
	          n = +e + (e < 0 ? t : 0);
	      return this.pushStack(0 <= n && n < t ? [this[n]] : []);
	    },
	    end: function () {
	      return this.prevObject || this.constructor();
	    },
	    push: u,
	    sort: t.sort,
	    splice: t.splice
	  }, S.extend = S.fn.extend = function () {
	    var e,
	        t,
	        n,
	        r,
	        i,
	        o,
	        a = arguments[0] || {},
	        s = 1,
	        u = arguments.length,
	        l = !1;

	    for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++) if (null != (e = arguments[s])) for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r));

	    return a;
	  }, S.extend({
	    expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
	    isReady: !0,
	    error: function (e) {
	      throw new Error(e);
	    },
	    noop: function () {},
	    isPlainObject: function (e) {
	      var t, n;
	      return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof (n = v.call(t, "constructor") && t.constructor) && a.call(n) === l);
	    },
	    isEmptyObject: function (e) {
	      var t;

	      for (t in e) return !1;

	      return !0;
	    },
	    globalEval: function (e, t, n) {
	      b(e, {
	        nonce: t && t.nonce
	      }, n);
	    },
	    each: function (e, t) {
	      var n,
	          r = 0;

	      if (p(e)) {
	        for (n = e.length; r < n; r++) if (!1 === t.call(e[r], r, e[r])) break;
	      } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break;

	      return e;
	    },
	    makeArray: function (e, t) {
	      var n = t || [];
	      return null != e && (p(Object(e)) ? S.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n;
	    },
	    inArray: function (e, t, n) {
	      return null == t ? -1 : i.call(t, e, n);
	    },
	    merge: function (e, t) {
	      for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r];

	      return e.length = i, e;
	    },
	    grep: function (e, t, n) {
	      for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i) !== a && r.push(e[i]);

	      return r;
	    },
	    map: function (e, t, n) {
	      var r,
	          i,
	          o = 0,
	          a = [];
	      if (p(e)) for (r = e.length; o < r; o++) null != (i = t(e[o], o, n)) && a.push(i);else for (o in e) null != (i = t(e[o], o, n)) && a.push(i);
	      return g(a);
	    },
	    guid: 1,
	    support: y
	  }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {
	    n["[object " + t + "]"] = t.toLowerCase();
	  });

	  var d = function (n) {
	    var e,
	        d,
	        b,
	        o,
	        i,
	        h,
	        f,
	        g,
	        w,
	        u,
	        l,
	        T,
	        C,
	        a,
	        E,
	        v,
	        s,
	        c,
	        y,
	        S = "sizzle" + 1 * new Date(),
	        p = n.document,
	        k = 0,
	        r = 0,
	        m = ue(),
	        x = ue(),
	        A = ue(),
	        N = ue(),
	        j = function (e, t) {
	      return e === t && (l = !0), 0;
	    },
	        D = {}.hasOwnProperty,
	        t = [],
	        q = t.pop,
	        L = t.push,
	        H = t.push,
	        O = t.slice,
	        P = function (e, t) {
	      for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;

	      return -1;
	    },
	        R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	        M = "[\\x20\\t\\r\\n\\f]",
	        I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
	        W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]",
	        F = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)",
	        B = new RegExp(M + "+", "g"),
	        $ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
	        _ = new RegExp("^" + M + "*," + M + "*"),
	        z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
	        U = new RegExp(M + "|>"),
	        X = new RegExp(F),
	        V = new RegExp("^" + I + "$"),
	        G = {
	      ID: new RegExp("^#(" + I + ")"),
	      CLASS: new RegExp("^\\.(" + I + ")"),
	      TAG: new RegExp("^(" + I + "|[*])"),
	      ATTR: new RegExp("^" + W),
	      PSEUDO: new RegExp("^" + F),
	      CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"),
	      bool: new RegExp("^(?:" + R + ")$", "i"),
	      needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i")
	    },
	        Y = /HTML$/i,
	        Q = /^(?:input|select|textarea|button)$/i,
	        J = /^h\d$/i,
	        K = /^[^{]+\{\s*\[native \w/,
	        Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	        ee = /[+~]/,
	        te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"),
	        ne = function (e, t) {
	      var n = "0x" + e.slice(1) - 65536;
	      return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320));
	    },
	        re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	        ie = function (e, t) {
	      return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e;
	    },
	        oe = function () {
	      T();
	    },
	        ae = be(function (e) {
	      return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase();
	    }, {
	      dir: "parentNode",
	      next: "legend"
	    });

	    try {
	      H.apply(t = O.call(p.childNodes), p.childNodes), t[p.childNodes.length].nodeType;
	    } catch (e) {
	      H = {
	        apply: t.length ? function (e, t) {
	          L.apply(e, O.call(t));
	        } : function (e, t) {
	          var n = e.length,
	              r = 0;

	          while (e[n++] = t[r++]);

	          e.length = n - 1;
	        }
	      };
	    }

	    function se(t, e, n, r) {
	      var i,
	          o,
	          a,
	          s,
	          u,
	          l,
	          c,
	          f = e && e.ownerDocument,
	          p = e ? e.nodeType : 9;
	      if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n;

	      if (!r && (T(e), e = e || C, E)) {
	        if (11 !== p && (u = Z.exec(t))) if (i = u[1]) {
	          if (9 === p) {
	            if (!(a = e.getElementById(i))) return n;
	            if (a.id === i) return n.push(a), n;
	          } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n;
	        } else {
	          if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n;
	          if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n;
	        }

	        if (d.qsa && !N[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) {
	          if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) {
	            (f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = S)), o = (l = h(t)).length;

	            while (o--) l[o] = (s ? "#" + s : ":scope") + " " + xe(l[o]);

	            c = l.join(",");
	          }

	          try {
	            return H.apply(n, f.querySelectorAll(c)), n;
	          } catch (e) {
	            N(t, !0);
	          } finally {
	            s === S && e.removeAttribute("id");
	          }
	        }
	      }

	      return g(t.replace($, "$1"), e, n, r);
	    }

	    function ue() {
	      var r = [];
	      return function e(t, n) {
	        return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n;
	      };
	    }

	    function le(e) {
	      return e[S] = !0, e;
	    }

	    function ce(e) {
	      var t = C.createElement("fieldset");

	      try {
	        return !!e(t);
	      } catch (e) {
	        return !1;
	      } finally {
	        t.parentNode && t.parentNode.removeChild(t), t = null;
	      }
	    }

	    function fe(e, t) {
	      var n = e.split("|"),
	          r = n.length;

	      while (r--) b.attrHandle[n[r]] = t;
	    }

	    function pe(e, t) {
	      var n = t && e,
	          r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
	      if (r) return r;
	      if (n) while (n = n.nextSibling) if (n === t) return -1;
	      return e ? 1 : -1;
	    }

	    function de(t) {
	      return function (e) {
	        return "input" === e.nodeName.toLowerCase() && e.type === t;
	      };
	    }

	    function he(n) {
	      return function (e) {
	        var t = e.nodeName.toLowerCase();
	        return ("input" === t || "button" === t) && e.type === n;
	      };
	    }

	    function ge(t) {
	      return function (e) {
	        return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t;
	      };
	    }

	    function ve(a) {
	      return le(function (o) {
	        return o = +o, le(function (e, t) {
	          var n,
	              r = a([], e.length, o),
	              i = r.length;

	          while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n]));
	        });
	      });
	    }

	    function ye(e) {
	      return e && "undefined" != typeof e.getElementsByTagName && e;
	    }

	    for (e in d = se.support = {}, i = se.isXML = function (e) {
	      var t = e && e.namespaceURI,
	          n = e && (e.ownerDocument || e).documentElement;
	      return !Y.test(t || n && n.nodeName || "HTML");
	    }, T = se.setDocument = function (e) {
	      var t,
	          n,
	          r = e ? e.ownerDocument || e : p;
	      return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.scope = ce(function (e) {
	        return a.appendChild(e).appendChild(C.createElement("div")), "undefined" != typeof e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length;
	      }), d.attributes = ce(function (e) {
	        return e.className = "i", !e.getAttribute("className");
	      }), d.getElementsByTagName = ce(function (e) {
	        return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length;
	      }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function (e) {
	        return a.appendChild(e).id = S, !C.getElementsByName || !C.getElementsByName(S).length;
	      }), d.getById ? (b.filter.ID = function (e) {
	        var t = e.replace(te, ne);
	        return function (e) {
	          return e.getAttribute("id") === t;
	        };
	      }, b.find.ID = function (e, t) {
	        if ("undefined" != typeof t.getElementById && E) {
	          var n = t.getElementById(e);
	          return n ? [n] : [];
	        }
	      }) : (b.filter.ID = function (e) {
	        var n = e.replace(te, ne);
	        return function (e) {
	          var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
	          return t && t.value === n;
	        };
	      }, b.find.ID = function (e, t) {
	        if ("undefined" != typeof t.getElementById && E) {
	          var n,
	              r,
	              i,
	              o = t.getElementById(e);

	          if (o) {
	            if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
	            i = t.getElementsByName(e), r = 0;

	            while (o = i[r++]) if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
	          }

	          return [];
	        }
	      }), b.find.TAG = d.getElementsByTagName ? function (e, t) {
	        return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0;
	      } : function (e, t) {
	        var n,
	            r = [],
	            i = 0,
	            o = t.getElementsByTagName(e);

	        if ("*" === e) {
	          while (n = o[i++]) 1 === n.nodeType && r.push(n);

	          return r;
	        }

	        return o;
	      }, b.find.CLASS = d.getElementsByClassName && function (e, t) {
	        if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e);
	      }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function (e) {
	        var t;
	        a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + S + "-]").length || v.push("~="), (t = C.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + S + "+*").length || v.push(".#.+[+~]"), e.querySelectorAll("\\\f"), v.push("[\\r\\n\\f]");
	      }), ce(function (e) {
	        e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
	        var t = C.createElement("input");
	        t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:");
	      })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) {
	        d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", F);
	      }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function (e, t) {
	        var n = 9 === e.nodeType ? e.documentElement : e,
	            r = t && t.parentNode;
	        return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
	      } : function (e, t) {
	        if (t) while (t = t.parentNode) if (t === e) return !0;
	        return !1;
	      }, j = t ? function (e, t) {
	        if (e === t) return l = !0, 0;
	        var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
	        return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1);
	      } : function (e, t) {
	        if (e === t) return l = !0, 0;
	        var n,
	            r = 0,
	            i = e.parentNode,
	            o = t.parentNode,
	            a = [e],
	            s = [t];
	        if (!i || !o) return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0;
	        if (i === o) return pe(e, t);
	        n = e;

	        while (n = n.parentNode) a.unshift(n);

	        n = t;

	        while (n = n.parentNode) s.unshift(n);

	        while (a[r] === s[r]) r++;

	        return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ? 1 : 0;
	      }), C;
	    }, se.matches = function (e, t) {
	      return se(e, null, null, t);
	    }, se.matchesSelector = function (e, t) {
	      if (T(e), d.matchesSelector && E && !N[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try {
	        var n = c.call(e, t);
	        if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n;
	      } catch (e) {
	        N(t, !0);
	      }
	      return 0 < se(t, C, null, [e]).length;
	    }, se.contains = function (e, t) {
	      return (e.ownerDocument || e) != C && T(e), y(e, t);
	    }, se.attr = function (e, t) {
	      (e.ownerDocument || e) != C && T(e);
	      var n = b.attrHandle[t.toLowerCase()],
	          r = n && D.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0;
	      return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
	    }, se.escape = function (e) {
	      return (e + "").replace(re, ie);
	    }, se.error = function (e) {
	      throw new Error("Syntax error, unrecognized expression: " + e);
	    }, se.uniqueSort = function (e) {
	      var t,
	          n = [],
	          r = 0,
	          i = 0;

	      if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(j), l) {
	        while (t = e[i++]) t === e[i] && (r = n.push(i));

	        while (r--) e.splice(n[r], 1);
	      }

	      return u = null, e;
	    }, o = se.getText = function (e) {
	      var t,
	          n = "",
	          r = 0,
	          i = e.nodeType;

	      if (i) {
	        if (1 === i || 9 === i || 11 === i) {
	          if ("string" == typeof e.textContent) return e.textContent;

	          for (e = e.firstChild; e; e = e.nextSibling) n += o(e);
	        } else if (3 === i || 4 === i) return e.nodeValue;
	      } else while (t = e[r++]) n += o(t);

	      return n;
	    }, (b = se.selectors = {
	      cacheLength: 50,
	      createPseudo: le,
	      match: G,
	      attrHandle: {},
	      find: {},
	      relative: {
	        ">": {
	          dir: "parentNode",
	          first: !0
	        },
	        " ": {
	          dir: "parentNode"
	        },
	        "+": {
	          dir: "previousSibling",
	          first: !0
	        },
	        "~": {
	          dir: "previousSibling"
	        }
	      },
	      preFilter: {
	        ATTR: function (e) {
	          return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);
	        },
	        CHILD: function (e) {
	          return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e;
	        },
	        PSEUDO: function (e) {
	          var t,
	              n = !e[6] && e[2];
	          return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3));
	        }
	      },
	      filter: {
	        TAG: function (e) {
	          var t = e.replace(te, ne).toLowerCase();
	          return "*" === e ? function () {
	            return !0;
	          } : function (e) {
	            return e.nodeName && e.nodeName.toLowerCase() === t;
	          };
	        },
	        CLASS: function (e) {
	          var t = m[e + " "];
	          return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && m(e, function (e) {
	            return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "");
	          });
	        },
	        ATTR: function (n, r, i) {
	          return function (e) {
	            var t = se.attr(e, n);
	            return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-"));
	          };
	        },
	        CHILD: function (h, e, t, g, v) {
	          var y = "nth" !== h.slice(0, 3),
	              m = "last" !== h.slice(-4),
	              x = "of-type" === e;
	          return 1 === g && 0 === v ? function (e) {
	            return !!e.parentNode;
	          } : function (e, t, n) {
	            var r,
	                i,
	                o,
	                a,
	                s,
	                u,
	                l = y !== m ? "nextSibling" : "previousSibling",
	                c = e.parentNode,
	                f = x && e.nodeName.toLowerCase(),
	                p = !n && !x,
	                d = !1;

	            if (c) {
	              if (y) {
	                while (l) {
	                  a = e;

	                  while (a = a[l]) if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1;

	                  u = l = "only" === h && !u && "nextSibling";
	                }

	                return !0;
	              }

	              if (u = [m ? c.firstChild : c.lastChild], m && p) {
	                d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2], a = s && c.childNodes[s];

	                while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if (1 === a.nodeType && ++d && a === e) {
	                  i[h] = [k, s, d];
	                  break;
	                }
	              } else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d) while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [k, d]), a === e)) break;

	              return (d -= v) === g || d % g == 0 && 0 <= d / g;
	            }
	          };
	        },
	        PSEUDO: function (e, o) {
	          var t,
	              a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
	          return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function (e, t) {
	            var n,
	                r = a(e, o),
	                i = r.length;

	            while (i--) e[n = P(e, r[i])] = !(t[n] = r[i]);
	          }) : function (e) {
	            return a(e, 0, t);
	          }) : a;
	        }
	      },
	      pseudos: {
	        not: le(function (e) {
	          var r = [],
	              i = [],
	              s = f(e.replace($, "$1"));
	          return s[S] ? le(function (e, t, n, r) {
	            var i,
	                o = s(e, null, r, []),
	                a = e.length;

	            while (a--) (i = o[a]) && (e[a] = !(t[a] = i));
	          }) : function (e, t, n) {
	            return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop();
	          };
	        }),
	        has: le(function (t) {
	          return function (e) {
	            return 0 < se(t, e).length;
	          };
	        }),
	        contains: le(function (t) {
	          return t = t.replace(te, ne), function (e) {
	            return -1 < (e.textContent || o(e)).indexOf(t);
	          };
	        }),
	        lang: le(function (n) {
	          return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(), function (e) {
	            var t;

	            do {
	              if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-");
	            } while ((e = e.parentNode) && 1 === e.nodeType);

	            return !1;
	          };
	        }),
	        target: function (e) {
	          var t = n.location && n.location.hash;
	          return t && t.slice(1) === e.id;
	        },
	        root: function (e) {
	          return e === a;
	        },
	        focus: function (e) {
	          return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
	        },
	        enabled: ge(!1),
	        disabled: ge(!0),
	        checked: function (e) {
	          var t = e.nodeName.toLowerCase();
	          return "input" === t && !!e.checked || "option" === t && !!e.selected;
	        },
	        selected: function (e) {
	          return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected;
	        },
	        empty: function (e) {
	          for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;

	          return !0;
	        },
	        parent: function (e) {
	          return !b.pseudos.empty(e);
	        },
	        header: function (e) {
	          return J.test(e.nodeName);
	        },
	        input: function (e) {
	          return Q.test(e.nodeName);
	        },
	        button: function (e) {
	          var t = e.nodeName.toLowerCase();
	          return "input" === t && "button" === e.type || "button" === t;
	        },
	        text: function (e) {
	          var t;
	          return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());
	        },
	        first: ve(function () {
	          return [0];
	        }),
	        last: ve(function (e, t) {
	          return [t - 1];
	        }),
	        eq: ve(function (e, t, n) {
	          return [n < 0 ? n + t : n];
	        }),
	        even: ve(function (e, t) {
	          for (var n = 0; n < t; n += 2) e.push(n);

	          return e;
	        }),
	        odd: ve(function (e, t) {
	          for (var n = 1; n < t; n += 2) e.push(n);

	          return e;
	        }),
	        lt: ve(function (e, t, n) {
	          for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;) e.push(r);

	          return e;
	        }),
	        gt: ve(function (e, t, n) {
	          for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r);

	          return e;
	        })
	      }
	    }).pseudos.nth = b.pseudos.eq, {
	      radio: !0,
	      checkbox: !0,
	      file: !0,
	      password: !0,
	      image: !0
	    }) b.pseudos[e] = de(e);

	    for (e in {
	      submit: !0,
	      reset: !0
	    }) b.pseudos[e] = he(e);

	    function me() {}

	    function xe(e) {
	      for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;

	      return r;
	    }

	    function be(s, e, t) {
	      var u = e.dir,
	          l = e.next,
	          c = l || u,
	          f = t && "parentNode" === c,
	          p = r++;
	      return e.first ? function (e, t, n) {
	        while (e = e[u]) if (1 === e.nodeType || f) return s(e, t, n);

	        return !1;
	      } : function (e, t, n) {
	        var r,
	            i,
	            o,
	            a = [k, p];

	        if (n) {
	          while (e = e[u]) if ((1 === e.nodeType || f) && s(e, t, n)) return !0;
	        } else while (e = e[u]) if (1 === e.nodeType || f) if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e;else {
	          if ((r = i[c]) && r[0] === k && r[1] === p) return a[2] = r[2];
	          if ((i[c] = a)[2] = s(e, t, n)) return !0;
	        }

	        return !1;
	      };
	    }

	    function we(i) {
	      return 1 < i.length ? function (e, t, n) {
	        var r = i.length;

	        while (r--) if (!i[r](e, t, n)) return !1;

	        return !0;
	      } : i[0];
	    }

	    function Te(e, t, n, r, i) {
	      for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++) (o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));

	      return a;
	    }

	    function Ce(d, h, g, v, y, e) {
	      return v && !v[S] && (v = Ce(v)), y && !y[S] && (y = Ce(y, e)), le(function (e, t, n, r) {
	        var i,
	            o,
	            a,
	            s = [],
	            u = [],
	            l = t.length,
	            c = e || function (e, t, n) {
	          for (var r = 0, i = t.length; r < i; r++) se(e, t[r], n);

	          return n;
	        }(h || "*", n.nodeType ? [n] : n, []),
	            f = !d || !e && h ? c : Te(c, s, d, n, r),
	            p = g ? y || (e ? d : l || v) ? [] : t : f;

	        if (g && g(f, p, n, r), v) {
	          i = Te(p, u), v(i, [], n, r), o = i.length;

	          while (o--) (a = i[o]) && (p[u[o]] = !(f[u[o]] = a));
	        }

	        if (e) {
	          if (y || d) {
	            if (y) {
	              i = [], o = p.length;

	              while (o--) (a = p[o]) && i.push(f[o] = a);

	              y(null, p = [], i, r);
	            }

	            o = p.length;

	            while (o--) (a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a));
	          }
	        } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p);
	      });
	    }

	    function Ee(e) {
	      for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function (e) {
	        return e === i;
	      }, a, !0), l = be(function (e) {
	        return -1 < P(i, e);
	      }, a, !0), c = [function (e, t, n) {
	        var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n));
	        return i = null, r;
	      }]; s < r; s++) if (t = b.relative[e[s].type]) c = [be(we(c), t)];else {
	        if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) {
	          for (n = ++s; n < r; n++) if (b.relative[e[n].type]) break;

	          return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({
	            value: " " === e[s - 2].type ? "*" : ""
	          })).replace($, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e));
	        }

	        c.push(t);
	      }

	      return we(c);
	    }

	    return me.prototype = b.filters = b.pseudos, b.setFilters = new me(), h = se.tokenize = function (e, t) {
	      var n,
	          r,
	          i,
	          o,
	          a,
	          s,
	          u,
	          l = x[e + " "];
	      if (l) return t ? 0 : l.slice(0);
	      a = e, s = [], u = b.preFilter;

	      while (a) {
	        for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({
	          value: n,
	          type: r[0].replace($, " ")
	        }), a = a.slice(n.length)), b.filter) !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({
	          value: n,
	          type: o,
	          matches: r
	        }), a = a.slice(n.length));

	        if (!n) break;
	      }

	      return t ? a.length : a ? se.error(e) : x(e, s).slice(0);
	    }, f = se.compile = function (e, t) {
	      var n,
	          v,
	          y,
	          m,
	          x,
	          r,
	          i = [],
	          o = [],
	          a = A[e + " "];

	      if (!a) {
	        t || (t = h(e)), n = t.length;

	        while (n--) (a = Ee(t[n]))[S] ? i.push(a) : o.push(a);

	        (a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function (e, t, n, r, i) {
	          var o,
	              a,
	              s,
	              u = 0,
	              l = "0",
	              c = e && [],
	              f = [],
	              p = w,
	              d = e || x && b.find.TAG("*", i),
	              h = k += null == p ? 1 : Math.random() || .1,
	              g = d.length;

	          for (i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++) {
	            if (x && o) {
	              a = 0, t || o.ownerDocument == C || (T(o), n = !E);

	              while (s = v[a++]) if (s(o, t || C, n)) {
	                r.push(o);
	                break;
	              }

	              i && (k = h);
	            }

	            m && ((o = !s && o) && u--, e && c.push(o));
	          }

	          if (u += l, m && l !== u) {
	            a = 0;

	            while (s = y[a++]) s(c, f, t, n);

	            if (e) {
	              if (0 < u) while (l--) c[l] || f[l] || (f[l] = q.call(r));
	              f = Te(f);
	            }

	            H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r);
	          }

	          return i && (k = h, w = p), c;
	        }, m ? le(r) : r))).selector = e;
	      }

	      return a;
	    }, g = se.select = function (e, t, n, r) {
	      var i,
	          o,
	          a,
	          s,
	          u,
	          l = "function" == typeof e && e,
	          c = !r && h(e = l.selector || e);

	      if (n = n || [], 1 === c.length) {
	        if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) {
	          if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n;
	          l && (t = t.parentNode), e = e.slice(o.shift().value.length);
	        }

	        i = G.needsContext.test(e) ? 0 : o.length;

	        while (i--) {
	          if (a = o[i], b.relative[s = a.type]) break;

	          if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) {
	            if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n;
	            break;
	          }
	        }
	      }

	      return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n;
	    }, d.sortStable = S.split("").sort(j).join("") === S, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function (e) {
	      return 1 & e.compareDocumentPosition(C.createElement("fieldset"));
	    }), ce(function (e) {
	      return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href");
	    }) || fe("type|href|height|width", function (e, t, n) {
	      if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
	    }), d.attributes && ce(function (e) {
	      return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value");
	    }) || fe("value", function (e, t, n) {
	      if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
	    }), ce(function (e) {
	      return null == e.getAttribute("disabled");
	    }) || fe(R, function (e, t, n) {
	      var r;
	      if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
	    }), se;
	  }(C);

	  S.find = d, S.expr = d.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape;

	  var h = function (e, t, n) {
	    var r = [],
	        i = void 0 !== n;

	    while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) {
	      if (i && S(e).is(n)) break;
	      r.push(e);
	    }

	    return r;
	  },
	      T = function (e, t) {
	    for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);

	    return n;
	  },
	      k = S.expr.match.needsContext;

	  function A(e, t) {
	    return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
	  }

	  var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

	  function j(e, n, r) {
	    return m(n) ? S.grep(e, function (e, t) {
	      return !!n.call(e, t, e) !== r;
	    }) : n.nodeType ? S.grep(e, function (e) {
	      return e === n !== r;
	    }) : "string" != typeof n ? S.grep(e, function (e) {
	      return -1 < i.call(n, e) !== r;
	    }) : S.filter(n, e, r);
	  }

	  S.filter = function (e, t, n) {
	    var r = t[0];
	    return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [r] : [] : S.find.matches(e, S.grep(t, function (e) {
	      return 1 === e.nodeType;
	    }));
	  }, S.fn.extend({
	    find: function (e) {
	      var t,
	          n,
	          r = this.length,
	          i = this;
	      if ("string" != typeof e) return this.pushStack(S(e).filter(function () {
	        for (t = 0; t < r; t++) if (S.contains(i[t], this)) return !0;
	      }));

	      for (n = this.pushStack([]), t = 0; t < r; t++) S.find(e, i[t], n);

	      return 1 < r ? S.uniqueSort(n) : n;
	    },
	    filter: function (e) {
	      return this.pushStack(j(this, e || [], !1));
	    },
	    not: function (e) {
	      return this.pushStack(j(this, e || [], !0));
	    },
	    is: function (e) {
	      return !!j(this, "string" == typeof e && k.test(e) ? S(e) : e || [], !1).length;
	    }
	  });
	  var D,
	      q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
	  (S.fn.init = function (e, t, n) {
	    var r, i;
	    if (!e) return this;

	    if (n = n || D, "string" == typeof e) {
	      if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);

	      if (r[1]) {
	        if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t)) for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
	        return this;
	      }

	      return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this;
	    }

	    return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this);
	  }).prototype = S.fn, D = S(E);
	  var L = /^(?:parents|prev(?:Until|All))/,
	      H = {
	    children: !0,
	    contents: !0,
	    next: !0,
	    prev: !0
	  };

	  function O(e, t) {
	    while ((e = e[t]) && 1 !== e.nodeType);

	    return e;
	  }

	  S.fn.extend({
	    has: function (e) {
	      var t = S(e, this),
	          n = t.length;
	      return this.filter(function () {
	        for (var e = 0; e < n; e++) if (S.contains(this, t[e])) return !0;
	      });
	    },
	    closest: function (e, t) {
	      var n,
	          r = 0,
	          i = this.length,
	          o = [],
	          a = "string" != typeof e && S(e);
	      if (!k.test(e)) for (; r < i; r++) for (n = this[r]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) {
	        o.push(n);
	        break;
	      }
	      return this.pushStack(1 < o.length ? S.uniqueSort(o) : o);
	    },
	    index: function (e) {
	      return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
	    },
	    add: function (e, t) {
	      return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t))));
	    },
	    addBack: function (e) {
	      return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
	    }
	  }), S.each({
	    parent: function (e) {
	      var t = e.parentNode;
	      return t && 11 !== t.nodeType ? t : null;
	    },
	    parents: function (e) {
	      return h(e, "parentNode");
	    },
	    parentsUntil: function (e, t, n) {
	      return h(e, "parentNode", n);
	    },
	    next: function (e) {
	      return O(e, "nextSibling");
	    },
	    prev: function (e) {
	      return O(e, "previousSibling");
	    },
	    nextAll: function (e) {
	      return h(e, "nextSibling");
	    },
	    prevAll: function (e) {
	      return h(e, "previousSibling");
	    },
	    nextUntil: function (e, t, n) {
	      return h(e, "nextSibling", n);
	    },
	    prevUntil: function (e, t, n) {
	      return h(e, "previousSibling", n);
	    },
	    siblings: function (e) {
	      return T((e.parentNode || {}).firstChild, e);
	    },
	    children: function (e) {
	      return T(e.firstChild);
	    },
	    contents: function (e) {
	      return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes));
	    }
	  }, function (r, i) {
	    S.fn[r] = function (e, t) {
	      var n = S.map(this, i, e);
	      return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = S.filter(t, n)), 1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n);
	    };
	  });
	  var P = /[^\x20\t\r\n\f]+/g;

	  function R(e) {
	    return e;
	  }

	  function M(e) {
	    throw e;
	  }

	  function I(e, t, n, r) {
	    var i;

	    try {
	      e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r));
	    } catch (e) {
	      n.apply(void 0, [e]);
	    }
	  }

	  S.Callbacks = function (r) {
	    var e, n;
	    r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(P) || [], function (e, t) {
	      n[t] = !0;
	    }), n) : S.extend({}, r);

	    var i,
	        t,
	        o,
	        a,
	        s = [],
	        u = [],
	        l = -1,
	        c = function () {
	      for (a = a || r.once, o = i = !0; u.length; l = -1) {
	        t = u.shift();

	        while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1);
	      }

	      r.memory || (t = !1), i = !1, a && (s = t ? [] : "");
	    },
	        f = {
	      add: function () {
	        return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) {
	          S.each(e, function (e, t) {
	            m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t);
	          });
	        }(arguments), t && !i && c()), this;
	      },
	      remove: function () {
	        return S.each(arguments, function (e, t) {
	          var n;

	          while (-1 < (n = S.inArray(t, s, n))) s.splice(n, 1), n <= l && l--;
	        }), this;
	      },
	      has: function (e) {
	        return e ? -1 < S.inArray(e, s) : 0 < s.length;
	      },
	      empty: function () {
	        return s && (s = []), this;
	      },
	      disable: function () {
	        return a = u = [], s = t = "", this;
	      },
	      disabled: function () {
	        return !s;
	      },
	      lock: function () {
	        return a = u = [], t || i || (s = t = ""), this;
	      },
	      locked: function () {
	        return !!a;
	      },
	      fireWith: function (e, t) {
	        return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this;
	      },
	      fire: function () {
	        return f.fireWith(this, arguments), this;
	      },
	      fired: function () {
	        return !!o;
	      }
	    };

	    return f;
	  }, S.extend({
	    Deferred: function (e) {
	      var o = [["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2], ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]],
	          i = "pending",
	          a = {
	        state: function () {
	          return i;
	        },
	        always: function () {
	          return s.done(arguments).fail(arguments), this;
	        },
	        "catch": function (e) {
	          return a.then(null, e);
	        },
	        pipe: function () {
	          var i = arguments;
	          return S.Deferred(function (r) {
	            S.each(o, function (e, t) {
	              var n = m(i[t[4]]) && i[t[4]];
	              s[t[1]](function () {
	                var e = n && n.apply(this, arguments);
	                e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments);
	              });
	            }), i = null;
	          }).promise();
	        },
	        then: function (t, n, r) {
	          var u = 0;

	          function l(i, o, a, s) {
	            return function () {
	              var n = this,
	                  r = arguments,
	                  e = function () {
	                var e, t;

	                if (!(i < u)) {
	                  if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution");
	                  t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [e]), (s || o.resolveWith)(n, r));
	                }
	              },
	                  t = s ? e : function () {
	                try {
	                  e();
	                } catch (e) {
	                  S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== M && (n = void 0, r = [e]), o.rejectWith(n, r));
	                }
	              };

	              i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t));
	            };
	          }

	          return S.Deferred(function (e) {
	            o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : R)), o[2][3].add(l(0, e, m(n) ? n : M));
	          }).promise();
	        },
	        promise: function (e) {
	          return null != e ? S.extend(e, a) : a;
	        }
	      },
	          s = {};
	      return S.each(o, function (e, t) {
	        var n = t[2],
	            r = t[5];
	        a[t[1]] = n.add, r && n.add(function () {
	          i = r;
	        }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function () {
	          return s[t[0] + "With"](this === s ? void 0 : this, arguments), this;
	        }, s[t[0] + "With"] = n.fireWith;
	      }), a.promise(s), e && e.call(s, s), s;
	    },
	    when: function (e) {
	      var n = arguments.length,
	          t = n,
	          r = Array(t),
	          i = s.call(arguments),
	          o = S.Deferred(),
	          a = function (t) {
	        return function (e) {
	          r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i);
	        };
	      };

	      if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then();

	      while (t--) I(i[t], a(t), o.reject);

	      return o.promise();
	    }
	  });
	  var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	  S.Deferred.exceptionHook = function (e, t) {
	    C.console && C.console.warn && e && W.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t);
	  }, S.readyException = function (e) {
	    C.setTimeout(function () {
	      throw e;
	    });
	  };
	  var F = S.Deferred();

	  function B() {
	    E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), S.ready();
	  }

	  S.fn.ready = function (e) {
	    return F.then(e)["catch"](function (e) {
	      S.readyException(e);
	    }), this;
	  }, S.extend({
	    isReady: !1,
	    readyWait: 1,
	    ready: function (e) {
	      (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [S]);
	    }
	  }), S.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B));

	  var $ = function (e, t, n, r, i, o, a) {
	    var s = 0,
	        u = e.length,
	        l = null == n;
	    if ("object" === w(n)) for (s in i = !0, n) $(e, t, s, n[s], !0, o, a);else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) {
	      return l.call(S(e), n);
	    })), t)) for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
	    return i ? e : l ? t.call(e) : u ? t(e[0], n) : o;
	  },
	      _ = /^-ms-/,
	      z = /-([a-z])/g;

	  function U(e, t) {
	    return t.toUpperCase();
	  }

	  function X(e) {
	    return e.replace(_, "ms-").replace(z, U);
	  }

	  var V = function (e) {
	    return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
	  };

	  function G() {
	    this.expando = S.expando + G.uid++;
	  }

	  G.uid = 1, G.prototype = {
	    cache: function (e) {
	      var t = e[this.expando];
	      return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
	        value: t,
	        configurable: !0
	      }))), t;
	    },
	    set: function (e, t, n) {
	      var r,
	          i = this.cache(e);
	      if ("string" == typeof t) i[X(t)] = n;else for (r in t) i[X(r)] = t[r];
	      return i;
	    },
	    get: function (e, t) {
	      return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)];
	    },
	    access: function (e, t, n) {
	      return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t);
	    },
	    remove: function (e, t) {
	      var n,
	          r = e[this.expando];

	      if (void 0 !== r) {
	        if (void 0 !== t) {
	          n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [t] : t.match(P) || []).length;

	          while (n--) delete r[t[n]];
	        }

	        (void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]);
	      }
	    },
	    hasData: function (e) {
	      var t = e[this.expando];
	      return void 0 !== t && !S.isEmptyObject(t);
	    }
	  };
	  var Y = new G(),
	      Q = new G(),
	      J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	      K = /[A-Z]/g;

	  function Z(e, t, n) {
	    var r, i;
	    if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) {
	      try {
	        n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i);
	      } catch (e) {}

	      Q.set(e, t, n);
	    } else n = void 0;
	    return n;
	  }

	  S.extend({
	    hasData: function (e) {
	      return Q.hasData(e) || Y.hasData(e);
	    },
	    data: function (e, t, n) {
	      return Q.access(e, t, n);
	    },
	    removeData: function (e, t) {
	      Q.remove(e, t);
	    },
	    _data: function (e, t, n) {
	      return Y.access(e, t, n);
	    },
	    _removeData: function (e, t) {
	      Y.remove(e, t);
	    }
	  }), S.fn.extend({
	    data: function (n, e) {
	      var t,
	          r,
	          i,
	          o = this[0],
	          a = o && o.attributes;

	      if (void 0 === n) {
	        if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) {
	          t = a.length;

	          while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = X(r.slice(5)), Z(o, r, i[r]));

	          Y.set(o, "hasDataAttrs", !0);
	        }

	        return i;
	      }

	      return "object" == typeof n ? this.each(function () {
	        Q.set(this, n);
	      }) : $(this, function (e) {
	        var t;
	        if (o && void 0 === e) return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ? t : void 0;
	        this.each(function () {
	          Q.set(this, n, e);
	        });
	      }, null, e, 1 < arguments.length, null, !0);
	    },
	    removeData: function (e) {
	      return this.each(function () {
	        Q.remove(this, e);
	      });
	    }
	  }), S.extend({
	    queue: function (e, t, n) {
	      var r;
	      if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || [];
	    },
	    dequeue: function (e, t) {
	      t = t || "fx";

	      var n = S.queue(e, t),
	          r = n.length,
	          i = n.shift(),
	          o = S._queueHooks(e, t);

	      "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function () {
	        S.dequeue(e, t);
	      }, o)), !r && o && o.empty.fire();
	    },
	    _queueHooks: function (e, t) {
	      var n = t + "queueHooks";
	      return Y.get(e, n) || Y.access(e, n, {
	        empty: S.Callbacks("once memory").add(function () {
	          Y.remove(e, [t + "queue", n]);
	        })
	      });
	    }
	  }), S.fn.extend({
	    queue: function (t, n) {
	      var e = 2;
	      return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function () {
	        var e = S.queue(this, t, n);
	        S._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && S.dequeue(this, t);
	      });
	    },
	    dequeue: function (e) {
	      return this.each(function () {
	        S.dequeue(this, e);
	      });
	    },
	    clearQueue: function (e) {
	      return this.queue(e || "fx", []);
	    },
	    promise: function (e, t) {
	      var n,
	          r = 1,
	          i = S.Deferred(),
	          o = this,
	          a = this.length,
	          s = function () {
	        --r || i.resolveWith(o, [o]);
	      };

	      "string" != typeof e && (t = e, e = void 0), e = e || "fx";

	      while (a--) (n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));

	      return s(), i.promise(t);
	    }
	  });

	  var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
	      te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"),
	      ne = ["Top", "Right", "Bottom", "Left"],
	      re = E.documentElement,
	      ie = function (e) {
	    return S.contains(e.ownerDocument, e);
	  },
	      oe = {
	    composed: !0
	  };

	  re.getRootNode && (ie = function (e) {
	    return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument;
	  });

	  var ae = function (e, t) {
	    return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === S.css(e, "display");
	  };

	  function se(e, t, n, r) {
	    var i,
	        o,
	        a = 20,
	        s = r ? function () {
	      return r.cur();
	    } : function () {
	      return S.css(e, t, "");
	    },
	        u = s(),
	        l = n && n[3] || (S.cssNumber[t] ? "" : "px"),
	        c = e.nodeType && (S.cssNumber[t] || "px" !== l && +u) && te.exec(S.css(e, t));

	    if (c && c[3] !== l) {
	      u /= 2, l = l || c[3], c = +u || 1;

	      while (a--) S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;

	      c *= 2, S.style(e, t, c + l), n = n || [];
	    }

	    return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i;
	  }

	  var ue = {};

	  function le(e, t) {
	    for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++) (r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Y.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ue[s] = u)))) : "none" !== n && (l[c] = "none", Y.set(r, "display", n)));

	    for (c = 0; c < f; c++) null != l[c] && (e[c].style.display = l[c]);

	    return e;
	  }

	  S.fn.extend({
	    show: function () {
	      return le(this, !0);
	    },
	    hide: function () {
	      return le(this);
	    },
	    toggle: function (e) {
	      return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
	        ae(this) ? S(this).show() : S(this).hide();
	      });
	    }
	  });
	  var ce,
	      fe,
	      pe = /^(?:checkbox|radio)$/i,
	      de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
	      he = /^$|^module$|\/(?:java|ecma)script/i;
	  ce = E.createDocumentFragment().appendChild(E.createElement("div")), (fe = E.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = "<option></option>", y.option = !!ce.lastChild;
	  var ge = {
	    thead: [1, "<table>", "</table>"],
	    col: [2, "<table><colgroup>", "</colgroup></table>"],
	    tr: [2, "<table><tbody>", "</tbody></table>"],
	    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	    _default: [0, "", ""]
	  };

	  function ve(e, t) {
	    var n;
	    return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? S.merge([e], n) : n;
	  }

	  function ye(e, t) {
	    for (var n = 0, r = e.length; n < r; n++) Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval"));
	  }

	  ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]);
	  var me = /<|&#?\w+;/;

	  function xe(e, t, n, r, i) {
	    for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++) if ((o = e[d]) || 0 === o) if ("object" === w(o)) S.merge(p, o.nodeType ? [o] : o);else if (me.test(o)) {
	      a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2], c = u[0];

	      while (c--) a = a.lastChild;

	      S.merge(p, a.childNodes), (a = f.firstChild).textContent = "";
	    } else p.push(t.createTextNode(o));

	    f.textContent = "", d = 0;

	    while (o = p[d++]) if (r && -1 < S.inArray(o, r)) i && i.push(o);else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) {
	      c = 0;

	      while (o = a[c++]) he.test(o.type || "") && n.push(o);
	    }

	    return f;
	  }

	  var be = /^([^.]*)(?:\.(.+)|)/;

	  function we() {
	    return !0;
	  }

	  function Te() {
	    return !1;
	  }

	  function Ce(e, t) {
	    return e === function () {
	      try {
	        return E.activeElement;
	      } catch (e) {}
	    }() == ("focus" === t);
	  }

	  function Ee(e, t, n, r, i, o) {
	    var a, s;

	    if ("object" == typeof t) {
	      for (s in "string" != typeof n && (r = r || n, n = void 0), t) Ee(e, s, n, r, t[s], o);

	      return e;
	    }

	    if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Te;else if (!i) return e;
	    return 1 === o && (a = i, (i = function (e) {
	      return S().off(e), a.apply(this, arguments);
	    }).guid = a.guid || (a.guid = S.guid++)), e.each(function () {
	      S.event.add(this, t, i, r, n);
	    });
	  }

	  function Se(e, i, o) {
	    o ? (Y.set(e, i, !1), S.event.add(e, i, {
	      namespace: !1,
	      handler: function (e) {
	        var t,
	            n,
	            r = Y.get(this, i);

	        if (1 & e.isTrigger && this[i]) {
	          if (r.length) (S.event.special[i] || {}).delegateType && e.stopPropagation();else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n && n.value;
	        } else r.length && (Y.set(this, i, {
	          value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this)
	        }), e.stopImmediatePropagation());
	      }
	    })) : void 0 === Y.get(e, i) && S.event.add(e, i, we);
	  }

	  S.event = {
	    global: {},
	    add: function (t, e, n, r, i) {
	      var o,
	          a,
	          s,
	          u,
	          l,
	          c,
	          f,
	          p,
	          d,
	          h,
	          g,
	          v = Y.get(t);

	      if (V(t)) {
	        n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(re, i), n.guid || (n.guid = S.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function (e) {
	          return "undefined" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0;
	        }), l = (e = (e || "").match(P) || [""]).length;

	        while (l--) d = g = (s = be.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({
	          type: d,
	          origType: g,
	          data: r,
	          handler: n,
	          guid: n.guid,
	          selector: i,
	          needsContext: i && S.expr.match.needsContext.test(i),
	          namespace: h.join(".")
	        }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0);
	      }
	    },
	    remove: function (e, t, n, r, i) {
	      var o,
	          a,
	          s,
	          u,
	          l,
	          c,
	          f,
	          p,
	          d,
	          h,
	          g,
	          v = Y.hasData(e) && Y.get(e);

	      if (v && (u = v.events)) {
	        l = (t = (t || "").match(P) || [""]).length;

	        while (l--) if (d = g = (s = be.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) {
	          f = S.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length;

	          while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));

	          a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d]);
	        } else for (d in u) S.event.remove(e, d + t[l], n, r, !0);

	        S.isEmptyObject(u) && Y.remove(e, "handle events");
	      }
	    },
	    dispatch: function (e) {
	      var t,
	          n,
	          r,
	          i,
	          o,
	          a,
	          s = new Array(arguments.length),
	          u = S.event.fix(e),
	          l = (Y.get(this, "events") || Object.create(null))[u.type] || [],
	          c = S.event.special[u.type] || {};

	      for (s[0] = u, t = 1; t < arguments.length; t++) s[t] = arguments[t];

	      if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) {
	        a = S.event.handlers.call(this, u, l), t = 0;

	        while ((i = a[t++]) && !u.isPropagationStopped()) {
	          u.currentTarget = i.elem, n = 0;

	          while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped()) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation()));
	        }

	        return c.postDispatch && c.postDispatch.call(this, u), u.result;
	      }
	    },
	    handlers: function (e, t) {
	      var n,
	          r,
	          i,
	          o,
	          a,
	          s = [],
	          u = t.delegateCount,
	          l = e.target;
	      if (u && l.nodeType && !("click" === e.type && 1 <= e.button)) for (; l !== this; l = l.parentNode || this) if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
	        for (o = [], a = {}, n = 0; n < u; n++) void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r);

	        o.length && s.push({
	          elem: l,
	          handlers: o
	        });
	      }
	      return l = this, u < t.length && s.push({
	        elem: l,
	        handlers: t.slice(u)
	      }), s;
	    },
	    addProp: function (t, e) {
	      Object.defineProperty(S.Event.prototype, t, {
	        enumerable: !0,
	        configurable: !0,
	        get: m(e) ? function () {
	          if (this.originalEvent) return e(this.originalEvent);
	        } : function () {
	          if (this.originalEvent) return this.originalEvent[t];
	        },
	        set: function (e) {
	          Object.defineProperty(this, t, {
	            enumerable: !0,
	            configurable: !0,
	            writable: !0,
	            value: e
	          });
	        }
	      });
	    },
	    fix: function (e) {
	      return e[S.expando] ? e : new S.Event(e);
	    },
	    special: {
	      load: {
	        noBubble: !0
	      },
	      click: {
	        setup: function (e) {
	          var t = this || e;
	          return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click", we), !1;
	        },
	        trigger: function (e) {
	          var t = this || e;
	          return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click"), !0;
	        },
	        _default: function (e) {
	          var t = e.target;
	          return pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click") || A(t, "a");
	        }
	      },
	      beforeunload: {
	        postDispatch: function (e) {
	          void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result);
	        }
	      }
	    }
	  }, S.removeEvent = function (e, t, n) {
	    e.removeEventListener && e.removeEventListener(t, n);
	  }, S.Event = function (e, t) {
	    if (!(this instanceof S.Event)) return new S.Event(e, t);
	    e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Te, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0;
	  }, S.Event.prototype = {
	    constructor: S.Event,
	    isDefaultPrevented: Te,
	    isPropagationStopped: Te,
	    isImmediatePropagationStopped: Te,
	    isSimulated: !1,
	    preventDefault: function () {
	      var e = this.originalEvent;
	      this.isDefaultPrevented = we, e && !this.isSimulated && e.preventDefault();
	    },
	    stopPropagation: function () {
	      var e = this.originalEvent;
	      this.isPropagationStopped = we, e && !this.isSimulated && e.stopPropagation();
	    },
	    stopImmediatePropagation: function () {
	      var e = this.originalEvent;
	      this.isImmediatePropagationStopped = we, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation();
	    }
	  }, S.each({
	    altKey: !0,
	    bubbles: !0,
	    cancelable: !0,
	    changedTouches: !0,
	    ctrlKey: !0,
	    detail: !0,
	    eventPhase: !0,
	    metaKey: !0,
	    pageX: !0,
	    pageY: !0,
	    shiftKey: !0,
	    view: !0,
	    "char": !0,
	    code: !0,
	    charCode: !0,
	    key: !0,
	    keyCode: !0,
	    button: !0,
	    buttons: !0,
	    clientX: !0,
	    clientY: !0,
	    offsetX: !0,
	    offsetY: !0,
	    pointerId: !0,
	    pointerType: !0,
	    screenX: !0,
	    screenY: !0,
	    targetTouches: !0,
	    toElement: !0,
	    touches: !0,
	    which: !0
	  }, S.event.addProp), S.each({
	    focus: "focusin",
	    blur: "focusout"
	  }, function (e, t) {
	    S.event.special[e] = {
	      setup: function () {
	        return Se(this, e, Ce), !1;
	      },
	      trigger: function () {
	        return Se(this, e), !0;
	      },
	      _default: function () {
	        return !0;
	      },
	      delegateType: t
	    };
	  }), S.each({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout",
	    pointerenter: "pointerover",
	    pointerleave: "pointerout"
	  }, function (e, i) {
	    S.event.special[e] = {
	      delegateType: i,
	      bindType: i,
	      handle: function (e) {
	        var t,
	            n = e.relatedTarget,
	            r = e.handleObj;
	        return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t;
	      }
	    };
	  }), S.fn.extend({
	    on: function (e, t, n, r) {
	      return Ee(this, e, t, n, r);
	    },
	    one: function (e, t, n, r) {
	      return Ee(this, e, t, n, r, 1);
	    },
	    off: function (e, t, n) {
	      var r, i;
	      if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;

	      if ("object" == typeof e) {
	        for (i in e) this.off(i, t, e[i]);

	        return this;
	      }

	      return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Te), this.each(function () {
	        S.event.remove(this, e, n, t);
	      });
	    }
	  });
	  var ke = /<script|<style|<link/i,
	      Ae = /checked\s*(?:[^=]|=\s*.checked.)/i,
	      Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	  function je(e, t) {
	    return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e;
	  }

	  function De(e) {
	    return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e;
	  }

	  function qe(e) {
	    return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e;
	  }

	  function Le(e, t) {
	    var n, r, i, o, a, s;

	    if (1 === t.nodeType) {
	      if (Y.hasData(e) && (s = Y.get(e).events)) for (i in Y.remove(t, "handle events"), s) for (n = 0, r = s[i].length; n < r; n++) S.event.add(t, i, s[i][n]);
	      Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a));
	    }
	  }

	  function He(n, r, i, o) {
	    r = g(r);
	    var e,
	        t,
	        a,
	        s,
	        u,
	        l,
	        c = 0,
	        f = n.length,
	        p = f - 1,
	        d = r[0],
	        h = m(d);
	    if (h || 1 < f && "string" == typeof d && !y.checkClone && Ae.test(d)) return n.each(function (e) {
	      var t = n.eq(e);
	      h && (r[0] = d.call(this, e, t.html())), He(t, r, i, o);
	    });

	    if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
	      for (s = (a = S.map(ve(e, "script"), De)).length; c < f; c++) u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, "script"))), i.call(n[c], u, c);

	      if (s) for (l = a[a.length - 1].ownerDocument, S.map(a, qe), c = 0; c < s; c++) u = a[c], he.test(u.type || "") && !Y.access(u, "globalEval") && S.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? S._evalUrl && !u.noModule && S._evalUrl(u.src, {
	        nonce: u.nonce || u.getAttribute("nonce")
	      }, l) : b(u.textContent.replace(Ne, ""), u, l));
	    }

	    return n;
	  }

	  function Oe(e, t, n) {
	    for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r));

	    return e;
	  }

	  S.extend({
	    htmlPrefilter: function (e) {
	      return e;
	    },
	    clone: function (e, t, n) {
	      var r,
	          i,
	          o,
	          a,
	          s,
	          u,
	          l,
	          c = e.cloneNode(!0),
	          f = ie(e);
	      if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e))) for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++) s = o[r], u = a[r], "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue);
	      if (t) if (n) for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++) Le(o[r], a[r]);else Le(e, c);
	      return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c;
	    },
	    cleanData: function (e) {
	      for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++) if (V(n)) {
	        if (t = n[Y.expando]) {
	          if (t.events) for (r in t.events) i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle);
	          n[Y.expando] = void 0;
	        }

	        n[Q.expando] && (n[Q.expando] = void 0);
	      }
	    }
	  }), S.fn.extend({
	    detach: function (e) {
	      return Oe(this, e, !0);
	    },
	    remove: function (e) {
	      return Oe(this, e);
	    },
	    text: function (e) {
	      return $(this, function (e) {
	        return void 0 === e ? S.text(this) : this.empty().each(function () {
	          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e);
	        });
	      }, null, e, arguments.length);
	    },
	    append: function () {
	      return He(this, arguments, function (e) {
	        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e).appendChild(e);
	      });
	    },
	    prepend: function () {
	      return He(this, arguments, function (e) {
	        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
	          var t = je(this, e);
	          t.insertBefore(e, t.firstChild);
	        }
	      });
	    },
	    before: function () {
	      return He(this, arguments, function (e) {
	        this.parentNode && this.parentNode.insertBefore(e, this);
	      });
	    },
	    after: function () {
	      return He(this, arguments, function (e) {
	        this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
	      });
	    },
	    empty: function () {
	      for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = "");

	      return this;
	    },
	    clone: function (e, t) {
	      return e = null != e && e, t = null == t ? e : t, this.map(function () {
	        return S.clone(this, e, t);
	      });
	    },
	    html: function (e) {
	      return $(this, function (e) {
	        var t = this[0] || {},
	            n = 0,
	            r = this.length;
	        if (void 0 === e && 1 === t.nodeType) return t.innerHTML;

	        if ("string" == typeof e && !ke.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) {
	          e = S.htmlPrefilter(e);

	          try {
	            for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e);

	            t = 0;
	          } catch (e) {}
	        }

	        t && this.empty().append(e);
	      }, null, e, arguments.length);
	    },
	    replaceWith: function () {
	      var n = [];
	      return He(this, arguments, function (e) {
	        var t = this.parentNode;
	        S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this));
	      }, n);
	    }
	  }), S.each({
	    appendTo: "append",
	    prependTo: "prepend",
	    insertBefore: "before",
	    insertAfter: "after",
	    replaceAll: "replaceWith"
	  }, function (e, a) {
	    S.fn[e] = function (e) {
	      for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++) t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get());

	      return this.pushStack(n);
	    };
	  });

	  var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"),
	      Re = function (e) {
	    var t = e.ownerDocument.defaultView;
	    return t && t.opener || (t = C), t.getComputedStyle(e);
	  },
	      Me = function (e, t, n) {
	    var r,
	        i,
	        o = {};

	    for (i in t) o[i] = e.style[i], e.style[i] = t[i];

	    for (i in r = n.call(e), t) e.style[i] = o[i];

	    return r;
	  },
	      Ie = new RegExp(ne.join("|"), "i");

	  function We(e, t, n) {
	    var r,
	        i,
	        o,
	        a,
	        s = e.style;
	    return (n = n || Re(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Pe.test(a) && Ie.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a;
	  }

	  function Fe(e, t) {
	    return {
	      get: function () {
	        if (!e()) return (this.get = t).apply(this, arguments);
	        delete this.get;
	      }
	    };
	  }

	  !function () {
	    function e() {
	      if (l) {
	        u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(u).appendChild(l);
	        var e = C.getComputedStyle(l);
	        n = "1%" !== e.top, s = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", i = 12 === t(l.offsetWidth / 3), re.removeChild(u), l = null;
	      }
	    }

	    function t(e) {
	      return Math.round(parseFloat(e));
	    }

	    var n,
	        r,
	        i,
	        o,
	        a,
	        s,
	        u = E.createElement("div"),
	        l = E.createElement("div");
	    l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend(y, {
	      boxSizingReliable: function () {
	        return e(), r;
	      },
	      pixelBoxStyles: function () {
	        return e(), o;
	      },
	      pixelPosition: function () {
	        return e(), n;
	      },
	      reliableMarginLeft: function () {
	        return e(), s;
	      },
	      scrollboxSize: function () {
	        return e(), i;
	      },
	      reliableTrDimensions: function () {
	        var e, t, n, r;
	        return null == a && (e = E.createElement("table"), t = E.createElement("tr"), n = E.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, re.removeChild(e)), a;
	      }
	    }));
	  }();
	  var Be = ["Webkit", "Moz", "ms"],
	      $e = E.createElement("div").style,
	      _e = {};

	  function ze(e) {
	    var t = S.cssProps[e] || _e[e];
	    return t || (e in $e ? e : _e[e] = function (e) {
	      var t = e[0].toUpperCase() + e.slice(1),
	          n = Be.length;

	      while (n--) if ((e = Be[n] + t) in $e) return e;
	    }(e) || e);
	  }

	  var Ue = /^(none|table(?!-c[ea]).+)/,
	      Xe = /^--/,
	      Ve = {
	    position: "absolute",
	    visibility: "hidden",
	    display: "block"
	  },
	      Ge = {
	    letterSpacing: "0",
	    fontWeight: "400"
	  };

	  function Ye(e, t, n) {
	    var r = te.exec(t);
	    return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t;
	  }

	  function Qe(e, t, n, r, i, o) {
	    var a = "width" === t ? 1 : 0,
	        s = 0,
	        u = 0;
	    if (n === (r ? "border" : "content")) return 0;

	    for (; a < 4; a += 2) "margin" === n && (u += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (u += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i));

	    return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u;
	  }

	  function Je(e, t, n) {
	    var r = Re(e),
	        i = (!y.boxSizingReliable() || n) && "border-box" === S.css(e, "boxSizing", !1, r),
	        o = i,
	        a = We(e, t, r),
	        s = "offset" + t[0].toUpperCase() + t.slice(1);

	    if (Pe.test(a)) {
	      if (!n) return a;
	      a = "auto";
	    }

	    return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === S.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Qe(e, t, n || (i ? "border" : "content"), o, r, a) + "px";
	  }

	  function Ke(e, t, n, r, i) {
	    return new Ke.prototype.init(e, t, n, r, i);
	  }

	  S.extend({
	    cssHooks: {
	      opacity: {
	        get: function (e, t) {
	          if (t) {
	            var n = We(e, "opacity");
	            return "" === n ? "1" : n;
	          }
	        }
	      }
	    },
	    cssNumber: {
	      animationIterationCount: !0,
	      columnCount: !0,
	      fillOpacity: !0,
	      flexGrow: !0,
	      flexShrink: !0,
	      fontWeight: !0,
	      gridArea: !0,
	      gridColumn: !0,
	      gridColumnEnd: !0,
	      gridColumnStart: !0,
	      gridRow: !0,
	      gridRowEnd: !0,
	      gridRowStart: !0,
	      lineHeight: !0,
	      opacity: !0,
	      order: !0,
	      orphans: !0,
	      widows: !0,
	      zIndex: !0,
	      zoom: !0
	    },
	    cssProps: {},
	    style: function (e, t, n, r) {
	      if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
	        var i,
	            o,
	            a,
	            s = X(t),
	            u = Xe.test(t),
	            l = e.style;
	        if (u || (t = ze(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
	        "string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n));
	      }
	    },
	    css: function (e, t, n, r) {
	      var i,
	          o,
	          a,
	          s = X(t);
	      return Xe.test(t) || (t = ze(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = We(e, t, r)), "normal" === i && t in Ge && (i = Ge[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i;
	    }
	  }), S.each(["height", "width"], function (e, u) {
	    S.cssHooks[u] = {
	      get: function (e, t, n) {
	        if (t) return !Ue.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Je(e, u, n) : Me(e, Ve, function () {
	          return Je(e, u, n);
	        });
	      },
	      set: function (e, t, n) {
	        var r,
	            i = Re(e),
	            o = !y.scrollboxSize() && "absolute" === i.position,
	            a = (o || n) && "border-box" === S.css(e, "boxSizing", !1, i),
	            s = n ? Qe(e, u, n, a, i) : 0;
	        return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Qe(e, u, "border", !1, i) - .5)), s && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = S.css(e, u)), Ye(0, t, s);
	      }
	    };
	  }), S.cssHooks.marginLeft = Fe(y.reliableMarginLeft, function (e, t) {
	    if (t) return (parseFloat(We(e, "marginLeft")) || e.getBoundingClientRect().left - Me(e, {
	      marginLeft: 0
	    }, function () {
	      return e.getBoundingClientRect().left;
	    })) + "px";
	  }), S.each({
	    margin: "",
	    padding: "",
	    border: "Width"
	  }, function (i, o) {
	    S.cssHooks[i + o] = {
	      expand: function (e) {
	        for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++) n[i + ne[t] + o] = r[t] || r[t - 2] || r[0];

	        return n;
	      }
	    }, "margin" !== i && (S.cssHooks[i + o].set = Ye);
	  }), S.fn.extend({
	    css: function (e, t) {
	      return $(this, function (e, t, n) {
	        var r,
	            i,
	            o = {},
	            a = 0;

	        if (Array.isArray(t)) {
	          for (r = Re(e), i = t.length; a < i; a++) o[t[a]] = S.css(e, t[a], !1, r);

	          return o;
	        }

	        return void 0 !== n ? S.style(e, t, n) : S.css(e, t);
	      }, e, t, 1 < arguments.length);
	    }
	  }), ((S.Tween = Ke).prototype = {
	    constructor: Ke,
	    init: function (e, t, n, r, i, o) {
	      this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? "" : "px");
	    },
	    cur: function () {
	      var e = Ke.propHooks[this.prop];
	      return e && e.get ? e.get(this) : Ke.propHooks._default.get(this);
	    },
	    run: function (e) {
	      var t,
	          n = Ke.propHooks[this.prop];
	      return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Ke.propHooks._default.set(this), this;
	    }
	  }).init.prototype = Ke.prototype, (Ke.propHooks = {
	    _default: {
	      get: function (e) {
	        var t;
	        return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0;
	      },
	      set: function (e) {
	        S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[ze(e.prop)] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit);
	      }
	    }
	  }).scrollTop = Ke.propHooks.scrollLeft = {
	    set: function (e) {
	      e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
	    }
	  }, S.easing = {
	    linear: function (e) {
	      return e;
	    },
	    swing: function (e) {
	      return .5 - Math.cos(e * Math.PI) / 2;
	    },
	    _default: "swing"
	  }, S.fx = Ke.prototype.init, S.fx.step = {};
	  var Ze,
	      et,
	      tt,
	      nt,
	      rt = /^(?:toggle|show|hide)$/,
	      it = /queueHooks$/;

	  function ot() {
	    et && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(ot) : C.setTimeout(ot, S.fx.interval), S.fx.tick());
	  }

	  function at() {
	    return C.setTimeout(function () {
	      Ze = void 0;
	    }), Ze = Date.now();
	  }

	  function st(e, t) {
	    var n,
	        r = 0,
	        i = {
	      height: e
	    };

	    for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = ne[r])] = i["padding" + n] = e;

	    return t && (i.opacity = i.width = e), i;
	  }

	  function ut(e, t, n) {
	    for (var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), o = 0, a = i.length; o < a; o++) if (r = i[o].call(n, t, e)) return r;
	  }

	  function lt(o, e, t) {
	    var n,
	        a,
	        r = 0,
	        i = lt.prefilters.length,
	        s = S.Deferred().always(function () {
	      delete u.elem;
	    }),
	        u = function () {
	      if (a) return !1;

	      for (var e = Ze || at(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++) l.tweens[r].run(n);

	      return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1);
	    },
	        l = s.promise({
	      elem: o,
	      props: S.extend({}, e),
	      opts: S.extend(!0, {
	        specialEasing: {},
	        easing: S.easing._default
	      }, t),
	      originalProperties: e,
	      originalOptions: t,
	      startTime: Ze || at(),
	      duration: t.duration,
	      tweens: [],
	      createTween: function (e, t) {
	        var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing);
	        return l.tweens.push(n), n;
	      },
	      stop: function (e) {
	        var t = 0,
	            n = e ? l.tweens.length : 0;
	        if (a) return this;

	        for (a = !0; t < n; t++) l.tweens[t].run(1);

	        return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this;
	      }
	    }),
	        c = l.props;

	    for (!function (e, t) {
	      var n, r, i, o, a;

	      for (n in e) if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && ("expand" in a)) for (n in o = a.expand(o), delete e[r], o) (n in e) || (e[n] = o[n], t[n] = i);else t[r] = i;
	    }(c, l.opts.specialEasing); r < i; r++) if (n = lt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n;

	    return S.map(c, ut, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(u, {
	      elem: o,
	      anim: l,
	      queue: l.opts.queue
	    })), l;
	  }

	  S.Animation = S.extend(lt, {
	    tweeners: {
	      "*": [function (e, t) {
	        var n = this.createTween(e, t);
	        return se(n.elem, e, te.exec(t), n), n;
	      }]
	    },
	    tweener: function (e, t) {
	      m(e) ? (t = e, e = ["*"]) : e = e.match(P);

	      for (var n, r = 0, i = e.length; r < i; r++) n = e[r], lt.tweeners[n] = lt.tweeners[n] || [], lt.tweeners[n].unshift(t);
	    },
	    prefilters: [function (e, t, n) {
	      var r,
	          i,
	          o,
	          a,
	          s,
	          u,
	          l,
	          c,
	          f = "width" in t || "height" in t,
	          p = this,
	          d = {},
	          h = e.style,
	          g = e.nodeType && ae(e),
	          v = Y.get(e, "fxshow");

	      for (r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
	        a.unqueued || s();
	      }), a.unqueued++, p.always(function () {
	        p.always(function () {
	          a.unqueued--, S.queue(e, "fx").length || a.empty.fire();
	        });
	      })), t) if (i = t[r], rt.test(i)) {
	        if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
	          if ("show" !== i || !v || void 0 === v[r]) continue;
	          g = !0;
	        }

	        d[r] = v && v[r] || S.style(e, r);
	      }

	      if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y.get(e, "display")), "none" === (c = S.css(e, "display")) && (l ? c = l : (le([e], !0), l = e.style.display || l, c = S.css(e, "display"), le([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === S.css(e, "float") && (u || (p.done(function () {
	        h.display = l;
	      }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () {
	        h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2];
	      })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = Y.access(e, "fxshow", {
	        display: l
	      }), o && (v.hidden = !g), g && le([e], !0), p.done(function () {
	        for (r in g || le([e]), Y.remove(e, "fxshow"), d) S.style(e, r, d[r]);
	      })), u = ut(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0));
	    }],
	    prefilter: function (e, t) {
	      t ? lt.prefilters.unshift(e) : lt.prefilters.push(e);
	    }
	  }), S.speed = function (e, t, n) {
	    var r = e && "object" == typeof e ? S.extend({}, e) : {
	      complete: n || !n && t || m(e) && e,
	      duration: e,
	      easing: n && t || t && !m(t) && t
	    };
	    return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () {
	      m(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue);
	    }, r;
	  }, S.fn.extend({
	    fadeTo: function (e, t, n, r) {
	      return this.filter(ae).css("opacity", 0).show().end().animate({
	        opacity: t
	      }, e, n, r);
	    },
	    animate: function (t, e, n, r) {
	      var i = S.isEmptyObject(t),
	          o = S.speed(e, n, r),
	          a = function () {
	        var e = lt(this, S.extend({}, t), o);
	        (i || Y.get(this, "finish")) && e.stop(!0);
	      };

	      return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a);
	    },
	    stop: function (i, e, o) {
	      var a = function (e) {
	        var t = e.stop;
	        delete e.stop, t(o);
	      };

	      return "string" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || "fx", []), this.each(function () {
	        var e = !0,
	            t = null != i && i + "queueHooks",
	            n = S.timers,
	            r = Y.get(this);
	        if (t) r[t] && r[t].stop && a(r[t]);else for (t in r) r[t] && r[t].stop && it.test(t) && a(r[t]);

	        for (t = n.length; t--;) n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1));

	        !e && o || S.dequeue(this, i);
	      });
	    },
	    finish: function (a) {
	      return !1 !== a && (a = a || "fx"), this.each(function () {
	        var e,
	            t = Y.get(this),
	            n = t[a + "queue"],
	            r = t[a + "queueHooks"],
	            i = S.timers,
	            o = n ? n.length : 0;

	        for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;) i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1));

	        for (e = 0; e < o; e++) n[e] && n[e].finish && n[e].finish.call(this);

	        delete t.finish;
	      });
	    }
	  }), S.each(["toggle", "show", "hide"], function (e, r) {
	    var i = S.fn[r];

	    S.fn[r] = function (e, t, n) {
	      return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(st(r, !0), e, t, n);
	    };
	  }), S.each({
	    slideDown: st("show"),
	    slideUp: st("hide"),
	    slideToggle: st("toggle"),
	    fadeIn: {
	      opacity: "show"
	    },
	    fadeOut: {
	      opacity: "hide"
	    },
	    fadeToggle: {
	      opacity: "toggle"
	    }
	  }, function (e, r) {
	    S.fn[e] = function (e, t, n) {
	      return this.animate(r, e, t, n);
	    };
	  }), S.timers = [], S.fx.tick = function () {
	    var e,
	        t = 0,
	        n = S.timers;

	    for (Ze = Date.now(); t < n.length; t++) (e = n[t])() || n[t] !== e || n.splice(t--, 1);

	    n.length || S.fx.stop(), Ze = void 0;
	  }, S.fx.timer = function (e) {
	    S.timers.push(e), S.fx.start();
	  }, S.fx.interval = 13, S.fx.start = function () {
	    et || (et = !0, ot());
	  }, S.fx.stop = function () {
	    et = null;
	  }, S.fx.speeds = {
	    slow: 600,
	    fast: 200,
	    _default: 400
	  }, S.fn.delay = function (r, e) {
	    return r = S.fx && S.fx.speeds[r] || r, e = e || "fx", this.queue(e, function (e, t) {
	      var n = C.setTimeout(e, r);

	      t.stop = function () {
	        C.clearTimeout(n);
	      };
	    });
	  }, tt = E.createElement("input"), nt = E.createElement("select").appendChild(E.createElement("option")), tt.type = "checkbox", y.checkOn = "" !== tt.value, y.optSelected = nt.selected, (tt = E.createElement("input")).value = "t", tt.type = "radio", y.radioValue = "t" === tt.value;
	  var ct,
	      ft = S.expr.attrHandle;
	  S.fn.extend({
	    attr: function (e, t) {
	      return $(this, S.attr, e, t, 1 < arguments.length);
	    },
	    removeAttr: function (e) {
	      return this.each(function () {
	        S.removeAttr(this, e);
	      });
	    }
	  }), S.extend({
	    attr: function (e, t, n) {
	      var r,
	          i,
	          o = e.nodeType;
	      if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? ct : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r);
	    },
	    attrHooks: {
	      type: {
	        set: function (e, t) {
	          if (!y.radioValue && "radio" === t && A(e, "input")) {
	            var n = e.value;
	            return e.setAttribute("type", t), n && (e.value = n), t;
	          }
	        }
	      }
	    },
	    removeAttr: function (e, t) {
	      var n,
	          r = 0,
	          i = t && t.match(P);
	      if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n);
	    }
	  }), ct = {
	    set: function (e, t, n) {
	      return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n;
	    }
	  }, S.each(S.expr.match.bool.source.match(/\w+/g), function (e, t) {
	    var a = ft[t] || S.find.attr;

	    ft[t] = function (e, t, n) {
	      var r,
	          i,
	          o = t.toLowerCase();
	      return n || (i = ft[o], ft[o] = r, r = null != a(e, t, n) ? o : null, ft[o] = i), r;
	    };
	  });
	  var pt = /^(?:input|select|textarea|button)$/i,
	      dt = /^(?:a|area)$/i;

	  function ht(e) {
	    return (e.match(P) || []).join(" ");
	  }

	  function gt(e) {
	    return e.getAttribute && e.getAttribute("class") || "";
	  }

	  function vt(e) {
	    return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || [];
	  }

	  S.fn.extend({
	    prop: function (e, t) {
	      return $(this, S.prop, e, t, 1 < arguments.length);
	    },
	    removeProp: function (e) {
	      return this.each(function () {
	        delete this[S.propFix[e] || e];
	      });
	    }
	  }), S.extend({
	    prop: function (e, t, n) {
	      var r,
	          i,
	          o = e.nodeType;
	      if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t];
	    },
	    propHooks: {
	      tabIndex: {
	        get: function (e) {
	          var t = S.find.attr(e, "tabindex");
	          return t ? parseInt(t, 10) : pt.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1;
	        }
	      }
	    },
	    propFix: {
	      "for": "htmlFor",
	      "class": "className"
	    }
	  }), y.optSelected || (S.propHooks.selected = {
	    get: function (e) {
	      var t = e.parentNode;
	      return t && t.parentNode && t.parentNode.selectedIndex, null;
	    },
	    set: function (e) {
	      var t = e.parentNode;
	      t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);
	    }
	  }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
	    S.propFix[this.toLowerCase()] = this;
	  }), S.fn.extend({
	    addClass: function (t) {
	      var e,
	          n,
	          r,
	          i,
	          o,
	          a,
	          s,
	          u = 0;
	      if (m(t)) return this.each(function (e) {
	        S(this).addClass(t.call(this, e, gt(this)));
	      });
	      if ((e = vt(t)).length) while (n = this[u++]) if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
	        a = 0;

	        while (o = e[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " ");

	        i !== (s = ht(r)) && n.setAttribute("class", s);
	      }
	      return this;
	    },
	    removeClass: function (t) {
	      var e,
	          n,
	          r,
	          i,
	          o,
	          a,
	          s,
	          u = 0;
	      if (m(t)) return this.each(function (e) {
	        S(this).removeClass(t.call(this, e, gt(this)));
	      });
	      if (!arguments.length) return this.attr("class", "");
	      if ((e = vt(t)).length) while (n = this[u++]) if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
	        a = 0;

	        while (o = e[a++]) while (-1 < r.indexOf(" " + o + " ")) r = r.replace(" " + o + " ", " ");

	        i !== (s = ht(r)) && n.setAttribute("class", s);
	      }
	      return this;
	    },
	    toggleClass: function (i, t) {
	      var o = typeof i,
	          a = "string" === o || Array.isArray(i);
	      return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function (e) {
	        S(this).toggleClass(i.call(this, e, gt(this), t), t);
	      }) : this.each(function () {
	        var e, t, n, r;

	        if (a) {
	          t = 0, n = S(this), r = vt(i);

	          while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e);
	        } else void 0 !== i && "boolean" !== o || ((e = gt(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Y.get(this, "__className__") || ""));
	      });
	    },
	    hasClass: function (e) {
	      var t,
	          n,
	          r = 0;
	      t = " " + e + " ";

	      while (n = this[r++]) if (1 === n.nodeType && -1 < (" " + ht(gt(n)) + " ").indexOf(t)) return !0;

	      return !1;
	    }
	  });
	  var yt = /\r/g;
	  S.fn.extend({
	    val: function (n) {
	      var r,
	          e,
	          i,
	          t = this[0];
	      return arguments.length ? (i = m(n), this.each(function (e) {
	        var t;
	        1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function (e) {
	          return null == e ? "" : e + "";
	        })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t));
	      })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(yt, "") : null == e ? "" : e : void 0;
	    }
	  }), S.extend({
	    valHooks: {
	      option: {
	        get: function (e) {
	          var t = S.find.attr(e, "value");
	          return null != t ? t : ht(S.text(e));
	        }
	      },
	      select: {
	        get: function (e) {
	          var t,
	              n,
	              r,
	              i = e.options,
	              o = e.selectedIndex,
	              a = "select-one" === e.type,
	              s = a ? null : [],
	              u = a ? o + 1 : i.length;

	          for (r = o < 0 ? u : a ? o : 0; r < u; r++) if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) {
	            if (t = S(n).val(), a) return t;
	            s.push(t);
	          }

	          return s;
	        },
	        set: function (e, t) {
	          var n,
	              r,
	              i = e.options,
	              o = S.makeArray(t),
	              a = i.length;

	          while (a--) ((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0);

	          return n || (e.selectedIndex = -1), o;
	        }
	      }
	    }
	  }), S.each(["radio", "checkbox"], function () {
	    S.valHooks[this] = {
	      set: function (e, t) {
	        if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t);
	      }
	    }, y.checkOn || (S.valHooks[this].get = function (e) {
	      return null === e.getAttribute("value") ? "on" : e.value;
	    });
	  }), y.focusin = "onfocusin" in C;

	  var mt = /^(?:focusinfocus|focusoutblur)$/,
	      xt = function (e) {
	    e.stopPropagation();
	  };

	  S.extend(S.event, {
	    trigger: function (e, t, n, r) {
	      var i,
	          o,
	          a,
	          s,
	          u,
	          l,
	          c,
	          f,
	          p = [n || E],
	          d = v.call(e, "type") ? e.type : e,
	          h = v.call(e, "namespace") ? e.namespace.split(".") : [];

	      if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !mt.test(d + S.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[S.expando] ? e : new S.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : S.makeArray(t, [e]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) {
	        if (!r && !c.noBubble && !x(n)) {
	          for (s = c.delegateType || d, mt.test(s + d) || (o = o.parentNode); o; o = o.parentNode) p.push(o), a = o;

	          a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C);
	        }

	        i = 0;

	        while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Y.get(o, "events") || Object.create(null))[e.type] && Y.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());

	        return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, xt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, xt), S.event.triggered = void 0, a && (n[u] = a)), e.result;
	      }
	    },
	    simulate: function (e, t, n) {
	      var r = S.extend(new S.Event(), n, {
	        type: e,
	        isSimulated: !0
	      });
	      S.event.trigger(r, null, t);
	    }
	  }), S.fn.extend({
	    trigger: function (e, t) {
	      return this.each(function () {
	        S.event.trigger(e, t, this);
	      });
	    },
	    triggerHandler: function (e, t) {
	      var n = this[0];
	      if (n) return S.event.trigger(e, t, n, !0);
	    }
	  }), y.focusin || S.each({
	    focus: "focusin",
	    blur: "focusout"
	  }, function (n, r) {
	    var i = function (e) {
	      S.event.simulate(r, e.target, S.event.fix(e));
	    };

	    S.event.special[r] = {
	      setup: function () {
	        var e = this.ownerDocument || this.document || this,
	            t = Y.access(e, r);
	        t || e.addEventListener(n, i, !0), Y.access(e, r, (t || 0) + 1);
	      },
	      teardown: function () {
	        var e = this.ownerDocument || this.document || this,
	            t = Y.access(e, r) - 1;
	        t ? Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r));
	      }
	    };
	  });
	  var bt = C.location,
	      wt = {
	    guid: Date.now()
	  },
	      Tt = /\?/;

	  S.parseXML = function (e) {
	    var t, n;
	    if (!e || "string" != typeof e) return null;

	    try {
	      t = new C.DOMParser().parseFromString(e, "text/xml");
	    } catch (e) {}

	    return n = t && t.getElementsByTagName("parsererror")[0], t && !n || S.error("Invalid XML: " + (n ? S.map(n.childNodes, function (e) {
	      return e.textContent;
	    }).join("\n") : e)), t;
	  };

	  var Ct = /\[\]$/,
	      Et = /\r?\n/g,
	      St = /^(?:submit|button|image|reset|file)$/i,
	      kt = /^(?:input|select|textarea|keygen)/i;

	  function At(n, e, r, i) {
	    var t;
	    if (Array.isArray(e)) S.each(e, function (e, t) {
	      r || Ct.test(n) ? i(n, t) : At(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i);
	    });else if (r || "object" !== w(e)) i(n, e);else for (t in e) At(n + "[" + t + "]", e[t], r, i);
	  }

	  S.param = function (e, t) {
	    var n,
	        r = [],
	        i = function (e, t) {
	      var n = m(t) ? t() : t;
	      r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);
	    };

	    if (null == e) return "";
	    if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function () {
	      i(this.name, this.value);
	    });else for (n in e) At(n, e[n], t, i);
	    return r.join("&");
	  }, S.fn.extend({
	    serialize: function () {
	      return S.param(this.serializeArray());
	    },
	    serializeArray: function () {
	      return this.map(function () {
	        var e = S.prop(this, "elements");
	        return e ? S.makeArray(e) : this;
	      }).filter(function () {
	        var e = this.type;
	        return this.name && !S(this).is(":disabled") && kt.test(this.nodeName) && !St.test(e) && (this.checked || !pe.test(e));
	      }).map(function (e, t) {
	        var n = S(this).val();
	        return null == n ? null : Array.isArray(n) ? S.map(n, function (e) {
	          return {
	            name: t.name,
	            value: e.replace(Et, "\r\n")
	          };
	        }) : {
	          name: t.name,
	          value: n.replace(Et, "\r\n")
	        };
	      }).get();
	    }
	  });
	  var Nt = /%20/g,
	      jt = /#.*$/,
	      Dt = /([?&])_=[^&]*/,
	      qt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
	      Lt = /^(?:GET|HEAD)$/,
	      Ht = /^\/\//,
	      Ot = {},
	      Pt = {},
	      Rt = "*/".concat("*"),
	      Mt = E.createElement("a");

	  function It(o) {
	    return function (e, t) {
	      "string" != typeof e && (t = e, e = "*");
	      var n,
	          r = 0,
	          i = e.toLowerCase().match(P) || [];
	      if (m(t)) while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t);
	    };
	  }

	  function Wt(t, i, o, a) {
	    var s = {},
	        u = t === Pt;

	    function l(e) {
	      var r;
	      return s[e] = !0, S.each(t[e] || [], function (e, t) {
	        var n = t(i, o, a);
	        return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1);
	      }), r;
	    }

	    return l(i.dataTypes[0]) || !s["*"] && l("*");
	  }

	  function Ft(e, t) {
	    var n,
	        r,
	        i = S.ajaxSettings.flatOptions || {};

	    for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);

	    return r && S.extend(!0, e, r), e;
	  }

	  Mt.href = bt.href, S.extend({
	    active: 0,
	    lastModified: {},
	    etag: {},
	    ajaxSettings: {
	      url: bt.href,
	      type: "GET",
	      isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),
	      global: !0,
	      processData: !0,
	      async: !0,
	      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	      accepts: {
	        "*": Rt,
	        text: "text/plain",
	        html: "text/html",
	        xml: "application/xml, text/xml",
	        json: "application/json, text/javascript"
	      },
	      contents: {
	        xml: /\bxml\b/,
	        html: /\bhtml/,
	        json: /\bjson\b/
	      },
	      responseFields: {
	        xml: "responseXML",
	        text: "responseText",
	        json: "responseJSON"
	      },
	      converters: {
	        "* text": String,
	        "text html": !0,
	        "text json": JSON.parse,
	        "text xml": S.parseXML
	      },
	      flatOptions: {
	        url: !0,
	        context: !0
	      }
	    },
	    ajaxSetup: function (e, t) {
	      return t ? Ft(Ft(e, S.ajaxSettings), t) : Ft(S.ajaxSettings, e);
	    },
	    ajaxPrefilter: It(Ot),
	    ajaxTransport: It(Pt),
	    ajax: function (e, t) {
	      "object" == typeof e && (t = e, e = void 0), t = t || {};
	      var c,
	          f,
	          p,
	          n,
	          d,
	          r,
	          h,
	          g,
	          i,
	          o,
	          v = S.ajaxSetup({}, t),
	          y = v.context || v,
	          m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event,
	          x = S.Deferred(),
	          b = S.Callbacks("once memory"),
	          w = v.statusCode || {},
	          a = {},
	          s = {},
	          u = "canceled",
	          T = {
	        readyState: 0,
	        getResponseHeader: function (e) {
	          var t;

	          if (h) {
	            if (!n) {
	              n = {};

	              while (t = qt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]);
	            }

	            t = n[e.toLowerCase() + " "];
	          }

	          return null == t ? null : t.join(", ");
	        },
	        getAllResponseHeaders: function () {
	          return h ? p : null;
	        },
	        setRequestHeader: function (e, t) {
	          return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this;
	        },
	        overrideMimeType: function (e) {
	          return null == h && (v.mimeType = e), this;
	        },
	        statusCode: function (e) {
	          var t;
	          if (e) if (h) T.always(e[T.status]);else for (t in e) w[t] = [w[t], e[t]];
	          return this;
	        },
	        abort: function (e) {
	          var t = e || u;
	          return c && c.abort(t), l(0, t), this;
	        }
	      };

	      if (x.promise(T), v.url = ((e || v.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [""], null == v.crossDomain) {
	        r = E.createElement("a");

	        try {
	          r.href = v.url, r.href = r.href, v.crossDomain = Mt.protocol + "//" + Mt.host != r.protocol + "//" + r.host;
	        } catch (e) {
	          v.crossDomain = !0;
	        }
	      }

	      if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Wt(Ot, v, t, T), h) return T;

	      for (i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Lt.test(v.type), f = v.url.replace(jt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Nt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Tt.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Dt, "$1"), o = (Tt.test(f) ? "&" : "?") + "_=" + wt.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]);

	      if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort();

	      if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Wt(Pt, v, t, T)) {
	        if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T;
	        v.async && 0 < v.timeout && (d = C.setTimeout(function () {
	          T.abort("timeout");
	        }, v.timeout));

	        try {
	          h = !1, c.send(a, l);
	        } catch (e) {
	          if (h) throw e;
	          l(-1, e);
	        }
	      } else l(-1, "No Transport");

	      function l(e, t, n, r) {
	        var i,
	            o,
	            a,
	            s,
	            u,
	            l = t;
	        h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) {
	          var r,
	              i,
	              o,
	              a,
	              s = e.contents,
	              u = e.dataTypes;

	          while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));

	          if (r) for (i in s) if (s[i] && s[i].test(r)) {
	            u.unshift(i);
	            break;
	          }
	          if (u[0] in n) o = u[0];else {
	            for (i in n) {
	              if (!u[0] || e.converters[i + " " + u[0]]) {
	                o = i;
	                break;
	              }

	              a || (a = i);
	            }

	            o = o || a;
	          }
	          if (o) return o !== u[0] && u.unshift(o), n[o];
	        }(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && S.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function () {}), s = function (e, t, n, r) {
	          var i,
	              o,
	              a,
	              s,
	              u,
	              l = {},
	              c = e.dataTypes.slice();
	          if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
	          o = c.shift();

	          while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u;else if ("*" !== u && u !== o) {
	            if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {
	              !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1]));
	              break;
	            }
	            if (!0 !== a) if (a && e["throws"]) t = a(t);else try {
	              t = a(t);
	            } catch (e) {
	              return {
	                state: "parsererror",
	                error: a ? e : "No conversion from " + u + " to " + o
	              };
	            }
	          }

	          return {
	            state: "success",
	            data: t
	          };
	        }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --S.active || S.event.trigger("ajaxStop")));
	      }

	      return T;
	    },
	    getJSON: function (e, t, n) {
	      return S.get(e, t, n, "json");
	    },
	    getScript: function (e, t) {
	      return S.get(e, void 0, t, "script");
	    }
	  }), S.each(["get", "post"], function (e, i) {
	    S[i] = function (e, t, n, r) {
	      return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({
	        url: e,
	        type: i,
	        dataType: r,
	        data: t,
	        success: n
	      }, S.isPlainObject(e) && e));
	    };
	  }), S.ajaxPrefilter(function (e) {
	    var t;

	    for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "");
	  }), S._evalUrl = function (e, t, n) {
	    return S.ajax({
	      url: e,
	      type: "GET",
	      dataType: "script",
	      cache: !0,
	      async: !1,
	      global: !1,
	      converters: {
	        "text script": function () {}
	      },
	      dataFilter: function (e) {
	        S.globalEval(e, t, n);
	      }
	    });
	  }, S.fn.extend({
	    wrapAll: function (e) {
	      var t;
	      return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
	        var e = this;

	        while (e.firstElementChild) e = e.firstElementChild;

	        return e;
	      }).append(this)), this;
	    },
	    wrapInner: function (n) {
	      return m(n) ? this.each(function (e) {
	        S(this).wrapInner(n.call(this, e));
	      }) : this.each(function () {
	        var e = S(this),
	            t = e.contents();
	        t.length ? t.wrapAll(n) : e.append(n);
	      });
	    },
	    wrap: function (t) {
	      var n = m(t);
	      return this.each(function (e) {
	        S(this).wrapAll(n ? t.call(this, e) : t);
	      });
	    },
	    unwrap: function (e) {
	      return this.parent(e).not("body").each(function () {
	        S(this).replaceWith(this.childNodes);
	      }), this;
	    }
	  }), S.expr.pseudos.hidden = function (e) {
	    return !S.expr.pseudos.visible(e);
	  }, S.expr.pseudos.visible = function (e) {
	    return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
	  }, S.ajaxSettings.xhr = function () {
	    try {
	      return new C.XMLHttpRequest();
	    } catch (e) {}
	  };
	  var Bt = {
	    0: 200,
	    1223: 204
	  },
	      $t = S.ajaxSettings.xhr();
	  y.cors = !!$t && "withCredentials" in $t, y.ajax = $t = !!$t, S.ajaxTransport(function (i) {
	    var o, a;
	    if (y.cors || $t && !i.crossDomain) return {
	      send: function (e, t) {
	        var n,
	            r = i.xhr();
	        if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for (n in i.xhrFields) r[n] = i.xhrFields[n];

	        for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]);

	        o = function (e) {
	          return function () {
	            o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? {
	              binary: r.response
	            } : {
	              text: r.responseText
	            }, r.getAllResponseHeaders()));
	          };
	        }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () {
	          4 === r.readyState && C.setTimeout(function () {
	            o && a();
	          });
	        }, o = o("abort");

	        try {
	          r.send(i.hasContent && i.data || null);
	        } catch (e) {
	          if (o) throw e;
	        }
	      },
	      abort: function () {
	        o && o();
	      }
	    };
	  }), S.ajaxPrefilter(function (e) {
	    e.crossDomain && (e.contents.script = !1);
	  }), S.ajaxSetup({
	    accepts: {
	      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	    },
	    contents: {
	      script: /\b(?:java|ecma)script\b/
	    },
	    converters: {
	      "text script": function (e) {
	        return S.globalEval(e), e;
	      }
	    }
	  }), S.ajaxPrefilter("script", function (e) {
	    void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET");
	  }), S.ajaxTransport("script", function (n) {
	    var r, i;
	    if (n.crossDomain || n.scriptAttrs) return {
	      send: function (e, t) {
	        r = S("<script>").attr(n.scriptAttrs || {}).prop({
	          charset: n.scriptCharset,
	          src: n.url
	        }).on("load error", i = function (e) {
	          r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type);
	        }), E.head.appendChild(r[0]);
	      },
	      abort: function () {
	        i && i();
	      }
	    };
	  });

	  var _t,
	      zt = [],
	      Ut = /(=)\?(?=&|$)|\?\?/;

	  S.ajaxSetup({
	    jsonp: "callback",
	    jsonpCallback: function () {
	      var e = zt.pop() || S.expando + "_" + wt.guid++;
	      return this[e] = !0, e;
	    }
	  }), S.ajaxPrefilter("json jsonp", function (e, t, n) {
	    var r,
	        i,
	        o,
	        a = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data");
	    if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ut, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {
	      return o || S.error(r + " was not called"), o[0];
	    }, e.dataTypes[0] = "json", i = C[r], C[r] = function () {
	      o = arguments;
	    }, n.always(function () {
	      void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, zt.push(r)), o && m(i) && i(o[0]), o = i = void 0;
	    }), "script";
	  }), y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length), S.parseHTML = function (e, t, n) {
	    return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes)));
	    var r, i, o;
	  }, S.fn.load = function (e, t, n) {
	    var r,
	        i,
	        o,
	        a = this,
	        s = e.indexOf(" ");
	    return -1 < s && (r = ht(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && S.ajax({
	      url: e,
	      type: i || "GET",
	      dataType: "html",
	      data: t
	    }).done(function (e) {
	      o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e);
	    }).always(n && function (e, t) {
	      a.each(function () {
	        n.apply(this, o || [e.responseText, t, e]);
	      });
	    }), this;
	  }, S.expr.pseudos.animated = function (t) {
	    return S.grep(S.timers, function (e) {
	      return t === e.elem;
	    }).length;
	  }, S.offset = {
	    setOffset: function (e, t, n) {
	      var r,
	          i,
	          o,
	          a,
	          s,
	          u,
	          l = S.css(e, "position"),
	          c = S(e),
	          f = {};
	      "static" === l && (e.style.position = "relative"), s = c.offset(), o = S.css(e, "top"), u = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f);
	    }
	  }, S.fn.extend({
	    offset: function (t) {
	      if (arguments.length) return void 0 === t ? this : this.each(function (e) {
	        S.offset.setOffset(this, t, e);
	      });
	      var e,
	          n,
	          r = this[0];
	      return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
	        top: e.top + n.pageYOffset,
	        left: e.left + n.pageXOffset
	      }) : {
	        top: 0,
	        left: 0
	      } : void 0;
	    },
	    position: function () {
	      if (this[0]) {
	        var e,
	            t,
	            n,
	            r = this[0],
	            i = {
	          top: 0,
	          left: 0
	        };
	        if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect();else {
	          t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement;

	          while (e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position")) e = e.parentNode;

	          e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0));
	        }
	        return {
	          top: t.top - i.top - S.css(r, "marginTop", !0),
	          left: t.left - i.left - S.css(r, "marginLeft", !0)
	        };
	      }
	    },
	    offsetParent: function () {
	      return this.map(function () {
	        var e = this.offsetParent;

	        while (e && "static" === S.css(e, "position")) e = e.offsetParent;

	        return e || re;
	      });
	    }
	  }), S.each({
	    scrollLeft: "pageXOffset",
	    scrollTop: "pageYOffset"
	  }, function (t, i) {
	    var o = "pageYOffset" === i;

	    S.fn[t] = function (e) {
	      return $(this, function (e, t, n) {
	        var r;
	        if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t];
	        r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n;
	      }, t, e, arguments.length);
	    };
	  }), S.each(["top", "left"], function (e, n) {
	    S.cssHooks[n] = Fe(y.pixelPosition, function (e, t) {
	      if (t) return t = We(e, n), Pe.test(t) ? S(e).position()[n] + "px" : t;
	    });
	  }), S.each({
	    Height: "height",
	    Width: "width"
	  }, function (a, s) {
	    S.each({
	      padding: "inner" + a,
	      content: s,
	      "": "outer" + a
	    }, function (r, o) {
	      S.fn[o] = function (e, t) {
	        var n = arguments.length && (r || "boolean" != typeof e),
	            i = r || (!0 === e || !0 === t ? "margin" : "border");
	        return $(this, function (e, t, n) {
	          var r;
	          return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i);
	        }, s, n ? e : void 0, n);
	      };
	    });
	  }), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
	    S.fn[t] = function (e) {
	      return this.on(t, e);
	    };
	  }), S.fn.extend({
	    bind: function (e, t, n) {
	      return this.on(e, null, t, n);
	    },
	    unbind: function (e, t) {
	      return this.off(e, null, t);
	    },
	    delegate: function (e, t, n, r) {
	      return this.on(t, e, n, r);
	    },
	    undelegate: function (e, t, n) {
	      return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
	    },
	    hover: function (e, t) {
	      return this.mouseenter(e).mouseleave(t || e);
	    }
	  }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, n) {
	    S.fn[n] = function (e, t) {
	      return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n);
	    };
	  });
	  var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
	  S.proxy = function (e, t) {
	    var n, r, i;
	    if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function () {
	      return e.apply(t || this, r.concat(s.call(arguments)));
	    }).guid = e.guid = e.guid || S.guid++, i;
	  }, S.holdReady = function (e) {
	    e ? S.readyWait++ : S.ready(!0);
	  }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) {
	    var t = S.type(e);
	    return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));
	  }, S.trim = function (e) {
	    return null == e ? "" : (e + "").replace(Xt, "");
	  }, "function" == typeof undefined  ;
	  var Vt = C.jQuery,
	      Gt = C.$;
	  return S.noConflict = function (e) {
	    return C.$ === S && (C.$ = Gt), e && C.jQuery === S && (C.jQuery = Vt), S;
	  }, "undefined" == typeof e && (C.jQuery = C.$ = S), S;
	});
	});

	return jquery3_6_0_min;

})));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJqcXVlcnktMy42LjAubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdqcXVlcnkzNjBNaW4nLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmpxdWVyeTM2ME1pbiA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0dmFyIGpxdWVyeTNfNl8wX21pbiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0LyohIGpRdWVyeSB2My42LjAgfCAoYykgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IGpxdWVyeS5vcmcvbGljZW5zZSAqL1xuXHQhZnVuY3Rpb24gKGUsIHQpIHtcblxuXHQgICBtb2R1bGUuZXhwb3J0cyA9IGUuZG9jdW1lbnQgPyB0KGUsICEwKSA6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBpZiAoIWUuZG9jdW1lbnQpIHRocm93IG5ldyBFcnJvcihcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIik7XG5cdCAgICByZXR1cm4gdChlKTtcblx0ICB9IDtcblx0fShcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiBjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24gKEMsIGUpIHtcblxuXHQgIHZhciB0ID0gW10sXG5cdCAgICAgIHIgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG5cdCAgICAgIHMgPSB0LnNsaWNlLFxuXHQgICAgICBnID0gdC5mbGF0ID8gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiB0LmZsYXQuY2FsbChlKTtcblx0ICB9IDogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiB0LmNvbmNhdC5hcHBseShbXSwgZSk7XG5cdCAgfSxcblx0ICAgICAgdSA9IHQucHVzaCxcblx0ICAgICAgaSA9IHQuaW5kZXhPZixcblx0ICAgICAgbiA9IHt9LFxuXHQgICAgICBvID0gbi50b1N0cmluZyxcblx0ICAgICAgdiA9IG4uaGFzT3duUHJvcGVydHksXG5cdCAgICAgIGEgPSB2LnRvU3RyaW5nLFxuXHQgICAgICBsID0gYS5jYWxsKE9iamVjdCksXG5cdCAgICAgIHkgPSB7fSxcblx0ICAgICAgbSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlICYmIFwibnVtYmVyXCIgIT0gdHlwZW9mIGUubm9kZVR5cGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlLml0ZW07XG5cdCAgfSxcblx0ICAgICAgeCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICByZXR1cm4gbnVsbCAhPSBlICYmIGUgPT09IGUud2luZG93O1xuXHQgIH0sXG5cdCAgICAgIEUgPSBDLmRvY3VtZW50LFxuXHQgICAgICBjID0ge1xuXHQgICAgdHlwZTogITAsXG5cdCAgICBzcmM6ICEwLFxuXHQgICAgbm9uY2U6ICEwLFxuXHQgICAgbm9Nb2R1bGU6ICEwXG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIGIoZSwgdCwgbikge1xuXHQgICAgdmFyIHIsXG5cdCAgICAgICAgaSxcblx0ICAgICAgICBvID0gKG4gPSBuIHx8IEUpLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cdCAgICBpZiAoby50ZXh0ID0gZSwgdCkgZm9yIChyIGluIGMpIChpID0gdFtyXSB8fCB0LmdldEF0dHJpYnV0ZSAmJiB0LmdldEF0dHJpYnV0ZShyKSkgJiYgby5zZXRBdHRyaWJ1dGUociwgaSk7XG5cdCAgICBuLmhlYWQuYXBwZW5kQ2hpbGQobykucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB3KGUpIHtcblx0ICAgIHJldHVybiBudWxsID09IGUgPyBlICsgXCJcIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gbltvLmNhbGwoZSldIHx8IFwib2JqZWN0XCIgOiB0eXBlb2YgZTtcblx0ICB9XG5cblx0ICB2YXIgZiA9IFwiMy42LjBcIixcblx0ICAgICAgUyA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICByZXR1cm4gbmV3IFMuZm4uaW5pdChlLCB0KTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gcChlKSB7XG5cdCAgICB2YXIgdCA9ICEhZSAmJiBcImxlbmd0aFwiIGluIGUgJiYgZS5sZW5ndGgsXG5cdCAgICAgICAgbiA9IHcoZSk7XG5cdCAgICByZXR1cm4gIW0oZSkgJiYgIXgoZSkgJiYgKFwiYXJyYXlcIiA9PT0gbiB8fCAwID09PSB0IHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgJiYgMCA8IHQgJiYgdCAtIDEgaW4gZSk7XG5cdCAgfVxuXG5cdCAgUy5mbiA9IFMucHJvdG90eXBlID0ge1xuXHQgICAganF1ZXJ5OiBmLFxuXHQgICAgY29uc3RydWN0b3I6IFMsXG5cdCAgICBsZW5ndGg6IDAsXG5cdCAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBzLmNhbGwodGhpcyk7XG5cdCAgICB9LFxuXHQgICAgZ2V0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gbnVsbCA9PSBlID8gcy5jYWxsKHRoaXMpIDogZSA8IDAgPyB0aGlzW2UgKyB0aGlzLmxlbmd0aF0gOiB0aGlzW2VdO1xuXHQgICAgfSxcblx0ICAgIHB1c2hTdGFjazogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQgPSBTLm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSwgZSk7XG5cdCAgICAgIHJldHVybiB0LnByZXZPYmplY3QgPSB0aGlzLCB0O1xuXHQgICAgfSxcblx0ICAgIGVhY2g6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBTLmVhY2godGhpcywgZSk7XG5cdCAgICB9LFxuXHQgICAgbWFwOiBmdW5jdGlvbiAobikge1xuXHQgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soUy5tYXAodGhpcywgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICByZXR1cm4gbi5jYWxsKGUsIHQsIGUpO1xuXHQgICAgICB9KSk7XG5cdCAgICB9LFxuXHQgICAgc2xpY2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgICB9LFxuXHQgICAgZmlyc3Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZXEoMCk7XG5cdCAgICB9LFxuXHQgICAgbGFzdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5lcSgtMSk7XG5cdCAgICB9LFxuXHQgICAgZXZlbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soUy5ncmVwKHRoaXMsIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgcmV0dXJuICh0ICsgMSkgJSAyO1xuXHQgICAgICB9KSk7XG5cdCAgICB9LFxuXHQgICAgb2RkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhTLmdyZXAodGhpcywgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICByZXR1cm4gdCAlIDI7XG5cdCAgICAgIH0pKTtcblx0ICAgIH0sXG5cdCAgICBlcTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQgPSB0aGlzLmxlbmd0aCxcblx0ICAgICAgICAgIG4gPSArZSArIChlIDwgMCA/IHQgOiAwKTtcblx0ICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKDAgPD0gbiAmJiBuIDwgdCA/IFt0aGlzW25dXSA6IFtdKTtcblx0ICAgIH0sXG5cdCAgICBlbmQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdCAgICB9LFxuXHQgICAgcHVzaDogdSxcblx0ICAgIHNvcnQ6IHQuc29ydCxcblx0ICAgIHNwbGljZTogdC5zcGxpY2Vcblx0ICB9LCBTLmV4dGVuZCA9IFMuZm4uZXh0ZW5kID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGUsXG5cdCAgICAgICAgdCxcblx0ICAgICAgICBuLFxuXHQgICAgICAgIHIsXG5cdCAgICAgICAgaSxcblx0ICAgICAgICBvLFxuXHQgICAgICAgIGEgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdCAgICAgICAgcyA9IDEsXG5cdCAgICAgICAgdSA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdCAgICAgICAgbCA9ICExO1xuXG5cdCAgICBmb3IgKFwiYm9vbGVhblwiID09IHR5cGVvZiBhICYmIChsID0gYSwgYSA9IGFyZ3VtZW50c1tzXSB8fCB7fSwgcysrKSwgXCJvYmplY3RcIiA9PSB0eXBlb2YgYSB8fCBtKGEpIHx8IChhID0ge30pLCBzID09PSB1ICYmIChhID0gdGhpcywgcy0tKTsgcyA8IHU7IHMrKykgaWYgKG51bGwgIT0gKGUgPSBhcmd1bWVudHNbc10pKSBmb3IgKHQgaW4gZSkgciA9IGVbdF0sIFwiX19wcm90b19fXCIgIT09IHQgJiYgYSAhPT0gciAmJiAobCAmJiByICYmIChTLmlzUGxhaW5PYmplY3QocikgfHwgKGkgPSBBcnJheS5pc0FycmF5KHIpKSkgPyAobiA9IGFbdF0sIG8gPSBpICYmICFBcnJheS5pc0FycmF5KG4pID8gW10gOiBpIHx8IFMuaXNQbGFpbk9iamVjdChuKSA/IG4gOiB7fSwgaSA9ICExLCBhW3RdID0gUy5leHRlbmQobCwgbywgcikpIDogdm9pZCAwICE9PSByICYmIChhW3RdID0gcikpO1xuXG5cdCAgICByZXR1cm4gYTtcblx0ICB9LCBTLmV4dGVuZCh7XG5cdCAgICBleHBhbmRvOiBcImpRdWVyeVwiICsgKGYgKyBNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXEQvZywgXCJcIiksXG5cdCAgICBpc1JlYWR5OiAhMCxcblx0ICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG5cdCAgICB9LFxuXHQgICAgbm9vcDogZnVuY3Rpb24gKCkge30sXG5cdCAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdCwgbjtcblx0ICAgICAgcmV0dXJuICEoIWUgfHwgXCJbb2JqZWN0IE9iamVjdF1cIiAhPT0gby5jYWxsKGUpKSAmJiAoISh0ID0gcihlKSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiAobiA9IHYuY2FsbCh0LCBcImNvbnN0cnVjdG9yXCIpICYmIHQuY29uc3RydWN0b3IpICYmIGEuY2FsbChuKSA9PT0gbCk7XG5cdCAgICB9LFxuXHQgICAgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQ7XG5cblx0ICAgICAgZm9yICh0IGluIGUpIHJldHVybiAhMTtcblxuXHQgICAgICByZXR1cm4gITA7XG5cdCAgICB9LFxuXHQgICAgZ2xvYmFsRXZhbDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgYihlLCB7XG5cdCAgICAgICAgbm9uY2U6IHQgJiYgdC5ub25jZVxuXHQgICAgICB9LCBuKTtcblx0ICAgIH0sXG5cdCAgICBlYWNoOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbixcblx0ICAgICAgICAgIHIgPSAwO1xuXG5cdCAgICAgIGlmIChwKGUpKSB7XG5cdCAgICAgICAgZm9yIChuID0gZS5sZW5ndGg7IHIgPCBuOyByKyspIGlmICghMSA9PT0gdC5jYWxsKGVbcl0sIHIsIGVbcl0pKSBicmVhaztcblx0ICAgICAgfSBlbHNlIGZvciAociBpbiBlKSBpZiAoITEgPT09IHQuY2FsbChlW3JdLCByLCBlW3JdKSkgYnJlYWs7XG5cblx0ICAgICAgcmV0dXJuIGU7XG5cdCAgICB9LFxuXHQgICAgbWFrZUFycmF5OiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbiA9IHQgfHwgW107XG5cdCAgICAgIHJldHVybiBudWxsICE9IGUgJiYgKHAoT2JqZWN0KGUpKSA/IFMubWVyZ2UobiwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IFtlXSA6IGUpIDogdS5jYWxsKG4sIGUpKSwgbjtcblx0ICAgIH0sXG5cdCAgICBpbkFycmF5OiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gbnVsbCA9PSB0ID8gLTEgOiBpLmNhbGwodCwgZSwgbik7XG5cdCAgICB9LFxuXHQgICAgbWVyZ2U6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIGZvciAodmFyIG4gPSArdC5sZW5ndGgsIHIgPSAwLCBpID0gZS5sZW5ndGg7IHIgPCBuOyByKyspIGVbaSsrXSA9IHRbcl07XG5cblx0ICAgICAgcmV0dXJuIGUubGVuZ3RoID0gaSwgZTtcblx0ICAgIH0sXG5cdCAgICBncmVwOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICBmb3IgKHZhciByID0gW10sIGkgPSAwLCBvID0gZS5sZW5ndGgsIGEgPSAhbjsgaSA8IG87IGkrKykgIXQoZVtpXSwgaSkgIT09IGEgJiYgci5wdXNoKGVbaV0pO1xuXG5cdCAgICAgIHJldHVybiByO1xuXHQgICAgfSxcblx0ICAgIG1hcDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgdmFyIHIsXG5cdCAgICAgICAgICBpLFxuXHQgICAgICAgICAgbyA9IDAsXG5cdCAgICAgICAgICBhID0gW107XG5cdCAgICAgIGlmIChwKGUpKSBmb3IgKHIgPSBlLmxlbmd0aDsgbyA8IHI7IG8rKykgbnVsbCAhPSAoaSA9IHQoZVtvXSwgbywgbikpICYmIGEucHVzaChpKTtlbHNlIGZvciAobyBpbiBlKSBudWxsICE9IChpID0gdChlW29dLCBvLCBuKSkgJiYgYS5wdXNoKGkpO1xuXHQgICAgICByZXR1cm4gZyhhKTtcblx0ICAgIH0sXG5cdCAgICBndWlkOiAxLFxuXHQgICAgc3VwcG9ydDogeVxuXHQgIH0pLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiAoUy5mbltTeW1ib2wuaXRlcmF0b3JdID0gdFtTeW1ib2wuaXRlcmF0b3JdKSwgUy5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICBuW1wiW29iamVjdCBcIiArIHQgKyBcIl1cIl0gPSB0LnRvTG93ZXJDYXNlKCk7XG5cdCAgfSk7XG5cblx0ICB2YXIgZCA9IGZ1bmN0aW9uIChuKSB7XG5cdCAgICB2YXIgZSxcblx0ICAgICAgICBkLFxuXHQgICAgICAgIGIsXG5cdCAgICAgICAgbyxcblx0ICAgICAgICBpLFxuXHQgICAgICAgIGgsXG5cdCAgICAgICAgZixcblx0ICAgICAgICBnLFxuXHQgICAgICAgIHcsXG5cdCAgICAgICAgdSxcblx0ICAgICAgICBsLFxuXHQgICAgICAgIFQsXG5cdCAgICAgICAgQyxcblx0ICAgICAgICBhLFxuXHQgICAgICAgIEUsXG5cdCAgICAgICAgdixcblx0ICAgICAgICBzLFxuXHQgICAgICAgIGMsXG5cdCAgICAgICAgeSxcblx0ICAgICAgICBTID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHQgICAgICAgIHAgPSBuLmRvY3VtZW50LFxuXHQgICAgICAgIGsgPSAwLFxuXHQgICAgICAgIHIgPSAwLFxuXHQgICAgICAgIG0gPSB1ZSgpLFxuXHQgICAgICAgIHggPSB1ZSgpLFxuXHQgICAgICAgIEEgPSB1ZSgpLFxuXHQgICAgICAgIE4gPSB1ZSgpLFxuXHQgICAgICAgIGogPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gZSA9PT0gdCAmJiAobCA9ICEwKSwgMDtcblx0ICAgIH0sXG5cdCAgICAgICAgRCA9IHt9Lmhhc093blByb3BlcnR5LFxuXHQgICAgICAgIHQgPSBbXSxcblx0ICAgICAgICBxID0gdC5wb3AsXG5cdCAgICAgICAgTCA9IHQucHVzaCxcblx0ICAgICAgICBIID0gdC5wdXNoLFxuXHQgICAgICAgIE8gPSB0LnNsaWNlLFxuXHQgICAgICAgIFAgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICBmb3IgKHZhciBuID0gMCwgciA9IGUubGVuZ3RoOyBuIDwgcjsgbisrKSBpZiAoZVtuXSA9PT0gdCkgcmV0dXJuIG47XG5cblx0ICAgICAgcmV0dXJuIC0xO1xuXHQgICAgfSxcblx0ICAgICAgICBSID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXHQgICAgICAgIE0gPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cdCAgICAgICAgSSA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIE0gKyBcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuXHQgICAgICAgIFcgPSBcIlxcXFxbXCIgKyBNICsgXCIqKFwiICsgSSArIFwiKSg/OlwiICsgTSArIFwiKihbKl4kfCF+XT89KVwiICsgTSArIFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBJICsgXCIpKXwpXCIgKyBNICsgXCIqXFxcXF1cIixcblx0ICAgICAgICBGID0gXCI6KFwiICsgSSArIFwiKSg/OlxcXFwoKCgnKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIFcgKyBcIikqKXwuKilcXFxcKXwpXCIsXG5cdCAgICAgICAgQiA9IG5ldyBSZWdFeHAoTSArIFwiK1wiLCBcImdcIiksXG5cdCAgICAgICAgJCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBNICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgTSArIFwiKyRcIiwgXCJnXCIpLFxuXHQgICAgICAgIF8gPSBuZXcgUmVnRXhwKFwiXlwiICsgTSArIFwiKixcIiArIE0gKyBcIipcIiksXG5cdCAgICAgICAgeiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBNICsgXCIqKFs+K35dfFwiICsgTSArIFwiKVwiICsgTSArIFwiKlwiKSxcblx0ICAgICAgICBVID0gbmV3IFJlZ0V4cChNICsgXCJ8PlwiKSxcblx0ICAgICAgICBYID0gbmV3IFJlZ0V4cChGKSxcblx0ICAgICAgICBWID0gbmV3IFJlZ0V4cChcIl5cIiArIEkgKyBcIiRcIiksXG5cdCAgICAgICAgRyA9IHtcblx0ICAgICAgSUQ6IG5ldyBSZWdFeHAoXCJeIyhcIiArIEkgKyBcIilcIiksXG5cdCAgICAgIENMQVNTOiBuZXcgUmVnRXhwKFwiXlxcXFwuKFwiICsgSSArIFwiKVwiKSxcblx0ICAgICAgVEFHOiBuZXcgUmVnRXhwKFwiXihcIiArIEkgKyBcInxbKl0pXCIpLFxuXHQgICAgICBBVFRSOiBuZXcgUmVnRXhwKFwiXlwiICsgVyksXG5cdCAgICAgIFBTRVVETzogbmV3IFJlZ0V4cChcIl5cIiArIEYpLFxuXHQgICAgICBDSElMRDogbmV3IFJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyBNICsgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIE0gKyBcIiooPzooWystXXwpXCIgKyBNICsgXCIqKFxcXFxkKyl8KSlcIiArIE0gKyBcIipcXFxcKXwpXCIsIFwiaVwiKSxcblx0ICAgICAgYm9vbDogbmV3IFJlZ0V4cChcIl4oPzpcIiArIFIgKyBcIikkXCIsIFwiaVwiKSxcblx0ICAgICAgbmVlZHNDb250ZXh0OiBuZXcgUmVnRXhwKFwiXlwiICsgTSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIE0gKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyBNICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIpXG5cdCAgICB9LFxuXHQgICAgICAgIFkgPSAvSFRNTCQvaSxcblx0ICAgICAgICBRID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0ICAgICAgICBKID0gL15oXFxkJC9pLFxuXHQgICAgICAgIEsgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXHQgICAgICAgIFogPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblx0ICAgICAgICBlZSA9IC9bK35dLyxcblx0ICAgICAgICB0ZSA9IG5ldyBSZWdFeHAoXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgTSArIFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiKSxcblx0ICAgICAgICBuZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHZhciBuID0gXCIweFwiICsgZS5zbGljZSgxKSAtIDY1NTM2O1xuXHQgICAgICByZXR1cm4gdCB8fCAobiA8IDAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKG4gKyA2NTUzNikgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4gPj4gMTAgfCA1NTI5NiwgMTAyMyAmIG4gfCA1NjMyMCkpO1xuXHQgICAgfSxcblx0ICAgICAgICByZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHQgICAgICAgIGllID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgcmV0dXJuIHQgPyBcIlxcMFwiID09PSBlID8gXCJcXHVmZmZkXCIgOiBlLnNsaWNlKDAsIC0xKSArIFwiXFxcXFwiICsgZS5jaGFyQ29kZUF0KGUubGVuZ3RoIC0gMSkudG9TdHJpbmcoMTYpICsgXCIgXCIgOiBcIlxcXFxcIiArIGU7XG5cdCAgICB9LFxuXHQgICAgICAgIG9lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBUKCk7XG5cdCAgICB9LFxuXHQgICAgICAgIGFlID0gYmUoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuICEwID09PSBlLmRpc2FibGVkICYmIFwiZmllbGRzZXRcIiA9PT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgfSwge1xuXHQgICAgICBkaXI6IFwicGFyZW50Tm9kZVwiLFxuXHQgICAgICBuZXh0OiBcImxlZ2VuZFwiXG5cdCAgICB9KTtcblxuXHQgICAgdHJ5IHtcblx0ICAgICAgSC5hcHBseSh0ID0gTy5jYWxsKHAuY2hpbGROb2RlcyksIHAuY2hpbGROb2RlcyksIHRbcC5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGU7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIEggPSB7XG5cdCAgICAgICAgYXBwbHk6IHQubGVuZ3RoID8gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICAgIEwuYXBwbHkoZSwgTy5jYWxsKHQpKTtcblx0ICAgICAgICB9IDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICAgIHZhciBuID0gZS5sZW5ndGgsXG5cdCAgICAgICAgICAgICAgciA9IDA7XG5cblx0ICAgICAgICAgIHdoaWxlIChlW24rK10gPSB0W3IrK10pO1xuXG5cdCAgICAgICAgICBlLmxlbmd0aCA9IG4gLSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gc2UodCwgZSwgbiwgcikge1xuXHQgICAgICB2YXIgaSxcblx0ICAgICAgICAgIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyxcblx0ICAgICAgICAgIHUsXG5cdCAgICAgICAgICBsLFxuXHQgICAgICAgICAgYyxcblx0ICAgICAgICAgIGYgPSBlICYmIGUub3duZXJEb2N1bWVudCxcblx0ICAgICAgICAgIHAgPSBlID8gZS5ub2RlVHlwZSA6IDk7XG5cdCAgICAgIGlmIChuID0gbiB8fCBbXSwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgdCB8fCAhdCB8fCAxICE9PSBwICYmIDkgIT09IHAgJiYgMTEgIT09IHApIHJldHVybiBuO1xuXG5cdCAgICAgIGlmICghciAmJiAoVChlKSwgZSA9IGUgfHwgQywgRSkpIHtcblx0ICAgICAgICBpZiAoMTEgIT09IHAgJiYgKHUgPSBaLmV4ZWModCkpKSBpZiAoaSA9IHVbMV0pIHtcblx0ICAgICAgICAgIGlmICg5ID09PSBwKSB7XG5cdCAgICAgICAgICAgIGlmICghKGEgPSBlLmdldEVsZW1lbnRCeUlkKGkpKSkgcmV0dXJuIG47XG5cdCAgICAgICAgICAgIGlmIChhLmlkID09PSBpKSByZXR1cm4gbi5wdXNoKGEpLCBuO1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChmICYmIChhID0gZi5nZXRFbGVtZW50QnlJZChpKSkgJiYgeShlLCBhKSAmJiBhLmlkID09PSBpKSByZXR1cm4gbi5wdXNoKGEpLCBuO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpZiAodVsyXSkgcmV0dXJuIEguYXBwbHkobiwgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0KSksIG47XG5cdCAgICAgICAgICBpZiAoKGkgPSB1WzNdKSAmJiBkLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSByZXR1cm4gSC5hcHBseShuLCBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaSkpLCBuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChkLnFzYSAmJiAhTlt0ICsgXCIgXCJdICYmICghdiB8fCAhdi50ZXN0KHQpKSAmJiAoMSAhPT0gcCB8fCBcIm9iamVjdFwiICE9PSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG5cdCAgICAgICAgICBpZiAoYyA9IHQsIGYgPSBlLCAxID09PSBwICYmIChVLnRlc3QodCkgfHwgei50ZXN0KHQpKSkge1xuXHQgICAgICAgICAgICAoZiA9IGVlLnRlc3QodCkgJiYgeWUoZS5wYXJlbnROb2RlKSB8fCBlKSA9PT0gZSAmJiBkLnNjb3BlIHx8ICgocyA9IGUuZ2V0QXR0cmlidXRlKFwiaWRcIikpID8gcyA9IHMucmVwbGFjZShyZSwgaWUpIDogZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzID0gUykpLCBvID0gKGwgPSBoKHQpKS5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgd2hpbGUgKG8tLSkgbFtvXSA9IChzID8gXCIjXCIgKyBzIDogXCI6c2NvcGVcIikgKyBcIiBcIiArIHhlKGxbb10pO1xuXG5cdCAgICAgICAgICAgIGMgPSBsLmpvaW4oXCIsXCIpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gSC5hcHBseShuLCBmLnF1ZXJ5U2VsZWN0b3JBbGwoYykpLCBuO1xuXHQgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICBOKHQsICEwKTtcblx0ICAgICAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgICAgIHMgPT09IFMgJiYgZS5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZyh0LnJlcGxhY2UoJCwgXCIkMVwiKSwgZSwgbiwgcik7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHVlKCkge1xuXHQgICAgICB2YXIgciA9IFtdO1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gZSh0LCBuKSB7XG5cdCAgICAgICAgcmV0dXJuIHIucHVzaCh0ICsgXCIgXCIpID4gYi5jYWNoZUxlbmd0aCAmJiBkZWxldGUgZVtyLnNoaWZ0KCldLCBlW3QgKyBcIiBcIl0gPSBuO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBsZShlKSB7XG5cdCAgICAgIHJldHVybiBlW1NdID0gITAsIGU7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNlKGUpIHtcblx0ICAgICAgdmFyIHQgPSBDLmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiAhIWUodCk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSwgdCA9IG51bGw7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZmUoZSwgdCkge1xuXHQgICAgICB2YXIgbiA9IGUuc3BsaXQoXCJ8XCIpLFxuXHQgICAgICAgICAgciA9IG4ubGVuZ3RoO1xuXG5cdCAgICAgIHdoaWxlIChyLS0pIGIuYXR0ckhhbmRsZVtuW3JdXSA9IHQ7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHBlKGUsIHQpIHtcblx0ICAgICAgdmFyIG4gPSB0ICYmIGUsXG5cdCAgICAgICAgICByID0gbiAmJiAxID09PSBlLm5vZGVUeXBlICYmIDEgPT09IHQubm9kZVR5cGUgJiYgZS5zb3VyY2VJbmRleCAtIHQuc291cmNlSW5kZXg7XG5cdCAgICAgIGlmIChyKSByZXR1cm4gcjtcblx0ICAgICAgaWYgKG4pIHdoaWxlIChuID0gbi5uZXh0U2libGluZykgaWYgKG4gPT09IHQpIHJldHVybiAtMTtcblx0ICAgICAgcmV0dXJuIGUgPyAxIDogLTE7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGRlKHQpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiaW5wdXRcIiA9PT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIGUudHlwZSA9PT0gdDtcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaGUobikge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdCA9IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICByZXR1cm4gKFwiaW5wdXRcIiA9PT0gdCB8fCBcImJ1dHRvblwiID09PSB0KSAmJiBlLnR5cGUgPT09IG47XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGdlKHQpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiZm9ybVwiIGluIGUgPyBlLnBhcmVudE5vZGUgJiYgITEgPT09IGUuZGlzYWJsZWQgPyBcImxhYmVsXCIgaW4gZSA/IFwibGFiZWxcIiBpbiBlLnBhcmVudE5vZGUgPyBlLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IHQgOiBlLmRpc2FibGVkID09PSB0IDogZS5pc0Rpc2FibGVkID09PSB0IHx8IGUuaXNEaXNhYmxlZCAhPT0gIXQgJiYgYWUoZSkgPT09IHQgOiBlLmRpc2FibGVkID09PSB0IDogXCJsYWJlbFwiIGluIGUgJiYgZS5kaXNhYmxlZCA9PT0gdDtcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gdmUoYSkge1xuXHQgICAgICByZXR1cm4gbGUoZnVuY3Rpb24gKG8pIHtcblx0ICAgICAgICByZXR1cm4gbyA9ICtvLCBsZShmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgICAgdmFyIG4sXG5cdCAgICAgICAgICAgICAgciA9IGEoW10sIGUubGVuZ3RoLCBvKSxcblx0ICAgICAgICAgICAgICBpID0gci5sZW5ndGg7XG5cblx0ICAgICAgICAgIHdoaWxlIChpLS0pIGVbbiA9IHJbaV1dICYmIChlW25dID0gISh0W25dID0gZVtuXSkpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24geWUoZSkge1xuXHQgICAgICByZXR1cm4gZSAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lICYmIGU7XG5cdCAgICB9XG5cblx0ICAgIGZvciAoZSBpbiBkID0gc2Uuc3VwcG9ydCA9IHt9LCBpID0gc2UuaXNYTUwgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdCA9IGUgJiYgZS5uYW1lc3BhY2VVUkksXG5cdCAgICAgICAgICBuID0gZSAmJiAoZS5vd25lckRvY3VtZW50IHx8IGUpLmRvY3VtZW50RWxlbWVudDtcblx0ICAgICAgcmV0dXJuICFZLnRlc3QodCB8fCBuICYmIG4ubm9kZU5hbWUgfHwgXCJIVE1MXCIpO1xuXHQgICAgfSwgVCA9IHNlLnNldERvY3VtZW50ID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQsXG5cdCAgICAgICAgICBuLFxuXHQgICAgICAgICAgciA9IGUgPyBlLm93bmVyRG9jdW1lbnQgfHwgZSA6IHA7XG5cdCAgICAgIHJldHVybiByICE9IEMgJiYgOSA9PT0gci5ub2RlVHlwZSAmJiByLmRvY3VtZW50RWxlbWVudCAmJiAoYSA9IChDID0gcikuZG9jdW1lbnRFbGVtZW50LCBFID0gIWkoQyksIHAgIT0gQyAmJiAobiA9IEMuZGVmYXVsdFZpZXcpICYmIG4udG9wICE9PSBuICYmIChuLmFkZEV2ZW50TGlzdGVuZXIgPyBuLmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgb2UsICExKSA6IG4uYXR0YWNoRXZlbnQgJiYgbi5hdHRhY2hFdmVudChcIm9udW5sb2FkXCIsIG9lKSksIGQuc2NvcGUgPSBjZShmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHJldHVybiBhLmFwcGVuZENoaWxkKGUpLmFwcGVuZENoaWxkKEMuY3JlYXRlRWxlbWVudChcImRpdlwiKSksIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGUucXVlcnlTZWxlY3RvckFsbCAmJiAhZS5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlIGZpZWxkc2V0IGRpdlwiKS5sZW5ndGg7XG5cdCAgICAgIH0pLCBkLmF0dHJpYnV0ZXMgPSBjZShmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHJldHVybiBlLmNsYXNzTmFtZSA9IFwiaVwiLCAhZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdCAgICAgIH0pLCBkLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gY2UoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICByZXR1cm4gZS5hcHBlbmRDaGlsZChDLmNyZWF0ZUNvbW1lbnQoXCJcIikpLCAhZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHQgICAgICB9KSwgZC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gSy50ZXN0KEMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSksIGQuZ2V0QnlJZCA9IGNlKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIGEuYXBwZW5kQ2hpbGQoZSkuaWQgPSBTLCAhQy5nZXRFbGVtZW50c0J5TmFtZSB8fCAhQy5nZXRFbGVtZW50c0J5TmFtZShTKS5sZW5ndGg7XG5cdCAgICAgIH0pLCBkLmdldEJ5SWQgPyAoYi5maWx0ZXIuSUQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciB0ID0gZS5yZXBsYWNlKHRlLCBuZSk7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gdDtcblx0ICAgICAgICB9O1xuXHQgICAgICB9LCBiLmZpbmQuSUQgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0LmdldEVsZW1lbnRCeUlkICYmIEUpIHtcblx0ICAgICAgICAgIHZhciBuID0gdC5nZXRFbGVtZW50QnlJZChlKTtcblx0ICAgICAgICAgIHJldHVybiBuID8gW25dIDogW107XG5cdCAgICAgICAgfVxuXHQgICAgICB9KSA6IChiLmZpbHRlci5JRCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIG4gPSBlLnJlcGxhY2UodGUsIG5lKTtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRBdHRyaWJ1dGVOb2RlICYmIGUuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHQgICAgICAgICAgcmV0dXJuIHQgJiYgdC52YWx1ZSA9PT0gbjtcblx0ICAgICAgICB9O1xuXHQgICAgICB9LCBiLmZpbmQuSUQgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0LmdldEVsZW1lbnRCeUlkICYmIEUpIHtcblx0ICAgICAgICAgIHZhciBuLFxuXHQgICAgICAgICAgICAgIHIsXG5cdCAgICAgICAgICAgICAgaSxcblx0ICAgICAgICAgICAgICBvID0gdC5nZXRFbGVtZW50QnlJZChlKTtcblxuXHQgICAgICAgICAgaWYgKG8pIHtcblx0ICAgICAgICAgICAgaWYgKChuID0gby5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikpICYmIG4udmFsdWUgPT09IGUpIHJldHVybiBbb107XG5cdCAgICAgICAgICAgIGkgPSB0LmdldEVsZW1lbnRzQnlOYW1lKGUpLCByID0gMDtcblxuXHQgICAgICAgICAgICB3aGlsZSAobyA9IGlbcisrXSkgaWYgKChuID0gby5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikpICYmIG4udmFsdWUgPT09IGUpIHJldHVybiBbb107XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pLCBiLmZpbmQuVEFHID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyB0LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpIDogZC5xc2EgPyB0LnF1ZXJ5U2VsZWN0b3JBbGwoZSkgOiB2b2lkIDA7XG5cdCAgICAgIH0gOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIHZhciBuLFxuXHQgICAgICAgICAgICByID0gW10sXG5cdCAgICAgICAgICAgIGkgPSAwLFxuXHQgICAgICAgICAgICBvID0gdC5nZXRFbGVtZW50c0J5VGFnTmFtZShlKTtcblxuXHQgICAgICAgIGlmIChcIipcIiA9PT0gZSkge1xuXHQgICAgICAgICAgd2hpbGUgKG4gPSBvW2krK10pIDEgPT09IG4ubm9kZVR5cGUgJiYgci5wdXNoKG4pO1xuXG5cdCAgICAgICAgICByZXR1cm4gcjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbztcblx0ICAgICAgfSwgYi5maW5kLkNMQVNTID0gZC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBFKSByZXR1cm4gdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGUpO1xuXHQgICAgICB9LCBzID0gW10sIHYgPSBbXSwgKGQucXNhID0gSy50ZXN0KEMucXVlcnlTZWxlY3RvckFsbCkpICYmIChjZShmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciB0O1xuXHQgICAgICAgIGEuYXBwZW5kQ2hpbGQoZSkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBTICsgXCInPjwvYT48c2VsZWN0IGlkPSdcIiArIFMgKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggJiYgdi5wdXNoKFwiWypeJF09XCIgKyBNICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCB8fCB2LnB1c2goXCJcXFxcW1wiICsgTSArIFwiKig/OnZhbHVlfFwiICsgUiArIFwiKVwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIiArIFMgKyBcIi1dXCIpLmxlbmd0aCB8fCB2LnB1c2goXCJ+PVwiKSwgKHQgPSBDLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIlwiKSwgZS5hcHBlbmRDaGlsZCh0KSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9JyddXCIpLmxlbmd0aCB8fCB2LnB1c2goXCJcXFxcW1wiICsgTSArIFwiKm5hbWVcIiArIE0gKyBcIio9XCIgKyBNICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggfHwgdi5wdXNoKFwiOmNoZWNrZWRcIiksIGUucXVlcnlTZWxlY3RvckFsbChcImEjXCIgKyBTICsgXCIrKlwiKS5sZW5ndGggfHwgdi5wdXNoKFwiLiMuK1srfl1cIiksIGUucXVlcnlTZWxlY3RvckFsbChcIlxcXFxcXGZcIiksIHYucHVzaChcIltcXFxcclxcXFxuXFxcXGZdXCIpO1xuXHQgICAgICB9KSwgY2UoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBlLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT48c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cdCAgICAgICAgdmFyIHQgPSBDLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0ICAgICAgICB0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJoaWRkZW5cIiksIGUuYXBwZW5kQ2hpbGQodCkuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIkRcIiksIGUucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCAmJiB2LnB1c2goXCJuYW1lXCIgKyBNICsgXCIqWypeJHwhfl0/PVwiKSwgMiAhPT0gZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICYmIHYucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpLCBhLmFwcGVuZENoaWxkKGUpLmRpc2FibGVkID0gITAsIDIgIT09IGUucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggJiYgdi5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiksIGUucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIiksIHYucHVzaChcIiwuKjpcIik7XG5cdCAgICAgIH0pKSwgKGQubWF0Y2hlc1NlbGVjdG9yID0gSy50ZXN0KGMgPSBhLm1hdGNoZXMgfHwgYS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgYS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgYS5vTWF0Y2hlc1NlbGVjdG9yIHx8IGEubXNNYXRjaGVzU2VsZWN0b3IpKSAmJiBjZShmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIGQuZGlzY29ubmVjdGVkTWF0Y2ggPSBjLmNhbGwoZSwgXCIqXCIpLCBjLmNhbGwoZSwgXCJbcyE9JyddOnhcIiksIHMucHVzaChcIiE9XCIsIEYpO1xuXHQgICAgICB9KSwgdiA9IHYubGVuZ3RoICYmIG5ldyBSZWdFeHAodi5qb2luKFwifFwiKSksIHMgPSBzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHMuam9pbihcInxcIikpLCB0ID0gSy50ZXN0KGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24pLCB5ID0gdCB8fCBLLnRlc3QoYS5jb250YWlucykgPyBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIHZhciBuID0gOSA9PT0gZS5ub2RlVHlwZSA/IGUuZG9jdW1lbnRFbGVtZW50IDogZSxcblx0ICAgICAgICAgICAgciA9IHQgJiYgdC5wYXJlbnROb2RlO1xuXHQgICAgICAgIHJldHVybiBlID09PSByIHx8ICEoIXIgfHwgMSAhPT0gci5ub2RlVHlwZSB8fCAhKG4uY29udGFpbnMgPyBuLmNvbnRhaW5zKHIpIDogZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiAxNiAmIGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ocikpKTtcblx0ICAgICAgfSA6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgaWYgKHQpIHdoaWxlICh0ID0gdC5wYXJlbnROb2RlKSBpZiAodCA9PT0gZSkgcmV0dXJuICEwO1xuXHQgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgfSwgaiA9IHQgPyBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIGlmIChlID09PSB0KSByZXR1cm4gbCA9ICEwLCAwO1xuXHQgICAgICAgIHZhciBuID0gIWUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0ICAgICAgICByZXR1cm4gbiB8fCAoMSAmIChuID0gKGUub3duZXJEb2N1bWVudCB8fCBlKSA9PSAodC5vd25lckRvY3VtZW50IHx8IHQpID8gZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KSA6IDEpIHx8ICFkLnNvcnREZXRhY2hlZCAmJiB0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGUpID09PSBuID8gZSA9PSBDIHx8IGUub3duZXJEb2N1bWVudCA9PSBwICYmIHkocCwgZSkgPyAtMSA6IHQgPT0gQyB8fCB0Lm93bmVyRG9jdW1lbnQgPT0gcCAmJiB5KHAsIHQpID8gMSA6IHUgPyBQKHUsIGUpIC0gUCh1LCB0KSA6IDAgOiA0ICYgbiA/IC0xIDogMSk7XG5cdCAgICAgIH0gOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIGlmIChlID09PSB0KSByZXR1cm4gbCA9ICEwLCAwO1xuXHQgICAgICAgIHZhciBuLFxuXHQgICAgICAgICAgICByID0gMCxcblx0ICAgICAgICAgICAgaSA9IGUucGFyZW50Tm9kZSxcblx0ICAgICAgICAgICAgbyA9IHQucGFyZW50Tm9kZSxcblx0ICAgICAgICAgICAgYSA9IFtlXSxcblx0ICAgICAgICAgICAgcyA9IFt0XTtcblx0ICAgICAgICBpZiAoIWkgfHwgIW8pIHJldHVybiBlID09IEMgPyAtMSA6IHQgPT0gQyA/IDEgOiBpID8gLTEgOiBvID8gMSA6IHUgPyBQKHUsIGUpIC0gUCh1LCB0KSA6IDA7XG5cdCAgICAgICAgaWYgKGkgPT09IG8pIHJldHVybiBwZShlLCB0KTtcblx0ICAgICAgICBuID0gZTtcblxuXHQgICAgICAgIHdoaWxlIChuID0gbi5wYXJlbnROb2RlKSBhLnVuc2hpZnQobik7XG5cblx0ICAgICAgICBuID0gdDtcblxuXHQgICAgICAgIHdoaWxlIChuID0gbi5wYXJlbnROb2RlKSBzLnVuc2hpZnQobik7XG5cblx0ICAgICAgICB3aGlsZSAoYVtyXSA9PT0gc1tyXSkgcisrO1xuXG5cdCAgICAgICAgcmV0dXJuIHIgPyBwZShhW3JdLCBzW3JdKSA6IGFbcl0gPT0gcCA/IC0xIDogc1tyXSA9PSBwID8gMSA6IDA7XG5cdCAgICAgIH0pLCBDO1xuXHQgICAgfSwgc2UubWF0Y2hlcyA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiBzZShlLCBudWxsLCBudWxsLCB0KTtcblx0ICAgIH0sIHNlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIGlmIChUKGUpLCBkLm1hdGNoZXNTZWxlY3RvciAmJiBFICYmICFOW3QgKyBcIiBcIl0gJiYgKCFzIHx8ICFzLnRlc3QodCkpICYmICghdiB8fCAhdi50ZXN0KHQpKSkgdHJ5IHtcblx0ICAgICAgICB2YXIgbiA9IGMuY2FsbChlLCB0KTtcblx0ICAgICAgICBpZiAobiB8fCBkLmRpc2Nvbm5lY3RlZE1hdGNoIHx8IGUuZG9jdW1lbnQgJiYgMTEgIT09IGUuZG9jdW1lbnQubm9kZVR5cGUpIHJldHVybiBuO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgTih0LCAhMCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIDAgPCBzZSh0LCBDLCBudWxsLCBbZV0pLmxlbmd0aDtcblx0ICAgIH0sIHNlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgcmV0dXJuIChlLm93bmVyRG9jdW1lbnQgfHwgZSkgIT0gQyAmJiBUKGUpLCB5KGUsIHQpO1xuXHQgICAgfSwgc2UuYXR0ciA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIChlLm93bmVyRG9jdW1lbnQgfHwgZSkgIT0gQyAmJiBUKGUpO1xuXHQgICAgICB2YXIgbiA9IGIuYXR0ckhhbmRsZVt0LnRvTG93ZXJDYXNlKCldLFxuXHQgICAgICAgICAgciA9IG4gJiYgRC5jYWxsKGIuYXR0ckhhbmRsZSwgdC50b0xvd2VyQ2FzZSgpKSA/IG4oZSwgdCwgIUUpIDogdm9pZCAwO1xuXHQgICAgICByZXR1cm4gdm9pZCAwICE9PSByID8gciA6IGQuYXR0cmlidXRlcyB8fCAhRSA/IGUuZ2V0QXR0cmlidXRlKHQpIDogKHIgPSBlLmdldEF0dHJpYnV0ZU5vZGUodCkpICYmIHIuc3BlY2lmaWVkID8gci52YWx1ZSA6IG51bGw7XG5cdCAgICB9LCBzZS5lc2NhcGUgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gKGUgKyBcIlwiKS5yZXBsYWNlKHJlLCBpZSk7XG5cdCAgICB9LCBzZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgZSk7XG5cdCAgICB9LCBzZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQsXG5cdCAgICAgICAgICBuID0gW10sXG5cdCAgICAgICAgICByID0gMCxcblx0ICAgICAgICAgIGkgPSAwO1xuXG5cdCAgICAgIGlmIChsID0gIWQuZGV0ZWN0RHVwbGljYXRlcywgdSA9ICFkLnNvcnRTdGFibGUgJiYgZS5zbGljZSgwKSwgZS5zb3J0KGopLCBsKSB7XG5cdCAgICAgICAgd2hpbGUgKHQgPSBlW2krK10pIHQgPT09IGVbaV0gJiYgKHIgPSBuLnB1c2goaSkpO1xuXG5cdCAgICAgICAgd2hpbGUgKHItLSkgZS5zcGxpY2UobltyXSwgMSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gdSA9IG51bGwsIGU7XG5cdCAgICB9LCBvID0gc2UuZ2V0VGV4dCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0LFxuXHQgICAgICAgICAgbiA9IFwiXCIsXG5cdCAgICAgICAgICByID0gMCxcblx0ICAgICAgICAgIGkgPSBlLm5vZGVUeXBlO1xuXG5cdCAgICAgIGlmIChpKSB7XG5cdCAgICAgICAgaWYgKDEgPT09IGkgfHwgOSA9PT0gaSB8fCAxMSA9PT0gaSkge1xuXHQgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUudGV4dENvbnRlbnQpIHJldHVybiBlLnRleHRDb250ZW50O1xuXG5cdCAgICAgICAgICBmb3IgKGUgPSBlLmZpcnN0Q2hpbGQ7IGU7IGUgPSBlLm5leHRTaWJsaW5nKSBuICs9IG8oZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmICgzID09PSBpIHx8IDQgPT09IGkpIHJldHVybiBlLm5vZGVWYWx1ZTtcblx0ICAgICAgfSBlbHNlIHdoaWxlICh0ID0gZVtyKytdKSBuICs9IG8odCk7XG5cblx0ICAgICAgcmV0dXJuIG47XG5cdCAgICB9LCAoYiA9IHNlLnNlbGVjdG9ycyA9IHtcblx0ICAgICAgY2FjaGVMZW5ndGg6IDUwLFxuXHQgICAgICBjcmVhdGVQc2V1ZG86IGxlLFxuXHQgICAgICBtYXRjaDogRyxcblx0ICAgICAgYXR0ckhhbmRsZToge30sXG5cdCAgICAgIGZpbmQ6IHt9LFxuXHQgICAgICByZWxhdGl2ZToge1xuXHQgICAgICAgIFwiPlwiOiB7XG5cdCAgICAgICAgICBkaXI6IFwicGFyZW50Tm9kZVwiLFxuXHQgICAgICAgICAgZmlyc3Q6ICEwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBcIiBcIjoge1xuXHQgICAgICAgICAgZGlyOiBcInBhcmVudE5vZGVcIlxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgXCIrXCI6IHtcblx0ICAgICAgICAgIGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0ICAgICAgICAgIGZpcnN0OiAhMFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgXCJ+XCI6IHtcblx0ICAgICAgICAgIGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIlxuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgcHJlRmlsdGVyOiB7XG5cdCAgICAgICAgQVRUUjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiBlWzFdID0gZVsxXS5yZXBsYWNlKHRlLCBuZSksIGVbM10gPSAoZVszXSB8fCBlWzRdIHx8IGVbNV0gfHwgXCJcIikucmVwbGFjZSh0ZSwgbmUpLCBcIn49XCIgPT09IGVbMl0gJiYgKGVbM10gPSBcIiBcIiArIGVbM10gKyBcIiBcIiksIGUuc2xpY2UoMCwgNCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBDSElMRDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiBlWzFdID0gZVsxXS50b0xvd2VyQ2FzZSgpLCBcIm50aFwiID09PSBlWzFdLnNsaWNlKDAsIDMpID8gKGVbM10gfHwgc2UuZXJyb3IoZVswXSksIGVbNF0gPSArKGVbNF0gPyBlWzVdICsgKGVbNl0gfHwgMSkgOiAyICogKFwiZXZlblwiID09PSBlWzNdIHx8IFwib2RkXCIgPT09IGVbM10pKSwgZVs1XSA9ICsoZVs3XSArIGVbOF0gfHwgXCJvZGRcIiA9PT0gZVszXSkpIDogZVszXSAmJiBzZS5lcnJvcihlWzBdKSwgZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFBTRVVETzogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciB0LFxuXHQgICAgICAgICAgICAgIG4gPSAhZVs2XSAmJiBlWzJdO1xuXHQgICAgICAgICAgcmV0dXJuIEcuQ0hJTEQudGVzdChlWzBdKSA/IG51bGwgOiAoZVszXSA/IGVbMl0gPSBlWzRdIHx8IGVbNV0gfHwgXCJcIiA6IG4gJiYgWC50ZXN0KG4pICYmICh0ID0gaChuLCAhMCkpICYmICh0ID0gbi5pbmRleE9mKFwiKVwiLCBuLmxlbmd0aCAtIHQpIC0gbi5sZW5ndGgpICYmIChlWzBdID0gZVswXS5zbGljZSgwLCB0KSwgZVsyXSA9IG4uc2xpY2UoMCwgdCkpLCBlLnNsaWNlKDAsIDMpKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIGZpbHRlcjoge1xuXHQgICAgICAgIFRBRzogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciB0ID0gZS5yZXBsYWNlKHRlLCBuZSkudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICAgIHJldHVybiBcIipcIiA9PT0gZSA/IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICEwO1xuXHQgICAgICAgICAgfSA6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBlLm5vZGVOYW1lICYmIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdDtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBDTEFTUzogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciB0ID0gbVtlICsgXCIgXCJdO1xuXHQgICAgICAgICAgcmV0dXJuIHQgfHwgKHQgPSBuZXcgUmVnRXhwKFwiKF58XCIgKyBNICsgXCIpXCIgKyBlICsgXCIoXCIgKyBNICsgXCJ8JClcIikpICYmIG0oZSwgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHQudGVzdChcInN0cmluZ1wiID09IHR5cGVvZiBlLmNsYXNzTmFtZSAmJiBlLmNsYXNzTmFtZSB8fCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBlLmdldEF0dHJpYnV0ZSAmJiBlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBBVFRSOiBmdW5jdGlvbiAobiwgciwgaSkge1xuXHQgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgIHZhciB0ID0gc2UuYXR0cihlLCBuKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gdCA/IFwiIT1cIiA9PT0gciA6ICFyIHx8ICh0ICs9IFwiXCIsIFwiPVwiID09PSByID8gdCA9PT0gaSA6IFwiIT1cIiA9PT0gciA/IHQgIT09IGkgOiBcIl49XCIgPT09IHIgPyBpICYmIDAgPT09IHQuaW5kZXhPZihpKSA6IFwiKj1cIiA9PT0gciA/IGkgJiYgLTEgPCB0LmluZGV4T2YoaSkgOiBcIiQ9XCIgPT09IHIgPyBpICYmIHQuc2xpY2UoLWkubGVuZ3RoKSA9PT0gaSA6IFwifj1cIiA9PT0gciA/IC0xIDwgKFwiIFwiICsgdC5yZXBsYWNlKEIsIFwiIFwiKSArIFwiIFwiKS5pbmRleE9mKGkpIDogXCJ8PVwiID09PSByICYmICh0ID09PSBpIHx8IHQuc2xpY2UoMCwgaS5sZW5ndGggKyAxKSA9PT0gaSArIFwiLVwiKSk7XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgQ0hJTEQ6IGZ1bmN0aW9uIChoLCBlLCB0LCBnLCB2KSB7XG5cdCAgICAgICAgICB2YXIgeSA9IFwibnRoXCIgIT09IGguc2xpY2UoMCwgMyksXG5cdCAgICAgICAgICAgICAgbSA9IFwibGFzdFwiICE9PSBoLnNsaWNlKC00KSxcblx0ICAgICAgICAgICAgICB4ID0gXCJvZi10eXBlXCIgPT09IGU7XG5cdCAgICAgICAgICByZXR1cm4gMSA9PT0gZyAmJiAwID09PSB2ID8gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICEhZS5wYXJlbnROb2RlO1xuXHQgICAgICAgICAgfSA6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgICAgIHZhciByLFxuXHQgICAgICAgICAgICAgICAgaSxcblx0ICAgICAgICAgICAgICAgIG8sXG5cdCAgICAgICAgICAgICAgICBhLFxuXHQgICAgICAgICAgICAgICAgcyxcblx0ICAgICAgICAgICAgICAgIHUsXG5cdCAgICAgICAgICAgICAgICBsID0geSAhPT0gbSA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdCAgICAgICAgICAgICAgICBjID0gZS5wYXJlbnROb2RlLFxuXHQgICAgICAgICAgICAgICAgZiA9IHggJiYgZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHQgICAgICAgICAgICAgICAgcCA9ICFuICYmICF4LFxuXHQgICAgICAgICAgICAgICAgZCA9ICExO1xuXG5cdCAgICAgICAgICAgIGlmIChjKSB7XG5cdCAgICAgICAgICAgICAgaWYgKHkpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChsKSB7XG5cdCAgICAgICAgICAgICAgICAgIGEgPSBlO1xuXG5cdCAgICAgICAgICAgICAgICAgIHdoaWxlIChhID0gYVtsXSkgaWYgKHggPyBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGYgOiAxID09PSBhLm5vZGVUeXBlKSByZXR1cm4gITE7XG5cblx0ICAgICAgICAgICAgICAgICAgdSA9IGwgPSBcIm9ubHlcIiA9PT0gaCAmJiAhdSAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICBpZiAodSA9IFttID8gYy5maXJzdENoaWxkIDogYy5sYXN0Q2hpbGRdLCBtICYmIHApIHtcblx0ICAgICAgICAgICAgICAgIGQgPSAocyA9IChyID0gKGkgPSAobyA9IChhID0gYylbU10gfHwgKGFbU10gPSB7fSkpW2EudW5pcXVlSURdIHx8IChvW2EudW5pcXVlSURdID0ge30pKVtoXSB8fCBbXSlbMF0gPT09IGsgJiYgclsxXSkgJiYgclsyXSwgYSA9IHMgJiYgYy5jaGlsZE5vZGVzW3NdO1xuXG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoYSA9ICsrcyAmJiBhICYmIGFbbF0gfHwgKGQgPSBzID0gMCkgfHwgdS5wb3AoKSkgaWYgKDEgPT09IGEubm9kZVR5cGUgJiYgKytkICYmIGEgPT09IGUpIHtcblx0ICAgICAgICAgICAgICAgICAgaVtoXSA9IFtrLCBzLCBkXTtcblx0ICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfSBlbHNlIGlmIChwICYmIChkID0gcyA9IChyID0gKGkgPSAobyA9IChhID0gZSlbU10gfHwgKGFbU10gPSB7fSkpW2EudW5pcXVlSURdIHx8IChvW2EudW5pcXVlSURdID0ge30pKVtoXSB8fCBbXSlbMF0gPT09IGsgJiYgclsxXSksICExID09PSBkKSB3aGlsZSAoYSA9ICsrcyAmJiBhICYmIGFbbF0gfHwgKGQgPSBzID0gMCkgfHwgdS5wb3AoKSkgaWYgKCh4ID8gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBmIDogMSA9PT0gYS5ub2RlVHlwZSkgJiYgKytkICYmIChwICYmICgoaSA9IChvID0gYVtTXSB8fCAoYVtTXSA9IHt9KSlbYS51bmlxdWVJRF0gfHwgKG9bYS51bmlxdWVJRF0gPSB7fSkpW2hdID0gW2ssIGRdKSwgYSA9PT0gZSkpIGJyZWFrO1xuXG5cdCAgICAgICAgICAgICAgcmV0dXJuIChkIC09IHYpID09PSBnIHx8IGQgJSBnID09IDAgJiYgMCA8PSBkIC8gZztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFBTRVVETzogZnVuY3Rpb24gKGUsIG8pIHtcblx0ICAgICAgICAgIHZhciB0LFxuXHQgICAgICAgICAgICAgIGEgPSBiLnBzZXVkb3NbZV0gfHwgYi5zZXRGaWx0ZXJzW2UudG9Mb3dlckNhc2UoKV0gfHwgc2UuZXJyb3IoXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgZSk7XG5cdCAgICAgICAgICByZXR1cm4gYVtTXSA/IGEobykgOiAxIDwgYS5sZW5ndGggPyAodCA9IFtlLCBlLCBcIlwiLCBvXSwgYi5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KGUudG9Mb3dlckNhc2UoKSkgPyBsZShmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgICAgICB2YXIgbixcblx0ICAgICAgICAgICAgICAgIHIgPSBhKGUsIG8pLFxuXHQgICAgICAgICAgICAgICAgaSA9IHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIHdoaWxlIChpLS0pIGVbbiA9IFAoZSwgcltpXSldID0gISh0W25dID0gcltpXSk7XG5cdCAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBhKGUsIDAsIHQpO1xuXHQgICAgICAgICAgfSkgOiBhO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgcHNldWRvczoge1xuXHQgICAgICAgIG5vdDogbGUoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciByID0gW10sXG5cdCAgICAgICAgICAgICAgaSA9IFtdLFxuXHQgICAgICAgICAgICAgIHMgPSBmKGUucmVwbGFjZSgkLCBcIiQxXCIpKTtcblx0ICAgICAgICAgIHJldHVybiBzW1NdID8gbGUoZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcblx0ICAgICAgICAgICAgdmFyIGksXG5cdCAgICAgICAgICAgICAgICBvID0gcyhlLCBudWxsLCByLCBbXSksXG5cdCAgICAgICAgICAgICAgICBhID0gZS5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgd2hpbGUgKGEtLSkgKGkgPSBvW2FdKSAmJiAoZVthXSA9ICEodFthXSA9IGkpKTtcblx0ICAgICAgICAgIH0pIDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJbMF0gPSBlLCBzKHIsIG51bGwsIG4sIGkpLCByWzBdID0gbnVsbCwgIWkucG9wKCk7XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIGhhczogbGUoZnVuY3Rpb24gKHQpIHtcblx0ICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gMCA8IHNlKHQsIGUpLmxlbmd0aDtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgY29udGFpbnM6IGxlKGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICByZXR1cm4gdCA9IHQucmVwbGFjZSh0ZSwgbmUpLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gLTEgPCAoZS50ZXh0Q29udGVudCB8fCBvKGUpKS5pbmRleE9mKHQpO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBsYW5nOiBsZShmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgcmV0dXJuIFYudGVzdChuIHx8IFwiXCIpIHx8IHNlLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBuKSwgbiA9IG4ucmVwbGFjZSh0ZSwgbmUpLnRvTG93ZXJDYXNlKCksIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgIHZhciB0O1xuXG5cdCAgICAgICAgICAgIGRvIHtcblx0ICAgICAgICAgICAgICBpZiAodCA9IEUgPyBlLmxhbmcgOiBlLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGUuZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgcmV0dXJuICh0ID0gdC50b0xvd2VyQ2FzZSgpKSA9PT0gbiB8fCAwID09PSB0LmluZGV4T2YobiArIFwiLVwiKTtcblx0ICAgICAgICAgICAgfSB3aGlsZSAoKGUgPSBlLnBhcmVudE5vZGUpICYmIDEgPT09IGUubm9kZVR5cGUpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgdGFyZ2V0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQgPSBuLmxvY2F0aW9uICYmIG4ubG9jYXRpb24uaGFzaDtcblx0ICAgICAgICAgIHJldHVybiB0ICYmIHQuc2xpY2UoMSkgPT09IGUuaWQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICByb290OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGUgPT09IGE7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmb2N1czogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiBlID09PSBDLmFjdGl2ZUVsZW1lbnQgJiYgKCFDLmhhc0ZvY3VzIHx8IEMuaGFzRm9jdXMoKSkgJiYgISEoZS50eXBlIHx8IGUuaHJlZiB8fCB+ZS50YWJJbmRleCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbmFibGVkOiBnZSghMSksXG5cdCAgICAgICAgZGlzYWJsZWQ6IGdlKCEwKSxcblx0ICAgICAgICBjaGVja2VkOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQgPSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICByZXR1cm4gXCJpbnB1dFwiID09PSB0ICYmICEhZS5jaGVja2VkIHx8IFwib3B0aW9uXCIgPT09IHQgJiYgISFlLnNlbGVjdGVkO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gZS5wYXJlbnROb2RlICYmIGUucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCAhMCA9PT0gZS5zZWxlY3RlZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVtcHR5OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgZm9yIChlID0gZS5maXJzdENoaWxkOyBlOyBlID0gZS5uZXh0U2libGluZykgaWYgKGUubm9kZVR5cGUgPCA2KSByZXR1cm4gITE7XG5cblx0ICAgICAgICAgIHJldHVybiAhMDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHBhcmVudDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiAhYi5wc2V1ZG9zLmVtcHR5KGUpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgaGVhZGVyOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgcmV0dXJuIEoudGVzdChlLm5vZGVOYW1lKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGlucHV0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgcmV0dXJuIFEudGVzdChlLm5vZGVOYW1lKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGJ1dHRvbjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciB0ID0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgcmV0dXJuIFwiaW5wdXRcIiA9PT0gdCAmJiBcImJ1dHRvblwiID09PSBlLnR5cGUgfHwgXCJidXR0b25cIiA9PT0gdDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHRleHQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdDtcblx0ICAgICAgICAgIHJldHVybiBcImlucHV0XCIgPT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAmJiBcInRleHRcIiA9PT0gZS50eXBlICYmIChudWxsID09ICh0ID0gZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSB8fCBcInRleHRcIiA9PT0gdC50b0xvd2VyQ2FzZSgpKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZpcnN0OiB2ZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICByZXR1cm4gWzBdO1xuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIGxhc3Q6IHZlKGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgICByZXR1cm4gW3QgLSAxXTtcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBlcTogdmUoZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgICAgIHJldHVybiBbbiA8IDAgPyBuICsgdCA6IG5dO1xuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIGV2ZW46IHZlKGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHQ7IG4gKz0gMikgZS5wdXNoKG4pO1xuXG5cdCAgICAgICAgICByZXR1cm4gZTtcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBvZGQ6IHZlKGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgICBmb3IgKHZhciBuID0gMTsgbiA8IHQ7IG4gKz0gMikgZS5wdXNoKG4pO1xuXG5cdCAgICAgICAgICByZXR1cm4gZTtcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBsdDogdmUoZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgICAgIGZvciAodmFyIHIgPSBuIDwgMCA/IG4gKyB0IDogdCA8IG4gPyB0IDogbjsgMCA8PSAtLXI7KSBlLnB1c2gocik7XG5cblx0ICAgICAgICAgIHJldHVybiBlO1xuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIGd0OiB2ZShmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICAgICAgZm9yICh2YXIgciA9IG4gPCAwID8gbiArIHQgOiBuOyArK3IgPCB0OykgZS5wdXNoKHIpO1xuXG5cdCAgICAgICAgICByZXR1cm4gZTtcblx0ICAgICAgICB9KVxuXHQgICAgICB9XG5cdCAgICB9KS5wc2V1ZG9zLm50aCA9IGIucHNldWRvcy5lcSwge1xuXHQgICAgICByYWRpbzogITAsXG5cdCAgICAgIGNoZWNrYm94OiAhMCxcblx0ICAgICAgZmlsZTogITAsXG5cdCAgICAgIHBhc3N3b3JkOiAhMCxcblx0ICAgICAgaW1hZ2U6ICEwXG5cdCAgICB9KSBiLnBzZXVkb3NbZV0gPSBkZShlKTtcblxuXHQgICAgZm9yIChlIGluIHtcblx0ICAgICAgc3VibWl0OiAhMCxcblx0ICAgICAgcmVzZXQ6ICEwXG5cdCAgICB9KSBiLnBzZXVkb3NbZV0gPSBoZShlKTtcblxuXHQgICAgZnVuY3Rpb24gbWUoKSB7fVxuXG5cdCAgICBmdW5jdGlvbiB4ZShlKSB7XG5cdCAgICAgIGZvciAodmFyIHQgPSAwLCBuID0gZS5sZW5ndGgsIHIgPSBcIlwiOyB0IDwgbjsgdCsrKSByICs9IGVbdF0udmFsdWU7XG5cblx0ICAgICAgcmV0dXJuIHI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGJlKHMsIGUsIHQpIHtcblx0ICAgICAgdmFyIHUgPSBlLmRpcixcblx0ICAgICAgICAgIGwgPSBlLm5leHQsXG5cdCAgICAgICAgICBjID0gbCB8fCB1LFxuXHQgICAgICAgICAgZiA9IHQgJiYgXCJwYXJlbnROb2RlXCIgPT09IGMsXG5cdCAgICAgICAgICBwID0gcisrO1xuXHQgICAgICByZXR1cm4gZS5maXJzdCA/IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgd2hpbGUgKGUgPSBlW3VdKSBpZiAoMSA9PT0gZS5ub2RlVHlwZSB8fCBmKSByZXR1cm4gcyhlLCB0LCBuKTtcblxuXHQgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgfSA6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgdmFyIHIsXG5cdCAgICAgICAgICAgIGksXG5cdCAgICAgICAgICAgIG8sXG5cdCAgICAgICAgICAgIGEgPSBbaywgcF07XG5cblx0ICAgICAgICBpZiAobikge1xuXHQgICAgICAgICAgd2hpbGUgKGUgPSBlW3VdKSBpZiAoKDEgPT09IGUubm9kZVR5cGUgfHwgZikgJiYgcyhlLCB0LCBuKSkgcmV0dXJuICEwO1xuXHQgICAgICAgIH0gZWxzZSB3aGlsZSAoZSA9IGVbdV0pIGlmICgxID09PSBlLm5vZGVUeXBlIHx8IGYpIGlmIChpID0gKG8gPSBlW1NdIHx8IChlW1NdID0ge30pKVtlLnVuaXF1ZUlEXSB8fCAob1tlLnVuaXF1ZUlEXSA9IHt9KSwgbCAmJiBsID09PSBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIGUgPSBlW3VdIHx8IGU7ZWxzZSB7XG5cdCAgICAgICAgICBpZiAoKHIgPSBpW2NdKSAmJiByWzBdID09PSBrICYmIHJbMV0gPT09IHApIHJldHVybiBhWzJdID0gclsyXTtcblx0ICAgICAgICAgIGlmICgoaVtjXSA9IGEpWzJdID0gcyhlLCB0LCBuKSkgcmV0dXJuICEwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gd2UoaSkge1xuXHQgICAgICByZXR1cm4gMSA8IGkubGVuZ3RoID8gZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgICB2YXIgciA9IGkubGVuZ3RoO1xuXG5cdCAgICAgICAgd2hpbGUgKHItLSkgaWYgKCFpW3JdKGUsIHQsIG4pKSByZXR1cm4gITE7XG5cblx0ICAgICAgICByZXR1cm4gITA7XG5cdCAgICAgIH0gOiBpWzBdO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBUZShlLCB0LCBuLCByLCBpKSB7XG5cdCAgICAgIGZvciAodmFyIG8sIGEgPSBbXSwgcyA9IDAsIHUgPSBlLmxlbmd0aCwgbCA9IG51bGwgIT0gdDsgcyA8IHU7IHMrKykgKG8gPSBlW3NdKSAmJiAobiAmJiAhbihvLCByLCBpKSB8fCAoYS5wdXNoKG8pLCBsICYmIHQucHVzaChzKSkpO1xuXG5cdCAgICAgIHJldHVybiBhO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBDZShkLCBoLCBnLCB2LCB5LCBlKSB7XG5cdCAgICAgIHJldHVybiB2ICYmICF2W1NdICYmICh2ID0gQ2UodikpLCB5ICYmICF5W1NdICYmICh5ID0gQ2UoeSwgZSkpLCBsZShmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICAgIHZhciBpLFxuXHQgICAgICAgICAgICBvLFxuXHQgICAgICAgICAgICBhLFxuXHQgICAgICAgICAgICBzID0gW10sXG5cdCAgICAgICAgICAgIHUgPSBbXSxcblx0ICAgICAgICAgICAgbCA9IHQubGVuZ3RoLFxuXHQgICAgICAgICAgICBjID0gZSB8fCBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICAgICAgZm9yICh2YXIgciA9IDAsIGkgPSB0Lmxlbmd0aDsgciA8IGk7IHIrKykgc2UoZSwgdFtyXSwgbik7XG5cblx0ICAgICAgICAgIHJldHVybiBuO1xuXHQgICAgICAgIH0oaCB8fCBcIipcIiwgbi5ub2RlVHlwZSA/IFtuXSA6IG4sIFtdKSxcblx0ICAgICAgICAgICAgZiA9ICFkIHx8ICFlICYmIGggPyBjIDogVGUoYywgcywgZCwgbiwgciksXG5cdCAgICAgICAgICAgIHAgPSBnID8geSB8fCAoZSA/IGQgOiBsIHx8IHYpID8gW10gOiB0IDogZjtcblxuXHQgICAgICAgIGlmIChnICYmIGcoZiwgcCwgbiwgciksIHYpIHtcblx0ICAgICAgICAgIGkgPSBUZShwLCB1KSwgdihpLCBbXSwgbiwgciksIG8gPSBpLmxlbmd0aDtcblxuXHQgICAgICAgICAgd2hpbGUgKG8tLSkgKGEgPSBpW29dKSAmJiAocFt1W29dXSA9ICEoZlt1W29dXSA9IGEpKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZSkge1xuXHQgICAgICAgICAgaWYgKHkgfHwgZCkge1xuXHQgICAgICAgICAgICBpZiAoeSkge1xuXHQgICAgICAgICAgICAgIGkgPSBbXSwgbyA9IHAubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgICAgd2hpbGUgKG8tLSkgKGEgPSBwW29dKSAmJiBpLnB1c2goZltvXSA9IGEpO1xuXG5cdCAgICAgICAgICAgICAgeShudWxsLCBwID0gW10sIGksIHIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbyA9IHAubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIHdoaWxlIChvLS0pIChhID0gcFtvXSkgJiYgLTEgPCAoaSA9IHkgPyBQKGUsIGEpIDogc1tvXSkgJiYgKGVbaV0gPSAhKHRbaV0gPSBhKSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHAgPSBUZShwID09PSB0ID8gcC5zcGxpY2UobCwgcC5sZW5ndGgpIDogcCksIHkgPyB5KG51bGwsIHQsIHAsIHIpIDogSC5hcHBseSh0LCBwKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEVlKGUpIHtcblx0ICAgICAgZm9yICh2YXIgaSwgdCwgbiwgciA9IGUubGVuZ3RoLCBvID0gYi5yZWxhdGl2ZVtlWzBdLnR5cGVdLCBhID0gbyB8fCBiLnJlbGF0aXZlW1wiIFwiXSwgcyA9IG8gPyAxIDogMCwgdSA9IGJlKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIGUgPT09IGk7XG5cdCAgICAgIH0sIGEsICEwKSwgbCA9IGJlKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIC0xIDwgUChpLCBlKTtcblx0ICAgICAgfSwgYSwgITApLCBjID0gW2Z1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgdmFyIHIgPSAhbyAmJiAobiB8fCB0ICE9PSB3KSB8fCAoKGkgPSB0KS5ub2RlVHlwZSA/IHUoZSwgdCwgbikgOiBsKGUsIHQsIG4pKTtcblx0ICAgICAgICByZXR1cm4gaSA9IG51bGwsIHI7XG5cdCAgICAgIH1dOyBzIDwgcjsgcysrKSBpZiAodCA9IGIucmVsYXRpdmVbZVtzXS50eXBlXSkgYyA9IFtiZSh3ZShjKSwgdCldO2Vsc2Uge1xuXHQgICAgICAgIGlmICgodCA9IGIuZmlsdGVyW2Vbc10udHlwZV0uYXBwbHkobnVsbCwgZVtzXS5tYXRjaGVzKSlbU10pIHtcblx0ICAgICAgICAgIGZvciAobiA9ICsrczsgbiA8IHI7IG4rKykgaWYgKGIucmVsYXRpdmVbZVtuXS50eXBlXSkgYnJlYWs7XG5cblx0ICAgICAgICAgIHJldHVybiBDZSgxIDwgcyAmJiB3ZShjKSwgMSA8IHMgJiYgeGUoZS5zbGljZSgwLCBzIC0gMSkuY29uY2F0KHtcblx0ICAgICAgICAgICAgdmFsdWU6IFwiIFwiID09PSBlW3MgLSAyXS50eXBlID8gXCIqXCIgOiBcIlwiXG5cdCAgICAgICAgICB9KSkucmVwbGFjZSgkLCBcIiQxXCIpLCB0LCBzIDwgbiAmJiBFZShlLnNsaWNlKHMsIG4pKSwgbiA8IHIgJiYgRWUoZSA9IGUuc2xpY2UobikpLCBuIDwgciAmJiB4ZShlKSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYy5wdXNoKHQpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHdlKGMpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbWUucHJvdG90eXBlID0gYi5maWx0ZXJzID0gYi5wc2V1ZG9zLCBiLnNldEZpbHRlcnMgPSBuZXcgbWUoKSwgaCA9IHNlLnRva2VuaXplID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgdmFyIG4sXG5cdCAgICAgICAgICByLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyxcblx0ICAgICAgICAgIHUsXG5cdCAgICAgICAgICBsID0geFtlICsgXCIgXCJdO1xuXHQgICAgICBpZiAobCkgcmV0dXJuIHQgPyAwIDogbC5zbGljZSgwKTtcblx0ICAgICAgYSA9IGUsIHMgPSBbXSwgdSA9IGIucHJlRmlsdGVyO1xuXG5cdCAgICAgIHdoaWxlIChhKSB7XG5cdCAgICAgICAgZm9yIChvIGluIG4gJiYgIShyID0gXy5leGVjKGEpKSB8fCAociAmJiAoYSA9IGEuc2xpY2UoclswXS5sZW5ndGgpIHx8IGEpLCBzLnB1c2goaSA9IFtdKSksIG4gPSAhMSwgKHIgPSB6LmV4ZWMoYSkpICYmIChuID0gci5zaGlmdCgpLCBpLnB1c2goe1xuXHQgICAgICAgICAgdmFsdWU6IG4sXG5cdCAgICAgICAgICB0eXBlOiByWzBdLnJlcGxhY2UoJCwgXCIgXCIpXG5cdCAgICAgICAgfSksIGEgPSBhLnNsaWNlKG4ubGVuZ3RoKSksIGIuZmlsdGVyKSAhKHIgPSBHW29dLmV4ZWMoYSkpIHx8IHVbb10gJiYgIShyID0gdVtvXShyKSkgfHwgKG4gPSByLnNoaWZ0KCksIGkucHVzaCh7XG5cdCAgICAgICAgICB2YWx1ZTogbixcblx0ICAgICAgICAgIHR5cGU6IG8sXG5cdCAgICAgICAgICBtYXRjaGVzOiByXG5cdCAgICAgICAgfSksIGEgPSBhLnNsaWNlKG4ubGVuZ3RoKSk7XG5cblx0ICAgICAgICBpZiAoIW4pIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHQgPyBhLmxlbmd0aCA6IGEgPyBzZS5lcnJvcihlKSA6IHgoZSwgcykuc2xpY2UoMCk7XG5cdCAgICB9LCBmID0gc2UuY29tcGlsZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHZhciBuLFxuXHQgICAgICAgICAgdixcblx0ICAgICAgICAgIHksXG5cdCAgICAgICAgICBtLFxuXHQgICAgICAgICAgeCxcblx0ICAgICAgICAgIHIsXG5cdCAgICAgICAgICBpID0gW10sXG5cdCAgICAgICAgICBvID0gW10sXG5cdCAgICAgICAgICBhID0gQVtlICsgXCIgXCJdO1xuXG5cdCAgICAgIGlmICghYSkge1xuXHQgICAgICAgIHQgfHwgKHQgPSBoKGUpKSwgbiA9IHQubGVuZ3RoO1xuXG5cdCAgICAgICAgd2hpbGUgKG4tLSkgKGEgPSBFZSh0W25dKSlbU10gPyBpLnB1c2goYSkgOiBvLnB1c2goYSk7XG5cblx0ICAgICAgICAoYSA9IEEoZSwgKHYgPSBvLCBtID0gMCA8ICh5ID0gaSkubGVuZ3RoLCB4ID0gMCA8IHYubGVuZ3RoLCByID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIsIGkpIHtcblx0ICAgICAgICAgIHZhciBvLFxuXHQgICAgICAgICAgICAgIGEsXG5cdCAgICAgICAgICAgICAgcyxcblx0ICAgICAgICAgICAgICB1ID0gMCxcblx0ICAgICAgICAgICAgICBsID0gXCIwXCIsXG5cdCAgICAgICAgICAgICAgYyA9IGUgJiYgW10sXG5cdCAgICAgICAgICAgICAgZiA9IFtdLFxuXHQgICAgICAgICAgICAgIHAgPSB3LFxuXHQgICAgICAgICAgICAgIGQgPSBlIHx8IHggJiYgYi5maW5kLlRBRyhcIipcIiwgaSksXG5cdCAgICAgICAgICAgICAgaCA9IGsgKz0gbnVsbCA9PSBwID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgLjEsXG5cdCAgICAgICAgICAgICAgZyA9IGQubGVuZ3RoO1xuXG5cdCAgICAgICAgICBmb3IgKGkgJiYgKHcgPSB0ID09IEMgfHwgdCB8fCBpKTsgbCAhPT0gZyAmJiBudWxsICE9IChvID0gZFtsXSk7IGwrKykge1xuXHQgICAgICAgICAgICBpZiAoeCAmJiBvKSB7XG5cdCAgICAgICAgICAgICAgYSA9IDAsIHQgfHwgby5vd25lckRvY3VtZW50ID09IEMgfHwgKFQobyksIG4gPSAhRSk7XG5cblx0ICAgICAgICAgICAgICB3aGlsZSAocyA9IHZbYSsrXSkgaWYgKHMobywgdCB8fCBDLCBuKSkge1xuXHQgICAgICAgICAgICAgICAgci5wdXNoKG8pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgaSAmJiAoayA9IGgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbSAmJiAoKG8gPSAhcyAmJiBvKSAmJiB1LS0sIGUgJiYgYy5wdXNoKG8pKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKHUgKz0gbCwgbSAmJiBsICE9PSB1KSB7XG5cdCAgICAgICAgICAgIGEgPSAwO1xuXG5cdCAgICAgICAgICAgIHdoaWxlIChzID0geVthKytdKSBzKGMsIGYsIHQsIG4pO1xuXG5cdCAgICAgICAgICAgIGlmIChlKSB7XG5cdCAgICAgICAgICAgICAgaWYgKDAgPCB1KSB3aGlsZSAobC0tKSBjW2xdIHx8IGZbbF0gfHwgKGZbbF0gPSBxLmNhbGwocikpO1xuXHQgICAgICAgICAgICAgIGYgPSBUZShmKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIEguYXBwbHkociwgZiksIGkgJiYgIWUgJiYgMCA8IGYubGVuZ3RoICYmIDEgPCB1ICsgeS5sZW5ndGggJiYgc2UudW5pcXVlU29ydChyKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgcmV0dXJuIGkgJiYgKGsgPSBoLCB3ID0gcCksIGM7XG5cdCAgICAgICAgfSwgbSA/IGxlKHIpIDogcikpKS5zZWxlY3RvciA9IGU7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gYTtcblx0ICAgIH0sIGcgPSBzZS5zZWxlY3QgPSBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICB2YXIgaSxcblx0ICAgICAgICAgIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyxcblx0ICAgICAgICAgIHUsXG5cdCAgICAgICAgICBsID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlICYmIGUsXG5cdCAgICAgICAgICBjID0gIXIgJiYgaChlID0gbC5zZWxlY3RvciB8fCBlKTtcblxuXHQgICAgICBpZiAobiA9IG4gfHwgW10sIDEgPT09IGMubGVuZ3RoKSB7XG5cdCAgICAgICAgaWYgKDIgPCAobyA9IGNbMF0gPSBjWzBdLnNsaWNlKDApKS5sZW5ndGggJiYgXCJJRFwiID09PSAoYSA9IG9bMF0pLnR5cGUgJiYgOSA9PT0gdC5ub2RlVHlwZSAmJiBFICYmIGIucmVsYXRpdmVbb1sxXS50eXBlXSkge1xuXHQgICAgICAgICAgaWYgKCEodCA9IChiLmZpbmQuSUQoYS5tYXRjaGVzWzBdLnJlcGxhY2UodGUsIG5lKSwgdCkgfHwgW10pWzBdKSkgcmV0dXJuIG47XG5cdCAgICAgICAgICBsICYmICh0ID0gdC5wYXJlbnROb2RlKSwgZSA9IGUuc2xpY2Uoby5zaGlmdCgpLnZhbHVlLmxlbmd0aCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaSA9IEcubmVlZHNDb250ZXh0LnRlc3QoZSkgPyAwIDogby5sZW5ndGg7XG5cblx0ICAgICAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgICAgICBpZiAoYSA9IG9baV0sIGIucmVsYXRpdmVbcyA9IGEudHlwZV0pIGJyZWFrO1xuXG5cdCAgICAgICAgICBpZiAoKHUgPSBiLmZpbmRbc10pICYmIChyID0gdShhLm1hdGNoZXNbMF0ucmVwbGFjZSh0ZSwgbmUpLCBlZS50ZXN0KG9bMF0udHlwZSkgJiYgeWUodC5wYXJlbnROb2RlKSB8fCB0KSkpIHtcblx0ICAgICAgICAgICAgaWYgKG8uc3BsaWNlKGksIDEpLCAhKGUgPSByLmxlbmd0aCAmJiB4ZShvKSkpIHJldHVybiBILmFwcGx5KG4sIHIpLCBuO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gKGwgfHwgZihlLCBjKSkociwgdCwgIUUsIG4sICF0IHx8IGVlLnRlc3QoZSkgJiYgeWUodC5wYXJlbnROb2RlKSB8fCB0KSwgbjtcblx0ICAgIH0sIGQuc29ydFN0YWJsZSA9IFMuc3BsaXQoXCJcIikuc29ydChqKS5qb2luKFwiXCIpID09PSBTLCBkLmRldGVjdER1cGxpY2F0ZXMgPSAhIWwsIFQoKSwgZC5zb3J0RGV0YWNoZWQgPSBjZShmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gMSAmIGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oQy5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikpO1xuXHQgICAgfSksIGNlKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBlLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiLCBcIiNcIiA9PT0gZS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG5cdCAgICB9KSB8fCBmZShcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgaWYgKCFuKSByZXR1cm4gZS5nZXRBdHRyaWJ1dGUodCwgXCJ0eXBlXCIgPT09IHQudG9Mb3dlckNhc2UoKSA/IDEgOiAyKTtcblx0ICAgIH0pLCBkLmF0dHJpYnV0ZXMgJiYgY2UoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIGUuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiLCBlLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgXCJcIiksIFwiXCIgPT09IGUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblx0ICAgIH0pIHx8IGZlKFwidmFsdWVcIiwgZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgaWYgKCFuICYmIFwiaW5wdXRcIiA9PT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSByZXR1cm4gZS5kZWZhdWx0VmFsdWU7XG5cdCAgICB9KSwgY2UoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIG51bGwgPT0gZS5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcblx0ICAgIH0pIHx8IGZlKFIsIGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHZhciByO1xuXHQgICAgICBpZiAoIW4pIHJldHVybiAhMCA9PT0gZVt0XSA/IHQudG9Mb3dlckNhc2UoKSA6IChyID0gZS5nZXRBdHRyaWJ1dGVOb2RlKHQpKSAmJiByLnNwZWNpZmllZCA/IHIudmFsdWUgOiBudWxsO1xuXHQgICAgfSksIHNlO1xuXHQgIH0oQyk7XG5cblx0ICBTLmZpbmQgPSBkLCBTLmV4cHIgPSBkLnNlbGVjdG9ycywgUy5leHByW1wiOlwiXSA9IFMuZXhwci5wc2V1ZG9zLCBTLnVuaXF1ZVNvcnQgPSBTLnVuaXF1ZSA9IGQudW5pcXVlU29ydCwgUy50ZXh0ID0gZC5nZXRUZXh0LCBTLmlzWE1MRG9jID0gZC5pc1hNTCwgUy5jb250YWlucyA9IGQuY29udGFpbnMsIFMuZXNjYXBlU2VsZWN0b3IgPSBkLmVzY2FwZTtcblxuXHQgIHZhciBoID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgIHZhciByID0gW10sXG5cdCAgICAgICAgaSA9IHZvaWQgMCAhPT0gbjtcblxuXHQgICAgd2hpbGUgKChlID0gZVt0XSkgJiYgOSAhPT0gZS5ub2RlVHlwZSkgaWYgKDEgPT09IGUubm9kZVR5cGUpIHtcblx0ICAgICAgaWYgKGkgJiYgUyhlKS5pcyhuKSkgYnJlYWs7XG5cdCAgICAgIHIucHVzaChlKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfSxcblx0ICAgICAgVCA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICBmb3IgKHZhciBuID0gW107IGU7IGUgPSBlLm5leHRTaWJsaW5nKSAxID09PSBlLm5vZGVUeXBlICYmIGUgIT09IHQgJiYgbi5wdXNoKGUpO1xuXG5cdCAgICByZXR1cm4gbjtcblx0ICB9LFxuXHQgICAgICBrID0gUy5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXHQgIGZ1bmN0aW9uIEEoZSwgdCkge1xuXHQgICAgcmV0dXJuIGUubm9kZU5hbWUgJiYgZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0LnRvTG93ZXJDYXNlKCk7XG5cdCAgfVxuXG5cdCAgdmFyIE4gPSAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaTtcblxuXHQgIGZ1bmN0aW9uIGooZSwgbiwgcikge1xuXHQgICAgcmV0dXJuIG0obikgPyBTLmdyZXAoZSwgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgcmV0dXJuICEhbi5jYWxsKGUsIHQsIGUpICE9PSByO1xuXHQgICAgfSkgOiBuLm5vZGVUeXBlID8gUy5ncmVwKGUsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBlID09PSBuICE9PSByO1xuXHQgICAgfSkgOiBcInN0cmluZ1wiICE9IHR5cGVvZiBuID8gUy5ncmVwKGUsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiAtMSA8IGkuY2FsbChuLCBlKSAhPT0gcjtcblx0ICAgIH0pIDogUy5maWx0ZXIobiwgZSwgcik7XG5cdCAgfVxuXG5cdCAgUy5maWx0ZXIgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgdmFyIHIgPSB0WzBdO1xuXHQgICAgcmV0dXJuIG4gJiYgKGUgPSBcIjpub3QoXCIgKyBlICsgXCIpXCIpLCAxID09PSB0Lmxlbmd0aCAmJiAxID09PSByLm5vZGVUeXBlID8gUy5maW5kLm1hdGNoZXNTZWxlY3RvcihyLCBlKSA/IFtyXSA6IFtdIDogUy5maW5kLm1hdGNoZXMoZSwgUy5ncmVwKHQsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiAxID09PSBlLm5vZGVUeXBlO1xuXHQgICAgfSkpO1xuXHQgIH0sIFMuZm4uZXh0ZW5kKHtcblx0ICAgIGZpbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0LFxuXHQgICAgICAgICAgbixcblx0ICAgICAgICAgIHIgPSB0aGlzLmxlbmd0aCxcblx0ICAgICAgICAgIGkgPSB0aGlzO1xuXHQgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFMoZSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHQgPSAwOyB0IDwgcjsgdCsrKSBpZiAoUy5jb250YWlucyhpW3RdLCB0aGlzKSkgcmV0dXJuICEwO1xuXHQgICAgICB9KSk7XG5cblx0ICAgICAgZm9yIChuID0gdGhpcy5wdXNoU3RhY2soW10pLCB0ID0gMDsgdCA8IHI7IHQrKykgUy5maW5kKGUsIGlbdF0sIG4pO1xuXG5cdCAgICAgIHJldHVybiAxIDwgciA/IFMudW5pcXVlU29ydChuKSA6IG47XG5cdCAgICB9LFxuXHQgICAgZmlsdGVyOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soaih0aGlzLCBlIHx8IFtdLCAhMSkpO1xuXHQgICAgfSxcblx0ICAgIG5vdDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGoodGhpcywgZSB8fCBbXSwgITApKTtcblx0ICAgIH0sXG5cdCAgICBpczogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuICEhaih0aGlzLCBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIGsudGVzdChlKSA/IFMoZSkgOiBlIHx8IFtdLCAhMSkubGVuZ3RoO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHZhciBELFxuXHQgICAgICBxID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC87XG5cdCAgKFMuZm4uaW5pdCA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICB2YXIgciwgaTtcblx0ICAgIGlmICghZSkgcmV0dXJuIHRoaXM7XG5cblx0ICAgIGlmIChuID0gbiB8fCBELCBcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG5cdCAgICAgIGlmICghKHIgPSBcIjxcIiA9PT0gZVswXSAmJiBcIj5cIiA9PT0gZVtlLmxlbmd0aCAtIDFdICYmIDMgPD0gZS5sZW5ndGggPyBbbnVsbCwgZSwgbnVsbF0gOiBxLmV4ZWMoZSkpIHx8ICFyWzFdICYmIHQpIHJldHVybiAhdCB8fCB0LmpxdWVyeSA/ICh0IHx8IG4pLmZpbmQoZSkgOiB0aGlzLmNvbnN0cnVjdG9yKHQpLmZpbmQoZSk7XG5cblx0ICAgICAgaWYgKHJbMV0pIHtcblx0ICAgICAgICBpZiAodCA9IHQgaW5zdGFuY2VvZiBTID8gdFswXSA6IHQsIFMubWVyZ2UodGhpcywgUy5wYXJzZUhUTUwoclsxXSwgdCAmJiB0Lm5vZGVUeXBlID8gdC5vd25lckRvY3VtZW50IHx8IHQgOiBFLCAhMCkpLCBOLnRlc3QoclsxXSkgJiYgUy5pc1BsYWluT2JqZWN0KHQpKSBmb3IgKHIgaW4gdCkgbSh0aGlzW3JdKSA/IHRoaXNbcl0odFtyXSkgOiB0aGlzLmF0dHIociwgdFtyXSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gKGkgPSBFLmdldEVsZW1lbnRCeUlkKHJbMl0pKSAmJiAodGhpc1swXSA9IGksIHRoaXMubGVuZ3RoID0gMSksIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBlLm5vZGVUeXBlID8gKHRoaXNbMF0gPSBlLCB0aGlzLmxlbmd0aCA9IDEsIHRoaXMpIDogbShlKSA/IHZvaWQgMCAhPT0gbi5yZWFkeSA/IG4ucmVhZHkoZSkgOiBlKFMpIDogUy5tYWtlQXJyYXkoZSwgdGhpcyk7XG5cdCAgfSkucHJvdG90eXBlID0gUy5mbiwgRCA9IFMoRSk7XG5cdCAgdmFyIEwgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblx0ICAgICAgSCA9IHtcblx0ICAgIGNoaWxkcmVuOiAhMCxcblx0ICAgIGNvbnRlbnRzOiAhMCxcblx0ICAgIG5leHQ6ICEwLFxuXHQgICAgcHJldjogITBcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gTyhlLCB0KSB7XG5cdCAgICB3aGlsZSAoKGUgPSBlW3RdKSAmJiAxICE9PSBlLm5vZGVUeXBlKTtcblxuXHQgICAgcmV0dXJuIGU7XG5cdCAgfVxuXG5cdCAgUy5mbi5leHRlbmQoe1xuXHQgICAgaGFzOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdCA9IFMoZSwgdGhpcyksXG5cdCAgICAgICAgICBuID0gdC5sZW5ndGg7XG5cdCAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBuOyBlKyspIGlmIChTLmNvbnRhaW5zKHRoaXMsIHRbZV0pKSByZXR1cm4gITA7XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHZhciBuLFxuXHQgICAgICAgICAgciA9IDAsXG5cdCAgICAgICAgICBpID0gdGhpcy5sZW5ndGgsXG5cdCAgICAgICAgICBvID0gW10sXG5cdCAgICAgICAgICBhID0gXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSAmJiBTKGUpO1xuXHQgICAgICBpZiAoIWsudGVzdChlKSkgZm9yICg7IHIgPCBpOyByKyspIGZvciAobiA9IHRoaXNbcl07IG4gJiYgbiAhPT0gdDsgbiA9IG4ucGFyZW50Tm9kZSkgaWYgKG4ubm9kZVR5cGUgPCAxMSAmJiAoYSA/IC0xIDwgYS5pbmRleChuKSA6IDEgPT09IG4ubm9kZVR5cGUgJiYgUy5maW5kLm1hdGNoZXNTZWxlY3RvcihuLCBlKSkpIHtcblx0ICAgICAgICBvLnB1c2gobik7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKDEgPCBvLmxlbmd0aCA/IFMudW5pcXVlU29ydChvKSA6IG8pO1xuXHQgICAgfSxcblx0ICAgIGluZGV4OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gZSA/IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBpLmNhbGwoUyhlKSwgdGhpc1swXSkgOiBpLmNhbGwodGhpcywgZS5qcXVlcnkgPyBlWzBdIDogZSkgOiB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdCAgICB9LFxuXHQgICAgYWRkOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soUy51bmlxdWVTb3J0KFMubWVyZ2UodGhpcy5nZXQoKSwgUyhlLCB0KSkpKTtcblx0ICAgIH0sXG5cdCAgICBhZGRCYWNrOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5hZGQobnVsbCA9PSBlID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihlKSk7XG5cdCAgICB9XG5cdCAgfSksIFMuZWFjaCh7XG5cdCAgICBwYXJlbnQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0ID0gZS5wYXJlbnROb2RlO1xuXHQgICAgICByZXR1cm4gdCAmJiAxMSAhPT0gdC5ub2RlVHlwZSA/IHQgOiBudWxsO1xuXHQgICAgfSxcblx0ICAgIHBhcmVudHM6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBoKGUsIFwicGFyZW50Tm9kZVwiKTtcblx0ICAgIH0sXG5cdCAgICBwYXJlbnRzVW50aWw6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHJldHVybiBoKGUsIFwicGFyZW50Tm9kZVwiLCBuKTtcblx0ICAgIH0sXG5cdCAgICBuZXh0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gTyhlLCBcIm5leHRTaWJsaW5nXCIpO1xuXHQgICAgfSxcblx0ICAgIHByZXY6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBPKGUsIFwicHJldmlvdXNTaWJsaW5nXCIpO1xuXHQgICAgfSxcblx0ICAgIG5leHRBbGw6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBoKGUsIFwibmV4dFNpYmxpbmdcIik7XG5cdCAgICB9LFxuXHQgICAgcHJldkFsbDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIGgoZSwgXCJwcmV2aW91c1NpYmxpbmdcIik7XG5cdCAgICB9LFxuXHQgICAgbmV4dFVudGlsOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gaChlLCBcIm5leHRTaWJsaW5nXCIsIG4pO1xuXHQgICAgfSxcblx0ICAgIHByZXZVbnRpbDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgcmV0dXJuIGgoZSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgbik7XG5cdCAgICB9LFxuXHQgICAgc2libGluZ3M6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBUKChlLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGUpO1xuXHQgICAgfSxcblx0ICAgIGNoaWxkcmVuOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gVChlLmZpcnN0Q2hpbGQpO1xuXHQgICAgfSxcblx0ICAgIGNvbnRlbnRzOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gbnVsbCAhPSBlLmNvbnRlbnREb2N1bWVudCAmJiByKGUuY29udGVudERvY3VtZW50KSA/IGUuY29udGVudERvY3VtZW50IDogKEEoZSwgXCJ0ZW1wbGF0ZVwiKSAmJiAoZSA9IGUuY29udGVudCB8fCBlKSwgUy5tZXJnZShbXSwgZS5jaGlsZE5vZGVzKSk7XG5cdCAgICB9XG5cdCAgfSwgZnVuY3Rpb24gKHIsIGkpIHtcblx0ICAgIFMuZm5bcl0gPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbiA9IFMubWFwKHRoaXMsIGksIGUpO1xuXHQgICAgICByZXR1cm4gXCJVbnRpbFwiICE9PSByLnNsaWNlKC01KSAmJiAodCA9IGUpLCB0ICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgKG4gPSBTLmZpbHRlcih0LCBuKSksIDEgPCB0aGlzLmxlbmd0aCAmJiAoSFtyXSB8fCBTLnVuaXF1ZVNvcnQobiksIEwudGVzdChyKSAmJiBuLnJldmVyc2UoKSksIHRoaXMucHVzaFN0YWNrKG4pO1xuXHQgICAgfTtcblx0ICB9KTtcblx0ICB2YXIgUCA9IC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZztcblxuXHQgIGZ1bmN0aW9uIFIoZSkge1xuXHQgICAgcmV0dXJuIGU7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gTShlKSB7XG5cdCAgICB0aHJvdyBlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIEkoZSwgdCwgbiwgcikge1xuXHQgICAgdmFyIGk7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIGUgJiYgbShpID0gZS5wcm9taXNlKSA/IGkuY2FsbChlKS5kb25lKHQpLmZhaWwobikgOiBlICYmIG0oaSA9IGUudGhlbikgPyBpLmNhbGwoZSwgdCwgbikgOiB0LmFwcGx5KHZvaWQgMCwgW2VdLnNsaWNlKHIpKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgbi5hcHBseSh2b2lkIDAsIFtlXSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgUy5DYWxsYmFja3MgPSBmdW5jdGlvbiAocikge1xuXHQgICAgdmFyIGUsIG47XG5cdCAgICByID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgciA/IChlID0gciwgbiA9IHt9LCBTLmVhY2goZS5tYXRjaChQKSB8fCBbXSwgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgblt0XSA9ICEwO1xuXHQgICAgfSksIG4pIDogUy5leHRlbmQoe30sIHIpO1xuXG5cdCAgICB2YXIgaSxcblx0ICAgICAgICB0LFxuXHQgICAgICAgIG8sXG5cdCAgICAgICAgYSxcblx0ICAgICAgICBzID0gW10sXG5cdCAgICAgICAgdSA9IFtdLFxuXHQgICAgICAgIGwgPSAtMSxcblx0ICAgICAgICBjID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBmb3IgKGEgPSBhIHx8IHIub25jZSwgbyA9IGkgPSAhMDsgdS5sZW5ndGg7IGwgPSAtMSkge1xuXHQgICAgICAgIHQgPSB1LnNoaWZ0KCk7XG5cblx0ICAgICAgICB3aGlsZSAoKytsIDwgcy5sZW5ndGgpICExID09PSBzW2xdLmFwcGx5KHRbMF0sIHRbMV0pICYmIHIuc3RvcE9uRmFsc2UgJiYgKGwgPSBzLmxlbmd0aCwgdCA9ICExKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHIubWVtb3J5IHx8ICh0ID0gITEpLCBpID0gITEsIGEgJiYgKHMgPSB0ID8gW10gOiBcIlwiKTtcblx0ICAgIH0sXG5cdCAgICAgICAgZiA9IHtcblx0ICAgICAgYWRkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHMgJiYgKHQgJiYgIWkgJiYgKGwgPSBzLmxlbmd0aCAtIDEsIHUucHVzaCh0KSksIGZ1bmN0aW9uIG4oZSkge1xuXHQgICAgICAgICAgUy5lYWNoKGUsIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgICAgIG0odCkgPyByLnVuaXF1ZSAmJiBmLmhhcyh0KSB8fCBzLnB1c2godCkgOiB0ICYmIHQubGVuZ3RoICYmIFwic3RyaW5nXCIgIT09IHcodCkgJiYgbih0KTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0oYXJndW1lbnRzKSwgdCAmJiAhaSAmJiBjKCkpLCB0aGlzO1xuXHQgICAgICB9LFxuXHQgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gUy5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICAgIHZhciBuO1xuXG5cdCAgICAgICAgICB3aGlsZSAoLTEgPCAobiA9IFMuaW5BcnJheSh0LCBzLCBuKSkpIHMuc3BsaWNlKG4sIDEpLCBuIDw9IGwgJiYgbC0tO1xuXHQgICAgICAgIH0pLCB0aGlzO1xuXHQgICAgICB9LFxuXHQgICAgICBoYXM6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIGUgPyAtMSA8IFMuaW5BcnJheShlLCBzKSA6IDAgPCBzLmxlbmd0aDtcblx0ICAgICAgfSxcblx0ICAgICAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gcyAmJiAocyA9IFtdKSwgdGhpcztcblx0ICAgICAgfSxcblx0ICAgICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBhID0gdSA9IFtdLCBzID0gdCA9IFwiXCIsIHRoaXM7XG5cdCAgICAgIH0sXG5cdCAgICAgIGRpc2FibGVkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICFzO1xuXHQgICAgICB9LFxuXHQgICAgICBsb2NrOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGEgPSB1ID0gW10sIHQgfHwgaSB8fCAocyA9IHQgPSBcIlwiKSwgdGhpcztcblx0ICAgICAgfSxcblx0ICAgICAgbG9ja2VkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICEhYTtcblx0ICAgICAgfSxcblx0ICAgICAgZmlyZVdpdGg6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgcmV0dXJuIGEgfHwgKHQgPSBbZSwgKHQgPSB0IHx8IFtdKS5zbGljZSA/IHQuc2xpY2UoKSA6IHRdLCB1LnB1c2godCksIGkgfHwgYygpKSwgdGhpcztcblx0ICAgICAgfSxcblx0ICAgICAgZmlyZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBmLmZpcmVXaXRoKHRoaXMsIGFyZ3VtZW50cyksIHRoaXM7XG5cdCAgICAgIH0sXG5cdCAgICAgIGZpcmVkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICEhbztcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIGY7XG5cdCAgfSwgUy5leHRlbmQoe1xuXHQgICAgRGVmZXJyZWQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBvID0gW1tcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIFMuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLCBTLkNhbGxiYWNrcyhcIm1lbW9yeVwiKSwgMl0sIFtcInJlc29sdmVcIiwgXCJkb25lXCIsIFMuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFMuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIDAsIFwicmVzb2x2ZWRcIl0sIFtcInJlamVjdFwiLCBcImZhaWxcIiwgUy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgUy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgMSwgXCJyZWplY3RlZFwiXV0sXG5cdCAgICAgICAgICBpID0gXCJwZW5kaW5nXCIsXG5cdCAgICAgICAgICBhID0ge1xuXHQgICAgICAgIHN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICByZXR1cm4gaTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGFsd2F5czogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgcmV0dXJuIHMuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSwgdGhpcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiBhLnRoZW4obnVsbCwgZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBwaXBlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cztcblx0ICAgICAgICAgIHJldHVybiBTLkRlZmVycmVkKGZ1bmN0aW9uIChyKSB7XG5cdCAgICAgICAgICAgIFMuZWFjaChvLCBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgICAgICAgIHZhciBuID0gbShpW3RbNF1dKSAmJiBpW3RbNF1dO1xuXHQgICAgICAgICAgICAgIHNbdFsxXV0oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGUgPSBuICYmIG4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgIGUgJiYgbShlLnByb21pc2UpID8gZS5wcm9taXNlKCkucHJvZ3Jlc3Moci5ub3RpZnkpLmRvbmUoci5yZXNvbHZlKS5mYWlsKHIucmVqZWN0KSA6IHJbdFswXSArIFwiV2l0aFwiXSh0aGlzLCBuID8gW2VdIDogYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSksIGkgPSBudWxsO1xuXHQgICAgICAgICAgfSkucHJvbWlzZSgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdGhlbjogZnVuY3Rpb24gKHQsIG4sIHIpIHtcblx0ICAgICAgICAgIHZhciB1ID0gMDtcblxuXHQgICAgICAgICAgZnVuY3Rpb24gbChpLCBvLCBhLCBzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgICByID0gYXJndW1lbnRzLFxuXHQgICAgICAgICAgICAgICAgICBlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGUsIHQ7XG5cblx0ICAgICAgICAgICAgICAgIGlmICghKGkgPCB1KSkge1xuXHQgICAgICAgICAgICAgICAgICBpZiAoKGUgPSBhLmFwcGx5KG4sIHIpKSA9PT0gby5wcm9taXNlKCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIik7XG5cdCAgICAgICAgICAgICAgICAgIHQgPSBlICYmIChcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkgJiYgZS50aGVuLCBtKHQpID8gcyA/IHQuY2FsbChlLCBsKHUsIG8sIFIsIHMpLCBsKHUsIG8sIE0sIHMpKSA6ICh1KyssIHQuY2FsbChlLCBsKHUsIG8sIFIsIHMpLCBsKHUsIG8sIE0sIHMpLCBsKHUsIG8sIFIsIG8ubm90aWZ5V2l0aCkpKSA6IChhICE9PSBSICYmIChuID0gdm9pZCAwLCByID0gW2VdKSwgKHMgfHwgby5yZXNvbHZlV2l0aCkobiwgcikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgIHQgPSBzID8gZSA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgIGUoKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgUy5EZWZlcnJlZC5leGNlcHRpb25Ib29rICYmIFMuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayhlLCB0LnN0YWNrVHJhY2UpLCB1IDw9IGkgKyAxICYmIChhICE9PSBNICYmIChuID0gdm9pZCAwLCByID0gW2VdKSwgby5yZWplY3RXaXRoKG4sIHIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgICAgaSA/IHQoKSA6IChTLkRlZmVycmVkLmdldFN0YWNrSG9vayAmJiAodC5zdGFja1RyYWNlID0gUy5EZWZlcnJlZC5nZXRTdGFja0hvb2soKSksIEMuc2V0VGltZW91dCh0KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJldHVybiBTLkRlZmVycmVkKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgIG9bMF1bM10uYWRkKGwoMCwgZSwgbShyKSA/IHIgOiBSLCBlLm5vdGlmeVdpdGgpKSwgb1sxXVszXS5hZGQobCgwLCBlLCBtKHQpID8gdCA6IFIpKSwgb1syXVszXS5hZGQobCgwLCBlLCBtKG4pID8gbiA6IE0pKTtcblx0ICAgICAgICAgIH0pLnByb21pc2UoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHByb21pc2U6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gbnVsbCAhPSBlID8gUy5leHRlbmQoZSwgYSkgOiBhO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgICAgIHMgPSB7fTtcblx0ICAgICAgcmV0dXJuIFMuZWFjaChvLCBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIHZhciBuID0gdFsyXSxcblx0ICAgICAgICAgICAgciA9IHRbNV07XG5cdCAgICAgICAgYVt0WzFdXSA9IG4uYWRkLCByICYmIG4uYWRkKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGkgPSByO1xuXHQgICAgICAgIH0sIG9bMyAtIGVdWzJdLmRpc2FibGUsIG9bMyAtIGVdWzNdLmRpc2FibGUsIG9bMF1bMl0ubG9jaywgb1swXVszXS5sb2NrKSwgbi5hZGQodFszXS5maXJlKSwgc1t0WzBdXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHJldHVybiBzW3RbMF0gKyBcIldpdGhcIl0odGhpcyA9PT0gcyA/IHZvaWQgMCA6IHRoaXMsIGFyZ3VtZW50cyksIHRoaXM7XG5cdCAgICAgICAgfSwgc1t0WzBdICsgXCJXaXRoXCJdID0gbi5maXJlV2l0aDtcblx0ICAgICAgfSksIGEucHJvbWlzZShzKSwgZSAmJiBlLmNhbGwocywgcyksIHM7XG5cdCAgICB9LFxuXHQgICAgd2hlbjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLFxuXHQgICAgICAgICAgdCA9IG4sXG5cdCAgICAgICAgICByID0gQXJyYXkodCksXG5cdCAgICAgICAgICBpID0gcy5jYWxsKGFyZ3VtZW50cyksXG5cdCAgICAgICAgICBvID0gUy5EZWZlcnJlZCgpLFxuXHQgICAgICAgICAgYSA9IGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByW3RdID0gdGhpcywgaVt0XSA9IDEgPCBhcmd1bWVudHMubGVuZ3RoID8gcy5jYWxsKGFyZ3VtZW50cykgOiBlLCAtLW4gfHwgby5yZXNvbHZlV2l0aChyLCBpKTtcblx0ICAgICAgICB9O1xuXHQgICAgICB9O1xuXG5cdCAgICAgIGlmIChuIDw9IDEgJiYgKEkoZSwgby5kb25lKGEodCkpLnJlc29sdmUsIG8ucmVqZWN0LCAhbiksIFwicGVuZGluZ1wiID09PSBvLnN0YXRlKCkgfHwgbShpW3RdICYmIGlbdF0udGhlbikpKSByZXR1cm4gby50aGVuKCk7XG5cblx0ICAgICAgd2hpbGUgKHQtLSkgSShpW3RdLCBhKHQpLCBvLnJlamVjdCk7XG5cblx0ICAgICAgcmV0dXJuIG8ucHJvbWlzZSgpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHZhciBXID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cdCAgUy5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgIEMuY29uc29sZSAmJiBDLmNvbnNvbGUud2FybiAmJiBlICYmIFcudGVzdChlLm5hbWUpICYmIEMuY29uc29sZS53YXJuKFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlLm1lc3NhZ2UsIGUuc3RhY2ssIHQpO1xuXHQgIH0sIFMucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgQy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhyb3cgZTtcblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgdmFyIEYgPSBTLkRlZmVycmVkKCk7XG5cblx0ICBmdW5jdGlvbiBCKCkge1xuXHQgICAgRS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBCKSwgQy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBCKSwgUy5yZWFkeSgpO1xuXHQgIH1cblxuXHQgIFMuZm4ucmVhZHkgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgcmV0dXJuIEYudGhlbihlKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIFMucmVhZHlFeGNlcHRpb24oZSk7XG5cdCAgICB9KSwgdGhpcztcblx0ICB9LCBTLmV4dGVuZCh7XG5cdCAgICBpc1JlYWR5OiAhMSxcblx0ICAgIHJlYWR5V2FpdDogMSxcblx0ICAgIHJlYWR5OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAoITAgPT09IGUgPyAtLVMucmVhZHlXYWl0IDogUy5pc1JlYWR5KSB8fCAoUy5pc1JlYWR5ID0gITApICE9PSBlICYmIDAgPCAtLVMucmVhZHlXYWl0IHx8IEYucmVzb2x2ZVdpdGgoRSwgW1NdKTtcblx0ICAgIH1cblx0ICB9KSwgUy5yZWFkeS50aGVuID0gRi50aGVuLCBcImNvbXBsZXRlXCIgPT09IEUucmVhZHlTdGF0ZSB8fCBcImxvYWRpbmdcIiAhPT0gRS5yZWFkeVN0YXRlICYmICFFLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCA/IEMuc2V0VGltZW91dChTLnJlYWR5KSA6IChFLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIEIpLCBDLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIEIpKTtcblxuXHQgIHZhciAkID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIsIGksIG8sIGEpIHtcblx0ICAgIHZhciBzID0gMCxcblx0ICAgICAgICB1ID0gZS5sZW5ndGgsXG5cdCAgICAgICAgbCA9IG51bGwgPT0gbjtcblx0ICAgIGlmIChcIm9iamVjdFwiID09PSB3KG4pKSBmb3IgKHMgaW4gaSA9ICEwLCBuKSAkKGUsIHQsIHMsIG5bc10sICEwLCBvLCBhKTtlbHNlIGlmICh2b2lkIDAgIT09IHIgJiYgKGkgPSAhMCwgbShyKSB8fCAoYSA9ICEwKSwgbCAmJiAoYSA/ICh0LmNhbGwoZSwgciksIHQgPSBudWxsKSA6IChsID0gdCwgdCA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHJldHVybiBsLmNhbGwoUyhlKSwgbik7XG5cdCAgICB9KSksIHQpKSBmb3IgKDsgcyA8IHU7IHMrKykgdChlW3NdLCBuLCBhID8gciA6IHIuY2FsbChlW3NdLCBzLCB0KGVbc10sIG4pKSk7XG5cdCAgICByZXR1cm4gaSA/IGUgOiBsID8gdC5jYWxsKGUpIDogdSA/IHQoZVswXSwgbikgOiBvO1xuXHQgIH0sXG5cdCAgICAgIF8gPSAvXi1tcy0vLFxuXHQgICAgICB6ID0gLy0oW2Etel0pL2c7XG5cblx0ICBmdW5jdGlvbiBVKGUsIHQpIHtcblx0ICAgIHJldHVybiB0LnRvVXBwZXJDYXNlKCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gWChlKSB7XG5cdCAgICByZXR1cm4gZS5yZXBsYWNlKF8sIFwibXMtXCIpLnJlcGxhY2UoeiwgVSk7XG5cdCAgfVxuXG5cdCAgdmFyIFYgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgcmV0dXJuIDEgPT09IGUubm9kZVR5cGUgfHwgOSA9PT0gZS5ub2RlVHlwZSB8fCAhK2Uubm9kZVR5cGU7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIEcoKSB7XG5cdCAgICB0aGlzLmV4cGFuZG8gPSBTLmV4cGFuZG8gKyBHLnVpZCsrO1xuXHQgIH1cblxuXHQgIEcudWlkID0gMSwgRy5wcm90b3R5cGUgPSB7XG5cdCAgICBjYWNoZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQgPSBlW3RoaXMuZXhwYW5kb107XG5cdCAgICAgIHJldHVybiB0IHx8ICh0ID0ge30sIFYoZSkgJiYgKGUubm9kZVR5cGUgPyBlW3RoaXMuZXhwYW5kb10gPSB0IDogT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHRoaXMuZXhwYW5kbywge1xuXHQgICAgICAgIHZhbHVlOiB0LFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcblx0ICAgICAgfSkpKSwgdDtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHZhciByLFxuXHQgICAgICAgICAgaSA9IHRoaXMuY2FjaGUoZSk7XG5cdCAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0KSBpW1godCldID0gbjtlbHNlIGZvciAociBpbiB0KSBpW1gocildID0gdFtyXTtcblx0ICAgICAgcmV0dXJuIGk7XG5cdCAgICB9LFxuXHQgICAgZ2V0OiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gdm9pZCAwID09PSB0ID8gdGhpcy5jYWNoZShlKSA6IGVbdGhpcy5leHBhbmRvXSAmJiBlW3RoaXMuZXhwYW5kb11bWCh0KV07XG5cdCAgICB9LFxuXHQgICAgYWNjZXNzOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gdm9pZCAwID09PSB0IHx8IHQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiB2b2lkIDAgPT09IG4gPyB0aGlzLmdldChlLCB0KSA6ICh0aGlzLnNldChlLCB0LCBuKSwgdm9pZCAwICE9PSBuID8gbiA6IHQpO1xuXHQgICAgfSxcblx0ICAgIHJlbW92ZTogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgdmFyIG4sXG5cdCAgICAgICAgICByID0gZVt0aGlzLmV4cGFuZG9dO1xuXG5cdCAgICAgIGlmICh2b2lkIDAgIT09IHIpIHtcblx0ICAgICAgICBpZiAodm9pZCAwICE9PSB0KSB7XG5cdCAgICAgICAgICBuID0gKHQgPSBBcnJheS5pc0FycmF5KHQpID8gdC5tYXAoWCkgOiAodCA9IFgodCkpIGluIHIgPyBbdF0gOiB0Lm1hdGNoKFApIHx8IFtdKS5sZW5ndGg7XG5cblx0ICAgICAgICAgIHdoaWxlIChuLS0pIGRlbGV0ZSByW3Rbbl1dO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgICh2b2lkIDAgPT09IHQgfHwgUy5pc0VtcHR5T2JqZWN0KHIpKSAmJiAoZS5ub2RlVHlwZSA/IGVbdGhpcy5leHBhbmRvXSA9IHZvaWQgMCA6IGRlbGV0ZSBlW3RoaXMuZXhwYW5kb10pO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgaGFzRGF0YTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQgPSBlW3RoaXMuZXhwYW5kb107XG5cdCAgICAgIHJldHVybiB2b2lkIDAgIT09IHQgJiYgIVMuaXNFbXB0eU9iamVjdCh0KTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIHZhciBZID0gbmV3IEcoKSxcblx0ICAgICAgUSA9IG5ldyBHKCksXG5cdCAgICAgIEogPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdCAgICAgIEsgPSAvW0EtWl0vZztcblxuXHQgIGZ1bmN0aW9uIFooZSwgdCwgbikge1xuXHQgICAgdmFyIHIsIGk7XG5cdCAgICBpZiAodm9pZCAwID09PSBuICYmIDEgPT09IGUubm9kZVR5cGUpIGlmIChyID0gXCJkYXRhLVwiICsgdC5yZXBsYWNlKEssIFwiLSQmXCIpLnRvTG93ZXJDYXNlKCksIFwic3RyaW5nXCIgPT0gdHlwZW9mIChuID0gZS5nZXRBdHRyaWJ1dGUocikpKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgbiA9IFwidHJ1ZVwiID09PSAoaSA9IG4pIHx8IFwiZmFsc2VcIiAhPT0gaSAmJiAoXCJudWxsXCIgPT09IGkgPyBudWxsIDogaSA9PT0gK2kgKyBcIlwiID8gK2kgOiBKLnRlc3QoaSkgPyBKU09OLnBhcnNlKGkpIDogaSk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cblx0ICAgICAgUS5zZXQoZSwgdCwgbik7XG5cdCAgICB9IGVsc2UgbiA9IHZvaWQgMDtcblx0ICAgIHJldHVybiBuO1xuXHQgIH1cblxuXHQgIFMuZXh0ZW5kKHtcblx0ICAgIGhhc0RhdGE6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBRLmhhc0RhdGEoZSkgfHwgWS5oYXNEYXRhKGUpO1xuXHQgICAgfSxcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHJldHVybiBRLmFjY2VzcyhlLCB0LCBuKTtcblx0ICAgIH0sXG5cdCAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICBRLnJlbW92ZShlLCB0KTtcblx0ICAgIH0sXG5cdCAgICBfZGF0YTogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgcmV0dXJuIFkuYWNjZXNzKGUsIHQsIG4pO1xuXHQgICAgfSxcblx0ICAgIF9yZW1vdmVEYXRhOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICBZLnJlbW92ZShlLCB0KTtcblx0ICAgIH1cblx0ICB9KSwgUy5mbi5leHRlbmQoe1xuXHQgICAgZGF0YTogZnVuY3Rpb24gKG4sIGUpIHtcblx0ICAgICAgdmFyIHQsXG5cdCAgICAgICAgICByLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8gPSB0aGlzWzBdLFxuXHQgICAgICAgICAgYSA9IG8gJiYgby5hdHRyaWJ1dGVzO1xuXG5cdCAgICAgIGlmICh2b2lkIDAgPT09IG4pIHtcblx0ICAgICAgICBpZiAodGhpcy5sZW5ndGggJiYgKGkgPSBRLmdldChvKSwgMSA9PT0gby5ub2RlVHlwZSAmJiAhWS5nZXQobywgXCJoYXNEYXRhQXR0cnNcIikpKSB7XG5cdCAgICAgICAgICB0ID0gYS5sZW5ndGg7XG5cblx0ICAgICAgICAgIHdoaWxlICh0LS0pIGFbdF0gJiYgMCA9PT0gKHIgPSBhW3RdLm5hbWUpLmluZGV4T2YoXCJkYXRhLVwiKSAmJiAociA9IFgoci5zbGljZSg1KSksIFoobywgciwgaVtyXSkpO1xuXG5cdCAgICAgICAgICBZLnNldChvLCBcImhhc0RhdGFBdHRyc1wiLCAhMCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgbiA/IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgUS5zZXQodGhpcywgbik7XG5cdCAgICAgIH0pIDogJCh0aGlzLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciB0O1xuXHQgICAgICAgIGlmIChvICYmIHZvaWQgMCA9PT0gZSkgcmV0dXJuIHZvaWQgMCAhPT0gKHQgPSBRLmdldChvLCBuKSkgPyB0IDogdm9pZCAwICE9PSAodCA9IFoobywgbikpID8gdCA6IHZvaWQgMDtcblx0ICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgUS5zZXQodGhpcywgbiwgZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0sIG51bGwsIGUsIDEgPCBhcmd1bWVudHMubGVuZ3RoLCBudWxsLCAhMCk7XG5cdCAgICB9LFxuXHQgICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgUS5yZW1vdmUodGhpcywgZSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0pLCBTLmV4dGVuZCh7XG5cdCAgICBxdWV1ZTogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgdmFyIHI7XG5cdCAgICAgIGlmIChlKSByZXR1cm4gdCA9ICh0IHx8IFwiZnhcIikgKyBcInF1ZXVlXCIsIHIgPSBZLmdldChlLCB0KSwgbiAmJiAoIXIgfHwgQXJyYXkuaXNBcnJheShuKSA/IHIgPSBZLmFjY2VzcyhlLCB0LCBTLm1ha2VBcnJheShuKSkgOiByLnB1c2gobikpLCByIHx8IFtdO1xuXHQgICAgfSxcblx0ICAgIGRlcXVldWU6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHQgPSB0IHx8IFwiZnhcIjtcblxuXHQgICAgICB2YXIgbiA9IFMucXVldWUoZSwgdCksXG5cdCAgICAgICAgICByID0gbi5sZW5ndGgsXG5cdCAgICAgICAgICBpID0gbi5zaGlmdCgpLFxuXHQgICAgICAgICAgbyA9IFMuX3F1ZXVlSG9va3MoZSwgdCk7XG5cblx0ICAgICAgXCJpbnByb2dyZXNzXCIgPT09IGkgJiYgKGkgPSBuLnNoaWZ0KCksIHItLSksIGkgJiYgKFwiZnhcIiA9PT0gdCAmJiBuLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpLCBkZWxldGUgby5zdG9wLCBpLmNhbGwoZSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFMuZGVxdWV1ZShlLCB0KTtcblx0ICAgICAgfSwgbykpLCAhciAmJiBvICYmIG8uZW1wdHkuZmlyZSgpO1xuXHQgICAgfSxcblx0ICAgIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbiA9IHQgKyBcInF1ZXVlSG9va3NcIjtcblx0ICAgICAgcmV0dXJuIFkuZ2V0KGUsIG4pIHx8IFkuYWNjZXNzKGUsIG4sIHtcblx0ICAgICAgICBlbXB0eTogUy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgWS5yZW1vdmUoZSwgW3QgKyBcInF1ZXVlXCIsIG5dKTtcblx0ICAgICAgICB9KVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9KSwgUy5mbi5leHRlbmQoe1xuXHQgICAgcXVldWU6IGZ1bmN0aW9uICh0LCBuKSB7XG5cdCAgICAgIHZhciBlID0gMjtcblx0ICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT0gdHlwZW9mIHQgJiYgKG4gPSB0LCB0ID0gXCJmeFwiLCBlLS0pLCBhcmd1bWVudHMubGVuZ3RoIDwgZSA/IFMucXVldWUodGhpc1swXSwgdCkgOiB2b2lkIDAgPT09IG4gPyB0aGlzIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZSA9IFMucXVldWUodGhpcywgdCwgbik7XG5cdCAgICAgICAgUy5fcXVldWVIb29rcyh0aGlzLCB0KSwgXCJmeFwiID09PSB0ICYmIFwiaW5wcm9ncmVzc1wiICE9PSBlWzBdICYmIFMuZGVxdWV1ZSh0aGlzLCB0KTtcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgZGVxdWV1ZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgUy5kZXF1ZXVlKHRoaXMsIGUpO1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5xdWV1ZShlIHx8IFwiZnhcIiwgW10pO1xuXHQgICAgfSxcblx0ICAgIHByb21pc2U6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHZhciBuLFxuXHQgICAgICAgICAgciA9IDEsXG5cdCAgICAgICAgICBpID0gUy5EZWZlcnJlZCgpLFxuXHQgICAgICAgICAgbyA9IHRoaXMsXG5cdCAgICAgICAgICBhID0gdGhpcy5sZW5ndGgsXG5cdCAgICAgICAgICBzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC0tciB8fCBpLnJlc29sdmVXaXRoKG8sIFtvXSk7XG5cdCAgICAgIH07XG5cblx0ICAgICAgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSAmJiAodCA9IGUsIGUgPSB2b2lkIDApLCBlID0gZSB8fCBcImZ4XCI7XG5cblx0ICAgICAgd2hpbGUgKGEtLSkgKG4gPSBZLmdldChvW2FdLCBlICsgXCJxdWV1ZUhvb2tzXCIpKSAmJiBuLmVtcHR5ICYmIChyKyssIG4uZW1wdHkuYWRkKHMpKTtcblxuXHQgICAgICByZXR1cm4gcygpLCBpLnByb21pc2UodCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICB2YXIgZWUgPSAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2UsXG5cdCAgICAgIHRlID0gbmV3IFJlZ0V4cChcIl4oPzooWystXSk9fCkoXCIgKyBlZSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIpLFxuXHQgICAgICBuZSA9IFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXSxcblx0ICAgICAgcmUgPSBFLmRvY3VtZW50RWxlbWVudCxcblx0ICAgICAgaWUgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgcmV0dXJuIFMuY29udGFpbnMoZS5vd25lckRvY3VtZW50LCBlKTtcblx0ICB9LFxuXHQgICAgICBvZSA9IHtcblx0ICAgIGNvbXBvc2VkOiAhMFxuXHQgIH07XG5cblx0ICByZS5nZXRSb290Tm9kZSAmJiAoaWUgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgcmV0dXJuIFMuY29udGFpbnMoZS5vd25lckRvY3VtZW50LCBlKSB8fCBlLmdldFJvb3ROb2RlKG9lKSA9PT0gZS5vd25lckRvY3VtZW50O1xuXHQgIH0pO1xuXG5cdCAgdmFyIGFlID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgIHJldHVybiBcIm5vbmVcIiA9PT0gKGUgPSB0IHx8IGUpLnN0eWxlLmRpc3BsYXkgfHwgXCJcIiA9PT0gZS5zdHlsZS5kaXNwbGF5ICYmIGllKGUpICYmIFwibm9uZVwiID09PSBTLmNzcyhlLCBcImRpc3BsYXlcIik7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHNlKGUsIHQsIG4sIHIpIHtcblx0ICAgIHZhciBpLFxuXHQgICAgICAgIG8sXG5cdCAgICAgICAgYSA9IDIwLFxuXHQgICAgICAgIHMgPSByID8gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gci5jdXIoKTtcblx0ICAgIH0gOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBTLmNzcyhlLCB0LCBcIlwiKTtcblx0ICAgIH0sXG5cdCAgICAgICAgdSA9IHMoKSxcblx0ICAgICAgICBsID0gbiAmJiBuWzNdIHx8IChTLmNzc051bWJlclt0XSA/IFwiXCIgOiBcInB4XCIpLFxuXHQgICAgICAgIGMgPSBlLm5vZGVUeXBlICYmIChTLmNzc051bWJlclt0XSB8fCBcInB4XCIgIT09IGwgJiYgK3UpICYmIHRlLmV4ZWMoUy5jc3MoZSwgdCkpO1xuXG5cdCAgICBpZiAoYyAmJiBjWzNdICE9PSBsKSB7XG5cdCAgICAgIHUgLz0gMiwgbCA9IGwgfHwgY1szXSwgYyA9ICt1IHx8IDE7XG5cblx0ICAgICAgd2hpbGUgKGEtLSkgUy5zdHlsZShlLCB0LCBjICsgbCksICgxIC0gbykgKiAoMSAtIChvID0gcygpIC8gdSB8fCAuNSkpIDw9IDAgJiYgKGEgPSAwKSwgYyAvPSBvO1xuXG5cdCAgICAgIGMgKj0gMiwgUy5zdHlsZShlLCB0LCBjICsgbCksIG4gPSBuIHx8IFtdO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbiAmJiAoYyA9ICtjIHx8ICt1IHx8IDAsIGkgPSBuWzFdID8gYyArIChuWzFdICsgMSkgKiBuWzJdIDogK25bMl0sIHIgJiYgKHIudW5pdCA9IGwsIHIuc3RhcnQgPSBjLCByLmVuZCA9IGkpKSwgaTtcblx0ICB9XG5cblx0ICB2YXIgdWUgPSB7fTtcblxuXHQgIGZ1bmN0aW9uIGxlKGUsIHQpIHtcblx0ICAgIGZvciAodmFyIG4sIHIsIGksIG8sIGEsIHMsIHUsIGwgPSBbXSwgYyA9IDAsIGYgPSBlLmxlbmd0aDsgYyA8IGY7IGMrKykgKHIgPSBlW2NdKS5zdHlsZSAmJiAobiA9IHIuc3R5bGUuZGlzcGxheSwgdCA/IChcIm5vbmVcIiA9PT0gbiAmJiAobFtjXSA9IFkuZ2V0KHIsIFwiZGlzcGxheVwiKSB8fCBudWxsLCBsW2NdIHx8IChyLnN0eWxlLmRpc3BsYXkgPSBcIlwiKSksIFwiXCIgPT09IHIuc3R5bGUuZGlzcGxheSAmJiBhZShyKSAmJiAobFtjXSA9ICh1ID0gYSA9IG8gPSB2b2lkIDAsIGEgPSAoaSA9IHIpLm93bmVyRG9jdW1lbnQsIHMgPSBpLm5vZGVOYW1lLCAodSA9IHVlW3NdKSB8fCAobyA9IGEuYm9keS5hcHBlbmRDaGlsZChhLmNyZWF0ZUVsZW1lbnQocykpLCB1ID0gUy5jc3MobywgXCJkaXNwbGF5XCIpLCBvLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobyksIFwibm9uZVwiID09PSB1ICYmICh1ID0gXCJibG9ja1wiKSwgdWVbc10gPSB1KSkpKSA6IFwibm9uZVwiICE9PSBuICYmIChsW2NdID0gXCJub25lXCIsIFkuc2V0KHIsIFwiZGlzcGxheVwiLCBuKSkpO1xuXG5cdCAgICBmb3IgKGMgPSAwOyBjIDwgZjsgYysrKSBudWxsICE9IGxbY10gJiYgKGVbY10uc3R5bGUuZGlzcGxheSA9IGxbY10pO1xuXG5cdCAgICByZXR1cm4gZTtcblx0ICB9XG5cblx0ICBTLmZuLmV4dGVuZCh7XG5cdCAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBsZSh0aGlzLCAhMCk7XG5cdCAgICB9LFxuXHQgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gbGUodGhpcyk7XG5cdCAgICB9LFxuXHQgICAgdG9nZ2xlOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gXCJib29sZWFuXCIgPT0gdHlwZW9mIGUgPyBlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgYWUodGhpcykgPyBTKHRoaXMpLnNob3coKSA6IFModGhpcykuaGlkZSgpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICB2YXIgY2UsXG5cdCAgICAgIGZlLFxuXHQgICAgICBwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLFxuXHQgICAgICBkZSA9IC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSxcblx0ICAgICAgaGUgPSAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pO1xuXHQgIGNlID0gRS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkuYXBwZW5kQ2hpbGQoRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwgKGZlID0gRS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJyYWRpb1wiKSwgZmUuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiksIGZlLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJ0XCIpLCBjZS5hcHBlbmRDaGlsZChmZSksIHkuY2hlY2tDbG9uZSA9IGNlLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCwgY2UuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCIsIHkubm9DbG9uZUNoZWNrZWQgPSAhIWNlLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZSwgY2UuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiLCB5Lm9wdGlvbiA9ICEhY2UubGFzdENoaWxkO1xuXHQgIHZhciBnZSA9IHtcblx0ICAgIHRoZWFkOiBbMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIl0sXG5cdCAgICBjb2w6IFsyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSxcblx0ICAgIHRyOiBbMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sXG5cdCAgICB0ZDogWzMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCJdLFxuXHQgICAgX2RlZmF1bHQ6IFswLCBcIlwiLCBcIlwiXVxuXHQgIH07XG5cblx0ICBmdW5jdGlvbiB2ZShlLCB0KSB7XG5cdCAgICB2YXIgbjtcblx0ICAgIHJldHVybiBuID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodCB8fCBcIipcIikgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBlLnF1ZXJ5U2VsZWN0b3JBbGwgPyBlLnF1ZXJ5U2VsZWN0b3JBbGwodCB8fCBcIipcIikgOiBbXSwgdm9pZCAwID09PSB0IHx8IHQgJiYgQShlLCB0KSA/IFMubWVyZ2UoW2VdLCBuKSA6IG47XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24geWUoZSwgdCkge1xuXHQgICAgZm9yICh2YXIgbiA9IDAsIHIgPSBlLmxlbmd0aDsgbiA8IHI7IG4rKykgWS5zZXQoZVtuXSwgXCJnbG9iYWxFdmFsXCIsICF0IHx8IFkuZ2V0KHRbbl0sIFwiZ2xvYmFsRXZhbFwiKSk7XG5cdCAgfVxuXG5cdCAgZ2UudGJvZHkgPSBnZS50Zm9vdCA9IGdlLmNvbGdyb3VwID0gZ2UuY2FwdGlvbiA9IGdlLnRoZWFkLCBnZS50aCA9IGdlLnRkLCB5Lm9wdGlvbiB8fCAoZ2Uub3B0Z3JvdXAgPSBnZS5vcHRpb24gPSBbMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCJdKTtcblx0ICB2YXIgbWUgPSAvPHwmIz9cXHcrOy87XG5cblx0ICBmdW5jdGlvbiB4ZShlLCB0LCBuLCByLCBpKSB7XG5cdCAgICBmb3IgKHZhciBvLCBhLCBzLCB1LCBsLCBjLCBmID0gdC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHAgPSBbXSwgZCA9IDAsIGggPSBlLmxlbmd0aDsgZCA8IGg7IGQrKykgaWYgKChvID0gZVtkXSkgfHwgMCA9PT0gbykgaWYgKFwib2JqZWN0XCIgPT09IHcobykpIFMubWVyZ2UocCwgby5ub2RlVHlwZSA/IFtvXSA6IG8pO2Vsc2UgaWYgKG1lLnRlc3QobykpIHtcblx0ICAgICAgYSA9IGEgfHwgZi5hcHBlbmRDaGlsZCh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLCBzID0gKGRlLmV4ZWMobykgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpLCB1ID0gZ2Vbc10gfHwgZ2UuX2RlZmF1bHQsIGEuaW5uZXJIVE1MID0gdVsxXSArIFMuaHRtbFByZWZpbHRlcihvKSArIHVbMl0sIGMgPSB1WzBdO1xuXG5cdCAgICAgIHdoaWxlIChjLS0pIGEgPSBhLmxhc3RDaGlsZDtcblxuXHQgICAgICBTLm1lcmdlKHAsIGEuY2hpbGROb2RlcyksIChhID0gZi5maXJzdENoaWxkKS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdCAgICB9IGVsc2UgcC5wdXNoKHQuY3JlYXRlVGV4dE5vZGUobykpO1xuXG5cdCAgICBmLnRleHRDb250ZW50ID0gXCJcIiwgZCA9IDA7XG5cblx0ICAgIHdoaWxlIChvID0gcFtkKytdKSBpZiAociAmJiAtMSA8IFMuaW5BcnJheShvLCByKSkgaSAmJiBpLnB1c2gobyk7ZWxzZSBpZiAobCA9IGllKG8pLCBhID0gdmUoZi5hcHBlbmRDaGlsZChvKSwgXCJzY3JpcHRcIiksIGwgJiYgeWUoYSksIG4pIHtcblx0ICAgICAgYyA9IDA7XG5cblx0ICAgICAgd2hpbGUgKG8gPSBhW2MrK10pIGhlLnRlc3Qoby50eXBlIHx8IFwiXCIpICYmIG4ucHVzaChvKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGY7XG5cdCAgfVxuXG5cdCAgdmFyIGJlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuXHQgIGZ1bmN0aW9uIHdlKCkge1xuXHQgICAgcmV0dXJuICEwO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIFRlKCkge1xuXHQgICAgcmV0dXJuICExO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIENlKGUsIHQpIHtcblx0ICAgIHJldHVybiBlID09PSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgcmV0dXJuIEUuYWN0aXZlRWxlbWVudDtcblx0ICAgICAgfSBjYXRjaCAoZSkge31cblx0ICAgIH0oKSA9PSAoXCJmb2N1c1wiID09PSB0KTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBFZShlLCB0LCBuLCByLCBpLCBvKSB7XG5cdCAgICB2YXIgYSwgcztcblxuXHQgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIHQpIHtcblx0ICAgICAgZm9yIChzIGluIFwic3RyaW5nXCIgIT0gdHlwZW9mIG4gJiYgKHIgPSByIHx8IG4sIG4gPSB2b2lkIDApLCB0KSBFZShlLCBzLCBuLCByLCB0W3NdLCBvKTtcblxuXHQgICAgICByZXR1cm4gZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG51bGwgPT0gciAmJiBudWxsID09IGkgPyAoaSA9IG4sIHIgPSBuID0gdm9pZCAwKSA6IG51bGwgPT0gaSAmJiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiA/IChpID0gciwgciA9IHZvaWQgMCkgOiAoaSA9IHIsIHIgPSBuLCBuID0gdm9pZCAwKSksICExID09PSBpKSBpID0gVGU7ZWxzZSBpZiAoIWkpIHJldHVybiBlO1xuXHQgICAgcmV0dXJuIDEgPT09IG8gJiYgKGEgPSBpLCAoaSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBTKCkub2ZmKGUpLCBhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB9KS5ndWlkID0gYS5ndWlkIHx8IChhLmd1aWQgPSBTLmd1aWQrKykpLCBlLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICBTLmV2ZW50LmFkZCh0aGlzLCB0LCBpLCByLCBuKTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIFNlKGUsIGksIG8pIHtcblx0ICAgIG8gPyAoWS5zZXQoZSwgaSwgITEpLCBTLmV2ZW50LmFkZChlLCBpLCB7XG5cdCAgICAgIG5hbWVzcGFjZTogITEsXG5cdCAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIHQsXG5cdCAgICAgICAgICAgIG4sXG5cdCAgICAgICAgICAgIHIgPSBZLmdldCh0aGlzLCBpKTtcblxuXHQgICAgICAgIGlmICgxICYgZS5pc1RyaWdnZXIgJiYgdGhpc1tpXSkge1xuXHQgICAgICAgICAgaWYgKHIubGVuZ3RoKSAoUy5ldmVudC5zcGVjaWFsW2ldIHx8IHt9KS5kZWxlZ2F0ZVR5cGUgJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtlbHNlIGlmIChyID0gcy5jYWxsKGFyZ3VtZW50cyksIFkuc2V0KHRoaXMsIGksIHIpLCB0ID0gbyh0aGlzLCBpKSwgdGhpc1tpXSgpLCByICE9PSAobiA9IFkuZ2V0KHRoaXMsIGkpKSB8fCB0ID8gWS5zZXQodGhpcywgaSwgITEpIDogbiA9IHt9LCByICE9PSBuKSByZXR1cm4gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCBuICYmIG4udmFsdWU7XG5cdCAgICAgICAgfSBlbHNlIHIubGVuZ3RoICYmIChZLnNldCh0aGlzLCBpLCB7XG5cdCAgICAgICAgICB2YWx1ZTogUy5ldmVudC50cmlnZ2VyKFMuZXh0ZW5kKHJbMF0sIFMuRXZlbnQucHJvdG90eXBlKSwgci5zbGljZSgxKSwgdGhpcylcblx0ICAgICAgICB9KSwgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSk7XG5cdCAgICAgIH1cblx0ICAgIH0pKSA6IHZvaWQgMCA9PT0gWS5nZXQoZSwgaSkgJiYgUy5ldmVudC5hZGQoZSwgaSwgd2UpO1xuXHQgIH1cblxuXHQgIFMuZXZlbnQgPSB7XG5cdCAgICBnbG9iYWw6IHt9LFxuXHQgICAgYWRkOiBmdW5jdGlvbiAodCwgZSwgbiwgciwgaSkge1xuXHQgICAgICB2YXIgbyxcblx0ICAgICAgICAgIGEsXG5cdCAgICAgICAgICBzLFxuXHQgICAgICAgICAgdSxcblx0ICAgICAgICAgIGwsXG5cdCAgICAgICAgICBjLFxuXHQgICAgICAgICAgZixcblx0ICAgICAgICAgIHAsXG5cdCAgICAgICAgICBkLFxuXHQgICAgICAgICAgaCxcblx0ICAgICAgICAgIGcsXG5cdCAgICAgICAgICB2ID0gWS5nZXQodCk7XG5cblx0ICAgICAgaWYgKFYodCkpIHtcblx0ICAgICAgICBuLmhhbmRsZXIgJiYgKG4gPSAobyA9IG4pLmhhbmRsZXIsIGkgPSBvLnNlbGVjdG9yKSwgaSAmJiBTLmZpbmQubWF0Y2hlc1NlbGVjdG9yKHJlLCBpKSwgbi5ndWlkIHx8IChuLmd1aWQgPSBTLmd1aWQrKyksICh1ID0gdi5ldmVudHMpIHx8ICh1ID0gdi5ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSwgKGEgPSB2LmhhbmRsZSkgfHwgKGEgPSB2LmhhbmRsZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUyAmJiBTLmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID8gUy5ldmVudC5kaXNwYXRjaC5hcHBseSh0LCBhcmd1bWVudHMpIDogdm9pZCAwO1xuXHQgICAgICAgIH0pLCBsID0gKGUgPSAoZSB8fCBcIlwiKS5tYXRjaChQKSB8fCBbXCJcIl0pLmxlbmd0aDtcblxuXHQgICAgICAgIHdoaWxlIChsLS0pIGQgPSBnID0gKHMgPSBiZS5leGVjKGVbbF0pIHx8IFtdKVsxXSwgaCA9IChzWzJdIHx8IFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksIGQgJiYgKGYgPSBTLmV2ZW50LnNwZWNpYWxbZF0gfHwge30sIGQgPSAoaSA/IGYuZGVsZWdhdGVUeXBlIDogZi5iaW5kVHlwZSkgfHwgZCwgZiA9IFMuZXZlbnQuc3BlY2lhbFtkXSB8fCB7fSwgYyA9IFMuZXh0ZW5kKHtcblx0ICAgICAgICAgIHR5cGU6IGQsXG5cdCAgICAgICAgICBvcmlnVHlwZTogZyxcblx0ICAgICAgICAgIGRhdGE6IHIsXG5cdCAgICAgICAgICBoYW5kbGVyOiBuLFxuXHQgICAgICAgICAgZ3VpZDogbi5ndWlkLFxuXHQgICAgICAgICAgc2VsZWN0b3I6IGksXG5cdCAgICAgICAgICBuZWVkc0NvbnRleHQ6IGkgJiYgUy5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KGkpLFxuXHQgICAgICAgICAgbmFtZXNwYWNlOiBoLmpvaW4oXCIuXCIpXG5cdCAgICAgICAgfSwgbyksIChwID0gdVtkXSkgfHwgKChwID0gdVtkXSA9IFtdKS5kZWxlZ2F0ZUNvdW50ID0gMCwgZi5zZXR1cCAmJiAhMSAhPT0gZi5zZXR1cC5jYWxsKHQsIHIsIGgsIGEpIHx8IHQuYWRkRXZlbnRMaXN0ZW5lciAmJiB0LmFkZEV2ZW50TGlzdGVuZXIoZCwgYSkpLCBmLmFkZCAmJiAoZi5hZGQuY2FsbCh0LCBjKSwgYy5oYW5kbGVyLmd1aWQgfHwgKGMuaGFuZGxlci5ndWlkID0gbi5ndWlkKSksIGkgPyBwLnNwbGljZShwLmRlbGVnYXRlQ291bnQrKywgMCwgYykgOiBwLnB1c2goYyksIFMuZXZlbnQuZ2xvYmFsW2RdID0gITApO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZSwgdCwgbiwgciwgaSkge1xuXHQgICAgICB2YXIgbyxcblx0ICAgICAgICAgIGEsXG5cdCAgICAgICAgICBzLFxuXHQgICAgICAgICAgdSxcblx0ICAgICAgICAgIGwsXG5cdCAgICAgICAgICBjLFxuXHQgICAgICAgICAgZixcblx0ICAgICAgICAgIHAsXG5cdCAgICAgICAgICBkLFxuXHQgICAgICAgICAgaCxcblx0ICAgICAgICAgIGcsXG5cdCAgICAgICAgICB2ID0gWS5oYXNEYXRhKGUpICYmIFkuZ2V0KGUpO1xuXG5cdCAgICAgIGlmICh2ICYmICh1ID0gdi5ldmVudHMpKSB7XG5cdCAgICAgICAgbCA9ICh0ID0gKHQgfHwgXCJcIikubWF0Y2goUCkgfHwgW1wiXCJdKS5sZW5ndGg7XG5cblx0ICAgICAgICB3aGlsZSAobC0tKSBpZiAoZCA9IGcgPSAocyA9IGJlLmV4ZWModFtsXSkgfHwgW10pWzFdLCBoID0gKHNbMl0gfHwgXCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKSwgZCkge1xuXHQgICAgICAgICAgZiA9IFMuZXZlbnQuc3BlY2lhbFtkXSB8fCB7fSwgcCA9IHVbZCA9IChyID8gZi5kZWxlZ2F0ZVR5cGUgOiBmLmJpbmRUeXBlKSB8fCBkXSB8fCBbXSwgcyA9IHNbMl0gJiYgbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgaC5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKSwgYSA9IG8gPSBwLmxlbmd0aDtcblxuXHQgICAgICAgICAgd2hpbGUgKG8tLSkgYyA9IHBbb10sICFpICYmIGcgIT09IGMub3JpZ1R5cGUgfHwgbiAmJiBuLmd1aWQgIT09IGMuZ3VpZCB8fCBzICYmICFzLnRlc3QoYy5uYW1lc3BhY2UpIHx8IHIgJiYgciAhPT0gYy5zZWxlY3RvciAmJiAoXCIqKlwiICE9PSByIHx8ICFjLnNlbGVjdG9yKSB8fCAocC5zcGxpY2UobywgMSksIGMuc2VsZWN0b3IgJiYgcC5kZWxlZ2F0ZUNvdW50LS0sIGYucmVtb3ZlICYmIGYucmVtb3ZlLmNhbGwoZSwgYykpO1xuXG5cdCAgICAgICAgICBhICYmICFwLmxlbmd0aCAmJiAoZi50ZWFyZG93biAmJiAhMSAhPT0gZi50ZWFyZG93bi5jYWxsKGUsIGgsIHYuaGFuZGxlKSB8fCBTLnJlbW92ZUV2ZW50KGUsIGQsIHYuaGFuZGxlKSwgZGVsZXRlIHVbZF0pO1xuXHQgICAgICAgIH0gZWxzZSBmb3IgKGQgaW4gdSkgUy5ldmVudC5yZW1vdmUoZSwgZCArIHRbbF0sIG4sIHIsICEwKTtcblxuXHQgICAgICAgIFMuaXNFbXB0eU9iamVjdCh1KSAmJiBZLnJlbW92ZShlLCBcImhhbmRsZSBldmVudHNcIik7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBkaXNwYXRjaDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQsXG5cdCAgICAgICAgICBuLFxuXHQgICAgICAgICAgcixcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICBvLFxuXHQgICAgICAgICAgYSxcblx0ICAgICAgICAgIHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksXG5cdCAgICAgICAgICB1ID0gUy5ldmVudC5maXgoZSksXG5cdCAgICAgICAgICBsID0gKFkuZ2V0KHRoaXMsIFwiZXZlbnRzXCIpIHx8IE9iamVjdC5jcmVhdGUobnVsbCkpW3UudHlwZV0gfHwgW10sXG5cdCAgICAgICAgICBjID0gUy5ldmVudC5zcGVjaWFsW3UudHlwZV0gfHwge307XG5cblx0ICAgICAgZm9yIChzWzBdID0gdSwgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspIHNbdF0gPSBhcmd1bWVudHNbdF07XG5cblx0ICAgICAgaWYgKHUuZGVsZWdhdGVUYXJnZXQgPSB0aGlzLCAhYy5wcmVEaXNwYXRjaCB8fCAhMSAhPT0gYy5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsIHUpKSB7XG5cdCAgICAgICAgYSA9IFMuZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCB1LCBsKSwgdCA9IDA7XG5cblx0ICAgICAgICB3aGlsZSAoKGkgPSBhW3QrK10pICYmICF1LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcblx0ICAgICAgICAgIHUuY3VycmVudFRhcmdldCA9IGkuZWxlbSwgbiA9IDA7XG5cblx0ICAgICAgICAgIHdoaWxlICgobyA9IGkuaGFuZGxlcnNbbisrXSkgJiYgIXUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkgdS5ybmFtZXNwYWNlICYmICExICE9PSBvLm5hbWVzcGFjZSAmJiAhdS5ybmFtZXNwYWNlLnRlc3Qoby5uYW1lc3BhY2UpIHx8ICh1LmhhbmRsZU9iaiA9IG8sIHUuZGF0YSA9IG8uZGF0YSwgdm9pZCAwICE9PSAociA9ICgoUy5ldmVudC5zcGVjaWFsW28ub3JpZ1R5cGVdIHx8IHt9KS5oYW5kbGUgfHwgby5oYW5kbGVyKS5hcHBseShpLmVsZW0sIHMpKSAmJiAhMSA9PT0gKHUucmVzdWx0ID0gcikgJiYgKHUucHJldmVudERlZmF1bHQoKSwgdS5zdG9wUHJvcGFnYXRpb24oKSkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBjLnBvc3REaXNwYXRjaCAmJiBjLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMsIHUpLCB1LnJlc3VsdDtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIGhhbmRsZXJzOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbixcblx0ICAgICAgICAgIHIsXG5cdCAgICAgICAgICBpLFxuXHQgICAgICAgICAgbyxcblx0ICAgICAgICAgIGEsXG5cdCAgICAgICAgICBzID0gW10sXG5cdCAgICAgICAgICB1ID0gdC5kZWxlZ2F0ZUNvdW50LFxuXHQgICAgICAgICAgbCA9IGUudGFyZ2V0O1xuXHQgICAgICBpZiAodSAmJiBsLm5vZGVUeXBlICYmICEoXCJjbGlja1wiID09PSBlLnR5cGUgJiYgMSA8PSBlLmJ1dHRvbikpIGZvciAoOyBsICE9PSB0aGlzOyBsID0gbC5wYXJlbnROb2RlIHx8IHRoaXMpIGlmICgxID09PSBsLm5vZGVUeXBlICYmIChcImNsaWNrXCIgIT09IGUudHlwZSB8fCAhMCAhPT0gbC5kaXNhYmxlZCkpIHtcblx0ICAgICAgICBmb3IgKG8gPSBbXSwgYSA9IHt9LCBuID0gMDsgbiA8IHU7IG4rKykgdm9pZCAwID09PSBhW2kgPSAociA9IHRbbl0pLnNlbGVjdG9yICsgXCIgXCJdICYmIChhW2ldID0gci5uZWVkc0NvbnRleHQgPyAtMSA8IFMoaSwgdGhpcykuaW5kZXgobCkgOiBTLmZpbmQoaSwgdGhpcywgbnVsbCwgW2xdKS5sZW5ndGgpLCBhW2ldICYmIG8ucHVzaChyKTtcblxuXHQgICAgICAgIG8ubGVuZ3RoICYmIHMucHVzaCh7XG5cdCAgICAgICAgICBlbGVtOiBsLFxuXHQgICAgICAgICAgaGFuZGxlcnM6IG9cblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbCA9IHRoaXMsIHUgPCB0Lmxlbmd0aCAmJiBzLnB1c2goe1xuXHQgICAgICAgIGVsZW06IGwsXG5cdCAgICAgICAgaGFuZGxlcnM6IHQuc2xpY2UodSlcblx0ICAgICAgfSksIHM7XG5cdCAgICB9LFxuXHQgICAgYWRkUHJvcDogZnVuY3Rpb24gKHQsIGUpIHtcblx0ICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFMuRXZlbnQucHJvdG90eXBlLCB0LCB7XG5cdCAgICAgICAgZW51bWVyYWJsZTogITAsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcblx0ICAgICAgICBnZXQ6IG0oZSkgPyBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSByZXR1cm4gZSh0aGlzLm9yaWdpbmFsRXZlbnQpO1xuXHQgICAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSByZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50W3RdO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHQsIHtcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG5cdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG5cdCAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcblx0ICAgICAgICAgICAgdmFsdWU6IGVcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgZml4OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gZVtTLmV4cGFuZG9dID8gZSA6IG5ldyBTLkV2ZW50KGUpO1xuXHQgICAgfSxcblx0ICAgIHNwZWNpYWw6IHtcblx0ICAgICAgbG9hZDoge1xuXHQgICAgICAgIG5vQnViYmxlOiAhMFxuXHQgICAgICB9LFxuXHQgICAgICBjbGljazoge1xuXHQgICAgICAgIHNldHVwOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQgPSB0aGlzIHx8IGU7XG5cdCAgICAgICAgICByZXR1cm4gcGUudGVzdCh0LnR5cGUpICYmIHQuY2xpY2sgJiYgQSh0LCBcImlucHV0XCIpICYmIFNlKHQsIFwiY2xpY2tcIiwgd2UpLCAhMTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdCA9IHRoaXMgfHwgZTtcblx0ICAgICAgICAgIHJldHVybiBwZS50ZXN0KHQudHlwZSkgJiYgdC5jbGljayAmJiBBKHQsIFwiaW5wdXRcIikgJiYgU2UodCwgXCJjbGlja1wiKSwgITA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBfZGVmYXVsdDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHZhciB0ID0gZS50YXJnZXQ7XG5cdCAgICAgICAgICByZXR1cm4gcGUudGVzdCh0LnR5cGUpICYmIHQuY2xpY2sgJiYgQSh0LCBcImlucHV0XCIpICYmIFkuZ2V0KHQsIFwiY2xpY2tcIikgfHwgQSh0LCBcImFcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBiZWZvcmV1bmxvYWQ6IHtcblx0ICAgICAgICBwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2b2lkIDAgIT09IGUucmVzdWx0ICYmIGUub3JpZ2luYWxFdmVudCAmJiAoZS5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZS5yZXN1bHQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIFMucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyICYmIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBuKTtcblx0ICB9LCBTLkV2ZW50ID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTLkV2ZW50KSkgcmV0dXJuIG5ldyBTLkV2ZW50KGUsIHQpO1xuXHQgICAgZSAmJiBlLnR5cGUgPyAodGhpcy5vcmlnaW5hbEV2ZW50ID0gZSwgdGhpcy50eXBlID0gZS50eXBlLCB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGUuZGVmYXVsdFByZXZlbnRlZCB8fCB2b2lkIDAgPT09IGUuZGVmYXVsdFByZXZlbnRlZCAmJiAhMSA9PT0gZS5yZXR1cm5WYWx1ZSA/IHdlIDogVGUsIHRoaXMudGFyZ2V0ID0gZS50YXJnZXQgJiYgMyA9PT0gZS50YXJnZXQubm9kZVR5cGUgPyBlLnRhcmdldC5wYXJlbnROb2RlIDogZS50YXJnZXQsIHRoaXMuY3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldCwgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gZS5yZWxhdGVkVGFyZ2V0KSA6IHRoaXMudHlwZSA9IGUsIHQgJiYgUy5leHRlbmQodGhpcywgdCksIHRoaXMudGltZVN0YW1wID0gZSAmJiBlLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpLCB0aGlzW1MuZXhwYW5kb10gPSAhMDtcblx0ICB9LCBTLkV2ZW50LnByb3RvdHlwZSA9IHtcblx0ICAgIGNvbnN0cnVjdG9yOiBTLkV2ZW50LFxuXHQgICAgaXNEZWZhdWx0UHJldmVudGVkOiBUZSxcblx0ICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiBUZSxcblx0ICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiBUZSxcblx0ICAgIGlzU2ltdWxhdGVkOiAhMSxcblx0ICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXHQgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHdlLCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICYmIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgIH0sXG5cdCAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cdCAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSB3ZSwgZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgfSxcblx0ICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblx0ICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHdlLCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICYmIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICB9XG5cdCAgfSwgUy5lYWNoKHtcblx0ICAgIGFsdEtleTogITAsXG5cdCAgICBidWJibGVzOiAhMCxcblx0ICAgIGNhbmNlbGFibGU6ICEwLFxuXHQgICAgY2hhbmdlZFRvdWNoZXM6ICEwLFxuXHQgICAgY3RybEtleTogITAsXG5cdCAgICBkZXRhaWw6ICEwLFxuXHQgICAgZXZlbnRQaGFzZTogITAsXG5cdCAgICBtZXRhS2V5OiAhMCxcblx0ICAgIHBhZ2VYOiAhMCxcblx0ICAgIHBhZ2VZOiAhMCxcblx0ICAgIHNoaWZ0S2V5OiAhMCxcblx0ICAgIHZpZXc6ICEwLFxuXHQgICAgXCJjaGFyXCI6ICEwLFxuXHQgICAgY29kZTogITAsXG5cdCAgICBjaGFyQ29kZTogITAsXG5cdCAgICBrZXk6ICEwLFxuXHQgICAga2V5Q29kZTogITAsXG5cdCAgICBidXR0b246ICEwLFxuXHQgICAgYnV0dG9uczogITAsXG5cdCAgICBjbGllbnRYOiAhMCxcblx0ICAgIGNsaWVudFk6ICEwLFxuXHQgICAgb2Zmc2V0WDogITAsXG5cdCAgICBvZmZzZXRZOiAhMCxcblx0ICAgIHBvaW50ZXJJZDogITAsXG5cdCAgICBwb2ludGVyVHlwZTogITAsXG5cdCAgICBzY3JlZW5YOiAhMCxcblx0ICAgIHNjcmVlblk6ICEwLFxuXHQgICAgdGFyZ2V0VG91Y2hlczogITAsXG5cdCAgICB0b0VsZW1lbnQ6ICEwLFxuXHQgICAgdG91Y2hlczogITAsXG5cdCAgICB3aGljaDogITBcblx0ICB9LCBTLmV2ZW50LmFkZFByb3ApLCBTLmVhY2goe1xuXHQgICAgZm9jdXM6IFwiZm9jdXNpblwiLFxuXHQgICAgYmx1cjogXCJmb2N1c291dFwiXG5cdCAgfSwgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgIFMuZXZlbnQuc3BlY2lhbFtlXSA9IHtcblx0ICAgICAgc2V0dXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gU2UodGhpcywgZSwgQ2UpLCAhMTtcblx0ICAgICAgfSxcblx0ICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBTZSh0aGlzLCBlKSwgITA7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9kZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICEwO1xuXHQgICAgICB9LFxuXHQgICAgICBkZWxlZ2F0ZVR5cGU6IHRcblx0ICAgIH07XG5cdCAgfSksIFMuZWFjaCh7XG5cdCAgICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHQgICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHQgICAgcG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdCAgICBwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG5cdCAgfSwgZnVuY3Rpb24gKGUsIGkpIHtcblx0ICAgIFMuZXZlbnQuc3BlY2lhbFtlXSA9IHtcblx0ICAgICAgZGVsZWdhdGVUeXBlOiBpLFxuXHQgICAgICBiaW5kVHlwZTogaSxcblx0ICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciB0LFxuXHQgICAgICAgICAgICBuID0gZS5yZWxhdGVkVGFyZ2V0LFxuXHQgICAgICAgICAgICByID0gZS5oYW5kbGVPYmo7XG5cdCAgICAgICAgcmV0dXJuIG4gJiYgKG4gPT09IHRoaXMgfHwgUy5jb250YWlucyh0aGlzLCBuKSkgfHwgKGUudHlwZSA9IHIub3JpZ1R5cGUsIHQgPSByLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgZS50eXBlID0gaSksIHQ7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfSksIFMuZm4uZXh0ZW5kKHtcblx0ICAgIG9uOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICByZXR1cm4gRWUodGhpcywgZSwgdCwgbiwgcik7XG5cdCAgICB9LFxuXHQgICAgb25lOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICByZXR1cm4gRWUodGhpcywgZSwgdCwgbiwgciwgMSk7XG5cdCAgICB9LFxuXHQgICAgb2ZmOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICB2YXIgciwgaTtcblx0ICAgICAgaWYgKGUgJiYgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLmhhbmRsZU9iaikgcmV0dXJuIHIgPSBlLmhhbmRsZU9iaiwgUyhlLmRlbGVnYXRlVGFyZ2V0KS5vZmYoci5uYW1lc3BhY2UgPyByLm9yaWdUeXBlICsgXCIuXCIgKyByLm5hbWVzcGFjZSA6IHIub3JpZ1R5cGUsIHIuc2VsZWN0b3IsIHIuaGFuZGxlciksIHRoaXM7XG5cblx0ICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUpIHtcblx0ICAgICAgICBmb3IgKGkgaW4gZSkgdGhpcy5vZmYoaSwgdCwgZVtpXSk7XG5cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiAhMSAhPT0gdCAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgfHwgKG4gPSB0LCB0ID0gdm9pZCAwKSwgITEgPT09IG4gJiYgKG4gPSBUZSksIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgUy5ldmVudC5yZW1vdmUodGhpcywgZSwgbiwgdCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHZhciBrZSA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXHQgICAgICBBZSA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdCAgICAgIE5lID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG5cdCAgZnVuY3Rpb24gamUoZSwgdCkge1xuXHQgICAgcmV0dXJuIEEoZSwgXCJ0YWJsZVwiKSAmJiBBKDExICE9PSB0Lm5vZGVUeXBlID8gdCA6IHQuZmlyc3RDaGlsZCwgXCJ0clwiKSAmJiBTKGUpLmNoaWxkcmVuKFwidGJvZHlcIilbMF0gfHwgZTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBEZShlKSB7XG5cdCAgICByZXR1cm4gZS50eXBlID0gKG51bGwgIT09IGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgKyBcIi9cIiArIGUudHlwZSwgZTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBxZShlKSB7XG5cdCAgICByZXR1cm4gXCJ0cnVlL1wiID09PSAoZS50eXBlIHx8IFwiXCIpLnNsaWNlKDAsIDUpID8gZS50eXBlID0gZS50eXBlLnNsaWNlKDUpIDogZS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpLCBlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIExlKGUsIHQpIHtcblx0ICAgIHZhciBuLCByLCBpLCBvLCBhLCBzO1xuXG5cdCAgICBpZiAoMSA9PT0gdC5ub2RlVHlwZSkge1xuXHQgICAgICBpZiAoWS5oYXNEYXRhKGUpICYmIChzID0gWS5nZXQoZSkuZXZlbnRzKSkgZm9yIChpIGluIFkucmVtb3ZlKHQsIFwiaGFuZGxlIGV2ZW50c1wiKSwgcykgZm9yIChuID0gMCwgciA9IHNbaV0ubGVuZ3RoOyBuIDwgcjsgbisrKSBTLmV2ZW50LmFkZCh0LCBpLCBzW2ldW25dKTtcblx0ICAgICAgUS5oYXNEYXRhKGUpICYmIChvID0gUS5hY2Nlc3MoZSksIGEgPSBTLmV4dGVuZCh7fSwgbyksIFEuc2V0KHQsIGEpKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBIZShuLCByLCBpLCBvKSB7XG5cdCAgICByID0gZyhyKTtcblx0ICAgIHZhciBlLFxuXHQgICAgICAgIHQsXG5cdCAgICAgICAgYSxcblx0ICAgICAgICBzLFxuXHQgICAgICAgIHUsXG5cdCAgICAgICAgbCxcblx0ICAgICAgICBjID0gMCxcblx0ICAgICAgICBmID0gbi5sZW5ndGgsXG5cdCAgICAgICAgcCA9IGYgLSAxLFxuXHQgICAgICAgIGQgPSByWzBdLFxuXHQgICAgICAgIGggPSBtKGQpO1xuXHQgICAgaWYgKGggfHwgMSA8IGYgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZCAmJiAheS5jaGVja0Nsb25lICYmIEFlLnRlc3QoZCkpIHJldHVybiBuLmVhY2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQgPSBuLmVxKGUpO1xuXHQgICAgICBoICYmIChyWzBdID0gZC5jYWxsKHRoaXMsIGUsIHQuaHRtbCgpKSksIEhlKHQsIHIsIGksIG8pO1xuXHQgICAgfSk7XG5cblx0ICAgIGlmIChmICYmICh0ID0gKGUgPSB4ZShyLCBuWzBdLm93bmVyRG9jdW1lbnQsICExLCBuLCBvKSkuZmlyc3RDaGlsZCwgMSA9PT0gZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAoZSA9IHQpLCB0IHx8IG8pKSB7XG5cdCAgICAgIGZvciAocyA9IChhID0gUy5tYXAodmUoZSwgXCJzY3JpcHRcIiksIERlKSkubGVuZ3RoOyBjIDwgZjsgYysrKSB1ID0gZSwgYyAhPT0gcCAmJiAodSA9IFMuY2xvbmUodSwgITAsICEwKSwgcyAmJiBTLm1lcmdlKGEsIHZlKHUsIFwic2NyaXB0XCIpKSksIGkuY2FsbChuW2NdLCB1LCBjKTtcblxuXHQgICAgICBpZiAocykgZm9yIChsID0gYVthLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQsIFMubWFwKGEsIHFlKSwgYyA9IDA7IGMgPCBzOyBjKyspIHUgPSBhW2NdLCBoZS50ZXN0KHUudHlwZSB8fCBcIlwiKSAmJiAhWS5hY2Nlc3ModSwgXCJnbG9iYWxFdmFsXCIpICYmIFMuY29udGFpbnMobCwgdSkgJiYgKHUuc3JjICYmIFwibW9kdWxlXCIgIT09ICh1LnR5cGUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA/IFMuX2V2YWxVcmwgJiYgIXUubm9Nb2R1bGUgJiYgUy5fZXZhbFVybCh1LnNyYywge1xuXHQgICAgICAgIG5vbmNlOiB1Lm5vbmNlIHx8IHUuZ2V0QXR0cmlidXRlKFwibm9uY2VcIilcblx0ICAgICAgfSwgbCkgOiBiKHUudGV4dENvbnRlbnQucmVwbGFjZShOZSwgXCJcIiksIHUsIGwpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG47XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gT2UoZSwgdCwgbikge1xuXHQgICAgZm9yICh2YXIgciwgaSA9IHQgPyBTLmZpbHRlcih0LCBlKSA6IGUsIG8gPSAwOyBudWxsICE9IChyID0gaVtvXSk7IG8rKykgbiB8fCAxICE9PSByLm5vZGVUeXBlIHx8IFMuY2xlYW5EYXRhKHZlKHIpKSwgci5wYXJlbnROb2RlICYmIChuICYmIGllKHIpICYmIHllKHZlKHIsIFwic2NyaXB0XCIpKSwgci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHIpKTtcblxuXHQgICAgcmV0dXJuIGU7XG5cdCAgfVxuXG5cdCAgUy5leHRlbmQoe1xuXHQgICAgaHRtbFByZWZpbHRlcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIGU7XG5cdCAgICB9LFxuXHQgICAgY2xvbmU6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHZhciByLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyxcblx0ICAgICAgICAgIHUsXG5cdCAgICAgICAgICBsLFxuXHQgICAgICAgICAgYyA9IGUuY2xvbmVOb2RlKCEwKSxcblx0ICAgICAgICAgIGYgPSBpZShlKTtcblx0ICAgICAgaWYgKCEoeS5ub0Nsb25lQ2hlY2tlZCB8fCAxICE9PSBlLm5vZGVUeXBlICYmIDExICE9PSBlLm5vZGVUeXBlIHx8IFMuaXNYTUxEb2MoZSkpKSBmb3IgKGEgPSB2ZShjKSwgciA9IDAsIGkgPSAobyA9IHZlKGUpKS5sZW5ndGg7IHIgPCBpOyByKyspIHMgPSBvW3JdLCB1ID0gYVtyXSwgXCJpbnB1dFwiID09PSAobCA9IHUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgJiYgcGUudGVzdChzLnR5cGUpID8gdS5jaGVja2VkID0gcy5jaGVja2VkIDogXCJpbnB1dFwiICE9PSBsICYmIFwidGV4dGFyZWFcIiAhPT0gbCB8fCAodS5kZWZhdWx0VmFsdWUgPSBzLmRlZmF1bHRWYWx1ZSk7XG5cdCAgICAgIGlmICh0KSBpZiAobikgZm9yIChvID0gbyB8fCB2ZShlKSwgYSA9IGEgfHwgdmUoYyksIHIgPSAwLCBpID0gby5sZW5ndGg7IHIgPCBpOyByKyspIExlKG9bcl0sIGFbcl0pO2Vsc2UgTGUoZSwgYyk7XG5cdCAgICAgIHJldHVybiAwIDwgKGEgPSB2ZShjLCBcInNjcmlwdFwiKSkubGVuZ3RoICYmIHllKGEsICFmICYmIHZlKGUsIFwic2NyaXB0XCIpKSwgYztcblx0ICAgIH0sXG5cdCAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGZvciAodmFyIHQsIG4sIHIsIGkgPSBTLmV2ZW50LnNwZWNpYWwsIG8gPSAwOyB2b2lkIDAgIT09IChuID0gZVtvXSk7IG8rKykgaWYgKFYobikpIHtcblx0ICAgICAgICBpZiAodCA9IG5bWS5leHBhbmRvXSkge1xuXHQgICAgICAgICAgaWYgKHQuZXZlbnRzKSBmb3IgKHIgaW4gdC5ldmVudHMpIGlbcl0gPyBTLmV2ZW50LnJlbW92ZShuLCByKSA6IFMucmVtb3ZlRXZlbnQobiwgciwgdC5oYW5kbGUpO1xuXHQgICAgICAgICAgbltZLmV4cGFuZG9dID0gdm9pZCAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG5bUS5leHBhbmRvXSAmJiAobltRLmV4cGFuZG9dID0gdm9pZCAwKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pLCBTLmZuLmV4dGVuZCh7XG5cdCAgICBkZXRhY2g6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBPZSh0aGlzLCBlLCAhMCk7XG5cdCAgICB9LFxuXHQgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gT2UodGhpcywgZSk7XG5cdCAgICB9LFxuXHQgICAgdGV4dDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuICQodGhpcywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICByZXR1cm4gdm9pZCAwID09PSBlID8gUy50ZXh0KHRoaXMpIDogdGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiAxMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiA5ICE9PSB0aGlzLm5vZGVUeXBlIHx8ICh0aGlzLnRleHRDb250ZW50ID0gZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0sIG51bGwsIGUsIGFyZ3VtZW50cy5sZW5ndGgpO1xuXHQgICAgfSxcblx0ICAgIGFwcGVuZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gSGUodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIDEgIT09IHRoaXMubm9kZVR5cGUgJiYgMTEgIT09IHRoaXMubm9kZVR5cGUgJiYgOSAhPT0gdGhpcy5ub2RlVHlwZSB8fCBqZSh0aGlzLCBlKS5hcHBlbmRDaGlsZChlKTtcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgcHJlcGVuZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gSGUodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIGlmICgxID09PSB0aGlzLm5vZGVUeXBlIHx8IDExID09PSB0aGlzLm5vZGVUeXBlIHx8IDkgPT09IHRoaXMubm9kZVR5cGUpIHtcblx0ICAgICAgICAgIHZhciB0ID0gamUodGhpcywgZSk7XG5cdCAgICAgICAgICB0Lmluc2VydEJlZm9yZShlLCB0LmZpcnN0Q2hpbGQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgYmVmb3JlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBIZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSwgdGhpcyk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIGFmdGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBIZSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSwgdGhpcy5uZXh0U2libGluZyk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGZvciAodmFyIGUsIHQgPSAwOyBudWxsICE9IChlID0gdGhpc1t0XSk7IHQrKykgMSA9PT0gZS5ub2RlVHlwZSAmJiAoUy5jbGVhbkRhdGEodmUoZSwgITEpKSwgZS50ZXh0Q29udGVudCA9IFwiXCIpO1xuXG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfSxcblx0ICAgIGNsb25lOiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICByZXR1cm4gZSA9IG51bGwgIT0gZSAmJiBlLCB0ID0gbnVsbCA9PSB0ID8gZSA6IHQsIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gUy5jbG9uZSh0aGlzLCBlLCB0KTtcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgaHRtbDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuICQodGhpcywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdCA9IHRoaXNbMF0gfHwge30sXG5cdCAgICAgICAgICAgIG4gPSAwLFxuXHQgICAgICAgICAgICByID0gdGhpcy5sZW5ndGg7XG5cdCAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSAmJiAxID09PSB0Lm5vZGVUeXBlKSByZXR1cm4gdC5pbm5lckhUTUw7XG5cblx0ICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiAha2UudGVzdChlKSAmJiAhZ2VbKGRlLmV4ZWMoZSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpXSkge1xuXHQgICAgICAgICAgZSA9IFMuaHRtbFByZWZpbHRlcihlKTtcblxuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgZm9yICg7IG4gPCByOyBuKyspIDEgPT09ICh0ID0gdGhpc1tuXSB8fCB7fSkubm9kZVR5cGUgJiYgKFMuY2xlYW5EYXRhKHZlKHQsICExKSksIHQuaW5uZXJIVE1MID0gZSk7XG5cblx0ICAgICAgICAgICAgdCA9IDA7XG5cdCAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHQgJiYgdGhpcy5lbXB0eSgpLmFwcGVuZChlKTtcblx0ICAgICAgfSwgbnVsbCwgZSwgYXJndW1lbnRzLmxlbmd0aCk7XG5cdCAgICB9LFxuXHQgICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIG4gPSBbXTtcblx0ICAgICAgcmV0dXJuIEhlKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdCA9IHRoaXMucGFyZW50Tm9kZTtcblx0ICAgICAgICBTLmluQXJyYXkodGhpcywgbikgPCAwICYmIChTLmNsZWFuRGF0YSh2ZSh0aGlzKSksIHQgJiYgdC5yZXBsYWNlQ2hpbGQoZSwgdGhpcykpO1xuXHQgICAgICB9LCBuKTtcblx0ICAgIH1cblx0ICB9KSwgUy5lYWNoKHtcblx0ICAgIGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHQgICAgcHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0ICAgIGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0ICAgIGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdCAgICByZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcblx0ICB9LCBmdW5jdGlvbiAoZSwgYSkge1xuXHQgICAgUy5mbltlXSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGZvciAodmFyIHQsIG4gPSBbXSwgciA9IFMoZSksIGkgPSByLmxlbmd0aCAtIDEsIG8gPSAwOyBvIDw9IGk7IG8rKykgdCA9IG8gPT09IGkgPyB0aGlzIDogdGhpcy5jbG9uZSghMCksIFMocltvXSlbYV0odCksIHUuYXBwbHkobiwgdC5nZXQoKSk7XG5cblx0ICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4pO1xuXHQgICAgfTtcblx0ICB9KTtcblxuXHQgIHZhciBQZSA9IG5ldyBSZWdFeHAoXCJeKFwiICsgZWUgKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiksXG5cdCAgICAgIFJlID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciB0ID0gZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHQgICAgcmV0dXJuIHQgJiYgdC5vcGVuZXIgfHwgKHQgPSBDKSwgdC5nZXRDb21wdXRlZFN0eWxlKGUpO1xuXHQgIH0sXG5cdCAgICAgIE1lID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgIHZhciByLFxuXHQgICAgICAgIGksXG5cdCAgICAgICAgbyA9IHt9O1xuXG5cdCAgICBmb3IgKGkgaW4gdCkgb1tpXSA9IGUuc3R5bGVbaV0sIGUuc3R5bGVbaV0gPSB0W2ldO1xuXG5cdCAgICBmb3IgKGkgaW4gciA9IG4uY2FsbChlKSwgdCkgZS5zdHlsZVtpXSA9IG9baV07XG5cblx0ICAgIHJldHVybiByO1xuXHQgIH0sXG5cdCAgICAgIEllID0gbmV3IFJlZ0V4cChuZS5qb2luKFwifFwiKSwgXCJpXCIpO1xuXG5cdCAgZnVuY3Rpb24gV2UoZSwgdCwgbikge1xuXHQgICAgdmFyIHIsXG5cdCAgICAgICAgaSxcblx0ICAgICAgICBvLFxuXHQgICAgICAgIGEsXG5cdCAgICAgICAgcyA9IGUuc3R5bGU7XG5cdCAgICByZXR1cm4gKG4gPSBuIHx8IFJlKGUpKSAmJiAoXCJcIiAhPT0gKGEgPSBuLmdldFByb3BlcnR5VmFsdWUodCkgfHwgblt0XSkgfHwgaWUoZSkgfHwgKGEgPSBTLnN0eWxlKGUsIHQpKSwgIXkucGl4ZWxCb3hTdHlsZXMoKSAmJiBQZS50ZXN0KGEpICYmIEllLnRlc3QodCkgJiYgKHIgPSBzLndpZHRoLCBpID0gcy5taW5XaWR0aCwgbyA9IHMubWF4V2lkdGgsIHMubWluV2lkdGggPSBzLm1heFdpZHRoID0gcy53aWR0aCA9IGEsIGEgPSBuLndpZHRoLCBzLndpZHRoID0gciwgcy5taW5XaWR0aCA9IGksIHMubWF4V2lkdGggPSBvKSksIHZvaWQgMCAhPT0gYSA/IGEgKyBcIlwiIDogYTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBGZShlLCB0KSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIWUoKSkgcmV0dXJuICh0aGlzLmdldCA9IHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgZGVsZXRlIHRoaXMuZ2V0O1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgICFmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBlKCkge1xuXHQgICAgICBpZiAobCkge1xuXHQgICAgICAgIHUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O21hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiLCBsLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDttYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O3dpZHRoOjYwJTt0b3A6MSVcIiwgcmUuYXBwZW5kQ2hpbGQodSkuYXBwZW5kQ2hpbGQobCk7XG5cdCAgICAgICAgdmFyIGUgPSBDLmdldENvbXB1dGVkU3R5bGUobCk7XG5cdCAgICAgICAgbiA9IFwiMSVcIiAhPT0gZS50b3AsIHMgPSAxMiA9PT0gdChlLm1hcmdpbkxlZnQpLCBsLnN0eWxlLnJpZ2h0ID0gXCI2MCVcIiwgbyA9IDM2ID09PSB0KGUucmlnaHQpLCByID0gMzYgPT09IHQoZS53aWR0aCksIGwuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGkgPSAxMiA9PT0gdChsLm9mZnNldFdpZHRoIC8gMyksIHJlLnJlbW92ZUNoaWxkKHUpLCBsID0gbnVsbDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB0KGUpIHtcblx0ICAgICAgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChlKSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBuLFxuXHQgICAgICAgIHIsXG5cdCAgICAgICAgaSxcblx0ICAgICAgICBvLFxuXHQgICAgICAgIGEsXG5cdCAgICAgICAgcyxcblx0ICAgICAgICB1ID0gRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHQgICAgICAgIGwgPSBFLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdCAgICBsLnN0eWxlICYmIChsLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiLCBsLmNsb25lTm9kZSghMCkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiLCB5LmNsZWFyQ2xvbmVTdHlsZSA9IFwiY29udGVudC1ib3hcIiA9PT0gbC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCwgUy5leHRlbmQoeSwge1xuXHQgICAgICBib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBlKCksIHI7XG5cdCAgICAgIH0sXG5cdCAgICAgIHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGUoKSwgbztcblx0ICAgICAgfSxcblx0ICAgICAgcGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBlKCksIG47XG5cdCAgICAgIH0sXG5cdCAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBlKCksIHM7XG5cdCAgICAgIH0sXG5cdCAgICAgIHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gZSgpLCBpO1xuXHQgICAgICB9LFxuXHQgICAgICByZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBlLCB0LCBuLCByO1xuXHQgICAgICAgIHJldHVybiBudWxsID09IGEgJiYgKGUgPSBFLmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKSwgdCA9IEUuY3JlYXRlRWxlbWVudChcInRyXCIpLCBuID0gRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7Ym9yZGVyLWNvbGxhcHNlOnNlcGFyYXRlXCIsIHQuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjFweCBzb2xpZFwiLCB0LnN0eWxlLmhlaWdodCA9IFwiMXB4XCIsIG4uc3R5bGUuaGVpZ2h0ID0gXCI5cHhcIiwgbi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCByZS5hcHBlbmRDaGlsZChlKS5hcHBlbmRDaGlsZCh0KS5hcHBlbmRDaGlsZChuKSwgciA9IEMuZ2V0Q29tcHV0ZWRTdHlsZSh0KSwgYSA9IHBhcnNlSW50KHIuaGVpZ2h0LCAxMCkgKyBwYXJzZUludChyLmJvcmRlclRvcFdpZHRoLCAxMCkgKyBwYXJzZUludChyLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgPT09IHQub2Zmc2V0SGVpZ2h0LCByZS5yZW1vdmVDaGlsZChlKSksIGE7XG5cdCAgICAgIH1cblx0ICAgIH0pKTtcblx0ICB9KCk7XG5cdCAgdmFyIEJlID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl0sXG5cdCAgICAgICRlID0gRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFxuXHQgICAgICBfZSA9IHt9O1xuXG5cdCAgZnVuY3Rpb24gemUoZSkge1xuXHQgICAgdmFyIHQgPSBTLmNzc1Byb3BzW2VdIHx8IF9lW2VdO1xuXHQgICAgcmV0dXJuIHQgfHwgKGUgaW4gJGUgPyBlIDogX2VbZV0gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdCA9IGVbMF0udG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSksXG5cdCAgICAgICAgICBuID0gQmUubGVuZ3RoO1xuXG5cdCAgICAgIHdoaWxlIChuLS0pIGlmICgoZSA9IEJlW25dICsgdCkgaW4gJGUpIHJldHVybiBlO1xuXHQgICAgfShlKSB8fCBlKTtcblx0ICB9XG5cblx0ICB2YXIgVWUgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdCAgICAgIFhlID0gL14tLS8sXG5cdCAgICAgIFZlID0ge1xuXHQgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcblx0ICAgIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsXG5cdCAgICBkaXNwbGF5OiBcImJsb2NrXCJcblx0ICB9LFxuXHQgICAgICBHZSA9IHtcblx0ICAgIGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHQgICAgZm9udFdlaWdodDogXCI0MDBcIlxuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBZZShlLCB0LCBuKSB7XG5cdCAgICB2YXIgciA9IHRlLmV4ZWModCk7XG5cdCAgICByZXR1cm4gciA/IE1hdGgubWF4KDAsIHJbMl0gLSAobiB8fCAwKSkgKyAoclszXSB8fCBcInB4XCIpIDogdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBRZShlLCB0LCBuLCByLCBpLCBvKSB7XG5cdCAgICB2YXIgYSA9IFwid2lkdGhcIiA9PT0gdCA/IDEgOiAwLFxuXHQgICAgICAgIHMgPSAwLFxuXHQgICAgICAgIHUgPSAwO1xuXHQgICAgaWYgKG4gPT09IChyID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSkgcmV0dXJuIDA7XG5cblx0ICAgIGZvciAoOyBhIDwgNDsgYSArPSAyKSBcIm1hcmdpblwiID09PSBuICYmICh1ICs9IFMuY3NzKGUsIG4gKyBuZVthXSwgITAsIGkpKSwgciA/IChcImNvbnRlbnRcIiA9PT0gbiAmJiAodSAtPSBTLmNzcyhlLCBcInBhZGRpbmdcIiArIG5lW2FdLCAhMCwgaSkpLCBcIm1hcmdpblwiICE9PSBuICYmICh1IC09IFMuY3NzKGUsIFwiYm9yZGVyXCIgKyBuZVthXSArIFwiV2lkdGhcIiwgITAsIGkpKSkgOiAodSArPSBTLmNzcyhlLCBcInBhZGRpbmdcIiArIG5lW2FdLCAhMCwgaSksIFwicGFkZGluZ1wiICE9PSBuID8gdSArPSBTLmNzcyhlLCBcImJvcmRlclwiICsgbmVbYV0gKyBcIldpZHRoXCIsICEwLCBpKSA6IHMgKz0gUy5jc3MoZSwgXCJib3JkZXJcIiArIG5lW2FdICsgXCJXaWR0aFwiLCAhMCwgaSkpO1xuXG5cdCAgICByZXR1cm4gIXIgJiYgMCA8PSBvICYmICh1ICs9IE1hdGgubWF4KDAsIE1hdGguY2VpbChlW1wib2Zmc2V0XCIgKyB0WzBdLnRvVXBwZXJDYXNlKCkgKyB0LnNsaWNlKDEpXSAtIG8gLSB1IC0gcyAtIC41KSkgfHwgMCksIHU7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gSmUoZSwgdCwgbikge1xuXHQgICAgdmFyIHIgPSBSZShlKSxcblx0ICAgICAgICBpID0gKCF5LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgbikgJiYgXCJib3JkZXItYm94XCIgPT09IFMuY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCByKSxcblx0ICAgICAgICBvID0gaSxcblx0ICAgICAgICBhID0gV2UoZSwgdCwgciksXG5cdCAgICAgICAgcyA9IFwib2Zmc2V0XCIgKyB0WzBdLnRvVXBwZXJDYXNlKCkgKyB0LnNsaWNlKDEpO1xuXG5cdCAgICBpZiAoUGUudGVzdChhKSkge1xuXHQgICAgICBpZiAoIW4pIHJldHVybiBhO1xuXHQgICAgICBhID0gXCJhdXRvXCI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiAoIXkuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpIHx8ICF5LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgQShlLCBcInRyXCIpIHx8IFwiYXV0b1wiID09PSBhIHx8ICFwYXJzZUZsb2F0KGEpICYmIFwiaW5saW5lXCIgPT09IFMuY3NzKGUsIFwiZGlzcGxheVwiLCAhMSwgcikpICYmIGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggJiYgKGkgPSBcImJvcmRlci1ib3hcIiA9PT0gUy5jc3MoZSwgXCJib3hTaXppbmdcIiwgITEsIHIpLCAobyA9IHMgaW4gZSkgJiYgKGEgPSBlW3NdKSksIChhID0gcGFyc2VGbG9hdChhKSB8fCAwKSArIFFlKGUsIHQsIG4gfHwgKGkgPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpLCBvLCByLCBhKSArIFwicHhcIjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBLZShlLCB0LCBuLCByLCBpKSB7XG5cdCAgICByZXR1cm4gbmV3IEtlLnByb3RvdHlwZS5pbml0KGUsIHQsIG4sIHIsIGkpO1xuXHQgIH1cblxuXHQgIFMuZXh0ZW5kKHtcblx0ICAgIGNzc0hvb2tzOiB7XG5cdCAgICAgIG9wYWNpdHk6IHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgICBpZiAodCkge1xuXHQgICAgICAgICAgICB2YXIgbiA9IFdlKGUsIFwib3BhY2l0eVwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiXCIgPT09IG4gPyBcIjFcIiA6IG47XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgY3NzTnVtYmVyOiB7XG5cdCAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAhMCxcblx0ICAgICAgY29sdW1uQ291bnQ6ICEwLFxuXHQgICAgICBmaWxsT3BhY2l0eTogITAsXG5cdCAgICAgIGZsZXhHcm93OiAhMCxcblx0ICAgICAgZmxleFNocmluazogITAsXG5cdCAgICAgIGZvbnRXZWlnaHQ6ICEwLFxuXHQgICAgICBncmlkQXJlYTogITAsXG5cdCAgICAgIGdyaWRDb2x1bW46ICEwLFxuXHQgICAgICBncmlkQ29sdW1uRW5kOiAhMCxcblx0ICAgICAgZ3JpZENvbHVtblN0YXJ0OiAhMCxcblx0ICAgICAgZ3JpZFJvdzogITAsXG5cdCAgICAgIGdyaWRSb3dFbmQ6ICEwLFxuXHQgICAgICBncmlkUm93U3RhcnQ6ICEwLFxuXHQgICAgICBsaW5lSGVpZ2h0OiAhMCxcblx0ICAgICAgb3BhY2l0eTogITAsXG5cdCAgICAgIG9yZGVyOiAhMCxcblx0ICAgICAgb3JwaGFuczogITAsXG5cdCAgICAgIHdpZG93czogITAsXG5cdCAgICAgIHpJbmRleDogITAsXG5cdCAgICAgIHpvb206ICEwXG5cdCAgICB9LFxuXHQgICAgY3NzUHJvcHM6IHt9LFxuXHQgICAgc3R5bGU6IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG5cdCAgICAgIGlmIChlICYmIDMgIT09IGUubm9kZVR5cGUgJiYgOCAhPT0gZS5ub2RlVHlwZSAmJiBlLnN0eWxlKSB7XG5cdCAgICAgICAgdmFyIGksXG5cdCAgICAgICAgICAgIG8sXG5cdCAgICAgICAgICAgIGEsXG5cdCAgICAgICAgICAgIHMgPSBYKHQpLFxuXHQgICAgICAgICAgICB1ID0gWGUudGVzdCh0KSxcblx0ICAgICAgICAgICAgbCA9IGUuc3R5bGU7XG5cdCAgICAgICAgaWYgKHUgfHwgKHQgPSB6ZShzKSksIGEgPSBTLmNzc0hvb2tzW3RdIHx8IFMuY3NzSG9va3Nbc10sIHZvaWQgMCA9PT0gbikgcmV0dXJuIGEgJiYgXCJnZXRcIiBpbiBhICYmIHZvaWQgMCAhPT0gKGkgPSBhLmdldChlLCAhMSwgcikpID8gaSA6IGxbdF07XG5cdCAgICAgICAgXCJzdHJpbmdcIiA9PT0gKG8gPSB0eXBlb2YgbikgJiYgKGkgPSB0ZS5leGVjKG4pKSAmJiBpWzFdICYmIChuID0gc2UoZSwgdCwgaSksIG8gPSBcIm51bWJlclwiKSwgbnVsbCAhPSBuICYmIG4gPT0gbiAmJiAoXCJudW1iZXJcIiAhPT0gbyB8fCB1IHx8IChuICs9IGkgJiYgaVszXSB8fCAoUy5jc3NOdW1iZXJbc10gPyBcIlwiIDogXCJweFwiKSksIHkuY2xlYXJDbG9uZVN0eWxlIHx8IFwiXCIgIT09IG4gfHwgMCAhPT0gdC5pbmRleE9mKFwiYmFja2dyb3VuZFwiKSB8fCAobFt0XSA9IFwiaW5oZXJpdFwiKSwgYSAmJiBcInNldFwiIGluIGEgJiYgdm9pZCAwID09PSAobiA9IGEuc2V0KGUsIG4sIHIpKSB8fCAodSA/IGwuc2V0UHJvcGVydHkodCwgbikgOiBsW3RdID0gbikpO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgY3NzOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICB2YXIgaSxcblx0ICAgICAgICAgIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyA9IFgodCk7XG5cdCAgICAgIHJldHVybiBYZS50ZXN0KHQpIHx8ICh0ID0gemUocykpLCAoYSA9IFMuY3NzSG9va3NbdF0gfHwgUy5jc3NIb29rc1tzXSkgJiYgXCJnZXRcIiBpbiBhICYmIChpID0gYS5nZXQoZSwgITAsIG4pKSwgdm9pZCAwID09PSBpICYmIChpID0gV2UoZSwgdCwgcikpLCBcIm5vcm1hbFwiID09PSBpICYmIHQgaW4gR2UgJiYgKGkgPSBHZVt0XSksIFwiXCIgPT09IG4gfHwgbiA/IChvID0gcGFyc2VGbG9hdChpKSwgITAgPT09IG4gfHwgaXNGaW5pdGUobykgPyBvIHx8IDAgOiBpKSA6IGk7XG5cdCAgICB9XG5cdCAgfSksIFMuZWFjaChbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiXSwgZnVuY3Rpb24gKGUsIHUpIHtcblx0ICAgIFMuY3NzSG9va3NbdV0gPSB7XG5cdCAgICAgIGdldDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgICBpZiAodCkgcmV0dXJuICFVZS50ZXN0KFMuY3NzKGUsIFwiZGlzcGxheVwiKSkgfHwgZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCAmJiBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID8gSmUoZSwgdSwgbikgOiBNZShlLCBWZSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgcmV0dXJuIEplKGUsIHUsIG4pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9LFxuXHQgICAgICBzZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgdmFyIHIsXG5cdCAgICAgICAgICAgIGkgPSBSZShlKSxcblx0ICAgICAgICAgICAgbyA9ICF5LnNjcm9sbGJveFNpemUoKSAmJiBcImFic29sdXRlXCIgPT09IGkucG9zaXRpb24sXG5cdCAgICAgICAgICAgIGEgPSAobyB8fCBuKSAmJiBcImJvcmRlci1ib3hcIiA9PT0gUy5jc3MoZSwgXCJib3hTaXppbmdcIiwgITEsIGkpLFxuXHQgICAgICAgICAgICBzID0gbiA/IFFlKGUsIHUsIG4sIGEsIGkpIDogMDtcblx0ICAgICAgICByZXR1cm4gYSAmJiBvICYmIChzIC09IE1hdGguY2VpbChlW1wib2Zmc2V0XCIgKyB1WzBdLnRvVXBwZXJDYXNlKCkgKyB1LnNsaWNlKDEpXSAtIHBhcnNlRmxvYXQoaVt1XSkgLSBRZShlLCB1LCBcImJvcmRlclwiLCAhMSwgaSkgLSAuNSkpLCBzICYmIChyID0gdGUuZXhlYyh0KSkgJiYgXCJweFwiICE9PSAoclszXSB8fCBcInB4XCIpICYmIChlLnN0eWxlW3VdID0gdCwgdCA9IFMuY3NzKGUsIHUpKSwgWWUoMCwgdCwgcyk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfSksIFMuY3NzSG9va3MubWFyZ2luTGVmdCA9IEZlKHkucmVsaWFibGVNYXJnaW5MZWZ0LCBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgaWYgKHQpIHJldHVybiAocGFyc2VGbG9hdChXZShlLCBcIm1hcmdpbkxlZnRcIikpIHx8IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIE1lKGUsIHtcblx0ICAgICAgbWFyZ2luTGVmdDogMFxuXHQgICAgfSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHQgICAgfSkpICsgXCJweFwiO1xuXHQgIH0pLCBTLmVhY2goe1xuXHQgICAgbWFyZ2luOiBcIlwiLFxuXHQgICAgcGFkZGluZzogXCJcIixcblx0ICAgIGJvcmRlcjogXCJXaWR0aFwiXG5cdCAgfSwgZnVuY3Rpb24gKGksIG8pIHtcblx0ICAgIFMuY3NzSG9va3NbaSArIG9dID0ge1xuXHQgICAgICBleHBhbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgZm9yICh2YXIgdCA9IDAsIG4gPSB7fSwgciA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBlLnNwbGl0KFwiIFwiKSA6IFtlXTsgdCA8IDQ7IHQrKykgbltpICsgbmVbdF0gKyBvXSA9IHJbdF0gfHwgclt0IC0gMl0gfHwgclswXTtcblxuXHQgICAgICAgIHJldHVybiBuO1xuXHQgICAgICB9XG5cdCAgICB9LCBcIm1hcmdpblwiICE9PSBpICYmIChTLmNzc0hvb2tzW2kgKyBvXS5zZXQgPSBZZSk7XG5cdCAgfSksIFMuZm4uZXh0ZW5kKHtcblx0ICAgIGNzczogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgcmV0dXJuICQodGhpcywgZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgICB2YXIgcixcblx0ICAgICAgICAgICAgaSxcblx0ICAgICAgICAgICAgbyA9IHt9LFxuXHQgICAgICAgICAgICBhID0gMDtcblxuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG5cdCAgICAgICAgICBmb3IgKHIgPSBSZShlKSwgaSA9IHQubGVuZ3RoOyBhIDwgaTsgYSsrKSBvW3RbYV1dID0gUy5jc3MoZSwgdFthXSwgITEsIHIpO1xuXG5cdCAgICAgICAgICByZXR1cm4gbztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBuID8gUy5zdHlsZShlLCB0LCBuKSA6IFMuY3NzKGUsIHQpO1xuXHQgICAgICB9LCBlLCB0LCAxIDwgYXJndW1lbnRzLmxlbmd0aCk7XG5cdCAgICB9XG5cdCAgfSksICgoUy5Ud2VlbiA9IEtlKS5wcm90b3R5cGUgPSB7XG5cdCAgICBjb25zdHJ1Y3RvcjogS2UsXG5cdCAgICBpbml0OiBmdW5jdGlvbiAoZSwgdCwgbiwgciwgaSwgbykge1xuXHQgICAgICB0aGlzLmVsZW0gPSBlLCB0aGlzLnByb3AgPSBuLCB0aGlzLmVhc2luZyA9IGkgfHwgUy5lYXNpbmcuX2RlZmF1bHQsIHRoaXMub3B0aW9ucyA9IHQsIHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCksIHRoaXMuZW5kID0gciwgdGhpcy51bml0ID0gbyB8fCAoUy5jc3NOdW1iZXJbbl0gPyBcIlwiIDogXCJweFwiKTtcblx0ICAgIH0sXG5cdCAgICBjdXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGUgPSBLZS5wcm9wSG9va3NbdGhpcy5wcm9wXTtcblx0ICAgICAgcmV0dXJuIGUgJiYgZS5nZXQgPyBlLmdldCh0aGlzKSA6IEtlLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcyk7XG5cdCAgICB9LFxuXHQgICAgcnVuOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdCxcblx0ICAgICAgICAgIG4gPSBLZS5wcm9wSG9va3NbdGhpcy5wcm9wXTtcblx0ICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA/IHRoaXMucG9zID0gdCA9IFMuZWFzaW5nW3RoaXMuZWFzaW5nXShlLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBlLCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24pIDogdGhpcy5wb3MgPSB0ID0gZSwgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIHQgKyB0aGlzLnN0YXJ0LCB0aGlzLm9wdGlvbnMuc3RlcCAmJiB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMpLCBuICYmIG4uc2V0ID8gbi5zZXQodGhpcykgOiBLZS5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLCB0aGlzO1xuXHQgICAgfVxuXHQgIH0pLmluaXQucHJvdG90eXBlID0gS2UucHJvdG90eXBlLCAoS2UucHJvcEhvb2tzID0ge1xuXHQgICAgX2RlZmF1bHQ6IHtcblx0ICAgICAgZ2V0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciB0O1xuXHQgICAgICAgIHJldHVybiAxICE9PSBlLmVsZW0ubm9kZVR5cGUgfHwgbnVsbCAhPSBlLmVsZW1bZS5wcm9wXSAmJiBudWxsID09IGUuZWxlbS5zdHlsZVtlLnByb3BdID8gZS5lbGVtW2UucHJvcF0gOiAodCA9IFMuY3NzKGUuZWxlbSwgZS5wcm9wLCBcIlwiKSkgJiYgXCJhdXRvXCIgIT09IHQgPyB0IDogMDtcblx0ICAgICAgfSxcblx0ICAgICAgc2V0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIFMuZnguc3RlcFtlLnByb3BdID8gUy5meC5zdGVwW2UucHJvcF0oZSkgOiAxICE9PSBlLmVsZW0ubm9kZVR5cGUgfHwgIVMuY3NzSG9va3NbZS5wcm9wXSAmJiBudWxsID09IGUuZWxlbS5zdHlsZVt6ZShlLnByb3ApXSA/IGUuZWxlbVtlLnByb3BdID0gZS5ub3cgOiBTLnN0eWxlKGUuZWxlbSwgZS5wcm9wLCBlLm5vdyArIGUudW5pdCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9KS5zY3JvbGxUb3AgPSBLZS5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0ICAgIHNldDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgZS5lbGVtLm5vZGVUeXBlICYmIGUuZWxlbS5wYXJlbnROb2RlICYmIChlLmVsZW1bZS5wcm9wXSA9IGUubm93KTtcblx0ICAgIH1cblx0ICB9LCBTLmVhc2luZyA9IHtcblx0ICAgIGxpbmVhcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIGU7XG5cdCAgICB9LFxuXHQgICAgc3dpbmc6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiAuNSAtIE1hdGguY29zKGUgKiBNYXRoLlBJKSAvIDI7XG5cdCAgICB9LFxuXHQgICAgX2RlZmF1bHQ6IFwic3dpbmdcIlxuXHQgIH0sIFMuZnggPSBLZS5wcm90b3R5cGUuaW5pdCwgUy5meC5zdGVwID0ge307XG5cdCAgdmFyIFplLFxuXHQgICAgICBldCxcblx0ICAgICAgdHQsXG5cdCAgICAgIG50LFxuXHQgICAgICBydCA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0ICAgICAgaXQgPSAvcXVldWVIb29rcyQvO1xuXG5cdCAgZnVuY3Rpb24gb3QoKSB7XG5cdCAgICBldCAmJiAoITEgPT09IEUuaGlkZGVuICYmIEMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gQy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUob3QpIDogQy5zZXRUaW1lb3V0KG90LCBTLmZ4LmludGVydmFsKSwgUy5meC50aWNrKCkpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGF0KCkge1xuXHQgICAgcmV0dXJuIEMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIFplID0gdm9pZCAwO1xuXHQgICAgfSksIFplID0gRGF0ZS5ub3coKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzdChlLCB0KSB7XG5cdCAgICB2YXIgbixcblx0ICAgICAgICByID0gMCxcblx0ICAgICAgICBpID0ge1xuXHQgICAgICBoZWlnaHQ6IGVcblx0ICAgIH07XG5cblx0ICAgIGZvciAodCA9IHQgPyAxIDogMDsgciA8IDQ7IHIgKz0gMiAtIHQpIGlbXCJtYXJnaW5cIiArIChuID0gbmVbcl0pXSA9IGlbXCJwYWRkaW5nXCIgKyBuXSA9IGU7XG5cblx0ICAgIHJldHVybiB0ICYmIChpLm9wYWNpdHkgPSBpLndpZHRoID0gZSksIGk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdXQoZSwgdCwgbikge1xuXHQgICAgZm9yICh2YXIgciwgaSA9IChsdC50d2VlbmVyc1t0XSB8fCBbXSkuY29uY2F0KGx0LnR3ZWVuZXJzW1wiKlwiXSksIG8gPSAwLCBhID0gaS5sZW5ndGg7IG8gPCBhOyBvKyspIGlmIChyID0gaVtvXS5jYWxsKG4sIHQsIGUpKSByZXR1cm4gcjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBsdChvLCBlLCB0KSB7XG5cdCAgICB2YXIgbixcblx0ICAgICAgICBhLFxuXHQgICAgICAgIHIgPSAwLFxuXHQgICAgICAgIGkgPSBsdC5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0ICAgICAgICBzID0gUy5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGRlbGV0ZSB1LmVsZW07XG5cdCAgICB9KSxcblx0ICAgICAgICB1ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoYSkgcmV0dXJuICExO1xuXG5cdCAgICAgIGZvciAodmFyIGUgPSBaZSB8fCBhdCgpLCB0ID0gTWF0aC5tYXgoMCwgbC5zdGFydFRpbWUgKyBsLmR1cmF0aW9uIC0gZSksIG4gPSAxIC0gKHQgLyBsLmR1cmF0aW9uIHx8IDApLCByID0gMCwgaSA9IGwudHdlZW5zLmxlbmd0aDsgciA8IGk7IHIrKykgbC50d2VlbnNbcl0ucnVuKG4pO1xuXG5cdCAgICAgIHJldHVybiBzLm5vdGlmeVdpdGgobywgW2wsIG4sIHRdKSwgbiA8IDEgJiYgaSA/IHQgOiAoaSB8fCBzLm5vdGlmeVdpdGgobywgW2wsIDEsIDBdKSwgcy5yZXNvbHZlV2l0aChvLCBbbF0pLCAhMSk7XG5cdCAgICB9LFxuXHQgICAgICAgIGwgPSBzLnByb21pc2Uoe1xuXHQgICAgICBlbGVtOiBvLFxuXHQgICAgICBwcm9wczogUy5leHRlbmQoe30sIGUpLFxuXHQgICAgICBvcHRzOiBTLmV4dGVuZCghMCwge1xuXHQgICAgICAgIHNwZWNpYWxFYXNpbmc6IHt9LFxuXHQgICAgICAgIGVhc2luZzogUy5lYXNpbmcuX2RlZmF1bHRcblx0ICAgICAgfSwgdCksXG5cdCAgICAgIG9yaWdpbmFsUHJvcGVydGllczogZSxcblx0ICAgICAgb3JpZ2luYWxPcHRpb25zOiB0LFxuXHQgICAgICBzdGFydFRpbWU6IFplIHx8IGF0KCksXG5cdCAgICAgIGR1cmF0aW9uOiB0LmR1cmF0aW9uLFxuXHQgICAgICB0d2VlbnM6IFtdLFxuXHQgICAgICBjcmVhdGVUd2VlbjogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IFMuVHdlZW4obywgbC5vcHRzLCBlLCB0LCBsLm9wdHMuc3BlY2lhbEVhc2luZ1tlXSB8fCBsLm9wdHMuZWFzaW5nKTtcblx0ICAgICAgICByZXR1cm4gbC50d2VlbnMucHVzaChuKSwgbjtcblx0ICAgICAgfSxcblx0ICAgICAgc3RvcDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdCA9IDAsXG5cdCAgICAgICAgICAgIG4gPSBlID8gbC50d2VlbnMubGVuZ3RoIDogMDtcblx0ICAgICAgICBpZiAoYSkgcmV0dXJuIHRoaXM7XG5cblx0ICAgICAgICBmb3IgKGEgPSAhMDsgdCA8IG47IHQrKykgbC50d2VlbnNbdF0ucnVuKDEpO1xuXG5cdCAgICAgICAgcmV0dXJuIGUgPyAocy5ub3RpZnlXaXRoKG8sIFtsLCAxLCAwXSksIHMucmVzb2x2ZVdpdGgobywgW2wsIGVdKSkgOiBzLnJlamVjdFdpdGgobywgW2wsIGVdKSwgdGhpcztcblx0ICAgICAgfVxuXHQgICAgfSksXG5cdCAgICAgICAgYyA9IGwucHJvcHM7XG5cblx0ICAgIGZvciAoIWZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHZhciBuLCByLCBpLCBvLCBhO1xuXG5cdCAgICAgIGZvciAobiBpbiBlKSBpZiAoaSA9IHRbciA9IFgobildLCBvID0gZVtuXSwgQXJyYXkuaXNBcnJheShvKSAmJiAoaSA9IG9bMV0sIG8gPSBlW25dID0gb1swXSksIG4gIT09IHIgJiYgKGVbcl0gPSBvLCBkZWxldGUgZVtuXSksIChhID0gUy5jc3NIb29rc1tyXSkgJiYgKFwiZXhwYW5kXCIgaW4gYSkpIGZvciAobiBpbiBvID0gYS5leHBhbmQobyksIGRlbGV0ZSBlW3JdLCBvKSAobiBpbiBlKSB8fCAoZVtuXSA9IG9bbl0sIHRbbl0gPSBpKTtlbHNlIHRbcl0gPSBpO1xuXHQgICAgfShjLCBsLm9wdHMuc3BlY2lhbEVhc2luZyk7IHIgPCBpOyByKyspIGlmIChuID0gbHQucHJlZmlsdGVyc1tyXS5jYWxsKGwsIG8sIGMsIGwub3B0cykpIHJldHVybiBtKG4uc3RvcCkgJiYgKFMuX3F1ZXVlSG9va3MobC5lbGVtLCBsLm9wdHMucXVldWUpLnN0b3AgPSBuLnN0b3AuYmluZChuKSksIG47XG5cblx0ICAgIHJldHVybiBTLm1hcChjLCB1dCwgbCksIG0obC5vcHRzLnN0YXJ0KSAmJiBsLm9wdHMuc3RhcnQuY2FsbChvLCBsKSwgbC5wcm9ncmVzcyhsLm9wdHMucHJvZ3Jlc3MpLmRvbmUobC5vcHRzLmRvbmUsIGwub3B0cy5jb21wbGV0ZSkuZmFpbChsLm9wdHMuZmFpbCkuYWx3YXlzKGwub3B0cy5hbHdheXMpLCBTLmZ4LnRpbWVyKFMuZXh0ZW5kKHUsIHtcblx0ICAgICAgZWxlbTogbyxcblx0ICAgICAgYW5pbTogbCxcblx0ICAgICAgcXVldWU6IGwub3B0cy5xdWV1ZVxuXHQgICAgfSkpLCBsO1xuXHQgIH1cblxuXHQgIFMuQW5pbWF0aW9uID0gUy5leHRlbmQobHQsIHtcblx0ICAgIHR3ZWVuZXJzOiB7XG5cdCAgICAgIFwiKlwiOiBbZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IHRoaXMuY3JlYXRlVHdlZW4oZSwgdCk7XG5cdCAgICAgICAgcmV0dXJuIHNlKG4uZWxlbSwgZSwgdGUuZXhlYyh0KSwgbiksIG47XG5cdCAgICAgIH1dXG5cdCAgICB9LFxuXHQgICAgdHdlZW5lcjogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgbShlKSA/ICh0ID0gZSwgZSA9IFtcIipcIl0pIDogZSA9IGUubWF0Y2goUCk7XG5cblx0ICAgICAgZm9yICh2YXIgbiwgciA9IDAsIGkgPSBlLmxlbmd0aDsgciA8IGk7IHIrKykgbiA9IGVbcl0sIGx0LnR3ZWVuZXJzW25dID0gbHQudHdlZW5lcnNbbl0gfHwgW10sIGx0LnR3ZWVuZXJzW25dLnVuc2hpZnQodCk7XG5cdCAgICB9LFxuXHQgICAgcHJlZmlsdGVyczogW2Z1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHZhciByLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyxcblx0ICAgICAgICAgIHUsXG5cdCAgICAgICAgICBsLFxuXHQgICAgICAgICAgYyxcblx0ICAgICAgICAgIGYgPSBcIndpZHRoXCIgaW4gdCB8fCBcImhlaWdodFwiIGluIHQsXG5cdCAgICAgICAgICBwID0gdGhpcyxcblx0ICAgICAgICAgIGQgPSB7fSxcblx0ICAgICAgICAgIGggPSBlLnN0eWxlLFxuXHQgICAgICAgICAgZyA9IGUubm9kZVR5cGUgJiYgYWUoZSksXG5cdCAgICAgICAgICB2ID0gWS5nZXQoZSwgXCJmeHNob3dcIik7XG5cblx0ICAgICAgZm9yIChyIGluIG4ucXVldWUgfHwgKG51bGwgPT0gKGEgPSBTLl9xdWV1ZUhvb2tzKGUsIFwiZnhcIikpLnVucXVldWVkICYmIChhLnVucXVldWVkID0gMCwgcyA9IGEuZW1wdHkuZmlyZSwgYS5lbXB0eS5maXJlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGEudW5xdWV1ZWQgfHwgcygpO1xuXHQgICAgICB9KSwgYS51bnF1ZXVlZCsrLCBwLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcC5hbHdheXMoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgYS51bnF1ZXVlZC0tLCBTLnF1ZXVlKGUsIFwiZnhcIikubGVuZ3RoIHx8IGEuZW1wdHkuZmlyZSgpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9KSksIHQpIGlmIChpID0gdFtyXSwgcnQudGVzdChpKSkge1xuXHQgICAgICAgIGlmIChkZWxldGUgdFtyXSwgbyA9IG8gfHwgXCJ0b2dnbGVcIiA9PT0gaSwgaSA9PT0gKGcgPyBcImhpZGVcIiA6IFwic2hvd1wiKSkge1xuXHQgICAgICAgICAgaWYgKFwic2hvd1wiICE9PSBpIHx8ICF2IHx8IHZvaWQgMCA9PT0gdltyXSkgY29udGludWU7XG5cdCAgICAgICAgICBnID0gITA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZFtyXSA9IHYgJiYgdltyXSB8fCBTLnN0eWxlKGUsIHIpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCh1ID0gIVMuaXNFbXB0eU9iamVjdCh0KSkgfHwgIVMuaXNFbXB0eU9iamVjdChkKSkgZm9yIChyIGluIGYgJiYgMSA9PT0gZS5ub2RlVHlwZSAmJiAobi5vdmVyZmxvdyA9IFtoLm92ZXJmbG93LCBoLm92ZXJmbG93WCwgaC5vdmVyZmxvd1ldLCBudWxsID09IChsID0gdiAmJiB2LmRpc3BsYXkpICYmIChsID0gWS5nZXQoZSwgXCJkaXNwbGF5XCIpKSwgXCJub25lXCIgPT09IChjID0gUy5jc3MoZSwgXCJkaXNwbGF5XCIpKSAmJiAobCA/IGMgPSBsIDogKGxlKFtlXSwgITApLCBsID0gZS5zdHlsZS5kaXNwbGF5IHx8IGwsIGMgPSBTLmNzcyhlLCBcImRpc3BsYXlcIiksIGxlKFtlXSkpKSwgKFwiaW5saW5lXCIgPT09IGMgfHwgXCJpbmxpbmUtYmxvY2tcIiA9PT0gYyAmJiBudWxsICE9IGwpICYmIFwibm9uZVwiID09PSBTLmNzcyhlLCBcImZsb2F0XCIpICYmICh1IHx8IChwLmRvbmUoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGguZGlzcGxheSA9IGw7XG5cdCAgICAgIH0pLCBudWxsID09IGwgJiYgKGMgPSBoLmRpc3BsYXksIGwgPSBcIm5vbmVcIiA9PT0gYyA/IFwiXCIgOiBjKSksIGguZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIpKSwgbi5vdmVyZmxvdyAmJiAoaC5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIHAuYWx3YXlzKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBoLm92ZXJmbG93ID0gbi5vdmVyZmxvd1swXSwgaC5vdmVyZmxvd1ggPSBuLm92ZXJmbG93WzFdLCBoLm92ZXJmbG93WSA9IG4ub3ZlcmZsb3dbMl07XG5cdCAgICAgIH0pKSwgdSA9ICExLCBkKSB1IHx8ICh2ID8gXCJoaWRkZW5cIiBpbiB2ICYmIChnID0gdi5oaWRkZW4pIDogdiA9IFkuYWNjZXNzKGUsIFwiZnhzaG93XCIsIHtcblx0ICAgICAgICBkaXNwbGF5OiBsXG5cdCAgICAgIH0pLCBvICYmICh2LmhpZGRlbiA9ICFnKSwgZyAmJiBsZShbZV0sICEwKSwgcC5kb25lKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHIgaW4gZyB8fCBsZShbZV0pLCBZLnJlbW92ZShlLCBcImZ4c2hvd1wiKSwgZCkgUy5zdHlsZShlLCByLCBkW3JdKTtcblx0ICAgICAgfSkpLCB1ID0gdXQoZyA/IHZbcl0gOiAwLCByLCBwKSwgciBpbiB2IHx8ICh2W3JdID0gdS5zdGFydCwgZyAmJiAodS5lbmQgPSB1LnN0YXJ0LCB1LnN0YXJ0ID0gMCkpO1xuXHQgICAgfV0sXG5cdCAgICBwcmVmaWx0ZXI6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHQgPyBsdC5wcmVmaWx0ZXJzLnVuc2hpZnQoZSkgOiBsdC5wcmVmaWx0ZXJzLnB1c2goZSk7XG5cdCAgICB9XG5cdCAgfSksIFMuc3BlZWQgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgdmFyIHIgPSBlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgPyBTLmV4dGVuZCh7fSwgZSkgOiB7XG5cdCAgICAgIGNvbXBsZXRlOiBuIHx8ICFuICYmIHQgfHwgbShlKSAmJiBlLFxuXHQgICAgICBkdXJhdGlvbjogZSxcblx0ICAgICAgZWFzaW5nOiBuICYmIHQgfHwgdCAmJiAhbSh0KSAmJiB0XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFMuZngub2ZmID8gci5kdXJhdGlvbiA9IDAgOiBcIm51bWJlclwiICE9IHR5cGVvZiByLmR1cmF0aW9uICYmIChyLmR1cmF0aW9uIGluIFMuZnguc3BlZWRzID8gci5kdXJhdGlvbiA9IFMuZnguc3BlZWRzW3IuZHVyYXRpb25dIDogci5kdXJhdGlvbiA9IFMuZnguc3BlZWRzLl9kZWZhdWx0KSwgbnVsbCAhPSByLnF1ZXVlICYmICEwICE9PSByLnF1ZXVlIHx8IChyLnF1ZXVlID0gXCJmeFwiKSwgci5vbGQgPSByLmNvbXBsZXRlLCByLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBtKHIub2xkKSAmJiByLm9sZC5jYWxsKHRoaXMpLCByLnF1ZXVlICYmIFMuZGVxdWV1ZSh0aGlzLCByLnF1ZXVlKTtcblx0ICAgIH0sIHI7XG5cdCAgfSwgUy5mbi5leHRlbmQoe1xuXHQgICAgZmFkZVRvOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoYWUpLmNzcyhcIm9wYWNpdHlcIiwgMCkuc2hvdygpLmVuZCgpLmFuaW1hdGUoe1xuXHQgICAgICAgIG9wYWNpdHk6IHRcblx0ICAgICAgfSwgZSwgbiwgcik7XG5cdCAgICB9LFxuXHQgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHQsIGUsIG4sIHIpIHtcblx0ICAgICAgdmFyIGkgPSBTLmlzRW1wdHlPYmplY3QodCksXG5cdCAgICAgICAgICBvID0gUy5zcGVlZChlLCBuLCByKSxcblx0ICAgICAgICAgIGEgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGUgPSBsdCh0aGlzLCBTLmV4dGVuZCh7fSwgdCksIG8pO1xuXHQgICAgICAgIChpIHx8IFkuZ2V0KHRoaXMsIFwiZmluaXNoXCIpKSAmJiBlLnN0b3AoITApO1xuXHQgICAgICB9O1xuXG5cdCAgICAgIHJldHVybiBhLmZpbmlzaCA9IGEsIGkgfHwgITEgPT09IG8ucXVldWUgPyB0aGlzLmVhY2goYSkgOiB0aGlzLnF1ZXVlKG8ucXVldWUsIGEpO1xuXHQgICAgfSxcblx0ICAgIHN0b3A6IGZ1bmN0aW9uIChpLCBlLCBvKSB7XG5cdCAgICAgIHZhciBhID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdCA9IGUuc3RvcDtcblx0ICAgICAgICBkZWxldGUgZS5zdG9wLCB0KG8pO1xuXHQgICAgICB9O1xuXG5cdCAgICAgIHJldHVybiBcInN0cmluZ1wiICE9IHR5cGVvZiBpICYmIChvID0gZSwgZSA9IGksIGkgPSB2b2lkIDApLCBlICYmIHRoaXMucXVldWUoaSB8fCBcImZ4XCIsIFtdKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZSA9ICEwLFxuXHQgICAgICAgICAgICB0ID0gbnVsbCAhPSBpICYmIGkgKyBcInF1ZXVlSG9va3NcIixcblx0ICAgICAgICAgICAgbiA9IFMudGltZXJzLFxuXHQgICAgICAgICAgICByID0gWS5nZXQodGhpcyk7XG5cdCAgICAgICAgaWYgKHQpIHJbdF0gJiYgclt0XS5zdG9wICYmIGEoclt0XSk7ZWxzZSBmb3IgKHQgaW4gcikgclt0XSAmJiByW3RdLnN0b3AgJiYgaXQudGVzdCh0KSAmJiBhKHJbdF0pO1xuXG5cdCAgICAgICAgZm9yICh0ID0gbi5sZW5ndGg7IHQtLTspIG5bdF0uZWxlbSAhPT0gdGhpcyB8fCBudWxsICE9IGkgJiYgblt0XS5xdWV1ZSAhPT0gaSB8fCAoblt0XS5hbmltLnN0b3AobyksIGUgPSAhMSwgbi5zcGxpY2UodCwgMSkpO1xuXG5cdCAgICAgICAgIWUgJiYgbyB8fCBTLmRlcXVldWUodGhpcywgaSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIGZpbmlzaDogZnVuY3Rpb24gKGEpIHtcblx0ICAgICAgcmV0dXJuICExICE9PSBhICYmIChhID0gYSB8fCBcImZ4XCIpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBlLFxuXHQgICAgICAgICAgICB0ID0gWS5nZXQodGhpcyksXG5cdCAgICAgICAgICAgIG4gPSB0W2EgKyBcInF1ZXVlXCJdLFxuXHQgICAgICAgICAgICByID0gdFthICsgXCJxdWV1ZUhvb2tzXCJdLFxuXHQgICAgICAgICAgICBpID0gUy50aW1lcnMsXG5cdCAgICAgICAgICAgIG8gPSBuID8gbi5sZW5ndGggOiAwO1xuXG5cdCAgICAgICAgZm9yICh0LmZpbmlzaCA9ICEwLCBTLnF1ZXVlKHRoaXMsIGEsIFtdKSwgciAmJiByLnN0b3AgJiYgci5zdG9wLmNhbGwodGhpcywgITApLCBlID0gaS5sZW5ndGg7IGUtLTspIGlbZV0uZWxlbSA9PT0gdGhpcyAmJiBpW2VdLnF1ZXVlID09PSBhICYmIChpW2VdLmFuaW0uc3RvcCghMCksIGkuc3BsaWNlKGUsIDEpKTtcblxuXHQgICAgICAgIGZvciAoZSA9IDA7IGUgPCBvOyBlKyspIG5bZV0gJiYgbltlXS5maW5pc2ggJiYgbltlXS5maW5pc2guY2FsbCh0aGlzKTtcblxuXHQgICAgICAgIGRlbGV0ZSB0LmZpbmlzaDtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSksIFMuZWFjaChbXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiXSwgZnVuY3Rpb24gKGUsIHIpIHtcblx0ICAgIHZhciBpID0gUy5mbltyXTtcblxuXHQgICAgUy5mbltyXSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHJldHVybiBudWxsID09IGUgfHwgXCJib29sZWFuXCIgPT0gdHlwZW9mIGUgPyBpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzLmFuaW1hdGUoc3QociwgITApLCBlLCB0LCBuKTtcblx0ICAgIH07XG5cdCAgfSksIFMuZWFjaCh7XG5cdCAgICBzbGlkZURvd246IHN0KFwic2hvd1wiKSxcblx0ICAgIHNsaWRlVXA6IHN0KFwiaGlkZVwiKSxcblx0ICAgIHNsaWRlVG9nZ2xlOiBzdChcInRvZ2dsZVwiKSxcblx0ICAgIGZhZGVJbjoge1xuXHQgICAgICBvcGFjaXR5OiBcInNob3dcIlxuXHQgICAgfSxcblx0ICAgIGZhZGVPdXQ6IHtcblx0ICAgICAgb3BhY2l0eTogXCJoaWRlXCJcblx0ICAgIH0sXG5cdCAgICBmYWRlVG9nZ2xlOiB7XG5cdCAgICAgIG9wYWNpdHk6IFwidG9nZ2xlXCJcblx0ICAgIH1cblx0ICB9LCBmdW5jdGlvbiAoZSwgcikge1xuXHQgICAgUy5mbltlXSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUociwgZSwgdCwgbik7XG5cdCAgICB9O1xuXHQgIH0pLCBTLnRpbWVycyA9IFtdLCBTLmZ4LnRpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZSxcblx0ICAgICAgICB0ID0gMCxcblx0ICAgICAgICBuID0gUy50aW1lcnM7XG5cblx0ICAgIGZvciAoWmUgPSBEYXRlLm5vdygpOyB0IDwgbi5sZW5ndGg7IHQrKykgKGUgPSBuW3RdKSgpIHx8IG5bdF0gIT09IGUgfHwgbi5zcGxpY2UodC0tLCAxKTtcblxuXHQgICAgbi5sZW5ndGggfHwgUy5meC5zdG9wKCksIFplID0gdm9pZCAwO1xuXHQgIH0sIFMuZngudGltZXIgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgUy50aW1lcnMucHVzaChlKSwgUy5meC5zdGFydCgpO1xuXHQgIH0sIFMuZnguaW50ZXJ2YWwgPSAxMywgUy5meC5zdGFydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGV0IHx8IChldCA9ICEwLCBvdCgpKTtcblx0ICB9LCBTLmZ4LnN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBldCA9IG51bGw7XG5cdCAgfSwgUy5meC5zcGVlZHMgPSB7XG5cdCAgICBzbG93OiA2MDAsXG5cdCAgICBmYXN0OiAyMDAsXG5cdCAgICBfZGVmYXVsdDogNDAwXG5cdCAgfSwgUy5mbi5kZWxheSA9IGZ1bmN0aW9uIChyLCBlKSB7XG5cdCAgICByZXR1cm4gciA9IFMuZnggJiYgUy5meC5zcGVlZHNbcl0gfHwgciwgZSA9IGUgfHwgXCJmeFwiLCB0aGlzLnF1ZXVlKGUsIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHZhciBuID0gQy5zZXRUaW1lb3V0KGUsIHIpO1xuXG5cdCAgICAgIHQuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBDLmNsZWFyVGltZW91dChuKTtcblx0ICAgICAgfTtcblx0ICAgIH0pO1xuXHQgIH0sIHR0ID0gRS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksIG50ID0gRS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLmFwcGVuZENoaWxkKEUuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSksIHR0LnR5cGUgPSBcImNoZWNrYm94XCIsIHkuY2hlY2tPbiA9IFwiXCIgIT09IHR0LnZhbHVlLCB5Lm9wdFNlbGVjdGVkID0gbnQuc2VsZWN0ZWQsICh0dCA9IEUuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS52YWx1ZSA9IFwidFwiLCB0dC50eXBlID0gXCJyYWRpb1wiLCB5LnJhZGlvVmFsdWUgPSBcInRcIiA9PT0gdHQudmFsdWU7XG5cdCAgdmFyIGN0LFxuXHQgICAgICBmdCA9IFMuZXhwci5hdHRySGFuZGxlO1xuXHQgIFMuZm4uZXh0ZW5kKHtcblx0ICAgIGF0dHI6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiAkKHRoaXMsIFMuYXR0ciwgZSwgdCwgMSA8IGFyZ3VtZW50cy5sZW5ndGgpO1xuXHQgICAgfSxcblx0ICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFMucmVtb3ZlQXR0cih0aGlzLCBlKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSksIFMuZXh0ZW5kKHtcblx0ICAgIGF0dHI6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHZhciByLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8gPSBlLm5vZGVUeXBlO1xuXHQgICAgICBpZiAoMyAhPT0gbyAmJiA4ICE9PSBvICYmIDIgIT09IG8pIHJldHVybiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBlLmdldEF0dHJpYnV0ZSA/IFMucHJvcChlLCB0LCBuKSA6ICgxID09PSBvICYmIFMuaXNYTUxEb2MoZSkgfHwgKGkgPSBTLmF0dHJIb29rc1t0LnRvTG93ZXJDYXNlKCldIHx8IChTLmV4cHIubWF0Y2guYm9vbC50ZXN0KHQpID8gY3QgOiB2b2lkIDApKSwgdm9pZCAwICE9PSBuID8gbnVsbCA9PT0gbiA/IHZvaWQgUy5yZW1vdmVBdHRyKGUsIHQpIDogaSAmJiBcInNldFwiIGluIGkgJiYgdm9pZCAwICE9PSAociA9IGkuc2V0KGUsIG4sIHQpKSA/IHIgOiAoZS5zZXRBdHRyaWJ1dGUodCwgbiArIFwiXCIpLCBuKSA6IGkgJiYgXCJnZXRcIiBpbiBpICYmIG51bGwgIT09IChyID0gaS5nZXQoZSwgdCkpID8gciA6IG51bGwgPT0gKHIgPSBTLmZpbmQuYXR0cihlLCB0KSkgPyB2b2lkIDAgOiByKTtcblx0ICAgIH0sXG5cdCAgICBhdHRySG9va3M6IHtcblx0ICAgICAgdHlwZToge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICAgIGlmICgheS5yYWRpb1ZhbHVlICYmIFwicmFkaW9cIiA9PT0gdCAmJiBBKGUsIFwiaW5wdXRcIikpIHtcblx0ICAgICAgICAgICAgdmFyIG4gPSBlLnZhbHVlO1xuXHQgICAgICAgICAgICByZXR1cm4gZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHQpLCBuICYmIChlLnZhbHVlID0gbiksIHQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgdmFyIG4sXG5cdCAgICAgICAgICByID0gMCxcblx0ICAgICAgICAgIGkgPSB0ICYmIHQubWF0Y2goUCk7XG5cdCAgICAgIGlmIChpICYmIDEgPT09IGUubm9kZVR5cGUpIHdoaWxlIChuID0gaVtyKytdKSBlLnJlbW92ZUF0dHJpYnV0ZShuKTtcblx0ICAgIH1cblx0ICB9KSwgY3QgPSB7XG5cdCAgICBzZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHJldHVybiAhMSA9PT0gdCA/IFMucmVtb3ZlQXR0cihlLCBuKSA6IGUuc2V0QXR0cmlidXRlKG4sIG4pLCBuO1xuXHQgICAgfVxuXHQgIH0sIFMuZWFjaChTLmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksIGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICB2YXIgYSA9IGZ0W3RdIHx8IFMuZmluZC5hdHRyO1xuXG5cdCAgICBmdFt0XSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHZhciByLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8gPSB0LnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgIHJldHVybiBuIHx8IChpID0gZnRbb10sIGZ0W29dID0gciwgciA9IG51bGwgIT0gYShlLCB0LCBuKSA/IG8gOiBudWxsLCBmdFtvXSA9IGkpLCByO1xuXHQgICAgfTtcblx0ICB9KTtcblx0ICB2YXIgcHQgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHQgICAgICBkdCA9IC9eKD86YXxhcmVhKSQvaTtcblxuXHQgIGZ1bmN0aW9uIGh0KGUpIHtcblx0ICAgIHJldHVybiAoZS5tYXRjaChQKSB8fCBbXSkuam9pbihcIiBcIik7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZ3QoZSkge1xuXHQgICAgcmV0dXJuIGUuZ2V0QXR0cmlidXRlICYmIGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB2dChlKSB7XG5cdCAgICByZXR1cm4gQXJyYXkuaXNBcnJheShlKSA/IGUgOiBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIGUubWF0Y2goUCkgfHwgW107XG5cdCAgfVxuXG5cdCAgUy5mbi5leHRlbmQoe1xuXHQgICAgcHJvcDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgcmV0dXJuICQodGhpcywgUy5wcm9wLCBlLCB0LCAxIDwgYXJndW1lbnRzLmxlbmd0aCk7XG5cdCAgICB9LFxuXHQgICAgcmVtb3ZlUHJvcDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZGVsZXRlIHRoaXNbUy5wcm9wRml4W2VdIHx8IGVdO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9KSwgUy5leHRlbmQoe1xuXHQgICAgcHJvcDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgdmFyIHIsXG5cdCAgICAgICAgICBpLFxuXHQgICAgICAgICAgbyA9IGUubm9kZVR5cGU7XG5cdCAgICAgIGlmICgzICE9PSBvICYmIDggIT09IG8gJiYgMiAhPT0gbykgcmV0dXJuIDEgPT09IG8gJiYgUy5pc1hNTERvYyhlKSB8fCAodCA9IFMucHJvcEZpeFt0XSB8fCB0LCBpID0gUy5wcm9wSG9va3NbdF0pLCB2b2lkIDAgIT09IG4gPyBpICYmIFwic2V0XCIgaW4gaSAmJiB2b2lkIDAgIT09IChyID0gaS5zZXQoZSwgbiwgdCkpID8gciA6IGVbdF0gPSBuIDogaSAmJiBcImdldFwiIGluIGkgJiYgbnVsbCAhPT0gKHIgPSBpLmdldChlLCB0KSkgPyByIDogZVt0XTtcblx0ICAgIH0sXG5cdCAgICBwcm9wSG9va3M6IHtcblx0ICAgICAgdGFiSW5kZXg6IHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdCA9IFMuZmluZC5hdHRyKGUsIFwidGFiaW5kZXhcIik7XG5cdCAgICAgICAgICByZXR1cm4gdCA/IHBhcnNlSW50KHQsIDEwKSA6IHB0LnRlc3QoZS5ub2RlTmFtZSkgfHwgZHQudGVzdChlLm5vZGVOYW1lKSAmJiBlLmhyZWYgPyAwIDogLTE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgcHJvcEZpeDoge1xuXHQgICAgICBcImZvclwiOiBcImh0bWxGb3JcIixcblx0ICAgICAgXCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdCAgICB9XG5cdCAgfSksIHkub3B0U2VsZWN0ZWQgfHwgKFMucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHQgICAgZ2V0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdCA9IGUucGFyZW50Tm9kZTtcblx0ICAgICAgcmV0dXJuIHQgJiYgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCBudWxsO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHQgPSBlLnBhcmVudE5vZGU7XG5cdCAgICAgIHQgJiYgKHQuc2VsZWN0ZWRJbmRleCwgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4KTtcblx0ICAgIH1cblx0ICB9KSwgUy5lYWNoKFtcInRhYkluZGV4XCIsIFwicmVhZE9ubHlcIiwgXCJtYXhMZW5ndGhcIiwgXCJjZWxsU3BhY2luZ1wiLCBcImNlbGxQYWRkaW5nXCIsIFwicm93U3BhblwiLCBcImNvbFNwYW5cIiwgXCJ1c2VNYXBcIiwgXCJmcmFtZUJvcmRlclwiLCBcImNvbnRlbnRFZGl0YWJsZVwiXSwgZnVuY3Rpb24gKCkge1xuXHQgICAgUy5wcm9wRml4W3RoaXMudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xuXHQgIH0pLCBTLmZuLmV4dGVuZCh7XG5cdCAgICBhZGRDbGFzczogZnVuY3Rpb24gKHQpIHtcblx0ICAgICAgdmFyIGUsXG5cdCAgICAgICAgICBuLFxuXHQgICAgICAgICAgcixcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICBvLFxuXHQgICAgICAgICAgYSxcblx0ICAgICAgICAgIHMsXG5cdCAgICAgICAgICB1ID0gMDtcblx0ICAgICAgaWYgKG0odCkpIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBTKHRoaXMpLmFkZENsYXNzKHQuY2FsbCh0aGlzLCBlLCBndCh0aGlzKSkpO1xuXHQgICAgICB9KTtcblx0ICAgICAgaWYgKChlID0gdnQodCkpLmxlbmd0aCkgd2hpbGUgKG4gPSB0aGlzW3UrK10pIGlmIChpID0gZ3QobiksIHIgPSAxID09PSBuLm5vZGVUeXBlICYmIFwiIFwiICsgaHQoaSkgKyBcIiBcIikge1xuXHQgICAgICAgIGEgPSAwO1xuXG5cdCAgICAgICAgd2hpbGUgKG8gPSBlW2ErK10pIHIuaW5kZXhPZihcIiBcIiArIG8gKyBcIiBcIikgPCAwICYmIChyICs9IG8gKyBcIiBcIik7XG5cblx0ICAgICAgICBpICE9PSAocyA9IGh0KHIpKSAmJiBuLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHMpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfSxcblx0ICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAodCkge1xuXHQgICAgICB2YXIgZSxcblx0ICAgICAgICAgIG4sXG5cdCAgICAgICAgICByLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIG8sXG5cdCAgICAgICAgICBhLFxuXHQgICAgICAgICAgcyxcblx0ICAgICAgICAgIHUgPSAwO1xuXHQgICAgICBpZiAobSh0KSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIFModGhpcykucmVtb3ZlQ2xhc3ModC5jYWxsKHRoaXMsIGUsIGd0KHRoaXMpKSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLmF0dHIoXCJjbGFzc1wiLCBcIlwiKTtcblx0ICAgICAgaWYgKChlID0gdnQodCkpLmxlbmd0aCkgd2hpbGUgKG4gPSB0aGlzW3UrK10pIGlmIChpID0gZ3QobiksIHIgPSAxID09PSBuLm5vZGVUeXBlICYmIFwiIFwiICsgaHQoaSkgKyBcIiBcIikge1xuXHQgICAgICAgIGEgPSAwO1xuXG5cdCAgICAgICAgd2hpbGUgKG8gPSBlW2ErK10pIHdoaWxlICgtMSA8IHIuaW5kZXhPZihcIiBcIiArIG8gKyBcIiBcIikpIHIgPSByLnJlcGxhY2UoXCIgXCIgKyBvICsgXCIgXCIsIFwiIFwiKTtcblxuXHQgICAgICAgIGkgIT09IChzID0gaHQocikpICYmIG4uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgcyk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9LFxuXHQgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIChpLCB0KSB7XG5cdCAgICAgIHZhciBvID0gdHlwZW9mIGksXG5cdCAgICAgICAgICBhID0gXCJzdHJpbmdcIiA9PT0gbyB8fCBBcnJheS5pc0FycmF5KGkpO1xuXHQgICAgICByZXR1cm4gXCJib29sZWFuXCIgPT0gdHlwZW9mIHQgJiYgYSA/IHQgPyB0aGlzLmFkZENsYXNzKGkpIDogdGhpcy5yZW1vdmVDbGFzcyhpKSA6IG0oaSkgPyB0aGlzLmVhY2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBTKHRoaXMpLnRvZ2dsZUNsYXNzKGkuY2FsbCh0aGlzLCBlLCBndCh0aGlzKSwgdCksIHQpO1xuXHQgICAgICB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGUsIHQsIG4sIHI7XG5cblx0ICAgICAgICBpZiAoYSkge1xuXHQgICAgICAgICAgdCA9IDAsIG4gPSBTKHRoaXMpLCByID0gdnQoaSk7XG5cblx0ICAgICAgICAgIHdoaWxlIChlID0gclt0KytdKSBuLmhhc0NsYXNzKGUpID8gbi5yZW1vdmVDbGFzcyhlKSA6IG4uYWRkQ2xhc3MoZSk7XG5cdCAgICAgICAgfSBlbHNlIHZvaWQgMCAhPT0gaSAmJiBcImJvb2xlYW5cIiAhPT0gbyB8fCAoKGUgPSBndCh0aGlzKSkgJiYgWS5zZXQodGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGUpLCB0aGlzLnNldEF0dHJpYnV0ZSAmJiB0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGUgfHwgITEgPT09IGkgPyBcIlwiIDogWS5nZXQodGhpcywgXCJfX2NsYXNzTmFtZV9fXCIpIHx8IFwiXCIpKTtcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0LFxuXHQgICAgICAgICAgbixcblx0ICAgICAgICAgIHIgPSAwO1xuXHQgICAgICB0ID0gXCIgXCIgKyBlICsgXCIgXCI7XG5cblx0ICAgICAgd2hpbGUgKG4gPSB0aGlzW3IrK10pIGlmICgxID09PSBuLm5vZGVUeXBlICYmIC0xIDwgKFwiIFwiICsgaHQoZ3QobikpICsgXCIgXCIpLmluZGV4T2YodCkpIHJldHVybiAhMDtcblxuXHQgICAgICByZXR1cm4gITE7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgdmFyIHl0ID0gL1xcci9nO1xuXHQgIFMuZm4uZXh0ZW5kKHtcblx0ICAgIHZhbDogZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgdmFyIHIsXG5cdCAgICAgICAgICBlLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIHQgPSB0aGlzWzBdO1xuXHQgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpID0gbShuKSwgdGhpcy5lYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIHQ7XG5cdCAgICAgICAgMSA9PT0gdGhpcy5ub2RlVHlwZSAmJiAobnVsbCA9PSAodCA9IGkgPyBuLmNhbGwodGhpcywgZSwgUyh0aGlzKS52YWwoKSkgOiBuKSA/IHQgPSBcIlwiIDogXCJudW1iZXJcIiA9PSB0eXBlb2YgdCA/IHQgKz0gXCJcIiA6IEFycmF5LmlzQXJyYXkodCkgJiYgKHQgPSBTLm1hcCh0LCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZSA/IFwiXCIgOiBlICsgXCJcIjtcblx0ICAgICAgICB9KSksIChyID0gUy52YWxIb29rc1t0aGlzLnR5cGVdIHx8IFMudmFsSG9va3NbdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkgJiYgXCJzZXRcIiBpbiByICYmIHZvaWQgMCAhPT0gci5zZXQodGhpcywgdCwgXCJ2YWx1ZVwiKSB8fCAodGhpcy52YWx1ZSA9IHQpKTtcblx0ICAgICAgfSkpIDogdCA/IChyID0gUy52YWxIb29rc1t0LnR5cGVdIHx8IFMudmFsSG9va3NbdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkgJiYgXCJnZXRcIiBpbiByICYmIHZvaWQgMCAhPT0gKGUgPSByLmdldCh0LCBcInZhbHVlXCIpKSA/IGUgOiBcInN0cmluZ1wiID09IHR5cGVvZiAoZSA9IHQudmFsdWUpID8gZS5yZXBsYWNlKHl0LCBcIlwiKSA6IG51bGwgPT0gZSA/IFwiXCIgOiBlIDogdm9pZCAwO1xuXHQgICAgfVxuXHQgIH0pLCBTLmV4dGVuZCh7XG5cdCAgICB2YWxIb29rczoge1xuXHQgICAgICBvcHRpb246IHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdCA9IFMuZmluZC5hdHRyKGUsIFwidmFsdWVcIik7XG5cdCAgICAgICAgICByZXR1cm4gbnVsbCAhPSB0ID8gdCA6IGh0KFMudGV4dChlKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBzZWxlY3Q6IHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdCxcblx0ICAgICAgICAgICAgICBuLFxuXHQgICAgICAgICAgICAgIHIsXG5cdCAgICAgICAgICAgICAgaSA9IGUub3B0aW9ucyxcblx0ICAgICAgICAgICAgICBvID0gZS5zZWxlY3RlZEluZGV4LFxuXHQgICAgICAgICAgICAgIGEgPSBcInNlbGVjdC1vbmVcIiA9PT0gZS50eXBlLFxuXHQgICAgICAgICAgICAgIHMgPSBhID8gbnVsbCA6IFtdLFxuXHQgICAgICAgICAgICAgIHUgPSBhID8gbyArIDEgOiBpLmxlbmd0aDtcblxuXHQgICAgICAgICAgZm9yIChyID0gbyA8IDAgPyB1IDogYSA/IG8gOiAwOyByIDwgdTsgcisrKSBpZiAoKChuID0gaVtyXSkuc2VsZWN0ZWQgfHwgciA9PT0gbykgJiYgIW4uZGlzYWJsZWQgJiYgKCFuLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIUEobi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIpKSkge1xuXHQgICAgICAgICAgICBpZiAodCA9IFMobikudmFsKCksIGEpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBzLnB1c2godCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJldHVybiBzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgICAgdmFyIG4sXG5cdCAgICAgICAgICAgICAgcixcblx0ICAgICAgICAgICAgICBpID0gZS5vcHRpb25zLFxuXHQgICAgICAgICAgICAgIG8gPSBTLm1ha2VBcnJheSh0KSxcblx0ICAgICAgICAgICAgICBhID0gaS5sZW5ndGg7XG5cblx0ICAgICAgICAgIHdoaWxlIChhLS0pICgociA9IGlbYV0pLnNlbGVjdGVkID0gLTEgPCBTLmluQXJyYXkoUy52YWxIb29rcy5vcHRpb24uZ2V0KHIpLCBvKSkgJiYgKG4gPSAhMCk7XG5cblx0ICAgICAgICAgIHJldHVybiBuIHx8IChlLnNlbGVjdGVkSW5kZXggPSAtMSksIG87XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSksIFMuZWFjaChbXCJyYWRpb1wiLCBcImNoZWNrYm94XCJdLCBmdW5jdGlvbiAoKSB7XG5cdCAgICBTLnZhbEhvb2tzW3RoaXNdID0ge1xuXHQgICAgICBzZXQ6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHJldHVybiBlLmNoZWNrZWQgPSAtMSA8IFMuaW5BcnJheShTKGUpLnZhbCgpLCB0KTtcblx0ICAgICAgfVxuXHQgICAgfSwgeS5jaGVja09uIHx8IChTLnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiBudWxsID09PSBlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID8gXCJvblwiIDogZS52YWx1ZTtcblx0ICAgIH0pO1xuXHQgIH0pLCB5LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIEM7XG5cblx0ICB2YXIgbXQgPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdCAgICAgIHh0ID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgfTtcblxuXHQgIFMuZXh0ZW5kKFMuZXZlbnQsIHtcblx0ICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG5cdCAgICAgIHZhciBpLFxuXHQgICAgICAgICAgbyxcblx0ICAgICAgICAgIGEsXG5cdCAgICAgICAgICBzLFxuXHQgICAgICAgICAgdSxcblx0ICAgICAgICAgIGwsXG5cdCAgICAgICAgICBjLFxuXHQgICAgICAgICAgZixcblx0ICAgICAgICAgIHAgPSBbbiB8fCBFXSxcblx0ICAgICAgICAgIGQgPSB2LmNhbGwoZSwgXCJ0eXBlXCIpID8gZS50eXBlIDogZSxcblx0ICAgICAgICAgIGggPSB2LmNhbGwoZSwgXCJuYW1lc3BhY2VcIikgPyBlLm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcblxuXHQgICAgICBpZiAobyA9IGYgPSBhID0gbiA9IG4gfHwgRSwgMyAhPT0gbi5ub2RlVHlwZSAmJiA4ICE9PSBuLm5vZGVUeXBlICYmICFtdC50ZXN0KGQgKyBTLmV2ZW50LnRyaWdnZXJlZCkgJiYgKC0xIDwgZC5pbmRleE9mKFwiLlwiKSAmJiAoZCA9IChoID0gZC5zcGxpdChcIi5cIikpLnNoaWZ0KCksIGguc29ydCgpKSwgdSA9IGQuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIGQsIChlID0gZVtTLmV4cGFuZG9dID8gZSA6IG5ldyBTLkV2ZW50KGQsIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgZSkpLmlzVHJpZ2dlciA9IHIgPyAyIDogMywgZS5uYW1lc3BhY2UgPSBoLmpvaW4oXCIuXCIpLCBlLnJuYW1lc3BhY2UgPSBlLm5hbWVzcGFjZSA/IG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIGguam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIikgOiBudWxsLCBlLnJlc3VsdCA9IHZvaWQgMCwgZS50YXJnZXQgfHwgKGUudGFyZ2V0ID0gbiksIHQgPSBudWxsID09IHQgPyBbZV0gOiBTLm1ha2VBcnJheSh0LCBbZV0pLCBjID0gUy5ldmVudC5zcGVjaWFsW2RdIHx8IHt9LCByIHx8ICFjLnRyaWdnZXIgfHwgITEgIT09IGMudHJpZ2dlci5hcHBseShuLCB0KSkpIHtcblx0ICAgICAgICBpZiAoIXIgJiYgIWMubm9CdWJibGUgJiYgIXgobikpIHtcblx0ICAgICAgICAgIGZvciAocyA9IGMuZGVsZWdhdGVUeXBlIHx8IGQsIG10LnRlc3QocyArIGQpIHx8IChvID0gby5wYXJlbnROb2RlKTsgbzsgbyA9IG8ucGFyZW50Tm9kZSkgcC5wdXNoKG8pLCBhID0gbztcblxuXHQgICAgICAgICAgYSA9PT0gKG4ub3duZXJEb2N1bWVudCB8fCBFKSAmJiBwLnB1c2goYS5kZWZhdWx0VmlldyB8fCBhLnBhcmVudFdpbmRvdyB8fCBDKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpID0gMDtcblxuXHQgICAgICAgIHdoaWxlICgobyA9IHBbaSsrXSkgJiYgIWUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkgZiA9IG8sIGUudHlwZSA9IDEgPCBpID8gcyA6IGMuYmluZFR5cGUgfHwgZCwgKGwgPSAoWS5nZXQobywgXCJldmVudHNcIikgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSlbZS50eXBlXSAmJiBZLmdldChvLCBcImhhbmRsZVwiKSkgJiYgbC5hcHBseShvLCB0KSwgKGwgPSB1ICYmIG9bdV0pICYmIGwuYXBwbHkgJiYgVihvKSAmJiAoZS5yZXN1bHQgPSBsLmFwcGx5KG8sIHQpLCAhMSA9PT0gZS5yZXN1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpKTtcblxuXHQgICAgICAgIHJldHVybiBlLnR5cGUgPSBkLCByIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgYy5fZGVmYXVsdCAmJiAhMSAhPT0gYy5fZGVmYXVsdC5hcHBseShwLnBvcCgpLCB0KSB8fCAhVihuKSB8fCB1ICYmIG0obltkXSkgJiYgIXgobikgJiYgKChhID0gblt1XSkgJiYgKG5bdV0gPSBudWxsKSwgUy5ldmVudC50cmlnZ2VyZWQgPSBkLCBlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZi5hZGRFdmVudExpc3RlbmVyKGQsIHh0KSwgbltkXSgpLCBlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZi5yZW1vdmVFdmVudExpc3RlbmVyKGQsIHh0KSwgUy5ldmVudC50cmlnZ2VyZWQgPSB2b2lkIDAsIGEgJiYgKG5bdV0gPSBhKSksIGUucmVzdWx0O1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgc2ltdWxhdGU6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHZhciByID0gUy5leHRlbmQobmV3IFMuRXZlbnQoKSwgbiwge1xuXHQgICAgICAgIHR5cGU6IGUsXG5cdCAgICAgICAgaXNTaW11bGF0ZWQ6ICEwXG5cdCAgICAgIH0pO1xuXHQgICAgICBTLmV2ZW50LnRyaWdnZXIociwgbnVsbCwgdCk7XG5cdCAgICB9XG5cdCAgfSksIFMuZm4uZXh0ZW5kKHtcblx0ICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFMuZXZlbnQudHJpZ2dlcihlLCB0LCB0aGlzKTtcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHZhciBuID0gdGhpc1swXTtcblx0ICAgICAgaWYgKG4pIHJldHVybiBTLmV2ZW50LnRyaWdnZXIoZSwgdCwgbiwgITApO1xuXHQgICAgfVxuXHQgIH0pLCB5LmZvY3VzaW4gfHwgUy5lYWNoKHtcblx0ICAgIGZvY3VzOiBcImZvY3VzaW5cIixcblx0ICAgIGJsdXI6IFwiZm9jdXNvdXRcIlxuXHQgIH0sIGZ1bmN0aW9uIChuLCByKSB7XG5cdCAgICB2YXIgaSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIFMuZXZlbnQuc2ltdWxhdGUociwgZS50YXJnZXQsIFMuZXZlbnQuZml4KGUpKTtcblx0ICAgIH07XG5cblx0ICAgIFMuZXZlbnQuc3BlY2lhbFtyXSA9IHtcblx0ICAgICAgc2V0dXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZSA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdCAgICAgICAgICAgIHQgPSBZLmFjY2VzcyhlLCByKTtcblx0ICAgICAgICB0IHx8IGUuYWRkRXZlbnRMaXN0ZW5lcihuLCBpLCAhMCksIFkuYWNjZXNzKGUsIHIsICh0IHx8IDApICsgMSk7XG5cdCAgICAgIH0sXG5cdCAgICAgIHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGUgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHQgICAgICAgICAgICB0ID0gWS5hY2Nlc3MoZSwgcikgLSAxO1xuXHQgICAgICAgIHQgPyBZLmFjY2VzcyhlLCByLCB0KSA6IChlLnJlbW92ZUV2ZW50TGlzdGVuZXIobiwgaSwgITApLCBZLnJlbW92ZShlLCByKSk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfSk7XG5cdCAgdmFyIGJ0ID0gQy5sb2NhdGlvbixcblx0ICAgICAgd3QgPSB7XG5cdCAgICBndWlkOiBEYXRlLm5vdygpXG5cdCAgfSxcblx0ICAgICAgVHQgPSAvXFw/LztcblxuXHQgIFMucGFyc2VYTUwgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgdmFyIHQsIG47XG5cdCAgICBpZiAoIWUgfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSkgcmV0dXJuIG51bGw7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIHQgPSBuZXcgQy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZSwgXCJ0ZXh0L3htbFwiKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cblx0ICAgIHJldHVybiBuID0gdCAmJiB0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIilbMF0sIHQgJiYgIW4gfHwgUy5lcnJvcihcIkludmFsaWQgWE1MOiBcIiArIChuID8gUy5tYXAobi5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gZS50ZXh0Q29udGVudDtcblx0ICAgIH0pLmpvaW4oXCJcXG5cIikgOiBlKSksIHQ7XG5cdCAgfTtcblxuXHQgIHZhciBDdCA9IC9cXFtcXF0kLyxcblx0ICAgICAgRXQgPSAvXFxyP1xcbi9nLFxuXHQgICAgICBTdCA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0ICAgICAga3QgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cblx0ICBmdW5jdGlvbiBBdChuLCBlLCByLCBpKSB7XG5cdCAgICB2YXIgdDtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSBTLmVhY2goZSwgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgciB8fCBDdC50ZXN0KG4pID8gaShuLCB0KSA6IEF0KG4gKyBcIltcIiArIChcIm9iamVjdFwiID09IHR5cGVvZiB0ICYmIG51bGwgIT0gdCA/IGUgOiBcIlwiKSArIFwiXVwiLCB0LCByLCBpKTtcblx0ICAgIH0pO2Vsc2UgaWYgKHIgfHwgXCJvYmplY3RcIiAhPT0gdyhlKSkgaShuLCBlKTtlbHNlIGZvciAodCBpbiBlKSBBdChuICsgXCJbXCIgKyB0ICsgXCJdXCIsIGVbdF0sIHIsIGkpO1xuXHQgIH1cblxuXHQgIFMucGFyYW0gPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgdmFyIG4sXG5cdCAgICAgICAgciA9IFtdLFxuXHQgICAgICAgIGkgPSBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICB2YXIgbiA9IG0odCkgPyB0KCkgOiB0O1xuXHQgICAgICByW3IubGVuZ3RoXSA9IGVuY29kZVVSSUNvbXBvbmVudChlKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG51bGwgPT0gbiA/IFwiXCIgOiBuKTtcblx0ICAgIH07XG5cblx0ICAgIGlmIChudWxsID09IGUpIHJldHVybiBcIlwiO1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkgfHwgZS5qcXVlcnkgJiYgIVMuaXNQbGFpbk9iamVjdChlKSkgUy5lYWNoKGUsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaSh0aGlzLm5hbWUsIHRoaXMudmFsdWUpO1xuXHQgICAgfSk7ZWxzZSBmb3IgKG4gaW4gZSkgQXQobiwgZVtuXSwgdCwgaSk7XG5cdCAgICByZXR1cm4gci5qb2luKFwiJlwiKTtcblx0ICB9LCBTLmZuLmV4dGVuZCh7XG5cdCAgICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIFMucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKTtcblx0ICAgIH0sXG5cdCAgICBzZXJpYWxpemVBcnJheTogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBlID0gUy5wcm9wKHRoaXMsIFwiZWxlbWVudHNcIik7XG5cdCAgICAgICAgcmV0dXJuIGUgPyBTLm1ha2VBcnJheShlKSA6IHRoaXM7XG5cdCAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGUgPSB0aGlzLnR5cGU7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubmFtZSAmJiAhUyh0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSAmJiBrdC50ZXN0KHRoaXMubm9kZU5hbWUpICYmICFTdC50ZXN0KGUpICYmICh0aGlzLmNoZWNrZWQgfHwgIXBlLnRlc3QoZSkpO1xuXHQgICAgICB9KS5tYXAoZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IFModGhpcykudmFsKCk7XG5cdCAgICAgICAgcmV0dXJuIG51bGwgPT0gbiA/IG51bGwgOiBBcnJheS5pc0FycmF5KG4pID8gUy5tYXAobiwgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIG5hbWU6IHQubmFtZSxcblx0ICAgICAgICAgICAgdmFsdWU6IGUucmVwbGFjZShFdCwgXCJcXHJcXG5cIilcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSkgOiB7XG5cdCAgICAgICAgICBuYW1lOiB0Lm5hbWUsXG5cdCAgICAgICAgICB2YWx1ZTogbi5yZXBsYWNlKEV0LCBcIlxcclxcblwiKVxuXHQgICAgICAgIH07XG5cdCAgICAgIH0pLmdldCgpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHZhciBOdCA9IC8lMjAvZyxcblx0ICAgICAganQgPSAvIy4qJC8sXG5cdCAgICAgIER0ID0gLyhbPyZdKV89W14mXSovLFxuXHQgICAgICBxdCA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvZ20sXG5cdCAgICAgIEx0ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0ICAgICAgSHQgPSAvXlxcL1xcLy8sXG5cdCAgICAgIE90ID0ge30sXG5cdCAgICAgIFB0ID0ge30sXG5cdCAgICAgIFJ0ID0gXCIqL1wiLmNvbmNhdChcIipcIiksXG5cdCAgICAgIE10ID0gRS5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblxuXHQgIGZ1bmN0aW9uIEl0KG8pIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICBcInN0cmluZ1wiICE9IHR5cGVvZiBlICYmICh0ID0gZSwgZSA9IFwiKlwiKTtcblx0ICAgICAgdmFyIG4sXG5cdCAgICAgICAgICByID0gMCxcblx0ICAgICAgICAgIGkgPSBlLnRvTG93ZXJDYXNlKCkubWF0Y2goUCkgfHwgW107XG5cdCAgICAgIGlmIChtKHQpKSB3aGlsZSAobiA9IGlbcisrXSkgXCIrXCIgPT09IG5bMF0gPyAobiA9IG4uc2xpY2UoMSkgfHwgXCIqXCIsIChvW25dID0gb1tuXSB8fCBbXSkudW5zaGlmdCh0KSkgOiAob1tuXSA9IG9bbl0gfHwgW10pLnB1c2godCk7XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIFd0KHQsIGksIG8sIGEpIHtcblx0ICAgIHZhciBzID0ge30sXG5cdCAgICAgICAgdSA9IHQgPT09IFB0O1xuXG5cdCAgICBmdW5jdGlvbiBsKGUpIHtcblx0ICAgICAgdmFyIHI7XG5cdCAgICAgIHJldHVybiBzW2VdID0gITAsIFMuZWFjaCh0W2VdIHx8IFtdLCBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICAgIHZhciBuID0gdChpLCBvLCBhKTtcblx0ICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiAhPSB0eXBlb2YgbiB8fCB1IHx8IHNbbl0gPyB1ID8gIShyID0gbikgOiB2b2lkIDAgOiAoaS5kYXRhVHlwZXMudW5zaGlmdChuKSwgbChuKSwgITEpO1xuXHQgICAgICB9KSwgcjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGwoaS5kYXRhVHlwZXNbMF0pIHx8ICFzW1wiKlwiXSAmJiBsKFwiKlwiKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBGdChlLCB0KSB7XG5cdCAgICB2YXIgbixcblx0ICAgICAgICByLFxuXHQgICAgICAgIGkgPSBTLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHQgICAgZm9yIChuIGluIHQpIHZvaWQgMCAhPT0gdFtuXSAmJiAoKGlbbl0gPyBlIDogciB8fCAociA9IHt9KSlbbl0gPSB0W25dKTtcblxuXHQgICAgcmV0dXJuIHIgJiYgUy5leHRlbmQoITAsIGUsIHIpLCBlO1xuXHQgIH1cblxuXHQgIE10LmhyZWYgPSBidC5ocmVmLCBTLmV4dGVuZCh7XG5cdCAgICBhY3RpdmU6IDAsXG5cdCAgICBsYXN0TW9kaWZpZWQ6IHt9LFxuXHQgICAgZXRhZzoge30sXG5cdCAgICBhamF4U2V0dGluZ3M6IHtcblx0ICAgICAgdXJsOiBidC5ocmVmLFxuXHQgICAgICB0eXBlOiBcIkdFVFwiLFxuXHQgICAgICBpc0xvY2FsOiAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLy50ZXN0KGJ0LnByb3RvY29sKSxcblx0ICAgICAgZ2xvYmFsOiAhMCxcblx0ICAgICAgcHJvY2Vzc0RhdGE6ICEwLFxuXHQgICAgICBhc3luYzogITAsXG5cdCAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHQgICAgICBhY2NlcHRzOiB7XG5cdCAgICAgICAgXCIqXCI6IFJ0LFxuXHQgICAgICAgIHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHQgICAgICAgIGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdCAgICAgICAgeG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0ICAgICAgICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdCAgICAgIH0sXG5cdCAgICAgIGNvbnRlbnRzOiB7XG5cdCAgICAgICAgeG1sOiAvXFxieG1sXFxiLyxcblx0ICAgICAgICBodG1sOiAvXFxiaHRtbC8sXG5cdCAgICAgICAganNvbjogL1xcYmpzb25cXGIvXG5cdCAgICAgIH0sXG5cdCAgICAgIHJlc3BvbnNlRmllbGRzOiB7XG5cdCAgICAgICAgeG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdCAgICAgICAgdGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0ICAgICAgICBqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdCAgICAgIH0sXG5cdCAgICAgIGNvbnZlcnRlcnM6IHtcblx0ICAgICAgICBcIiogdGV4dFwiOiBTdHJpbmcsXG5cdCAgICAgICAgXCJ0ZXh0IGh0bWxcIjogITAsXG5cdCAgICAgICAgXCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblx0ICAgICAgICBcInRleHQgeG1sXCI6IFMucGFyc2VYTUxcblx0ICAgICAgfSxcblx0ICAgICAgZmxhdE9wdGlvbnM6IHtcblx0ICAgICAgICB1cmw6ICEwLFxuXHQgICAgICAgIGNvbnRleHQ6ICEwXG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBhamF4U2V0dXA6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiB0ID8gRnQoRnQoZSwgUy5hamF4U2V0dGluZ3MpLCB0KSA6IEZ0KFMuYWpheFNldHRpbmdzLCBlKTtcblx0ICAgIH0sXG5cdCAgICBhamF4UHJlZmlsdGVyOiBJdChPdCksXG5cdCAgICBhamF4VHJhbnNwb3J0OiBJdChQdCksXG5cdCAgICBhamF4OiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICBcIm9iamVjdFwiID09IHR5cGVvZiBlICYmICh0ID0gZSwgZSA9IHZvaWQgMCksIHQgPSB0IHx8IHt9O1xuXHQgICAgICB2YXIgYyxcblx0ICAgICAgICAgIGYsXG5cdCAgICAgICAgICBwLFxuXHQgICAgICAgICAgbixcblx0ICAgICAgICAgIGQsXG5cdCAgICAgICAgICByLFxuXHQgICAgICAgICAgaCxcblx0ICAgICAgICAgIGcsXG5cdCAgICAgICAgICBpLFxuXHQgICAgICAgICAgbyxcblx0ICAgICAgICAgIHYgPSBTLmFqYXhTZXR1cCh7fSwgdCksXG5cdCAgICAgICAgICB5ID0gdi5jb250ZXh0IHx8IHYsXG5cdCAgICAgICAgICBtID0gdi5jb250ZXh0ICYmICh5Lm5vZGVUeXBlIHx8IHkuanF1ZXJ5KSA/IFMoeSkgOiBTLmV2ZW50LFxuXHQgICAgICAgICAgeCA9IFMuRGVmZXJyZWQoKSxcblx0ICAgICAgICAgIGIgPSBTLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuXHQgICAgICAgICAgdyA9IHYuc3RhdHVzQ29kZSB8fCB7fSxcblx0ICAgICAgICAgIGEgPSB7fSxcblx0ICAgICAgICAgIHMgPSB7fSxcblx0ICAgICAgICAgIHUgPSBcImNhbmNlbGVkXCIsXG5cdCAgICAgICAgICBUID0ge1xuXHQgICAgICAgIHJlYWR5U3RhdGU6IDAsXG5cdCAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdDtcblxuXHQgICAgICAgICAgaWYgKGgpIHtcblx0ICAgICAgICAgICAgaWYgKCFuKSB7XG5cdCAgICAgICAgICAgICAgbiA9IHt9O1xuXG5cdCAgICAgICAgICAgICAgd2hpbGUgKHQgPSBxdC5leGVjKHApKSBuW3RbMV0udG9Mb3dlckNhc2UoKSArIFwiIFwiXSA9IChuW3RbMV0udG9Mb3dlckNhc2UoKSArIFwiIFwiXSB8fCBbXSkuY29uY2F0KHRbMl0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdCA9IG5bZS50b0xvd2VyQ2FzZSgpICsgXCIgXCJdO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gbnVsbCA9PSB0ID8gbnVsbCA6IHQuam9pbihcIiwgXCIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICByZXR1cm4gaCA/IHAgOiBudWxsO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICAgIHJldHVybiBudWxsID09IGggJiYgKGUgPSBzW2UudG9Mb3dlckNhc2UoKV0gPSBzW2UudG9Mb3dlckNhc2UoKV0gfHwgZSwgYVtlXSA9IHQpLCB0aGlzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiBudWxsID09IGggJiYgKHYubWltZVR5cGUgPSBlKSwgdGhpcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHN0YXR1c0NvZGU6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB2YXIgdDtcblx0ICAgICAgICAgIGlmIChlKSBpZiAoaCkgVC5hbHdheXMoZVtULnN0YXR1c10pO2Vsc2UgZm9yICh0IGluIGUpIHdbdF0gPSBbd1t0XSwgZVt0XV07XG5cdCAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdmFyIHQgPSBlIHx8IHU7XG5cdCAgICAgICAgICByZXR1cm4gYyAmJiBjLmFib3J0KHQpLCBsKDAsIHQpLCB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblxuXHQgICAgICBpZiAoeC5wcm9taXNlKFQpLCB2LnVybCA9ICgoZSB8fCB2LnVybCB8fCBidC5ocmVmKSArIFwiXCIpLnJlcGxhY2UoSHQsIGJ0LnByb3RvY29sICsgXCIvL1wiKSwgdi50eXBlID0gdC5tZXRob2QgfHwgdC50eXBlIHx8IHYubWV0aG9kIHx8IHYudHlwZSwgdi5kYXRhVHlwZXMgPSAodi5kYXRhVHlwZSB8fCBcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChQKSB8fCBbXCJcIl0sIG51bGwgPT0gdi5jcm9zc0RvbWFpbikge1xuXHQgICAgICAgIHIgPSBFLmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIHIuaHJlZiA9IHYudXJsLCByLmhyZWYgPSByLmhyZWYsIHYuY3Jvc3NEb21haW4gPSBNdC5wcm90b2NvbCArIFwiLy9cIiArIE10Lmhvc3QgIT0gci5wcm90b2NvbCArIFwiLy9cIiArIHIuaG9zdDtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICB2LmNyb3NzRG9tYWluID0gITA7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHYuZGF0YSAmJiB2LnByb2Nlc3NEYXRhICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIHYuZGF0YSAmJiAodi5kYXRhID0gUy5wYXJhbSh2LmRhdGEsIHYudHJhZGl0aW9uYWwpKSwgV3QoT3QsIHYsIHQsIFQpLCBoKSByZXR1cm4gVDtcblxuXHQgICAgICBmb3IgKGkgaW4gKGcgPSBTLmV2ZW50ICYmIHYuZ2xvYmFsKSAmJiAwID09IFMuYWN0aXZlKysgJiYgUy5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpLCB2LnR5cGUgPSB2LnR5cGUudG9VcHBlckNhc2UoKSwgdi5oYXNDb250ZW50ID0gIUx0LnRlc3Qodi50eXBlKSwgZiA9IHYudXJsLnJlcGxhY2UoanQsIFwiXCIpLCB2Lmhhc0NvbnRlbnQgPyB2LmRhdGEgJiYgdi5wcm9jZXNzRGF0YSAmJiAwID09PSAodi5jb250ZW50VHlwZSB8fCBcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmICh2LmRhdGEgPSB2LmRhdGEucmVwbGFjZShOdCwgXCIrXCIpKSA6IChvID0gdi51cmwuc2xpY2UoZi5sZW5ndGgpLCB2LmRhdGEgJiYgKHYucHJvY2Vzc0RhdGEgfHwgXCJzdHJpbmdcIiA9PSB0eXBlb2Ygdi5kYXRhKSAmJiAoZiArPSAoVHQudGVzdChmKSA/IFwiJlwiIDogXCI/XCIpICsgdi5kYXRhLCBkZWxldGUgdi5kYXRhKSwgITEgPT09IHYuY2FjaGUgJiYgKGYgPSBmLnJlcGxhY2UoRHQsIFwiJDFcIiksIG8gPSAoVHQudGVzdChmKSA/IFwiJlwiIDogXCI/XCIpICsgXCJfPVwiICsgd3QuZ3VpZCsrICsgbyksIHYudXJsID0gZiArIG8pLCB2LmlmTW9kaWZpZWQgJiYgKFMubGFzdE1vZGlmaWVkW2ZdICYmIFQuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsIFMubGFzdE1vZGlmaWVkW2ZdKSwgUy5ldGFnW2ZdICYmIFQuc2V0UmVxdWVzdEhlYWRlcihcIklmLU5vbmUtTWF0Y2hcIiwgUy5ldGFnW2ZdKSksICh2LmRhdGEgJiYgdi5oYXNDb250ZW50ICYmICExICE9PSB2LmNvbnRlbnRUeXBlIHx8IHQuY29udGVudFR5cGUpICYmIFQuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCB2LmNvbnRlbnRUeXBlKSwgVC5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIHYuZGF0YVR5cGVzWzBdICYmIHYuYWNjZXB0c1t2LmRhdGFUeXBlc1swXV0gPyB2LmFjY2VwdHNbdi5kYXRhVHlwZXNbMF1dICsgKFwiKlwiICE9PSB2LmRhdGFUeXBlc1swXSA/IFwiLCBcIiArIFJ0ICsgXCI7IHE9MC4wMVwiIDogXCJcIikgOiB2LmFjY2VwdHNbXCIqXCJdKSwgdi5oZWFkZXJzKSBULnNldFJlcXVlc3RIZWFkZXIoaSwgdi5oZWFkZXJzW2ldKTtcblxuXHQgICAgICBpZiAodi5iZWZvcmVTZW5kICYmICghMSA9PT0gdi5iZWZvcmVTZW5kLmNhbGwoeSwgVCwgdikgfHwgaCkpIHJldHVybiBULmFib3J0KCk7XG5cblx0ICAgICAgaWYgKHUgPSBcImFib3J0XCIsIGIuYWRkKHYuY29tcGxldGUpLCBULmRvbmUodi5zdWNjZXNzKSwgVC5mYWlsKHYuZXJyb3IpLCBjID0gV3QoUHQsIHYsIHQsIFQpKSB7XG5cdCAgICAgICAgaWYgKFQucmVhZHlTdGF0ZSA9IDEsIGcgJiYgbS50cmlnZ2VyKFwiYWpheFNlbmRcIiwgW1QsIHZdKSwgaCkgcmV0dXJuIFQ7XG5cdCAgICAgICAgdi5hc3luYyAmJiAwIDwgdi50aW1lb3V0ICYmIChkID0gQy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIFQuYWJvcnQoXCJ0aW1lb3V0XCIpO1xuXHQgICAgICAgIH0sIHYudGltZW91dCkpO1xuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIGggPSAhMSwgYy5zZW5kKGEsIGwpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgIGlmIChoKSB0aHJvdyBlO1xuXHQgICAgICAgICAgbCgtMSwgZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgbCgtMSwgXCJObyBUcmFuc3BvcnRcIik7XG5cblx0ICAgICAgZnVuY3Rpb24gbChlLCB0LCBuLCByKSB7XG5cdCAgICAgICAgdmFyIGksXG5cdCAgICAgICAgICAgIG8sXG5cdCAgICAgICAgICAgIGEsXG5cdCAgICAgICAgICAgIHMsXG5cdCAgICAgICAgICAgIHUsXG5cdCAgICAgICAgICAgIGwgPSB0O1xuXHQgICAgICAgIGggfHwgKGggPSAhMCwgZCAmJiBDLmNsZWFyVGltZW91dChkKSwgYyA9IHZvaWQgMCwgcCA9IHIgfHwgXCJcIiwgVC5yZWFkeVN0YXRlID0gMCA8IGUgPyA0IDogMCwgaSA9IDIwMCA8PSBlICYmIGUgPCAzMDAgfHwgMzA0ID09PSBlLCBuICYmIChzID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgICAgIHZhciByLFxuXHQgICAgICAgICAgICAgIGksXG5cdCAgICAgICAgICAgICAgbyxcblx0ICAgICAgICAgICAgICBhLFxuXHQgICAgICAgICAgICAgIHMgPSBlLmNvbnRlbnRzLFxuXHQgICAgICAgICAgICAgIHUgPSBlLmRhdGFUeXBlcztcblxuXHQgICAgICAgICAgd2hpbGUgKFwiKlwiID09PSB1WzBdKSB1LnNoaWZ0KCksIHZvaWQgMCA9PT0gciAmJiAociA9IGUubWltZVR5cGUgfHwgdC5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSk7XG5cblx0ICAgICAgICAgIGlmIChyKSBmb3IgKGkgaW4gcykgaWYgKHNbaV0gJiYgc1tpXS50ZXN0KHIpKSB7XG5cdCAgICAgICAgICAgIHUudW5zaGlmdChpKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAodVswXSBpbiBuKSBvID0gdVswXTtlbHNlIHtcblx0ICAgICAgICAgICAgZm9yIChpIGluIG4pIHtcblx0ICAgICAgICAgICAgICBpZiAoIXVbMF0gfHwgZS5jb252ZXJ0ZXJzW2kgKyBcIiBcIiArIHVbMF1dKSB7XG5cdCAgICAgICAgICAgICAgICBvID0gaTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgIGEgfHwgKGEgPSBpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG8gPSBvIHx8IGE7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAobykgcmV0dXJuIG8gIT09IHVbMF0gJiYgdS51bnNoaWZ0KG8pLCBuW29dO1xuXHQgICAgICAgIH0odiwgVCwgbikpLCAhaSAmJiAtMSA8IFMuaW5BcnJheShcInNjcmlwdFwiLCB2LmRhdGFUeXBlcykgJiYgUy5pbkFycmF5KFwianNvblwiLCB2LmRhdGFUeXBlcykgPCAwICYmICh2LmNvbnZlcnRlcnNbXCJ0ZXh0IHNjcmlwdFwiXSA9IGZ1bmN0aW9uICgpIHt9KSwgcyA9IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG5cdCAgICAgICAgICB2YXIgaSxcblx0ICAgICAgICAgICAgICBvLFxuXHQgICAgICAgICAgICAgIGEsXG5cdCAgICAgICAgICAgICAgcyxcblx0ICAgICAgICAgICAgICB1LFxuXHQgICAgICAgICAgICAgIGwgPSB7fSxcblx0ICAgICAgICAgICAgICBjID0gZS5kYXRhVHlwZXMuc2xpY2UoKTtcblx0ICAgICAgICAgIGlmIChjWzFdKSBmb3IgKGEgaW4gZS5jb252ZXJ0ZXJzKSBsW2EudG9Mb3dlckNhc2UoKV0gPSBlLmNvbnZlcnRlcnNbYV07XG5cdCAgICAgICAgICBvID0gYy5zaGlmdCgpO1xuXG5cdCAgICAgICAgICB3aGlsZSAobykgaWYgKGUucmVzcG9uc2VGaWVsZHNbb10gJiYgKG5bZS5yZXNwb25zZUZpZWxkc1tvXV0gPSB0KSwgIXUgJiYgciAmJiBlLmRhdGFGaWx0ZXIgJiYgKHQgPSBlLmRhdGFGaWx0ZXIodCwgZS5kYXRhVHlwZSkpLCB1ID0gbywgbyA9IGMuc2hpZnQoKSkgaWYgKFwiKlwiID09PSBvKSBvID0gdTtlbHNlIGlmIChcIipcIiAhPT0gdSAmJiB1ICE9PSBvKSB7XG5cdCAgICAgICAgICAgIGlmICghKGEgPSBsW3UgKyBcIiBcIiArIG9dIHx8IGxbXCIqIFwiICsgb10pKSBmb3IgKGkgaW4gbCkgaWYgKChzID0gaS5zcGxpdChcIiBcIikpWzFdID09PSBvICYmIChhID0gbFt1ICsgXCIgXCIgKyBzWzBdXSB8fCBsW1wiKiBcIiArIHNbMF1dKSkge1xuXHQgICAgICAgICAgICAgICEwID09PSBhID8gYSA9IGxbaV0gOiAhMCAhPT0gbFtpXSAmJiAobyA9IHNbMF0sIGMudW5zaGlmdChzWzFdKSk7XG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCEwICE9PSBhKSBpZiAoYSAmJiBlW1widGhyb3dzXCJdKSB0ID0gYSh0KTtlbHNlIHRyeSB7XG5cdCAgICAgICAgICAgICAgdCA9IGEodCk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgc3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0ICAgICAgICAgICAgICAgIGVycm9yOiBhID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgdSArIFwiIHRvIFwiICsgb1xuXHQgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgc3RhdGU6IFwic3VjY2Vzc1wiLFxuXHQgICAgICAgICAgICBkYXRhOiB0XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0odiwgcywgVCwgaSksIGkgPyAodi5pZk1vZGlmaWVkICYmICgodSA9IFQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpKSAmJiAoUy5sYXN0TW9kaWZpZWRbZl0gPSB1KSwgKHUgPSBULmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKSkgJiYgKFMuZXRhZ1tmXSA9IHUpKSwgMjA0ID09PSBlIHx8IFwiSEVBRFwiID09PSB2LnR5cGUgPyBsID0gXCJub2NvbnRlbnRcIiA6IDMwNCA9PT0gZSA/IGwgPSBcIm5vdG1vZGlmaWVkXCIgOiAobCA9IHMuc3RhdGUsIG8gPSBzLmRhdGEsIGkgPSAhKGEgPSBzLmVycm9yKSkpIDogKGEgPSBsLCAhZSAmJiBsIHx8IChsID0gXCJlcnJvclwiLCBlIDwgMCAmJiAoZSA9IDApKSksIFQuc3RhdHVzID0gZSwgVC5zdGF0dXNUZXh0ID0gKHQgfHwgbCkgKyBcIlwiLCBpID8geC5yZXNvbHZlV2l0aCh5LCBbbywgbCwgVF0pIDogeC5yZWplY3RXaXRoKHksIFtULCBsLCBhXSksIFQuc3RhdHVzQ29kZSh3KSwgdyA9IHZvaWQgMCwgZyAmJiBtLnRyaWdnZXIoaSA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsIFtULCB2LCBpID8gbyA6IGFdKSwgYi5maXJlV2l0aCh5LCBbVCwgbF0pLCBnICYmIChtLnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIiwgW1QsIHZdKSwgLS1TLmFjdGl2ZSB8fCBTLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIFQ7XG5cdCAgICB9LFxuXHQgICAgZ2V0SlNPTjogZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgcmV0dXJuIFMuZ2V0KGUsIHQsIG4sIFwianNvblwiKTtcblx0ICAgIH0sXG5cdCAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiBTLmdldChlLCB2b2lkIDAsIHQsIFwic2NyaXB0XCIpO1xuXHQgICAgfVxuXHQgIH0pLCBTLmVhY2goW1wiZ2V0XCIsIFwicG9zdFwiXSwgZnVuY3Rpb24gKGUsIGkpIHtcblx0ICAgIFNbaV0gPSBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICByZXR1cm4gbSh0KSAmJiAociA9IHIgfHwgbiwgbiA9IHQsIHQgPSB2b2lkIDApLCBTLmFqYXgoUy5leHRlbmQoe1xuXHQgICAgICAgIHVybDogZSxcblx0ICAgICAgICB0eXBlOiBpLFxuXHQgICAgICAgIGRhdGFUeXBlOiByLFxuXHQgICAgICAgIGRhdGE6IHQsXG5cdCAgICAgICAgc3VjY2VzczogblxuXHQgICAgICB9LCBTLmlzUGxhaW5PYmplY3QoZSkgJiYgZSkpO1xuXHQgICAgfTtcblx0ICB9KSwgUy5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgdDtcblxuXHQgICAgZm9yICh0IGluIGUuaGVhZGVycykgXCJjb250ZW50LXR5cGVcIiA9PT0gdC50b0xvd2VyQ2FzZSgpICYmIChlLmNvbnRlbnRUeXBlID0gZS5oZWFkZXJzW3RdIHx8IFwiXCIpO1xuXHQgIH0pLCBTLl9ldmFsVXJsID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgIHJldHVybiBTLmFqYXgoe1xuXHQgICAgICB1cmw6IGUsXG5cdCAgICAgIHR5cGU6IFwiR0VUXCIsXG5cdCAgICAgIGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHQgICAgICBjYWNoZTogITAsXG5cdCAgICAgIGFzeW5jOiAhMSxcblx0ICAgICAgZ2xvYmFsOiAhMSxcblx0ICAgICAgY29udmVydGVyczoge1xuXHQgICAgICAgIFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24gKCkge31cblx0ICAgICAgfSxcblx0ICAgICAgZGF0YUZpbHRlcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBTLmdsb2JhbEV2YWwoZSwgdCwgbik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH0sIFMuZm4uZXh0ZW5kKHtcblx0ICAgIHdyYXBBbGw6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB0O1xuXHQgICAgICByZXR1cm4gdGhpc1swXSAmJiAobShlKSAmJiAoZSA9IGUuY2FsbCh0aGlzWzBdKSksIHQgPSBTKGUsIHRoaXNbMF0ub3duZXJEb2N1bWVudCkuZXEoMCkuY2xvbmUoITApLCB0aGlzWzBdLnBhcmVudE5vZGUgJiYgdC5pbnNlcnRCZWZvcmUodGhpc1swXSksIHQubWFwKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZSA9IHRoaXM7XG5cblx0ICAgICAgICB3aGlsZSAoZS5maXJzdEVsZW1lbnRDaGlsZCkgZSA9IGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cblx0ICAgICAgICByZXR1cm4gZTtcblx0ICAgICAgfSkuYXBwZW5kKHRoaXMpKSwgdGhpcztcblx0ICAgIH0sXG5cdCAgICB3cmFwSW5uZXI6IGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgIHJldHVybiBtKG4pID8gdGhpcy5lYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgUyh0aGlzKS53cmFwSW5uZXIobi5jYWxsKHRoaXMsIGUpKTtcblx0ICAgICAgfSkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBlID0gUyh0aGlzKSxcblx0ICAgICAgICAgICAgdCA9IGUuY29udGVudHMoKTtcblx0ICAgICAgICB0Lmxlbmd0aCA/IHQud3JhcEFsbChuKSA6IGUuYXBwZW5kKG4pO1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICB3cmFwOiBmdW5jdGlvbiAodCkge1xuXHQgICAgICB2YXIgbiA9IG0odCk7XG5cdCAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBTKHRoaXMpLndyYXBBbGwobiA/IHQuY2FsbCh0aGlzLCBlKSA6IHQpO1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICB1bndyYXA6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnBhcmVudChlKS5ub3QoXCJib2R5XCIpLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFModGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKTtcblx0ICAgICAgfSksIHRoaXM7XG5cdCAgICB9XG5cdCAgfSksIFMuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICByZXR1cm4gIVMuZXhwci5wc2V1ZG9zLnZpc2libGUoZSk7XG5cdCAgfSwgUy5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICByZXR1cm4gISEoZS5vZmZzZXRXaWR0aCB8fCBlLm9mZnNldEhlaWdodCB8fCBlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcblx0ICB9LCBTLmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXR1cm4gbmV3IEMuWE1MSHR0cFJlcXVlc3QoKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgfTtcblx0ICB2YXIgQnQgPSB7XG5cdCAgICAwOiAyMDAsXG5cdCAgICAxMjIzOiAyMDRcblx0ICB9LFxuXHQgICAgICAkdCA9IFMuYWpheFNldHRpbmdzLnhocigpO1xuXHQgIHkuY29ycyA9ICEhJHQgJiYgXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiAkdCwgeS5hamF4ID0gJHQgPSAhISR0LCBTLmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24gKGkpIHtcblx0ICAgIHZhciBvLCBhO1xuXHQgICAgaWYgKHkuY29ycyB8fCAkdCAmJiAhaS5jcm9zc0RvbWFpbikgcmV0dXJuIHtcblx0ICAgICAgc2VuZDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgICB2YXIgbixcblx0ICAgICAgICAgICAgciA9IGkueGhyKCk7XG5cdCAgICAgICAgaWYgKHIub3BlbihpLnR5cGUsIGkudXJsLCBpLmFzeW5jLCBpLnVzZXJuYW1lLCBpLnBhc3N3b3JkKSwgaS54aHJGaWVsZHMpIGZvciAobiBpbiBpLnhockZpZWxkcykgcltuXSA9IGkueGhyRmllbGRzW25dO1xuXG5cdCAgICAgICAgZm9yIChuIGluIGkubWltZVR5cGUgJiYgci5vdmVycmlkZU1pbWVUeXBlICYmIHIub3ZlcnJpZGVNaW1lVHlwZShpLm1pbWVUeXBlKSwgaS5jcm9zc0RvbWFpbiB8fCBlW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSB8fCAoZVtcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCIpLCBlKSByLnNldFJlcXVlc3RIZWFkZXIobiwgZVtuXSk7XG5cblx0ICAgICAgICBvID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIG8gJiYgKG8gPSBhID0gci5vbmxvYWQgPSByLm9uZXJyb3IgPSByLm9uYWJvcnQgPSByLm9udGltZW91dCA9IHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbCwgXCJhYm9ydFwiID09PSBlID8gci5hYm9ydCgpIDogXCJlcnJvclwiID09PSBlID8gXCJudW1iZXJcIiAhPSB0eXBlb2Ygci5zdGF0dXMgPyB0KDAsIFwiZXJyb3JcIikgOiB0KHIuc3RhdHVzLCByLnN0YXR1c1RleHQpIDogdChCdFtyLnN0YXR1c10gfHwgci5zdGF0dXMsIHIuc3RhdHVzVGV4dCwgXCJ0ZXh0XCIgIT09IChyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIikgfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2Ygci5yZXNwb25zZVRleHQgPyB7XG5cdCAgICAgICAgICAgICAgYmluYXJ5OiByLnJlc3BvbnNlXG5cdCAgICAgICAgICAgIH0gOiB7XG5cdCAgICAgICAgICAgICAgdGV4dDogci5yZXNwb25zZVRleHRcblx0ICAgICAgICAgICAgfSwgci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9LCByLm9ubG9hZCA9IG8oKSwgYSA9IHIub25lcnJvciA9IHIub250aW1lb3V0ID0gbyhcImVycm9yXCIpLCB2b2lkIDAgIT09IHIub25hYm9ydCA/IHIub25hYm9ydCA9IGEgOiByLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIDQgPT09IHIucmVhZHlTdGF0ZSAmJiBDLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBvICYmIGEoKTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sIG8gPSBvKFwiYWJvcnRcIik7XG5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgci5zZW5kKGkuaGFzQ29udGVudCAmJiBpLmRhdGEgfHwgbnVsbCk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgaWYgKG8pIHRocm93IGU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIG8gJiYgbygpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0pLCBTLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24gKGUpIHtcblx0ICAgIGUuY3Jvc3NEb21haW4gJiYgKGUuY29udGVudHMuc2NyaXB0ID0gITEpO1xuXHQgIH0pLCBTLmFqYXhTZXR1cCh7XG5cdCAgICBhY2NlcHRzOiB7XG5cdCAgICAgIHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdCAgICB9LFxuXHQgICAgY29udGVudHM6IHtcblx0ICAgICAgc2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0ICAgIH0sXG5cdCAgICBjb252ZXJ0ZXJzOiB7XG5cdCAgICAgIFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICByZXR1cm4gUy5nbG9iYWxFdmFsKGUpLCBlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSksIFMuYWpheFByZWZpbHRlcihcInNjcmlwdFwiLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgdm9pZCAwID09PSBlLmNhY2hlICYmIChlLmNhY2hlID0gITEpLCBlLmNyb3NzRG9tYWluICYmIChlLnR5cGUgPSBcIkdFVFwiKTtcblx0ICB9KSwgUy5hamF4VHJhbnNwb3J0KFwic2NyaXB0XCIsIGZ1bmN0aW9uIChuKSB7XG5cdCAgICB2YXIgciwgaTtcblx0ICAgIGlmIChuLmNyb3NzRG9tYWluIHx8IG4uc2NyaXB0QXR0cnMpIHJldHVybiB7XG5cdCAgICAgIHNlbmQ6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgciA9IFMoXCI8c2NyaXB0PlwiKS5hdHRyKG4uc2NyaXB0QXR0cnMgfHwge30pLnByb3Aoe1xuXHQgICAgICAgICAgY2hhcnNldDogbi5zY3JpcHRDaGFyc2V0LFxuXHQgICAgICAgICAgc3JjOiBuLnVybFxuXHQgICAgICAgIH0pLm9uKFwibG9hZCBlcnJvclwiLCBpID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHIucmVtb3ZlKCksIGkgPSBudWxsLCBlICYmIHQoXCJlcnJvclwiID09PSBlLnR5cGUgPyA0MDQgOiAyMDAsIGUudHlwZSk7XG5cdCAgICAgICAgfSksIEUuaGVhZC5hcHBlbmRDaGlsZChyWzBdKTtcblx0ICAgICAgfSxcblx0ICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpICYmIGkoKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICB9KTtcblxuXHQgIHZhciBfdCxcblx0ICAgICAgenQgPSBbXSxcblx0ICAgICAgVXQgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG5cdCAgUy5hamF4U2V0dXAoe1xuXHQgICAganNvbnA6IFwiY2FsbGJhY2tcIixcblx0ICAgIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGUgPSB6dC5wb3AoKSB8fCBTLmV4cGFuZG8gKyBcIl9cIiArIHd0Lmd1aWQrKztcblx0ICAgICAgcmV0dXJuIHRoaXNbZV0gPSAhMCwgZTtcblx0ICAgIH1cblx0ICB9KSwgUy5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgdmFyIHIsXG5cdCAgICAgICAgaSxcblx0ICAgICAgICBvLFxuXHQgICAgICAgIGEgPSAhMSAhPT0gZS5qc29ucCAmJiAoVXQudGVzdChlLnVybCkgPyBcInVybFwiIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgZS5kYXRhICYmIDAgPT09IChlLmNvbnRlbnRUeXBlIHx8IFwiXCIpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikgJiYgVXQudGVzdChlLmRhdGEpICYmIFwiZGF0YVwiKTtcblx0ICAgIGlmIChhIHx8IFwianNvbnBcIiA9PT0gZS5kYXRhVHlwZXNbMF0pIHJldHVybiByID0gZS5qc29ucENhbGxiYWNrID0gbShlLmpzb25wQ2FsbGJhY2spID8gZS5qc29ucENhbGxiYWNrKCkgOiBlLmpzb25wQ2FsbGJhY2ssIGEgPyBlW2FdID0gZVthXS5yZXBsYWNlKFV0LCBcIiQxXCIgKyByKSA6ICExICE9PSBlLmpzb25wICYmIChlLnVybCArPSAoVHQudGVzdChlLnVybCkgPyBcIiZcIiA6IFwiP1wiKSArIGUuanNvbnAgKyBcIj1cIiArIHIpLCBlLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIG8gfHwgUy5lcnJvcihyICsgXCIgd2FzIG5vdCBjYWxsZWRcIiksIG9bMF07XG5cdCAgICB9LCBlLmRhdGFUeXBlc1swXSA9IFwianNvblwiLCBpID0gQ1tyXSwgQ1tyXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgbyA9IGFyZ3VtZW50cztcblx0ICAgIH0sIG4uYWx3YXlzKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdm9pZCAwID09PSBpID8gUyhDKS5yZW1vdmVQcm9wKHIpIDogQ1tyXSA9IGksIGVbcl0gJiYgKGUuanNvbnBDYWxsYmFjayA9IHQuanNvbnBDYWxsYmFjaywgenQucHVzaChyKSksIG8gJiYgbShpKSAmJiBpKG9bMF0pLCBvID0gaSA9IHZvaWQgMDtcblx0ICAgIH0pLCBcInNjcmlwdFwiO1xuXHQgIH0pLCB5LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICgoX3QgPSBFLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKS5ib2R5KS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCIsIDIgPT09IF90LmNoaWxkTm9kZXMubGVuZ3RoKSwgUy5wYXJzZUhUTUwgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgcmV0dXJuIFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgPyBbXSA6IChcImJvb2xlYW5cIiA9PSB0eXBlb2YgdCAmJiAobiA9IHQsIHQgPSAhMSksIHQgfHwgKHkuY3JlYXRlSFRNTERvY3VtZW50ID8gKChyID0gKHQgPSBFLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKSkuY3JlYXRlRWxlbWVudChcImJhc2VcIikpLmhyZWYgPSBFLmxvY2F0aW9uLmhyZWYsIHQuaGVhZC5hcHBlbmRDaGlsZChyKSkgOiB0ID0gRSksIG8gPSAhbiAmJiBbXSwgKGkgPSBOLmV4ZWMoZSkpID8gW3QuY3JlYXRlRWxlbWVudChpWzFdKV0gOiAoaSA9IHhlKFtlXSwgdCwgbyksIG8gJiYgby5sZW5ndGggJiYgUyhvKS5yZW1vdmUoKSwgUy5tZXJnZShbXSwgaS5jaGlsZE5vZGVzKSkpO1xuXHQgICAgdmFyIHIsIGksIG87XG5cdCAgfSwgUy5mbi5sb2FkID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgIHZhciByLFxuXHQgICAgICAgIGksXG5cdCAgICAgICAgbyxcblx0ICAgICAgICBhID0gdGhpcyxcblx0ICAgICAgICBzID0gZS5pbmRleE9mKFwiIFwiKTtcblx0ICAgIHJldHVybiAtMSA8IHMgJiYgKHIgPSBodChlLnNsaWNlKHMpKSwgZSA9IGUuc2xpY2UoMCwgcykpLCBtKHQpID8gKG4gPSB0LCB0ID0gdm9pZCAwKSA6IHQgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiAoaSA9IFwiUE9TVFwiKSwgMCA8IGEubGVuZ3RoICYmIFMuYWpheCh7XG5cdCAgICAgIHVybDogZSxcblx0ICAgICAgdHlwZTogaSB8fCBcIkdFVFwiLFxuXHQgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG5cdCAgICAgIGRhdGE6IHRcblx0ICAgIH0pLmRvbmUoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgbyA9IGFyZ3VtZW50cywgYS5odG1sKHIgPyBTKFwiPGRpdj5cIikuYXBwZW5kKFMucGFyc2VIVE1MKGUpKS5maW5kKHIpIDogZSk7XG5cdCAgICB9KS5hbHdheXMobiAmJiBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICBhLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIG4uYXBwbHkodGhpcywgbyB8fCBbZS5yZXNwb25zZVRleHQsIHQsIGVdKTtcblx0ICAgICAgfSk7XG5cdCAgICB9KSwgdGhpcztcblx0ICB9LCBTLmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uICh0KSB7XG5cdCAgICByZXR1cm4gUy5ncmVwKFMudGltZXJzLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gdCA9PT0gZS5lbGVtO1xuXHQgICAgfSkubGVuZ3RoO1xuXHQgIH0sIFMub2Zmc2V0ID0ge1xuXHQgICAgc2V0T2Zmc2V0OiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICB2YXIgcixcblx0ICAgICAgICAgIGksXG5cdCAgICAgICAgICBvLFxuXHQgICAgICAgICAgYSxcblx0ICAgICAgICAgIHMsXG5cdCAgICAgICAgICB1LFxuXHQgICAgICAgICAgbCA9IFMuY3NzKGUsIFwicG9zaXRpb25cIiksXG5cdCAgICAgICAgICBjID0gUyhlKSxcblx0ICAgICAgICAgIGYgPSB7fTtcblx0ICAgICAgXCJzdGF0aWNcIiA9PT0gbCAmJiAoZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIiksIHMgPSBjLm9mZnNldCgpLCBvID0gUy5jc3MoZSwgXCJ0b3BcIiksIHUgPSBTLmNzcyhlLCBcImxlZnRcIiksIChcImFic29sdXRlXCIgPT09IGwgfHwgXCJmaXhlZFwiID09PSBsKSAmJiAtMSA8IChvICsgdSkuaW5kZXhPZihcImF1dG9cIikgPyAoYSA9IChyID0gYy5wb3NpdGlvbigpKS50b3AsIGkgPSByLmxlZnQpIDogKGEgPSBwYXJzZUZsb2F0KG8pIHx8IDAsIGkgPSBwYXJzZUZsb2F0KHUpIHx8IDApLCBtKHQpICYmICh0ID0gdC5jYWxsKGUsIG4sIFMuZXh0ZW5kKHt9LCBzKSkpLCBudWxsICE9IHQudG9wICYmIChmLnRvcCA9IHQudG9wIC0gcy50b3AgKyBhKSwgbnVsbCAhPSB0LmxlZnQgJiYgKGYubGVmdCA9IHQubGVmdCAtIHMubGVmdCArIGkpLCBcInVzaW5nXCIgaW4gdCA/IHQudXNpbmcuY2FsbChlLCBmKSA6IGMuY3NzKGYpO1xuXHQgICAgfVxuXHQgIH0sIFMuZm4uZXh0ZW5kKHtcblx0ICAgIG9mZnNldDogZnVuY3Rpb24gKHQpIHtcblx0ICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2b2lkIDAgPT09IHQgPyB0aGlzIDogdGhpcy5lYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgUy5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsIHQsIGUpO1xuXHQgICAgICB9KTtcblx0ICAgICAgdmFyIGUsXG5cdCAgICAgICAgICBuLFxuXHQgICAgICAgICAgciA9IHRoaXNbMF07XG5cdCAgICAgIHJldHVybiByID8gci5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA/IChlID0gci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbiA9IHIub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldywge1xuXHQgICAgICAgIHRvcDogZS50b3AgKyBuLnBhZ2VZT2Zmc2V0LFxuXHQgICAgICAgIGxlZnQ6IGUubGVmdCArIG4ucGFnZVhPZmZzZXRcblx0ICAgICAgfSkgOiB7XG5cdCAgICAgICAgdG9wOiAwLFxuXHQgICAgICAgIGxlZnQ6IDBcblx0ICAgICAgfSA6IHZvaWQgMDtcblx0ICAgIH0sXG5cdCAgICBwb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAodGhpc1swXSkge1xuXHQgICAgICAgIHZhciBlLFxuXHQgICAgICAgICAgICB0LFxuXHQgICAgICAgICAgICBuLFxuXHQgICAgICAgICAgICByID0gdGhpc1swXSxcblx0ICAgICAgICAgICAgaSA9IHtcblx0ICAgICAgICAgIHRvcDogMCxcblx0ICAgICAgICAgIGxlZnQ6IDBcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChcImZpeGVkXCIgPT09IFMuY3NzKHIsIFwicG9zaXRpb25cIikpIHQgPSByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2Vsc2Uge1xuXHQgICAgICAgICAgdCA9IHRoaXMub2Zmc2V0KCksIG4gPSByLm93bmVyRG9jdW1lbnQsIGUgPSByLm9mZnNldFBhcmVudCB8fCBuLmRvY3VtZW50RWxlbWVudDtcblxuXHQgICAgICAgICAgd2hpbGUgKGUgJiYgKGUgPT09IG4uYm9keSB8fCBlID09PSBuLmRvY3VtZW50RWxlbWVudCkgJiYgXCJzdGF0aWNcIiA9PT0gUy5jc3MoZSwgXCJwb3NpdGlvblwiKSkgZSA9IGUucGFyZW50Tm9kZTtcblxuXHQgICAgICAgICAgZSAmJiBlICE9PSByICYmIDEgPT09IGUubm9kZVR5cGUgJiYgKChpID0gUyhlKS5vZmZzZXQoKSkudG9wICs9IFMuY3NzKGUsIFwiYm9yZGVyVG9wV2lkdGhcIiwgITApLCBpLmxlZnQgKz0gUy5jc3MoZSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgITApKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIHRvcDogdC50b3AgLSBpLnRvcCAtIFMuY3NzKHIsIFwibWFyZ2luVG9wXCIsICEwKSxcblx0ICAgICAgICAgIGxlZnQ6IHQubGVmdCAtIGkubGVmdCAtIFMuY3NzKHIsIFwibWFyZ2luTGVmdFwiLCAhMClcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGUgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHQgICAgICAgIHdoaWxlIChlICYmIFwic3RhdGljXCIgPT09IFMuY3NzKGUsIFwicG9zaXRpb25cIikpIGUgPSBlLm9mZnNldFBhcmVudDtcblxuXHQgICAgICAgIHJldHVybiBlIHx8IHJlO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9KSwgUy5lYWNoKHtcblx0ICAgIHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIixcblx0ICAgIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiXG5cdCAgfSwgZnVuY3Rpb24gKHQsIGkpIHtcblx0ICAgIHZhciBvID0gXCJwYWdlWU9mZnNldFwiID09PSBpO1xuXG5cdCAgICBTLmZuW3RdID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmV0dXJuICQodGhpcywgZnVuY3Rpb24gKGUsIHQsIG4pIHtcblx0ICAgICAgICB2YXIgcjtcblx0ICAgICAgICBpZiAoeChlKSA/IHIgPSBlIDogOSA9PT0gZS5ub2RlVHlwZSAmJiAociA9IGUuZGVmYXVsdFZpZXcpLCB2b2lkIDAgPT09IG4pIHJldHVybiByID8gcltpXSA6IGVbdF07XG5cdCAgICAgICAgciA/IHIuc2Nyb2xsVG8obyA/IHIucGFnZVhPZmZzZXQgOiBuLCBvID8gbiA6IHIucGFnZVlPZmZzZXQpIDogZVt0XSA9IG47XG5cdCAgICAgIH0sIHQsIGUsIGFyZ3VtZW50cy5sZW5ndGgpO1xuXHQgICAgfTtcblx0ICB9KSwgUy5lYWNoKFtcInRvcFwiLCBcImxlZnRcIl0sIGZ1bmN0aW9uIChlLCBuKSB7XG5cdCAgICBTLmNzc0hvb2tzW25dID0gRmUoeS5waXhlbFBvc2l0aW9uLCBmdW5jdGlvbiAoZSwgdCkge1xuXHQgICAgICBpZiAodCkgcmV0dXJuIHQgPSBXZShlLCBuKSwgUGUudGVzdCh0KSA/IFMoZSkucG9zaXRpb24oKVtuXSArIFwicHhcIiA6IHQ7XG5cdCAgICB9KTtcblx0ICB9KSwgUy5lYWNoKHtcblx0ICAgIEhlaWdodDogXCJoZWlnaHRcIixcblx0ICAgIFdpZHRoOiBcIndpZHRoXCJcblx0ICB9LCBmdW5jdGlvbiAoYSwgcykge1xuXHQgICAgUy5lYWNoKHtcblx0ICAgICAgcGFkZGluZzogXCJpbm5lclwiICsgYSxcblx0ICAgICAgY29udGVudDogcyxcblx0ICAgICAgXCJcIjogXCJvdXRlclwiICsgYVxuXHQgICAgfSwgZnVuY3Rpb24gKHIsIG8pIHtcblx0ICAgICAgUy5mbltvXSA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoICYmIChyIHx8IFwiYm9vbGVhblwiICE9IHR5cGVvZiBlKSxcblx0ICAgICAgICAgICAgaSA9IHIgfHwgKCEwID09PSBlIHx8ICEwID09PSB0ID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIpO1xuXHQgICAgICAgIHJldHVybiAkKHRoaXMsIGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgICAgICB2YXIgcjtcblx0ICAgICAgICAgIHJldHVybiB4KGUpID8gMCA9PT0gby5pbmRleE9mKFwib3V0ZXJcIikgPyBlW1wiaW5uZXJcIiArIGFdIDogZS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIiArIGFdIDogOSA9PT0gZS5ub2RlVHlwZSA/IChyID0gZS5kb2N1bWVudEVsZW1lbnQsIE1hdGgubWF4KGUuYm9keVtcInNjcm9sbFwiICsgYV0sIHJbXCJzY3JvbGxcIiArIGFdLCBlLmJvZHlbXCJvZmZzZXRcIiArIGFdLCByW1wib2Zmc2V0XCIgKyBhXSwgcltcImNsaWVudFwiICsgYV0pKSA6IHZvaWQgMCA9PT0gbiA/IFMuY3NzKGUsIHQsIGkpIDogUy5zdHlsZShlLCB0LCBuLCBpKTtcblx0ICAgICAgICB9LCBzLCBuID8gZSA6IHZvaWQgMCwgbik7XG5cdCAgICAgIH07XG5cdCAgICB9KTtcblx0ICB9KSwgUy5lYWNoKFtcImFqYXhTdGFydFwiLCBcImFqYXhTdG9wXCIsIFwiYWpheENvbXBsZXRlXCIsIFwiYWpheEVycm9yXCIsIFwiYWpheFN1Y2Nlc3NcIiwgXCJhamF4U2VuZFwiXSwgZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgIFMuZm5bdF0gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5vbih0LCBlKTtcblx0ICAgIH07XG5cdCAgfSksIFMuZm4uZXh0ZW5kKHtcblx0ICAgIGJpbmQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm9uKGUsIG51bGwsIHQsIG4pO1xuXHQgICAgfSxcblx0ICAgIHVuYmluZDogZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMub2ZmKGUsIG51bGwsIHQpO1xuXHQgICAgfSxcblx0ICAgIGRlbGVnYXRlOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuXHQgICAgICByZXR1cm4gdGhpcy5vbih0LCBlLCBuLCByKTtcblx0ICAgIH0sXG5cdCAgICB1bmRlbGVnYXRlOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuXHQgICAgICByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMub2ZmKGUsIFwiKipcIikgOiB0aGlzLm9mZih0LCBlIHx8IFwiKipcIiwgbik7XG5cdCAgICB9LFxuXHQgICAgaG92ZXI6IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm1vdXNlZW50ZXIoZSkubW91c2VsZWF2ZSh0IHx8IGUpO1xuXHQgICAgfVxuXHQgIH0pLCBTLmVhY2goXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiAoZSwgbikge1xuXHQgICAgUy5mbltuXSA9IGZ1bmN0aW9uIChlLCB0KSB7XG5cdCAgICAgIHJldHVybiAwIDwgYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMub24obiwgbnVsbCwgZSwgdCkgOiB0aGlzLnRyaWdnZXIobik7XG5cdCAgICB9O1xuXHQgIH0pO1xuXHQgIHZhciBYdCA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblx0ICBTLnByb3h5ID0gZnVuY3Rpb24gKGUsIHQpIHtcblx0ICAgIHZhciBuLCByLCBpO1xuXHQgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgKG4gPSBlW3RdLCB0ID0gZSwgZSA9IG4pLCBtKGUpKSByZXR1cm4gciA9IHMuY2FsbChhcmd1bWVudHMsIDIpLCAoaSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGUuYXBwbHkodCB8fCB0aGlzLCByLmNvbmNhdChzLmNhbGwoYXJndW1lbnRzKSkpO1xuXHQgICAgfSkuZ3VpZCA9IGUuZ3VpZCA9IGUuZ3VpZCB8fCBTLmd1aWQrKywgaTtcblx0ICB9LCBTLmhvbGRSZWFkeSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBlID8gUy5yZWFkeVdhaXQrKyA6IFMucmVhZHkoITApO1xuXHQgIH0sIFMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXksIFMucGFyc2VKU09OID0gSlNPTi5wYXJzZSwgUy5ub2RlTmFtZSA9IEEsIFMuaXNGdW5jdGlvbiA9IG0sIFMuaXNXaW5kb3cgPSB4LCBTLmNhbWVsQ2FzZSA9IFgsIFMudHlwZSA9IHcsIFMubm93ID0gRGF0ZS5ub3csIFMuaXNOdW1lcmljID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciB0ID0gUy50eXBlKGUpO1xuXHQgICAgcmV0dXJuIChcIm51bWJlclwiID09PSB0IHx8IFwic3RyaW5nXCIgPT09IHQpICYmICFpc05hTihlIC0gcGFyc2VGbG9hdChlKSk7XG5cdCAgfSwgUy50cmltID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiBudWxsID09IGUgPyBcIlwiIDogKGUgKyBcIlwiKS5yZXBsYWNlKFh0LCBcIlwiKTtcblx0ICB9LCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHVuZGVmaW5lZCAgO1xuXHQgIHZhciBWdCA9IEMualF1ZXJ5LFxuXHQgICAgICBHdCA9IEMuJDtcblx0ICByZXR1cm4gUy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiBDLiQgPT09IFMgJiYgKEMuJCA9IEd0KSwgZSAmJiBDLmpRdWVyeSA9PT0gUyAmJiAoQy5qUXVlcnkgPSBWdCksIFM7XG5cdCAgfSwgXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgZSAmJiAoQy5qUXVlcnkgPSBDLiQgPSBTKSwgUztcblx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiBqcXVlcnkzXzZfMF9taW47XG5cbn0pKSk7XG4iXSwiZmlsZSI6ImpxdWVyeS0zLjYuMC5taW4uanMifQ==
